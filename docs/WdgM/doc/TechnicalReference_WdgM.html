---
layout: default
title: TechnicalReference_WdgM
nav_order: 1
parent: Watchdog Manager
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR WDGM </b></p>
<p>Technical Reference </p>
<p> </p>
<p>  </p>
<p>Version 1.1.0 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Christian Leder, Daniel Richter </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>2 </p>
<p>based on template version 5.12.0 </p>
<p><b>Document Information </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Daniel Richter, </p>
<p>Christian Leder </p>
<p>2016-02-12 </p>
<p>1.0.0 </p>
<p>First version of the migrated WdgM Technical </p>
<p>Reference </p>
<p>Christian Leder </p>
<p>2016-07-13 </p>
<p>1.1.0 </p>
<p>Update after introduction of native CFG5 generator </p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Source </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_SWS_WatchdogManager.pdf </p>
<p>V2.0.0 </p>
<p>[2] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_SWS_WatchdogInterface.pdf </p>
<p>V2.3.0 </p>
<p>[3] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_SWS_WatchdogDriver.pdf </p>
<p>V2.3.0 </p>
<p>[4] </p>
<p> </p>
<p>Vector </p>
<p>Informatik </p>
<p>TechnicalReference_WdgIf.pdf </p>
<p>V1.0.0 </p>
<p>[5] </p>
<p> </p>
<p>Vector </p>
<p>Informatik </p>
<p>Safety Manual </p>
<p> </p>
<p>[6] </p>
<p> ISO </p>
<p>Road vehicles – Functional safety </p>
<p>ISO </p>
<p>26262-</p>
<p>1:2011(E) </p>
<p>[7] </p>
<p> AUTOSAR </p>
<p>AUTOSAR_TR_BSWModuleList.pdf </p>
<p>V1.4.0 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>We  have  configured  the  programs  in  accordance  with  your  specifications  in  the </p>
<p>questionnaire.  Whereas  the  programs  do  support  other  configurations  than  the  one </p>
<p>specified  in  your  questionnaire,  Vector´s  release  of  the  programs  delivered  to  your </p>
<p>company </p>
<p>is </p>
<p>expressly </p>
<p>restricted </p>
<p>to </p>
<p>the </p>
<p>configuration </p>
<p>you </p>
<p>have </p>
<p>specified </p>
<p>in </p>
<p>the </p>
<p>questionnaire. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>3 </p>
<p>based on template version 5.12.0 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Component History ...................................................................................................... 8</b></p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Introduction................................................................................................................... 9</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>Architecture Overview ...................................................................................... 10</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>Use Cases ....................................................................................................... 13</p>
<p> </p>
<p>2.3</p>
<p> </p>
<p>Basic Functionality of the WdgM ...................................................................... 14</p>
<p> </p>
<p>2.3.1</p>
<p> </p>
<p>Supervised Entity and Program Flow Supervision ............................ 14</p>
<p> </p>
<p>2.3.2</p>
<p> </p>
<p>Program Flow Supervision ............................................................... 15</p>
<p> </p>
<p>2.3.3</p>
<p> </p>
<p>Deadline Supervision ....................................................................... 16</p>
<p> </p>
<p>2.3.4</p>
<p> </p>
<p>Alive Supervision ............................................................................. 20</p>
<p> </p>
<p>2.3.5</p>
<p> </p>
<p>More Details on Checkpoints and Transitions................................... 23</p>
<p> </p>
<p>2.3.6</p>
<p> </p>
<p>Global Transitions ............................................................................ 24</p>
<p> </p>
<p>2.3.7</p>
<p> </p>
<p>Global Transitions and Program Flow .............................................. 26</p>
<p> </p>
<p>2.3.7.1</p>
<p> </p>
<p>Example of an Incorrect Global Transition Split .............. 26</p>
<p> </p>
<p>2.3.7.2</p>
<p> </p>
<p>Example of an Incorrect Program Split in the Middle of </p>
<p>an Entity ......................................................................... 26</p>
<p> </p>
<p>2.3.8</p>
<p> </p>
<p>WdgM Supervision Cycle ................................................................. 27</p>
<p> </p>
<p>2.3.9</p>
<p> </p>
<p>Fault Detection Time Evaluation ....................................................... 29</p>
<p> </p>
<p>2.3.9.1</p>
<p> </p>
<p>Alive Supervision Fault Detection Time .......................... 30</p>
<p> </p>
<p>2.3.9.2</p>
<p> </p>
<p>Deadline Supervision Fault Detection Time .................... 31</p>
<p> </p>
<p>2.3.9.3</p>
<p> </p>
<p>Program Flow Supervision Fault Detection Time ............ 32</p>
<p> </p>
<p>2.3.10</p>
<p> </p>
<p>Fault Reaction Time Evaluation ........................................................ 34</p>
<p> </p>
<p>2.3.10.1</p>
<p> </p>
<p>Alive Supervision Fault Reaction Time ........................... 34</p>
<p> </p>
<p>2.3.10.2</p>
<p> </p>
<p>Deadline Supervision Fault Reaction Time ..................... 35</p>
<p> </p>
<p>2.3.10.3</p>
<p> </p>
<p>Program Flow Supervision Fault Reaction Time ............. 35</p>
<p> </p>
<p>2.3.11</p>
<p> </p>
<p>Reset Path and Safe State ............................................................... 36</p>
<p> </p>
<p>2.3.12</p>
<p> </p>
<p>WdgM Local Entity State .................................................................. 37</p>
<p> </p>
<p>2.3.13</p>
<p> </p>
<p>WdgM Global State .......................................................................... 39</p>
<p> </p>
<p>2.3.14</p>
<p> </p>
<p>Basic Operation of the WdgM Stack ................................................. 39</p>
<p> </p>
<p>2.4</p>
<p> </p>
<p>WdgM in Multi-Core Systems ........................................................................... 41</p>
<p> </p>
<p>2.4.1</p>
<p> </p>
<p>State Combiner ................................................................................ 44</p>
<p> </p>
<p>2.4.2</p>
<p> </p>
<p>AUTOSAR Debugging ..................................................................... 45</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 47</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Features .......................................................................................................... 47</p>
<p> </p>
<p>3.1.1</p>
<p> </p>
<p>Deviations from the AUTOSAR 4.0.1 Watchdog Manager ................ 48</p>
<p> </p>
<p>3.1.1.1</p>
<p> </p>
<p>Entities, Checkpoints and Transitions ............................ 48</p>
<p> </p>
<p>3.1.1.2</p>
<p> </p>
<p>Watchdog and Reset ..................................................... 49</p>
<p> </p>
<p>3.1.1.3</p>
<p> </p>
<p>API ................................................................................. 50</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>4 </p>
<p>based on template version 5.12.0 </p>
<p>3.1.2</p>
<p> </p>
<p>Additions/ Extensions ....................................................................... 50</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Initialization ...................................................................................................... 50</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Memory Sections ............................................................................................. 53</p>
<p> </p>
<p>3.3.1</p>
<p> </p>
<p>Memory Sections Details ................................................................. 54</p>
<p> </p>
<p>3.3.2</p>
<p> </p>
<p>Code and Constants ........................................................................ 55</p>
<p> </p>
<p>3.3.3</p>
<p> </p>
<p>Module Variables ............................................................................. 55</p>
<p> </p>
<p>3.3.3.1</p>
<p> </p>
<p>Module Variables with MICROSAR Os Gen6 / </p>
<p>AUTOSAR Os version 4.0 .............................................. 55</p>
<p> </p>
<p>3.3.3.2</p>
<p> </p>
<p>Module Variables with MICROSAR Os Gen7 / </p>
<p>AUTOSAR Os version 4.2 .............................................. 56</p>
<p> </p>
<p>3.3.4</p>
<p> </p>
<p>Supervised Entity Variables .............................................................. 57</p>
<p> </p>
<p>3.3.4.1</p>
<p> </p>
<p>Supervised Entity Variables with MICROSAR Os </p>
<p>Gen6 / AUTOSAR Os version 4.0 .................................. 57</p>
<p> </p>
<p>3.3.4.2</p>
<p> </p>
<p>Supervised Entity Variables with MICROSAR Os </p>
<p>Gen7 / AUTOSAR Os version 4.2 .................................. 57</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>Timing Setup .................................................................................................... 58</p>
<p> </p>
<p>3.4.1</p>
<p> </p>
<p>Deadline Measurement and Tick Counter ........................................ 60</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Using Checkpoints in Interrupts ....................................................................... 62</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Integration into a Multi-Core System ................................................................ 63</p>
<p> </p>
<p>3.7</p>
<p> </p>
<p>States .............................................................................................................. 63</p>
<p> </p>
<p>3.8</p>
<p> </p>
<p>Main Functions ................................................................................................ 63</p>
<p> </p>
<p>3.9</p>
<p> </p>
<p>Error Handling .................................................................................................. 63</p>
<p> </p>
<p>3.9.1</p>
<p> </p>
<p>Development Error Reporting ........................................................... 63</p>
<p> </p>
<p>3.9.2</p>
<p> </p>
<p>Production Code Error Reporting ..................................................... 65</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Integration ................................................................................................................... 66</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Scope of Delivery ............................................................................................. 66</p>
<p> </p>
<p>4.1.1</p>
<p> </p>
<p>Static Files ....................................................................................... 66</p>
<p> </p>
<p>4.1.2</p>
<p> </p>
<p>Dynamic Files .................................................................................. 66</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Critical Sections ............................................................................................... 67</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>API Description ........................................................................................................... 68</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Type Definitions ............................................................................................... 68</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Services provided by WdgM ............................................................................ 69</p>
<p> </p>
<p>5.2.1</p>
<p> </p>
<p>WdgM_Init ........................................................................................ 69</p>
<p> </p>
<p>5.2.2</p>
<p> </p>
<p>WdgM_GetVersionInfo ..................................................................... 70</p>
<p> </p>
<p>5.2.3</p>
<p> </p>
<p>WdgM_SetMode .............................................................................. 70</p>
<p> </p>
<p>5.2.4</p>
<p> </p>
<p>WdgM_ActivateSupervisionEntity ..................................................... 71</p>
<p> </p>
<p>5.2.5</p>
<p> </p>
<p>WdgM_DeactivateSupervisionEntity ................................................ 72</p>
<p> </p>
<p>5.2.6</p>
<p> </p>
<p>WdgM_MainFunction ....................................................................... 73</p>
<p> </p>
<p>5.2.7</p>
<p> </p>
<p>WdgM_GetMode .............................................................................. 74</p>
<p> </p>
<p>5.2.8</p>
<p> </p>
<p>WdgM_GetLocalStatus .................................................................... 75</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>5 </p>
<p>based on template version 5.12.0 </p>
<p>5.2.9</p>
<p> </p>
<p>WdgM_GetGlobalStatus .................................................................. 75</p>
<p> </p>
<p>5.2.10</p>
<p> </p>
<p>WdgM_CheckpointReached ............................................................. 76</p>
<p> </p>
<p>5.2.11</p>
<p> </p>
<p>WdgM_PerformReset ....................................................................... 76</p>
<p> </p>
<p>5.2.12</p>
<p> </p>
<p>WdgM_GetFirstExpiredSEID ............................................................ 77</p>
<p> </p>
<p>5.2.13</p>
<p> </p>
<p>WdgM_GetFirstExpiredSEViolation .................................................. 78</p>
<p> </p>
<p>5.2.14</p>
<p> </p>
<p>WdgM_UpdateTickCount ................................................................. 78</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Services used by WdgM .................................................................................. 79</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>Configurable Interfaces .................................................................................... 81</p>
<p> </p>
<p>5.4.1</p>
<p> </p>
<p>Notifications ..................................................................................... 81</p>
<p> </p>
<p>5.4.1.1</p>
<p> </p>
<p>Global state callback ...................................................... 81</p>
<p> </p>
<p>5.4.1.2</p>
<p> </p>
<p>Local state change notification ....................................... 83</p>
<p> </p>
<p>5.5</p>
<p> </p>
<p>Service Ports ................................................................................................... 84</p>
<p> </p>
<p>5.5.1</p>
<p> </p>
<p>Client Server Interface ..................................................................... 84</p>
<p> </p>
<p>5.5.1.1</p>
<p> </p>
<p>Provide Ports on WdgM Side ......................................... 84</p>
<p> </p>
<p>5.5.1.1.1</p>
<p> </p>
<p>Port Prototype for </p>
<p>WdgM_AliveSupervision ............................ 84</p>
<p> </p>
<p>5.5.1.1.2</p>
<p> </p>
<p>Port Prototype for </p>
<p>WdgM_IndividualMode .............................. 85</p>
<p> </p>
<p>5.5.1.1.3</p>
<p> </p>
<p>Port Prototype for WdgM_GlobalMode ....... 85</p>
<p> </p>
<p>5.5.1.2</p>
<p> </p>
<p>Require Ports on WdgM Side ......................................... 86</p>
<p> </p>
<p>5.5.1.2.1</p>
<p> </p>
<p>Port Prototype for </p>
<p>WdgM_LocalStatusCallbackInterface......... 86</p>
<p> </p>
<p>5.5.1.2.2</p>
<p> </p>
<p>Port Prototype for </p>
<p>WdgM_GlobalStatusCallbackInterface ....... 86</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Configuration .............................................................................................................. 87</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Configuration Variants ...................................................................................... 87</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>WdgM Configuration Verification ...................................................................... 87</p>
<p> </p>
<p>6.2.1.1</p>
<p> </p>
<p>Installing the WdgM Verifier ........................................... 89</p>
<p> </p>
<p>6.2.1.2</p>
<p> </p>
<p>Creation of WdgM Info Files ........................................... 89</p>
<p> </p>
<p>6.2.1.3</p>
<p> </p>
<p>Verifier Compilation ........................................................ 90</p>
<p> </p>
<p>6.2.1.4</p>
<p> </p>
<p>Verifier Run .................................................................... 91</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Glossary and Abbreviations ...................................................................................... 93</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Glossary .......................................................................................................... 93</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Abbreviations ................................................................................................... 96</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Contact ........................................................................................................................ 97</b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>6 </p>
<p>based on template version 5.12.0 </p>
<p><b>Figures </b></p>
<p>Figure 2-1</p>
<p> </p>
<p> AUTOSAR 4.x Architecture Overview ...................................................... 10</p>
<p> </p>
<p>Figure 2-2</p>
<p> </p>
<p> Watchdog Manager Stack in an AUTOSAR environment ......................... 11</p>
<p> </p>
<p>Figure 2-3</p>
<p> </p>
<p> Layered structure of the Watchdog Manager ........................................... 12</p>
<p> </p>
<p>Figure 2-4</p>
<p> </p>
<p> Example of a simple supervised entity with a control flow ........................ 15</p>
<p> </p>
<p>Figure 2-5</p>
<p> </p>
<p> Example of a simple supervised entity with deadlines .............................. 17</p>
<p> </p>
<p>Figure 2-6</p>
<p> </p>
<p> Example of multiple outgoing transitions with deadlines .......................... 18</p>
<p> </p>
<p>Figure 2-7</p>
<p> </p>
<p> Example of a the case where only one of several outgoing transitions </p>
<p>has a deadline .......................................................................................... 19</p>
<p> </p>
<p>Figure 2-8</p>
<p> </p>
<p> A task being monitored during one WdgM supervision cycle (20ms) ........ 22</p>
<p> </p>
<p>Figure 2-9</p>
<p> </p>
<p> A task being monitored during two WdgM supervision cycles (40ms)....... 23</p>
<p> </p>
<p>Figure 2-10</p>
<p> </p>
<p> Global transition between two supervised entities .................................... 25</p>
<p> </p>
<p>Figure 2-11</p>
<p> </p>
<p> Incorrect global transition split ................................................................. 26</p>
<p> </p>
<p>Figure 2-12</p>
<p> </p>
<p> Incorrect program split in the middle of an entity ...................................... 27</p>
<p> </p>
<p>Figure 2-13</p>
<p> </p>
<p> WdgM supervision cycle .......................................................................... 28</p>
<p> </p>
<p>Figure 2-14</p>
<p> </p>
<p> Alive supervision fault detection time ....................................................... 31</p>
<p> </p>
<p>Figure 2-15</p>
<p> </p>
<p> Deadline supervision fault detection time ................................................. 32</p>
<p> </p>
<p>Figure 2-16</p>
<p> </p>
<p> Program flow supervision fault detection time .......................................... 33</p>
<p> </p>
<p>Figure 2-17</p>
<p> </p>
<p> Primary and secondary reset path of the WdgM ...................................... 36</p>
<p> </p>
<p>Figure 2-18</p>
<p> </p>
<p> Modified state machine ............................................................................ 38</p>
<p> </p>
<p>Figure 2-19</p>
<p> </p>
<p> Example of an WdgM Stack configuration ............................................... 40</p>
<p> </p>
<p>Figure 2-20</p>
<p> </p>
<p> Behavior of the WdgM Stack ................................................................... 41</p>
<p> </p>
<p>Figure 2-21</p>
<p> </p>
<p> WdgM Stack on a multi-core system configured for independent core </p>
<p>reaction ..................................................................................................... 43</p>
<p> </p>
<p>Figure 2-22</p>
<p> </p>
<p> WdgM Stack on a multi-core system using the State Combiner for a </p>
<p>combined core reaction ............................................................................ 44</p>
<p> </p>
<p>Figure 2-23</p>
<p> </p>
<p> Dynamic Behavior on a multi-core system using the State Combiner for </p>
<p>a combined core reaction.......................................................................... 45</p>
<p> </p>
<p>Figure 3-1</p>
<p> </p>
<p> Start phase of the WdgM ......................................................................... 51</p>
<p> </p>
<p>Figure 3-2</p>
<p> </p>
<p> Memory usage of the WdgM .................................................................... 54</p>
<p> </p>
<p>Figure 3-3</p>
<p> </p>
<p> Time base of WdgM ................................................................................. 59</p>
<p> </p>
<p>Figure 3-4</p>
<p> </p>
<p> WdgM Tick source selection for deadline supervision .............................. 61</p>
<p> </p>
<p>Figure 5-1</p>
<p> </p>
<p> Expected interfaces to external modules ................................................. 80</p>
<p> </p>
<p>Figure 6-1</p>
<p> </p>
<p> Workflow of the WdgM Configuration Verifier build .................................. 87</p>
<p> </p>
<p><b> </b></p>
<p><b>Tables </b></p>
<p>Table 1-1</p>
<p> </p>
<p>Component history...................................................................................... 8</p>
<p> </p>
<p>Table 2-1 </p>
<p> </p>
<p>WdgM Local Entity Stats ........................................................................... 37</p>
<p> </p>
<p>Table 2-2 </p>
<p> </p>
<p>Names of configuration fields .................................................................... 38</p>
<p> </p>
<p>Table 3-1 </p>
<p> </p>
<p>Supported AUTOSAR standard conform features ..................................... 48</p>
<p> </p>
<p>Table 3-2 </p>
<p> </p>
<p>Features provided beyond the AUTOSAR standard .................................. 50</p>
<p> </p>
<p>Table 3-3 </p>
<p> </p>
<p>Code and Constants ................................................................................. 55</p>
<p> </p>
<p>Table 3-4 </p>
<p> </p>
<p>WdgM constants ....................................................................................... 55</p>
<p> </p>
<p>Table 3-5 </p>
<p> </p>
<p>Module variables with MICROSAR Os Gen6 / AUTOSAR Os version 4.0 . 56</p>
<p> </p>
<p>Table 3-6 </p>
<p> </p>
<p>Module variables MICROSAR Os Gen7 / AUTOSAR Os version 4.2 ........ 57</p>
<p> </p>
<p>Table 3-7 </p>
<p> </p>
<p>Supervised Entity Variables MICROSAR Os Gen6 / AUTOSAR Os </p>
<p>version 4.0 ................................................................................................ 57</p>
<p> </p>
<p>Table 3-8 </p>
<p> </p>
<p>Supervised Entity Variables MICROSAR Os Gen7 / AUTOSAR Os </p>
<p>version 4.2 ................................................................................................ 57</p>
<p> </p>
<p>Table 3-9 </p>
<p> </p>
<p>Configuration Parameters ......................................................................... 60</p>
<p> </p>
<p>Table 3-10 </p>
<p> </p>
<p>Service IDs ............................................................................................... 64</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>7 </p>
<p>based on template version 5.12.0 </p>
<p>Table 3-11 </p>
<p> </p>
<p>Errors reported to DET ............................................................................. 65</p>
<p> </p>
<p>Table 3-12 </p>
<p> </p>
<p>Errors reported to DEM ............................................................................. 65</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Static files ................................................................................................. 66</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>Generated files ......................................................................................... 66</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>Type definitions ......................................................................................... 69</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>WdgM_Init ................................................................................................ 70</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>WdgM_GetVersionInfo .............................................................................. 70</p>
<p> </p>
<p>Table 5-4 </p>
<p> </p>
<p>WdgM_SetMode ....................................................................................... 71</p>
<p> </p>
<p>Table 5-5 </p>
<p> </p>
<p>WdgM_ActivateSupervisionEntity ............................................................. 72</p>
<p> </p>
<p>Table 5-6 </p>
<p> </p>
<p>WdgM_DeactivateSupervisionEntity ......................................................... 73</p>
<p> </p>
<p>Table 5-7 </p>
<p> </p>
<p>WdgM_MainFunction ................................................................................ 74</p>
<p> </p>
<p>Table 5-8 </p>
<p> </p>
<p>WdgM_GetMode ...................................................................................... 75</p>
<p> </p>
<p>Table 5-9 </p>
<p> </p>
<p>WdgM_GetLocalStatus ............................................................................. 75</p>
<p> </p>
<p>Table 5-10 </p>
<p> </p>
<p>WdgM_GetGlobalStatus ........................................................................... 76</p>
<p> </p>
<p>Table 5-11 </p>
<p> </p>
<p>WdgM_CheckpointReached ..................................................................... 76</p>
<p> </p>
<p>Table 5-12 </p>
<p> </p>
<p>WdgM_PerformReset ............................................................................... 77</p>
<p> </p>
<p>Table 5-13 </p>
<p> </p>
<p>WdgM_GetFirstExpiredSEID .................................................................... 78</p>
<p> </p>
<p>Table 5-14 </p>
<p> </p>
<p>WdgM_GetFirstExpiredSEViolation .......................................................... 78</p>
<p> </p>
<p>Table 5-15 </p>
<p> </p>
<p>WdgM_UpdateTickCount .......................................................................... 79</p>
<p> </p>
<p>Table 5-16 </p>
<p> </p>
<p>Services used by the WdgM ..................................................................... 79</p>
<p> </p>
<p>Table 5-17 </p>
<p> </p>
<p>Global state callback ................................................................................. 82</p>
<p> </p>
<p>Table 5-18 </p>
<p> </p>
<p>Local state change notification .................................................................. 83</p>
<p> </p>
<p>Table 5-19</p>
<p>alive_&lt;WdgMSupervisedEntityShortname&gt;_&lt;WdgMCheckpointShortname&gt; 84</p>
<p> </p>
<p>Table 5-20 </p>
<p> </p>
<p>alive_&lt;WdgMSupervisedEntityShortname&gt; .............................................. 85</p>
<p> </p>
<p>Table 5-21 </p>
<p> </p>
<p>individual_&lt;WdgMSupervisedEntityShortname&gt; ...................................... 85</p>
<p> </p>
<p>Table 5-22 </p>
<p> </p>
<p>global_&lt;WdgMGlobalMemoryAppTaskRefShortname&gt; / global_WdgM .... 85</p>
<p> </p>
<p>Table 5-23 </p>
<p> </p>
<p>localStateChangeCbk_&lt;WdgMSupervisedEntityShortname&gt; ................... 86</p>
<p> </p>
<p>Table 5-24 </p>
<p> </p>
<p>localStateChangeCbk_&lt;WdgMSupervisedEntityShortname&gt; ................... 86</p>
<p> </p>
<p>Table 7-1 </p>
<p> </p>
<p>Glossary ................................................................................................... 95</p>
<p> </p>
<p>Table 7-2 </p>
<p> </p>
<p>Abbreviations ............................................................................................ 96</p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>8 </p>
<p>based on template version 5.12.0 </p>
<p><b>1 </b></p>
<p><b>Component History </b></p>
<p>The </p>
<p>component </p>
<p>history </p>
<p>gives </p>
<p>an </p>
<p>overview </p>
<p>over </p>
<p>the </p>
<p>important </p>
<p>milestones </p>
<p>that </p>
<p>are </p>
<p>supported in the different versions of the component.  </p>
<p><b>Component Version </b></p>
<p><b>New Features </b></p>
<p>1.00 </p>
<p>Migration of the WdgM to Vector Informatik GmbH </p>
<p>2.00 </p>
<p>Introduction of native CFG5 generator </p>
<p>Table 1-1 </p>
<p>Component history </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>9 </p>
<p>based on template version 5.12.0 </p>
<p><b>2 </b></p>
<p><b>Introduction </b></p>
<p>This document describes the functionality, API and configuration of the AUTOSAR BSW </p>
<p>module WdgM as specified in [1]. </p>
<p> </p>
<p><b>Supported AUTOSAR Release*: </b></p>
<p>4.0.1 </p>
<p><b>Supported Configuration Variants: </b></p>
<p>pre-compile </p>
<p><b>Vendor ID: </b></p>
<p>WDGM_VENDOR_ID </p>
<p>30 decimal </p>
<p>(= Vector-Informatik, </p>
<p>according to HIS) </p>
<p><b>Module ID: </b></p>
<p>WDGM_MODULE_ID  </p>
<p>13 decimal </p>
<p>(according to ref. [7]) </p>
<p>* For the detailed functional specification please also refer to the corresponding AUTOSAR SWS. </p>
<p> </p>
<p> </p>
<p>The Watchdog (Wdg) Stack provides software modules to monitor the correct functioning </p>
<p>of safety-relevant activities in systems with software modules of mixed criticality, such as </p>
<p><b>&gt; </b></p>
<p>newly developed safety-related functions, </p>
<p><b>&gt; </b></p>
<p>legacy functions, and </p>
<p><b>&gt; </b></p>
<p>basic software. </p>
<p>The Wdg Stack is designed to be used in automotive ECUs. </p>
<p>The Wdg Stack has three software modules: </p>
<p><b>&gt; </b></p>
<p>Watchdog Manager (WdgM) </p>
<p><b>&gt; </b></p>
<p>Watchdog Interface (WdgIf) </p>
<p><b>&gt; </b></p>
<p>Watchdog Driver (Wdg) </p>
<p>The WdgM can run on single-core and multi-core systems. </p>
<p>This user manual describes the WdgM, which is an AUTOSAR basic software module that </p>
<p>is  part  of  the  AUTOSAR  service  layer.  The WdgM  checks  the  logical  program  flow  and </p>
<p>temporal </p>
<p>behavior </p>
<p>of </p>
<p>the </p>
<p>program </p>
<p>flow </p>
<p>of </p>
<p>safety-relevant </p>
<p>functions. </p>
<p>Safety-relevant </p>
<p>functions  use  checkpoint  calls  to  send  life  signs  to  the  WdgM.  Internal  or  external </p>
<p>watchdog hardware is used independently from the system CPU to monitor </p>
<p><b>&gt; </b></p>
<p>if the system is still alive, </p>
<p><b>&gt; </b></p>
<p>if the system functions properly, and  </p>
<p><b>&gt; </b></p>
<p>if the system shows the correct temporal behavior and logical program flow. </p>
<p>The  WdgM  was  developed  according  to  AUTOSAR  version  4.0.1  [1].  The  WdgM  is </p>
<p>compatible  with  this  AUTOSAR  version,  but  not  fully  compliant.  For  the  deviations,  see </p>
<p>section Deviations from the AUTOSAR 4.0.1 Watchdog Manager. If the WdgM is used in </p>
<p>safety-related </p>
<p>systems </p>
<p>with </p>
<p>AUTOSAR </p>
<p>4.0.1 </p>
<p>or </p>
<p>another </p>
<p>version, </p>
<p>all </p>
<p>requirements </p>
<p>described in the Safety Manual [5] must be fulfilled. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>10 </p>
<p>based on template version 5.12.0 </p>
<p>This user manual does not cover safety-related topics. For safety-related requirements for </p>
<p>the integration and the application of the WdgM, refer to the Safety Manual [5]. </p>
<p><b>2.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The following figure shows where the WdgM is located in the AUTOSAR architecture. </p>
<p> </p>
<p>Figure 2-1   AUTOSAR 4.x Architecture Overview  </p>
<p>The WdgM Stack consists of the hardware-independent modules Watchdog Manager (blue </p>
<p>rectangle) and Watchdog Interface and a hardware-dependent module Watchdog Driver. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>11 </p>
<p>based on template version 5.12.0 </p>
<p>Figure 2-2 shows the WdgM Stack with its modules in an AUTOSAR environment. </p>
<p> </p>
<p>Figure 2-2   Watchdog Manager Stack in an AUTOSAR environment </p>
<p> </p>
<p>The </p>
<p>WdgM </p>
<p>controls, </p>
<p>through </p>
<p>the </p>
<p>WdgIf </p>
<p>and </p>
<p>the </p>
<p>Wdg, </p>
<p>the </p>
<p>hardware-implemented </p>
<p>watchdogs, which can be one or more internal or external watchdog devices. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>A watchdog device requires a hardware-dependent Wdg driver. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Figure 2-3 shows the layered structure of the WdgM Stack. The attached watchdog device </p>
<p>can be internal or external. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>12 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-3   Layered structure of the Watchdog Manager </p>
<p> </p>
<p>The  WdgM  monitors  the  program  flow  and  timing  constraints  of  so-called  supervised </p>
<p>entities (SE). The SEs are software entities (like application software) that are supervised </p>
<p>by the WdgM. When the WdgM detects a violation of the preconfigured program flow or </p>
<p>the timing constraints, it takes a number of configurable actions to log that violation and/or </p>
<p>go to a safe state (for details, see Section Basic Functionality of the WdgM). </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>13 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.2 </b></p>
<p><b>Use Cases </b></p>
<p>The WdgM monitors the user software at runtime and compares the preconfigured logical </p>
<p>and  temporal  constraints  with  the  actual  logical  and  temporal  behavior.  The WdgM  can </p>
<p>monitor the following violations: </p>
<p><b>&gt; </b></p>
<p>timing violation (checked by deadline supervision and alive supervision) </p>
<p><b>&gt; </b></p>
<p>program flow violation (checked by logical monitoring) </p>
<p>The  WdgM  periodically  triggers  the  watchdog  device  through  its  interface  (WdgIf)  and </p>
<p>driver layer (Wdg). When the WdgM detects a fault in the program flow or timing then it </p>
<p>stops the watchdog triggering, or it initiates a reset of the microcontroller immediately or </p>
<p>after a delay, depending on the WdgM configuration. </p>
<p>The WdgM monitors the following software and hardware faults: </p>
<p><b>&gt; </b></p>
<p>The supervised entity is executed, but the execution was not requested. </p>
<p><b>&gt; </b></p>
<p>The supervised entity was not executed, but the execution was requested. </p>
<p><b>&gt; </b></p>
<p>The execution of the supervised entity started too early or too late. </p>
<p><b>&gt; </b></p>
<p>The execution time of a supervised entity or part of a supervised entity or many </p>
<p>supervised entities is longer or shorter than expected. </p>
<p><b>&gt; </b></p>
<p>The program flow of a supervised entity or part of a supervised entity or many </p>
<p>supervised entities differs from expected program flow. </p>
<p>The reaction of the WdgM to detected faults can be configured as follows: </p>
<p><b>&gt; </b></p>
<p>WdgM sends information about the detected fault. </p>
<p><b>&gt; </b></p>
<p>WdgM initiates a reset of the microcontroller after a watchdog timeout. </p>
<p><b>&gt; </b></p>
<p>WdgM initiates an immediate reset of the microcontroller. </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>14 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.3 </b></p>
<p><b>Basic Functionality of the WdgM </b></p>
<p>As  described  in AUTOSAR  [1],  the WdgM  is a  basic software  module  that monitors the </p>
<p>program flow of supervised entities (SE). </p>
<p><b>2.3.1 </b></p>
<p><b>Supervised Entity and Program Flow Supervision </b></p>
<p>A supervised entity is a software part that is monitored by the WdgM. There is no fixed </p>
<p>relationship </p>
<p>between </p>
<p>supervised </p>
<p>entities </p>
<p>and </p>
<p>the </p>
<p>architectural </p>
<p>building </p>
<p>blocks </p>
<p>in </p>
<p>AUTOSAR. </p>
<p>The  checkpoints  mark  important  steps  during  the  execution  of  an  algorithm.  At  the </p>
<p>checkpoint, a supervised entity calls the function </p>
<p>WdgM_CheckpointReached()</p>
<p> directly </p>
<p>(if no runtime environment is present) or with a wrapper function (if a runtime environment </p>
<p>is present) being provided by the runtime environment. The checkpoints are connected by </p>
<p>transitions. Local transitions bind Checkpoints to a closed graph. These graphs represent </p>
<p>the program flow. </p>
<p>The  WdgM  knows  which  program  flow  is  correct  and  decides  if  a  supervised  entity </p>
<p>behaves as expected or violates the predefined rules. </p>
<p>The  question  of  how  to  identify  the  checkpoints  for  an  algorithm  is  a  trade-off  between </p>
<p>performance and code block size per checkpoint: </p>
<p><b>&gt; </b></p>
<p>The more checkpoints an algorithm has, the better is the representation of the code </p>
<p>structure. But this has an adverse effect on performance. </p>
<p><b>&gt; </b></p>
<p>However, if an algorithm has only a few checkpoints, then there are code segments </p>
<p>and program flow branches that are not represented. In this case, performance will be </p>
<p>better, but not everything will be monitored. </p>
<p>A supervised entity can represent an algorithm, a function, or – in the case of an operating </p>
<p>system – an entire task. In the AUTOSAR definition, a supervised entity can be distributed </p>
<p>over more than one task or application. There can be several supervised entities for the </p>
<p>same task. However, the WdgM implementation does not support the distribution of one </p>
<p>supervised  entity  over  more  than  one  task  or  application  when  they  run  in  different </p>
<p>contexts.  The  WdgM  expects </p>
<p>that  at </p>
<p>least </p>
<p>one  supervised  entity  and  at </p>
<p>least </p>
<p>one </p>
<p>checkpoint are defined. </p>
<p>Figure </p>
<p>2-4 </p>
<p>shows </p>
<p>the </p>
<p>example </p>
<p>of </p>
<p>a </p>
<p>simple </p>
<p>supervised </p>
<p>entity </p>
<p>called </p>
<p>temperature_control</p>
<p>: </p>
<p><b>&gt; </b></p>
<p>Supervised  entity </p>
<p>temperature_control</p>
<p>  has  six  checkpoints  (illustrated  by  oval </p>
<p>boxes), which are connected by directed transitions (illustrated by arrows). </p>
<p><b>&gt; </b></p>
<p>As </p>
<p>can </p>
<p>be </p>
<p>seen </p>
<p>in </p>
<p>Figure </p>
<p>2-4, </p>
<p>it </p>
<p>is </p>
<p>possible </p>
<p>to </p>
<p>reach </p>
<p>the </p>
<p>checkpoint </p>
<p>temperature_needs_correction</p>
<p> after the checkpoint </p>
<p>read_temperature</p>
<p>. </p>
<p><b>&gt; </b></p>
<p>However,  reaching  the </p>
<p>checkpoint heater_adjusted_successfully</p>
<p>  after the </p>
<p>checkpoint </p>
<p>read_temperature</p>
<p> would be a violation of the program flow. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>15 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-4   Example of a simple supervised entity with a control flow </p>
<p> </p>
<p><b>2.3.2 </b></p>
<p><b>Program Flow Supervision </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Program Flow </p>
<p>Supervision</p>
<p> can only be used if the WDG add-on for program flow and </p>
<p>deadline </p>
<p>supervision</p>
<p> is licensed. </p>
<p>(“WdgM_ProgramFlowAndDeadlineMonitoring”)</p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Control (program) flow supervision is highly recommended by ISO 26262-6 (7.4.14). Apart </p>
<p>from its main feature, which is to detect logical errors in the monitored algorithms, program </p>
<p>flow supervision increases the probability of detecting illegal program counter jumps within </p>
<p>the whole system. </p>
<p>In  addition  to  the  specification  by  AUTOSAR,  it  is  possible  to  tolerate  program  flow </p>
<p>violations  within  a  supervised  entity  for  a  certain  amount  of  supervision  cycles.  It  is </p>
<p>possible  to  define  a  program  flow  reference  cycle  (a  multiple  of  the  WdgM  supervision </p>
<p>cycle) and a tolerance, which is a number of program flow reference cycles, during which </p>
<p>program  flow  violations  should  be  tolerated  for  the  supervised  entity.  If  a  program  flow </p>
<p>violation  is  detected for more program flow  reference  cycles  than  the  defined tolerance, </p>
<p>then the supervised entity changes its status from </p>
<p>FAILED</p>
<p> to </p>
<p>EXPIRED</p>
<p>. </p>
<p>The </p>
<p>necessary </p>
<p>configuration </p>
<p>parameters </p>
<p>to </p>
<p>tolerate </p>
<p>program </p>
<p>flow </p>
<p>violations </p>
<p>of </p>
<p>a </p>
<p>supervised entity are: </p>
<p><b>&gt; </b></p>
<p>WdgMFailedProgramFlowRefCycleTol</p>
<p>:  This  parameter  contains  the  acceptable </p>
<p>amount of program flow violations for this supervised entity. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>16 </p>
<p>based on template version 5.12.0 </p>
<p><b>&gt; </b></p>
<p>WdgMProgramFlowReferenceCycle</p>
<p>: </p>
<p>This </p>
<p>parameter </p>
<p>contains </p>
<p>the </p>
<p>amount </p>
<p>of </p>
<p>supervision cycles to be used as reference by the program flow supervisions of this </p>
<p>supervised entity. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The program flow reference cycle for a supervised entity starts with the first detected </p>
<p>program flow violation and not with the WdgM startup. Hence, the first program flow </p>
<p>reference  cycle  starts  with  the  transition  of  the  supervised  entity  from  status  OK  to </p>
<p>FAILED. If  no  program flow  violation  is  detected for  a  whole  program flow  reference </p>
<p>cycle within the tolerance then the supervised entity recovers and changes its status </p>
<p>from  FAILED  to  OK.  Otherwise,  if  the  tolerance  is  exhausted  and  the  program  flow </p>
<p>violations continue, then the supervised entity changes its status to EXPIRED. It can be </p>
<p>said that the program flow reference cycle is processed only during the status FAILED </p>
<p>–  it  starts  with  the  first  detected  program  flow  violation. The  program  flow  reference </p>
<p>cycle  is  restarted  with  each  following  transition  from  OK  to  FAILED,  and  it  is  not </p>
<p>processed during the status OK, EXPIRED or DEACTIVATED.<b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.3 </b></p>
<p><b>Deadline Supervision </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Deadline Supervision can only be used if the WDG add-on for program flow and </p>
<p>deadline supervision is licensed. </p>
<p>(“WdgM_ProgramFlowAndDeadlineMonitoring”) </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The main purpose of deadline supervision is to check the temporal, dynamic behavior of </p>
<p>the supervised entity. However, it would also strongly increase the probability of detecting </p>
<p>random  jumps  or  irregular  updates  of  the  timebase  tick  counter,  which  might  otherwise </p>
<p>degrade system integrity without being discovered. </p>
<p>The temporal behavior of the supervised entities can be monitored by assigning deadlines </p>
<p>to transitions. </p>
<p><b>&gt; </b></p>
<p>A deadline is defined through a maximum deadline (parameter </p>
<p>WdgMDeadlineMax</p>
<p>) </p>
<p>and a minimum deadline (parameter </p>
<p>WdgMDeadlineMin</p>
<p>). The destination checkpoint </p>
<p>of a transition should not be reached before the minimum time or after the maximum </p>
<p>time after which the source checkpoint of that transition was reached. Otherwise the </p>
<p>WdgM  will  detect  a  deadline  violation.  Apart  from  a  maximum  deadline  time  it  is </p>
<p>strongly recommended to use a minimum deadline time as well, where applicable. This </p>
<p>allows  discovering  timebase  tick  counter  errors  implicitly.  Deadlines  are  good  for </p>
<p>discovering  crashed  tasks  or  infinite  loops.  If  the  destination  checkpoint  is  never </p>
<p>reached because the task ended with an error or is stuck in a loop, this would cause a </p>
<p>deadline violation. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>17 </p>
<p>based on template version 5.12.0 </p>
<p><b>&gt; </b></p>
<p>A deadline is assigned to an already defined transition by specifying the same source </p>
<p>and </p>
<p>destination </p>
<p>checkpoints </p>
<p>as </p>
<p>for </p>
<p>the </p>
<p>transition. </p>
<p>The </p>
<p>corresponding </p>
<p>deadline </p>
<p>parameters are </p>
<p>WdgMDeadlineStartRef</p>
<p> and </p>
<p>WdgMDeadlineStopRef</p>
<p>. </p>
<p><b>&gt; </b></p>
<p>For  local  transitions,  the  source  and  destination  checkpoints  belong  to  the  same </p>
<p>supervised entity. </p>
<p><b>&gt; </b></p>
<p>For  global  transitions,  the  source  and  destination  checkpoints  belong  to  different </p>
<p>supervised entities. </p>
<p>An example of a supervised entity with deadlines defined for its transitions is given below. </p>
<p>The  first  deadline  is  defined  to  have  a  minimum  of  0  and  a  maximum  of  2  (seconds). </p>
<p>Hence,  CP1  must  be  reached  no  later  than  2  seconds  after  CP0. The  second  deadline </p>
<p>implies that CP2 must be reached no earlier than 1 and no later than 3 seconds after CP1. </p>
<p>Otherwise a deadline violation will be detected. </p>
<p> </p>
<p> </p>
<p>Figure 2-5   Example of a simple supervised entity with deadlines </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Deadline violation is detected </p>
<p><b>&gt; </b></p>
<p>when the next checkpoint is reached outside the defined deadline or </p>
<p><b>&gt; </b></p>
<p>within the </p>
<p>WdgM_MainFunction()</p>
<p> if the next checkpoint is not reached at all (or </p>
<p>has not been reached yet) and the maximum deadline has already expired</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>A </p>
<p>slightly </p>
<p>more </p>
<p>complex </p>
<p>situation </p>
<p>is </p>
<p>when </p>
<p>several </p>
<p>transitions </p>
<p>go </p>
<p>out </p>
<p>of </p>
<p>the </p>
<p>same </p>
<p>checkpoint. In this case, deadline violations are detected in the same manner when the </p>
<p>next  checkpoint  is  reached  outside  the  defined  deadlines.  However,  if  none  of  the  next </p>
<p>checkpoints  is  reached,  the </p>
<p>WdgM_MainFunction()</p>
<p>  detects  a  deadline  violation  only </p>
<p>after the maximum of maximum deadlines of all outgoing transitions has elapsed, which is </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>18 </p>
<p>based on template version 5.12.0 </p>
<p>seconds after reaching CP0, shown in Figure 2-6. If the program gets stuck after CP0, the </p>
<p>deadline violation is detected within the next main function that is executed not earlier than </p>
<p>5 seconds after reaching CP0. </p>
<p> </p>
<p>Figure 2-6   Example of multiple outgoing transitions with deadlines </p>
<p>A special case is a hybrid situation when some of the outgoing transitions have deadlines </p>
<p>and others do not. In this case, the main function detects a deadline violation if none of the </p>
<p>next checkpoints is reached within the maximum of configured deadlines in order to detect </p>
<p>blocked supervised entities. No deadline violation will be detected after the maximum has </p>
<p>expired, however, if the checkpoint without deadline is reached before the main function. If </p>
<p>none </p>
<p>of </p>
<p>the </p>
<p>CP1, </p>
<p>CP2 </p>
<p>is </p>
<p>reached </p>
<p>after </p>
<p>CP0 </p>
<p>(Figure </p>
<p>2-7), </p>
<p>then </p>
<p>the </p>
<p>next </p>
<p>WdgM_MainFunction()</p>
<p>  (executed  at  least  2  seconds  after  CP0  is  reached)  detects  a </p>
<p>deadline  violation.  If,  however,  CP1  is  reached  after  2  seconds,  but  before  the  next </p>
<p>WdgM_MainFunction()</p>
<p>, no deadline violation would be detected. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>To avoid this ambiguous situation it is a good practice to define deadlines for all </p>
<p>outgoing transitions of a checkpoint (or for none of them). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>19 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-7   Example of a the case where only one of several outgoing transitions has a deadline </p>
<p>The rules for deadline violation detection also apply to global transitions or to the case of </p>
<p>local transitions mixed with global transitions at a checkpoint. </p>
<p>In  addition  to  the  specification  by  AUTOSAR,  it  is  possible  to  tolerate  also  deadline </p>
<p>violations  within  a  supervised  entity  for  a  certain  amount  of  supervision  cycles.  It  is </p>
<p>possible define a deadline reference cycle (a multiple of the WdgM supervision cycle) and </p>
<p>a  tolerance,  which  is  a  number  of  deadline  reference  cycles,  during  which  deadline </p>
<p>violations should be tolerated for the supervised entity. If a deadline violation is detected </p>
<p>for more deadline reference cycles than the defined tolerance, then the supervised entity </p>
<p>changes its status from </p>
<p>FAILED</p>
<p> to </p>
<p>EXPIRED</p>
<p>. </p>
<p>The  necessary  configuration  parameters  to  tolerate  deadline  violations  of  a  supervised </p>
<p>entity are: </p>
<p><b>&gt; </b></p>
<p>WdgMFailedDeadlineRefCycleTol</p>
<p>: This parameter contains the acceptable </p>
<p>amount of violated deadlines for this supervised entity. </p>
<p><b>&gt; </b></p>
<p>WdgMDeadlineReferenceCycle</p>
<p>: This parameter contains the amount of </p>
<p>supervision cycles to be used as reference by the deadline supervisions of this </p>
<p>supervised entity. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>20 </p>
<p>based on template version 5.12.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The  deadline  reference  cycle  for  a  supervised  entity  starts  with  the  first  detected </p>
<p>deadline violation and not with the WdgM start up. Hence, the first deadline reference </p>
<p>cycle starts with the transition of the supervised entity from the status </p>
<p>OK</p>
<p> to </p>
<p>FAILED</p>
<p>. If </p>
<p>no  deadline  violation  is  detected  for  a  whole  deadline  reference  cycle  within  the </p>
<p>tolerance, then the supervised entity recovers and changes its status from </p>
<p>FAILED</p>
<p> to </p>
<p>OK</p>
<p>. Otherwise, if the tolerance is exhausted and the deadline violations continue, then </p>
<p>the supervised entity changes its status to </p>
<p>EXPIRED</p>
<p>. It can be said that the deadline </p>
<p>reference  cycle  is  processed  only  during  the  status </p>
<p>FAILED</p>
<p>  –  it  starts  with  the  first </p>
<p>detected </p>
<p>deadline </p>
<p>violation.  The </p>
<p>deadline </p>
<p>reference  cycle </p>
<p>is </p>
<p>restarted </p>
<p>with </p>
<p>each </p>
<p>following transition from </p>
<p>OK</p>
<p> to </p>
<p>FAILED</p>
<p>, and it is not processed during the status </p>
<p>OK</p>
<p>, </p>
<p>EXPIRED</p>
<p> or </p>
<p>DEACTIVATED</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.4 </b></p>
<p><b>Alive Supervision </b></p>
<p>Aliveness monitors the frequency of hits of checkpoints. For example, the algorithm could </p>
<p>expect a sensor to report its measurements on a regular basis, and a certain task needs to </p>
<p>process this data periodically. If a task stops reporting (alive sign is lost or too infrequent) </p>
<p>or starts reporting too often, then the aliveness of that task is violated. </p>
<p>Alive  supervision  is  associated  with  a  checkpoint  in  a  supervised  entity.  If  you  need  to </p>
<p>monitor only the frequency with which a task is called, you can define a supervised entity </p>
<p>that contains only one checkpoint with the corresponding aliveness parameters. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Irregular </p>
<p>calls </p>
<p>of </p>
<p>the </p>
<p>WdgM </p>
<p>main </p>
<p>function </p>
<p>or </p>
<p>the </p>
<p>omission </p>
<p>of </p>
<p>calls </p>
<p>of </p>
<p>WdgM_CheckPointReached()</p>
<p> would most likely result in aliveness violation. When </p>
<p>alive supervision for a checkpoint is activated, then that checkpoint must be regularly </p>
<p>called  for  the  entire  period  during  which  the  supervised  entity  is  active,  otherwise </p>
<p>aliveness  violation  will  be  detected.  In  the  first  supervision  cycle,  the  alive  counter </p>
<p>evaluation </p>
<p>can </p>
<p>be </p>
<p>suppressed </p>
<p>by </p>
<p>the </p>
<p>parameter </p>
<p>WdgMFirstCycleAliveCounterReset</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>It is important to consider which aliveness parameters are better for a specific situation. </p>
<p>The example below shows how to choose the appropriate alive supervision parameters: </p>
<p><b>&gt; </b></p>
<p>WdgMExpectedAliveIndications</p>
<p>: </p>
<p>Defines how many alive indications (checkpoint reached calls) are expected within one </p>
<p>supervision reference cycle. </p>
<p><b>&gt; </b></p>
<p>WdgMSupervisionReferenceCycle</p>
<p>: </p>
<p>Defines  the  supervision  reference  cycle  length  as  a  number  of  supervision  cycles </p>
<p>(</p>
<p>WdgMSupervisionCycle</p>
<p>). </p>
<p><b>&gt; </b></p>
<p>WdgMMinMargin</p>
<p>: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>21 </p>
<p>based on template version 5.12.0 </p>
<p>Defines the lower tolerance of expected alive indications. </p>
<p><b>&gt; </b></p>
<p>WdgMMaxMargin</p>
<p>: </p>
<p>Defines the upper tolerance of expected alive indications. </p>
<p><b>&gt; </b></p>
<p>Hence, the allowed number of indications is in the range </p>
<p>[WdgMExpectedAliveIndications - WdgMMinMargin, </p>
<p>WdgMExpectedAliveIndications + WdgMMaxMargin]</p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In contrast to the deadline and program flow reference cycle the alive supervision cycle </p>
<p>begins  with  the  WdgM  startup.  The  alive  supervision  in  the  very  first  cycle  can  be </p>
<p>influenced </p>
<p>by </p>
<p>the </p>
<p>parameter </p>
<p>WdgMFirstCycleAliveCounterReset</p>
<p>. </p>
<p>This </p>
<p>is </p>
<p>because  each  alive  counter  is  evaluated  once  per  supervision  reference  cycle.  This </p>
<p>means that the supervision reference cycle is processed from the system startup on </p>
<p>and  during  the  status </p>
<p>OK</p>
<p>  and </p>
<p>FAILED</p>
<p>  of  the  corresponding  supervised  entity.  If  the </p>
<p>supervised entity is in the status </p>
<p>EXPIRED</p>
<p>, then the supervision reference cycle is not </p>
<p>needed  anymore.  If  the  supervised  entity  is  in  the  status </p>
<p>DEACTIVATED</p>
<p>,  then  the </p>
<p>supervision reference cycle is frozen. It is restarted if the supervised entity is activated </p>
<p>again. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>There are several ways for monitoring the task given in the example above. Below, one </p>
<p>variant is given: </p>
<p>Set </p>
<p><b>&gt; </b></p>
<p>WdgMExpectedAliveIndications=1 </p>
<p><b>&gt; </b></p>
<p>WdgMSupervisionReferenceCycle=1 </p>
<p><b>&gt; </b></p>
<p>WdgMMinMargin=1</p>
<p> </p>
<p><b>&gt; </b></p>
<p>WdgMMaxMargin=0 </p>
<p>This means the WdgM should expect 1 or 0 (</p>
<p>WdgMExpectedAliveIndications - </p>
<p>WdgMMinMargin</p>
<p>) occurrences within one supervised reference cycle, which is fixed to </p>
<p>20ms (which is one WdgM supervision cycle). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>22 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-8   A task being monitored during one WdgM supervision cycle (20ms) </p>
<p>However,  if  the  task  stops  being  executed  it  will  not  be  detected,  because  zero  alive </p>
<p>indications per supervised reference cycle are tolerated. Therefore, this choice of setting </p>
<p>aliveness parameters is not very good. </p>
<p>Below, a second variant is given: </p>
<p>Set </p>
<p><b>&gt; </b></p>
<p>WdgMExpectedAliveIndications=2 </p>
<p><b>&gt; </b></p>
<p>WdgMSupervisionReferenceCycle=2</p>
<p> </p>
<p><b>&gt; </b></p>
<p>WdgMMinMargin=1 </p>
<p><b>&gt; </b></p>
<p>WdgMMaxMargin=0 </p>
<p>This  means  the  WdgM  should  expect  1  or  2  alive  indications  within  one  supervised </p>
<p>reference cycle, which is fixed to 40ms (and which is two WdgM supervision cycles). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>23 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-9   A task being monitored during two WdgM supervision cycles (40ms) </p>
<p>This configuration solves the problem of detecting the disappearance of the task. However, </p>
<p>the reaction time for error detection doubles from 20 to 40ms. </p>
<p>A  third  variant  would  be  to  set  the  supervision  reference  cycle  to  the  least  common </p>
<p>multiple of the WdgM supervision cycle and the task period. In the example given above </p>
<p>this  would  be 60ms  (three WdgM  supervision  cycles).  In this case,  we  expect exactly  2 </p>
<p>alive indications. Hence, the minimum and maximum margins are both </p>
<p>0</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The  task  period  and  the WdgM  supervision  cycle  must  be  synchronized  and  started </p>
<p>with an offset to each other (e.g. scheduled in an operating system). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.5 </b></p>
<p><b>More Details on Checkpoints and Transitions </b></p>
<p>Every supervised entity has one initial checkpoint. The number of end checkpoints can be </p>
<p>zero, one or more than one. If the supervised entity contains only one single checkpoint, </p>
<p>then it should be both an initial and an end checkpoint. Local transitions are defined by </p>
<p>their  source  and  destination  checkpoints,  which  must  belong  to  the  same  supervised </p>
<p>entity. </p>
<p>Those </p>
<p>local </p>
<p>transitions </p>
<p>are </p>
<p>specified </p>
<p>in </p>
<p>the </p>
<p>parameters </p>
<p>WdgMLocalTransitionSourceRef</p>
<p> and </p>
<p>WdgMLocalTransitionDestRef. </p>
<p>After initialization of the WdgM, all supervised entities are passive. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This has nothing to do with the supervised entity state </p>
<p>WDGM_LOCAL_STATUS_DEACTIVATED. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>24 </p>
<p>based on template version 5.12.0 </p>
<p>A supervised entity becomes active when its local initial checkpoint has been called. In the </p>
<p>example of the supervised entity </p>
<p>temperature_control</p>
<p> (see Section Supervised Entity </p>
<p>and Program Flow Supervision and Figure 2-4), the initial checkpoint is read_temperature. </p>
<p>Only  if  the  supervised  entity  is  active,  its  checkpoints  (other  than  the  initial  checkpoint) </p>
<p>may be reached, otherwise a program flow violation occurs. Reaching an end checkpoint, </p>
<p>the supervised entity is set to passive state, and it can be activated again only through the </p>
<p>initial checkpoint. </p>
<p> </p>
<p>Reaching the initial checkpoint again after the supervised entity has been activated is a </p>
<p>program flow violation. </p>
<p> </p>
<p>Local reflexive transitions (from a checkpoint to itself) are allowed only if configured. The </p>
<p>reflexive transitions cannot be defined for local initial or local end checkpoints. </p>
<p> </p>
<p>Local initial checkpoints are not allowed to have local incoming transitions. </p>
<p> </p>
<p>Local end checkpoints are not allowed to have local outgoing transitions. </p>
<p> </p>
<p><b>2.3.6 </b></p>
<p><b>Global Transitions </b></p>
<p>It  is  possible  to  represent  program  flow  dependencies  between  supervised  entities  by </p>
<p>using </p>
<p>so-called </p>
<p>global </p>
<p>transitions. </p>
<p>Global </p>
<p>transitions </p>
<p>are </p>
<p>defined </p>
<p>for </p>
<p>the </p>
<p>WdgM </p>
<p>configuration by their source and destination checkpoints, which must belong to different </p>
<p>supervised </p>
<p>entities </p>
<p>and </p>
<p>which </p>
<p>are </p>
<p>specified </p>
<p>by </p>
<p>the </p>
<p>parameters </p>
<p>WdgMExternalCheckpointInitialRef</p>
<p>  and </p>
<p>WdgMExternalCheckpointFinalRef</p>
<p>. </p>
<p>The end checkpoint of a supervised entity is usually connected to the initial checkpoint of </p>
<p>another  supervised  entity,  expressing  a  logical  dependency  between  them.  However, </p>
<p>global transitions are allowed between any two checkpoints of any two supervised entities. </p>
<p>One  must  keep  in  mind  several  things  when  defining  a  global  transition  between  two </p>
<p>arbitrary checkpoints: </p>
<p><b>&gt; </b></p>
<p>If  the  source  of  the  global  transition  is  not  a  local  end  checkpoint,  then  the  source </p>
<p>entity  will  remain  active.  Program  flow  violation  would  occur  if  its  initial  checkpoint </p>
<p>were reached again. </p>
<p><b>&gt; </b></p>
<p>If the destination checkpoint of the global transition is not a local initial checkpoint, the </p>
<p>destination entity may not be active. Program flow violation would occur if a non-initial </p>
<p>checkpoint of an inactive supervised entity were reached. </p>
<p><b>&gt; </b></p>
<p>Exactly one global initial checkpoint must be defined. The first global transition passed </p>
<p>must have that checkpoint as a source. </p>
<p><b>&gt; </b></p>
<p>It is possible to define one or several global end checkpoints or none. Once the global </p>
<p>end  checkpoint  served  as  a  destination  checkpoint  of  a  global  transition,  no  more </p>
<p>global </p>
<p>transitions </p>
<p>are </p>
<p>allowed </p>
<p>(unless </p>
<p>they </p>
<p>are </p>
<p>started </p>
<p>with </p>
<p>the </p>
<p>global </p>
<p>initial </p>
<p>checkpoint). </p>
<p>Figure 2-10 shows a global transition between two supervised entities: </p>
<p><b>&gt; </b></p>
<p>The </p>
<p>pressure_sensor_task</p>
<p> gets the pressure value. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>25 </p>
<p>based on template version 5.12.0 </p>
<p><b>&gt; </b></p>
<p>The </p>
<p>control_pressure_task</p>
<p>  calculates  a  reaction  and  reacts  to  the  measured </p>
<p>pressure.  However,  it  can  start  only  after  the  first  task  (</p>
<p>pressure_sensor_task</p>
<p>) </p>
<p>has finished and after the pressure value has been obtained. This relation is shown by </p>
<p>a global transition (see dotted arrow). </p>
<p><b>&gt; </b></p>
<p>Some transitions in Figure 2-10 have comments that show deadlines in milliseconds. </p>
<p><b>&gt; </b></p>
<p>Deadlines can also be defined for global transitions (see dotted arrow), where 1..5ms </p>
<p>means that the second task (</p>
<p>control_pressure_task</p>
<p>) should start not later than </p>
<p>5ms, but not earlier than 1ms after the first task has finished. </p>
<p> </p>
<p>Figure 2-10  </p>
<p>Global transition between two supervised entities </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Global transitions between supervised entities that are assigned to different processor </p>
<p>cores are not supported. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>26 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.3.7 </b></p>
<p><b>Global Transitions and Program Flow </b></p>
<p>In general the, program flow does not differ between local and global transitions. But what </p>
<p>seems  intuitive  for  local  transitions  might  not  be  so  obvious  for  global  transitions.  This </p>
<p>section gives examples that show the usage of local and global transitions with a focus on </p>
<p>program flow split. </p>
<p>From  the  perspective  of  the  WdgM,  the  program  flow  is  the  consecutive  reaching  of </p>
<p>checkpoints.  The  start  of  each  program  flow  must  be  a  local  initial  checkpoint.  The </p>
<p>program flow propagates through local transitions within the boundaries of a supervised </p>
<p>entity  and  through  global  transitions  within  the  boundaries  of  the  whole  system.  The </p>
<p>program flow might eventually come to an end at a local end checkpoint, or never come to </p>
<p>an end if a program flow loop occurs. </p>
<p>A very important feature is that it is not allowed to split the program flow. This means that </p>
<p>the program flow is allowed to take only one transition at each checkpoint from which more </p>
<p>than one local or global transition comes out. </p>
<p><b>2.3.7.1 </b></p>
<p><b>Example of an Incorrect Global Transition Split </b></p>
<p>Figure 2-11 shows that after checkpoint cp0_1 the program flow must decide to take either </p>
<p>the  global transition  cp1_0  or cp2_0.  Reaching  cp2_0  immediately  after reaching  cp1_0 </p>
<p>would result in a program flow violation. </p>
<p> </p>
<p>Figure 2-11  </p>
<p>Incorrect global transition split </p>
<p><b>2.3.7.2 </b></p>
<p><b>Example of an Incorrect Program Split in the Middle of an Entity </b></p>
<p>Figure 2-12 shows another example. Let us assume that the program flow reaches cp0_0 </p>
<p>and then cp0_1. Afterward the program flow decides to take the global transition reaching </p>
<p>cp1_0 instead of taking the local transition. Now, if the local transition took place afterward </p>
<p>(by  reaching  cp0_2),  a  program  flow  violation  would  occur.  However,  cp0_2  can  be </p>
<p>reached via the global transition if the program flow comes from cp1_1. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>27 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-12  </p>
<p>Incorrect program split in the middle of an entity </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>It  is  easy  to  create  configurations  with  complex  global  transitions  that  do  not  make </p>
<p>much sense in a real system. For example, if &quot;jumping out&quot; of a supervised entity from </p>
<p>a  checkpoint  that  is  not  a  local  end  checkpoint,  one  must  keep  in  mind  that  this </p>
<p>supervised  entity  is  still  active  (local  activity  flag  is  still </p>
<p>true</p>
<p>),  and  it  cannot  be </p>
<p>restarted by reaching its local initial checkpoint again. Thus, it is recommended to use </p>
<p>global  transitions  carefully  and  let  them  start  only  at  local  end  checkpoints  of  a </p>
<p>supervised entity and end at a local initial checkpoint of some other entity. Exceptions </p>
<p>to  this  must  be  analyzed  thoroughly,  with  respect  to  the  program  flow  and  the  local </p>
<p>activity of both supervised entities. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.8 </b></p>
<p><b>WdgM Supervision Cycle </b></p>
<p>The  supervision  cycle  is  the  time  period  in  which  the  cyclic  supervision  algorithm  is </p>
<p>executed. </p>
<p>At </p>
<p>the </p>
<p>end </p>
<p>of </p>
<p>each </p>
<p>supervision </p>
<p>cycle, </p>
<p>the </p>
<p>main </p>
<p>function, </p>
<p>WdgM_MainFunction()</p>
<p>, is called. This function evaluates the checkpoint data gathered </p>
<p>in  the  previous  period  and  triggers  the  Watchdog  if  no  violation  has  been  detected. </p>
<p>Function </p>
<p>WdgM_MainFunction()</p>
<p> also checks for violations depending on the reference </p>
<p>cycle defined for the respective monitoring feature. </p>
<p><b>Example</b>:  If </p>
<p>WdgMProgramFlowReferenceCycle=3</p>
<p>,  then  the  check  for  program  flow </p>
<p>violation is done in every third call of </p>
<p>WdgM_MainFunction()</p>
<p>. </p>
<p>The  shorter  this  period  and  the  reference  cycles,  the  shorter  the  reaction  time  of  the </p>
<p>WdgM, but the more processor time is consumed. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>28 </p>
<p>based on template version 5.12.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Aliveness  supervision  is  strongly  connected  to  this  period.  The  expected  number  of </p>
<p>alive </p>
<p>indications </p>
<p>for </p>
<p>a </p>
<p>certain </p>
<p>checkpoint </p>
<p>refers </p>
<p>to </p>
<p>the </p>
<p>last </p>
<p>supervision </p>
<p>cycle </p>
<p>(configurable  for  the  checkpoint),  which  is  expressed  in  the  number  of  supervision </p>
<p>cycles. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Figure 2-13 shows a time span with 3 supervision cycles. In each cycle, CP1 and CP2 are </p>
<p>hit once. Once the WdgM main function is called, the window for the next watchdog trigger </p>
<p>is defined by </p>
<p>WdgMTriggerWindowStart</p>
<p> and </p>
<p>WdgMTriggerConditionValue</p>
<p>. </p>
<p> </p>
<p>Figure 2-13  </p>
<p>WdgM supervision cycle </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For the scheduling of WdgM_MainFunction() calls, the integrator shall set </p>
<p><b>&gt; </b></p>
<p>WdgMTicksPerSecond, </p>
<p><b>&gt; </b></p>
<p>WdgMSupervisionCycle, </p>
<p><b>&gt; </b></p>
<p>WdgMTriggerWindowStart (per Wdg Trigger Mode), and </p>
<p><b>&gt; </b></p>
<p>WdgMTriggerConditionValue (per Wdg Trigger Mode) </p>
<p>according to the system requirements. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>29 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.3.9 </b></p>
<p><b>Fault Detection Time Evaluation </b></p>
<p>The WdgM distinguishes between the <b>fault detection time </b>and the <b>fault reaction time</b>. </p>
<p><b>&gt; </b></p>
<p>The  fault  detection  time  spans  from  the  occurrence  of  an  error  to  the  point  in  time </p>
<p>when  that  error  is  detected  and  communicated  to  the  system  (via  DET  or  callback </p>
<p>functions). </p>
<p><b>&gt; </b></p>
<p>The fault reaction time spans from the detection of an error to the actual system reset. </p>
<p>If a program flow violation or a deadline violation occurs, the source checkpoint and the </p>
<p>destination checkpoint report to the WdgM when hit. At the end of the current supervision </p>
<p>cycle,  the  WdgM  main  function, </p>
<p>WdgM_MainFunction()</p>
<p>,  is  called  and  the  violation  is </p>
<p>detected  (i.e.  the  configured  destination  checkpoint  was  hit  too  late  or  not  at  all)  and </p>
<p>communicated to the system. </p>
<p>If </p>
<p>an </p>
<p>alive </p>
<p>counter </p>
<p>violation </p>
<p>occurs, </p>
<p>it </p>
<p>is </p>
<p>also </p>
<p>the </p>
<p>main </p>
<p>function </p>
<p>that </p>
<p>detects </p>
<p>and </p>
<p>communicates  the  violation  at  the  end  of  the  supervision  reference  cycle  of  the  alive </p>
<p>supervision. </p>
<p>The </p>
<p>shortest </p>
<p>fault </p>
<p>detection </p>
<p>and </p>
<p>reaction </p>
<p>time </p>
<p>can </p>
<p>be </p>
<p>achieved </p>
<p>by </p>
<p>configuring </p>
<p>an </p>
<p>immediate  reset.  However,  the  time  still  depends  on  what  occurs  first  in  a  supervision </p>
<p>cycle, the fault or the hit of the checkpoint. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The time from fault occurrence to the system's safety reaction is the sum of </p>
<p><b>&gt; </b></p>
<p>WdgM Fault Detection Time, </p>
<p><b>&gt; </b></p>
<p>WdgM Fault Reaction Time, </p>
<p><b>&gt; </b></p>
<p>WdgIf Fault Reaction Time and </p>
<p><b>&gt; </b></p>
<p>Wdg Fault Reaction Time.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The WdgM fault detection time is evaluated differently for the various monitoring features </p>
<p>as shown in this section. </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>30 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.3.9.1 </b></p>
<p><b>Alive Supervision Fault Detection Time </b></p>
<p>Assume  that  a  fault  occurs  that  leads  to  an  alive  counter  violation.  The  WdgM  fault </p>
<p>detection time is the sum of the time spans </p>
<p><b>&gt; </b></p>
<p>from the fault to the scheduled call of the next checkpoint that is monitored and </p>
<p><b>&gt; </b></p>
<p>from this checkpoint to the next call of </p>
<p>WdgM_MainFunction()</p>
<p> with alive </p>
<p>supervision. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The multiple of supervision cycle that performs an alive supervision is defined by </p>
<p>WdgMSupervisionReferenceCycle</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>If zero calls of a checkpoint within an alive supervision interval are allowed, then </p>
<p>missing checkpoint calls cannot be detected. The fault detection time is then infinite. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The worst case for a given configuration happens when </p>
<p><b>&gt; </b></p>
<p>the time between the calls of </p>
<p>WdgM_MainFunction()</p>
<p> is always </p>
<p>WdgMTriggerConditionValue</p>
<p>, </p>
<p><b>&gt; </b></p>
<p>WdgM_MainFunction()</p>
<p> with alive supervision is called, </p>
<p><b>&gt; </b></p>
<p>all checkpoints scheduled for the alive supervision interval are passed immediately </p>
<p>afterwards, and </p>
<p><b>&gt; </b></p>
<p>the fault happens immediately after the last checkpoint. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Then the maximum fault detection time is almost: </p>
<p>2 ∗  </p>
<p>WdgMTriggerConditionValue</p>
<p>  ∗  </p>
<p>WdgMSupervisionReferenceCycle</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>For </p>
<p>WdgMSupervisionReferenceCycle</p>
<p>  =  2,  the  fault  detection  time  is  (almost)  4  * </p>
<p>WdgMTriggerConditionValue</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>31 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-14 </p>
<p> </p>
<p>Alive supervision fault detection time </p>
<p><b>2.3.9.2 </b></p>
<p><b>Deadline Supervision Fault Detection Time </b></p>
<p>Assume that a fault occurs that leads  to a deadline violation. The WdgM fault detection </p>
<p>time is the sum of the time spans </p>
<p><b>&gt; </b></p>
<p>from the fault to the end of the current deadline interval set by the previous checkpoint </p>
<p>and </p>
<p><b>&gt; </b></p>
<p>from the end of the current deadline interval to the next call of </p>
<p>WdgM_MainFunction()</p>
<p> at the end of a supervision cycle. </p>
<p>The worst case for a given configuration happens when </p>
<p><b>&gt; </b></p>
<p>the time between the calls of </p>
<p>WdgM_MainFunction() </p>
<p>is always </p>
<p>WdgMTriggerConditionValue</p>
<p>, </p>
<p><b>&gt; </b></p>
<p>a new supervision cycle starts and </p>
<p><b>&gt; </b></p>
<p>a checkpoint is passed immediately afterwards (setting a new deadline interval for the </p>
<p>next checkpoint), and </p>
<p><b>&gt; </b></p>
<p>the fault happens immediately after the checkpoint. </p>
<p>Then the fault detection time comprises </p>
<p><b>&gt; </b></p>
<p>(almost all of) the supervision cycle where the fault occurred, </p>
<p><b>&gt; </b></p>
<p>all supervision cycles up to the supervision cycle where the deadline interval ends, </p>
<p>WdgM_MainFunction</p>
<p>With alive supervision</p>
<p>TriggerCondition</p>
<p>Value (1st </p>
<p>supervision cycle)</p>
<p>WdgM_MainFunction</p>
<p>alive supervision interval</p>
<p>WdgM fault detection time</p>
<p>TriggerCondition</p>
<p>Value (3rd </p>
<p>supervision cycle)</p>
<p>WdgM_MainFunction</p>
<p>TriggerCondition</p>
<p>Value (2nd </p>
<p>supervision cycle)</p>
<p>WdgM_MainFunction</p>
<p>With alive supervision</p>
<p>WdgM_MainFunction</p>
<p>With alive supervision</p>
<p>TriggerCondition</p>
<p>Value (4th </p>
<p>supervision cycle)</p>
<p>alive supervision interval</p>
<p>Passed</p>
<p>checkpoint</p>
<p>Missed</p>
<p>checkpoint</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>32 </p>
<p>based on template version 5.12.0 </p>
<p><b>&gt; </b></p>
<p>including the complete supervision cycle where the deadline interval ends, because </p>
<p>the fault is detected at the end of this supervision cycle. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Then the maximum fault detection time is almost: </p>
<p>(𝑛𝑟 + 1) ∗  </p>
<p>WdgMTriggerConditionValue</p>
<p> </p>
<p> </p>
<p>Where the end of the deadline interval is </p>
<p>𝑛𝑟</p>
<p> supervision cycles after the successfully </p>
<p>passed checkpoint</p>
<p>.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>For </p>
<p>𝑛𝑟</p>
<p> = 3, the Fault Detection Time is (almost) 4 * </p>
<p>WdgMTriggerConditionValue</p>
<p>. </p>
<p> </p>
<p>Figure 2-15 </p>
<p> </p>
<p>Deadline supervision fault detection time </p>
<p><b>2.3.9.3 </b></p>
<p><b>Program Flow Supervision Fault Detection Time </b></p>
<p>Assume  that  a  fault  occurs  that  leads  to  a  program  flow  violation.  The  WdgM  fault </p>
<p>detection time is the sum of the time spans </p>
<p><b>&gt; </b></p>
<p>from the fault to the call of the next but unscheduled checkpoint and </p>
<p><b>&gt; </b></p>
<p>from this checkpoint to the next call of </p>
<p>WdgM_MainFunction()</p>
<p> at the end of the </p>
<p>current supervision cycle. </p>
<p>The worst case for a given configuration happens when </p>
<p>TriggerCondition</p>
<p>Value (1st </p>
<p>supervision cycle)</p>
<p>WdgM_MainFunction</p>
<p>WdgM fault detection time</p>
<p>TriggerCondition</p>
<p>Value (3rd </p>
<p>supervision cycle)</p>
<p>WdgM_MainFunction</p>
<p>TriggerCondition</p>
<p>Value (2nd </p>
<p>supervision cycle)</p>
<p>TriggerCondition</p>
<p>Value (4th </p>
<p>supervision cycle)</p>
<p>Passed</p>
<p>checkpoint</p>
<p>WdgM_MainFunction</p>
<p>WdgM_MainFunction</p>
<p>WdgM_MainFunction</p>
<p>End of</p>
<p>deadline</p>
<p>interval</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>33 </p>
<p>based on template version 5.12.0 </p>
<p><b>&gt; </b></p>
<p>the time between the calls of </p>
<p>WdgM_MainFunction()</p>
<p> is always </p>
<p>WdgMTriggerConditionValue,</p>
<p> </p>
<p><b>&gt; </b></p>
<p>a new supervision cycle starts, </p>
<p><b>&gt; </b></p>
<p>a scheduled checkpoint is passed immediately afterwards and </p>
<p><b>&gt; </b></p>
<p>the fault happens immediately afterwards. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Then the maximum fault detection time is almost: </p>
<p>(𝑠𝑐 + 1) ∗  </p>
<p>WdgMTriggerConditionValue</p>
<p> </p>
<p> </p>
<p>Where the unscheduled checkpoint is passed </p>
<p>𝑠𝑐</p>
<p> supervision cycles after the scheduled </p>
<p>checkpoint</p>
<p>.</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>For </p>
<p>𝑠𝑐</p>
<p> = 2, the fault detection time is (almost) 3 * </p>
<p>WdgMTriggerConditionValue.</p>
<p> </p>
<p> </p>
<p>Figure 2-16 </p>
<p> </p>
<p>Program flow supervision fault detection time </p>
<p>TriggerCondition</p>
<p>Value (1st </p>
<p>supervision cycle)</p>
<p>WdgM_MainFunction</p>
<p>WdgM fault detection time</p>
<p>TriggerCondition</p>
<p>Value (3rd </p>
<p>supervision cycle)</p>
<p>WdgM_MainFunction</p>
<p>TriggerCondition</p>
<p>Value (2nd </p>
<p>supervision cycle)</p>
<p>Scheduled</p>
<p>checkpoint</p>
<p>WdgM_MainFunction</p>
<p>WdgM_MainFunction</p>
<p>Unscheduled</p>
<p>checkpoint</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>34 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.3.10 </b></p>
<p><b>Fault Reaction Time Evaluation </b></p>
<p>The WdgM fault reaction time is evaluated differently for the various monitoring features as </p>
<p>shown in this section. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>This section does not discuss Wdg device resets due to a WdgM error (like DET </p>
<p>errors). The section does also not discuss resets using </p>
<p>Appl_Mcu_PerformReset()</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The WdgM fault reaction time spans </p>
<p><b>&gt; </b></p>
<p>from the end of the WdgM fault detection time </p>
<p><b>&gt; </b></p>
<p>to the error escalation to the WdgIf (excluding the processes performed in WdgIf). </p>
<p>The error is escalated to the WdgIf through </p>
<p><b>&gt; </b></p>
<p>a call of </p>
<p>WdgIf_SetTriggerWindow(DeviceIndex, 0,0)</p>
<p> (if </p>
<p>WDGM_IMMEDIATE_RESET</p>
<p> is </p>
<p>STD_ON</p>
<p>) or </p>
<p><b>&gt; </b></p>
<p>discontinuing of the Wdg device triggers (if </p>
<p>WDGM_IMMEDIATE_RESET</p>
<p> is </p>
<p>STD_OFF</p>
<p>). </p>
<p>The following assumptions take place here: </p>
<p><b>&gt; </b></p>
<p>A violation from a fault continues until the error is escalated. Discontinuing a violation </p>
<p>before error escalation results in a recovery to OK. </p>
<p><b>&gt; </b></p>
<p>Each monitored supervised entity is active all the time. Deactivation of a supervised </p>
<p>entity aborts the monitoring of this supervised entity. Activation of a supervised entity </p>
<p>resumes the monitoring with OK.   </p>
<p>The WdgM fault reaction times of the different monitoring features do not affect each other </p>
<p>(except  that  the  error  escalation  of  one  monitoring  violation  aborts  all  other  monitoring </p>
<p>violations). </p>
<p> </p>
<p><b>2.3.10.1 </b></p>
<p><b>Alive Supervision Fault Reaction Time </b></p>
<p>If  a  call  of </p>
<p>WdgM_MainFunction()</p>
<p>ends  the  fault  detection  time  and  starts  the  fault </p>
<p>reaction time, then  </p>
<p>the error is escalated by </p>
<p>WdgM_MainFunction()</p>
<p> <i>i </i>supervision cycles later,  </p>
<p>where </p>
<p> </p>
<p><i>i </i></p>
<p>= </p>
<p>(</p>
<p>WdgMSupervisionReferenceCycle</p>
<p> </p>
<p>* </p>
<p>WdgMFailedSupervisionRefCycleTol</p>
<p>) </p>
<p>+ </p>
<p>WdgMExpiredSupervisionCycleTol</p>
<p>. </p>
<p> </p>
<p>In </p>
<p>the </p>
<p>worst </p>
<p>case, </p>
<p>every </p>
<p>supervision </p>
<p>cycle </p>
<p>has </p>
<p>the </p>
<p>length </p>
<p>of </p>
<p>WdgMTriggerConditionValue</p>
<p>. </p>
<p>The </p>
<p>fault </p>
<p>reaction </p>
<p>time </p>
<p>is </p>
<p>then </p>
<p>WdgMTriggerConditionValue</p>
<p> * <i>i</i>, where <i>i </i>is as defined above. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>35 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.3.10.2 </b></p>
<p><b>Deadline Supervision Fault Reaction Time </b></p>
<p>If  a  call  of </p>
<p>WdgM_MainFunction()</p>
<p>  ends  the  fault  detection  time  and  starts  the  fault </p>
<p>reaction time, then  </p>
<p>the error is escalated by </p>
<p>WdgM_MainFunction()</p>
<p> <i>i </i>supervision cycles later, </p>
<p>where  </p>
<p> </p>
<p><i>i </i> =  (</p>
<p>WdgMDeadlineReferenceCycle</p>
<p>  * </p>
<p>WdgMFailedDeadlineRefCycleTol</p>
<p>)  + </p>
<p>WdgMExpiredSupervisionCycleTol</p>
<p>. </p>
<p> </p>
<p>In </p>
<p>the </p>
<p>worst </p>
<p>case, </p>
<p>every </p>
<p>supervision </p>
<p>cycle </p>
<p>has </p>
<p>the </p>
<p>length </p>
<p>of </p>
<p>WdgMTriggerConditionValue</p>
<p>. </p>
<p>The </p>
<p>fault </p>
<p>reaction </p>
<p>time </p>
<p>is </p>
<p>then </p>
<p>WdgMTriggerConditionValue</p>
<p> * <i>i</i>, where <i>i </i>is as defined above. </p>
<p> </p>
<p><b>2.3.10.3 </b></p>
<p><b>Program Flow Supervision Fault Reaction Time </b></p>
<p>If  a  call  of </p>
<p>WdgM_MainFunction()</p>
<p>  ends  the  fault  detection  time  and  starts  the  fault </p>
<p>reaction time, then </p>
<p>the error is escalated by </p>
<p>WdgM_MainFunction()</p>
<p> <i>i </i>supervision cycles later, </p>
<p>where  </p>
<p><i>i </i></p>
<p>= </p>
<p>(</p>
<p>WdgMProgramFlowReferenceCycle</p>
<p> </p>
<p>* </p>
<p>WdgMFailedProgramFlowRefCycleTol</p>
<p>) </p>
<p>+ </p>
<p>WdgMExpiredSupervisionCycleTol</p>
<p>. </p>
<p> </p>
<p>In </p>
<p>the </p>
<p>worst </p>
<p>case, </p>
<p>every </p>
<p>supervision </p>
<p>cycle </p>
<p>has </p>
<p>the </p>
<p>length </p>
<p>of </p>
<p>WdgMTriggerConditionValue</p>
<p>. </p>
<p>The </p>
<p>fault </p>
<p>reaction </p>
<p>time </p>
<p>is </p>
<p>then </p>
<p>WdgMTriggerConditionValue</p>
<p> * <i>i</i>, where <i>i </i>is as defined above. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>36 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.3.11 </b></p>
<p><b>Reset Path and Safe State </b></p>
<p>The safe state is entered as a result of an MCU reset. The WdgM builds its functionality on </p>
<p>a reliable and robust reset path. The WdgM default reset path uses the Watchdog Device </p>
<p>itself through the WdgIf. The Watchdog Device can be either an external chip or an MCU-</p>
<p>internal controller. The system integrator can additionally set a secondary path by adding </p>
<p>the  parameter </p>
<p>WDGM_SECOND_RESET_PATH = STD_ON</p>
<p>.  The  secondary  reset  path  is </p>
<p>used when the Watchdog Interface returns an error response. This error response can be </p>
<p>caused by communication errors to the external Watchdog device. </p>
<p> </p>
<p>Figure 2-17  </p>
<p>Primary and secondary reset path of the WdgM </p>
<p>The WdgM uses the primary reset path for a regular Watchdog-initiated reset and also for </p>
<p>an immediate MCU reset. The primary reset path is the preferred path, because it is part of </p>
<p>the </p>
<p>WdgM </p>
<p>software </p>
<p>and </p>
<p>thus </p>
<p>safe. </p>
<p>The </p>
<p>MCU </p>
<p>driver </p>
<p>with </p>
<p>the </p>
<p>AUTOSAR </p>
<p>function </p>
<p>Appl_Mcu_PerformReset()</p>
<p> must guarantee freedom from interference. </p>
<p>The secondary reset path is optional. It is used when the primary reset path signals a fault. </p>
<p>The WdgM safe state is the MCU reset state. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>37 </p>
<p>based on template version 5.12.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The WdgM safe state is not necessarily the system safe state. </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The WdgM can invoke the safe state in two ways: </p>
<p><b>&gt; </b></p>
<p>MCU reset after watchdog timeout by discontinuing watchdog triggering. </p>
<p><b>&gt; </b></p>
<p>Immediate MCU reset by an immediate watchdog reset. The immediate reset can be </p>
<p>configured. </p>
<p><b>2.3.12 </b></p>
<p><b>WdgM Local Entity State </b></p>
<p>Every  supervised  entity  has  a  local  state  that  expresses  the  occurrence  of  detected </p>
<p>violations: </p>
<p><b>State </b></p>
<p><b>Description </b></p>
<p>OK </p>
<p>No violation has been detected </p>
<p>FAILED </p>
<p>A violation has been detected, the reset is pending within a delay time (maybe 0 </p>
<p>ticks) and the violation repeats. </p>
<p>EXPIRED </p>
<p>A violation has repeated throughout the delay time. A reset is inevitable. </p>
<p>Table 2-1  </p>
<p>WdgM Local Entity Stats </p>
<p>AUTOSAR allows configuring a tolerance delay after an alive counter violation has been </p>
<p>detected.  See  [1]  for  detailed  information.  AUTOSAR  does  not  allow  configuring  such </p>
<p>tolerances for program flow  and deadline violations. The WdgM  allows  configuring  such </p>
<p>tolerances for all three monitoring features described below: </p>
<p><b>&gt; </b></p>
<p>Once a violation has been detected, the WdgM changes its state from </p>
<p>OK</p>
<p> to </p>
<p>FAILED</p>
<p> </p>
<p>and starts a so-called tolerance time, which is configured as follows: </p>
<p>The tolerance time is the supervision reference cycle (according to the monitoring feature) </p>
<p>multiplied by a supervision reference cycle tolerance value. </p>
<p><b>&gt; </b></p>
<p>As  long  as  the  violation  repeats  within  the tolerance  time at  least  every  supervision </p>
<p>reference cycle, the WdgM stays in the state </p>
<p>FAILED</p>
<p>. </p>
<p><b>&gt; </b></p>
<p>If  the  violation  does  not  occur  in  a  supervision  reference  cycle  within  the  tolerance </p>
<p>delay,  the WdgM  returns  to  the  state </p>
<p>OK</p>
<p>  as  if  no  violation  had  happened.  Only  the </p>
<p>status change is logged. </p>
<p><b>&gt; </b></p>
<p>If  the  violation  has  repeated  to  the  end  of  the  tolerance  time,  the WdgM  enters  the </p>
<p>state </p>
<p>EXPIRED</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>38 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-18  </p>
<p>Modified state machine </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The AUTOSAR implementation can be simulated for deadline and program flow </p>
<p>violations with </p>
<p>reference cycle = reference cycle tolerance = 0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The exact names of the configuration fields for the tolerance delay are: </p>
<p><b>Monitoring </b></p>
<p><b>Reference Cycle </b></p>
<p><b>Reference Cycle Tolerance </b></p>
<p>Alive Supervision </p>
<p>WdgMSupervisionReferenceCycle </p>
<p>WdgMFailedSupervisionRefCycleTol </p>
<p>Program Flow </p>
<p>Supervision </p>
<p>WdgMProgramFlowReferenceCycle </p>
<p>WdgMFailedProgramFlowRefCycleTol </p>
<p>Deadline Supervision </p>
<p>WdgMDeadlineReferenceCycle </p>
<p>WdgMFailedDeadlineRefCycleTol </p>
<p>Table 2-2  </p>
<p>Names of configuration fields </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>39 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.3.13 </b></p>
<p><b>WdgM Global State </b></p>
<p>The  local  states  are  periodically  summarized  in  a  WdgM  global  state.  If  all  supervised </p>
<p>entities have the state </p>
<p>OK</p>
<p>, then the global state is </p>
<p>OK</p>
<p>. When at least one supervised entity </p>
<p>changes to the state </p>
<p>FAILED</p>
<p>, then the global state becomes </p>
<p>FAILED</p>
<p>. When at least one </p>
<p>supervised  entity  changes  to  the  state </p>
<p>EXPIRED</p>
<p>,  the  global  state  becomes </p>
<p>EXPIRED</p>
<p>. </p>
<p>Once the global state is </p>
<p>EXPIRED</p>
<p>, the WdgM continues the delay until it enters the state </p>
<p>STOPPED</p>
<p>. This is when the WdgM stops triggering the Watchdog (or resets it). The delay </p>
<p>is the supervision cycle multiplied by the configurable expired supervision cycle tolerance </p>
<p>(parameter </p>
<p>WdgMExpiredSupervisionCycleTol)</p>
<p>. </p>
<p>Once in the state </p>
<p>STOPPED</p>
<p>, the WdgM brings the system to the safe state by performing a </p>
<p>system reset through the WdgIf module and, thus, through the watchdog device(s) in the </p>
<p>system. If the preprocessor option </p>
<p>WDGM_SECOND_RESET_PATH</p>
<p> is set to </p>
<p>STD_ON</p>
<p> and the </p>
<p>WdgIf reports a failure, then the system goes into a safe state through the MCU module. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In a multi-core system, each Watchdog Manager instance running on a particular </p>
<p>processor core builds a separate global state independently of the other processor </p>
<p>cores. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.14 </b></p>
<p><b>Basic Operation of the WdgM Stack </b></p>
<p>The  WdgM  is  the  upper  layer  of  the  WdgM  Stack.  As  described  above,  the  WdgM  is </p>
<p>responsible  for  monitoring  applications  through  preconfigured  supervised  entities.  The </p>
<p>result of this monitoring is usually translated into servicing one or more watchdog devices </p>
<p>through the rest of the WdgM Stack – the Watchdog Interface (WdgIf) and one or more </p>
<p>Watchdog Drivers (Wdg). </p>
<p>Figure 2-19 shows a possible WdgM Stack configured to run on a microcontroller with two </p>
<p>watchdog devices, an internal and an external one. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>40 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-19  </p>
<p>Example of an WdgM Stack configuration </p>
<p>Figure 2-20 shows the behavior of the WdgM Stack. </p>
<p>First, the Wdg drivers configured in the system are initialized. Then the WdgM is initialized, </p>
<p>and it calls the </p>
<p>SetMode</p>
<p> functions of each configured driver during its initialization. During </p>
<p>runtime, </p>
<p>the </p>
<p>monitored </p>
<p>applications </p>
<p>report </p>
<p>to </p>
<p>the </p>
<p>WdgM </p>
<p>by </p>
<p>calling </p>
<p>the </p>
<p>function </p>
<p>WdgM_CheckpointReached()</p>
<p> or directly via RTE. During this call, the program flow and </p>
<p>part  of  the  deadline  supervision  is  evaluated  (see  compute  SE  local  state  #1  in  Figure </p>
<p>2-20).  In  each  supervision  cycle, </p>
<p>WdgM_MainFunction()</p>
<p>  is  called.  It  evaluates  the </p>
<p>status  of  each  supervised  entity,  the  rest  of  deadline  supervision  and  alive  supervision </p>
<p>(see compute SE local states #2 in Figure 2-20) and, based on this, it computes the global </p>
<p>state. Depending on the global state, the configured watchdogs are either serviced, or a </p>
<p>reset  is  deliberately  caused.  The  latter  is  done  either  by  omitting  the  servicing  or  by </p>
<p>instructing  the  watchdog  to  make  a  reset  right  away  (for  more  information  refer  to </p>
<p>parameter </p>
<p>WdgMImmediateReset</p>
<p>). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>41 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-20  </p>
<p>Behavior of the WdgM Stack </p>
<p><b>2.4 </b></p>
<p><b>WdgM in Multi-Core Systems </b></p>
<p>The WdgM can be used in single-core and multi-core systems. Each processor core to be </p>
<p>monitored  by  the  WdgM  runs  a  separate  WdgM  instance.  This  is  as  if  we  had  several </p>
<p>independent WdgM  Stacks  running  on  the  processor  cores.  It  is not  necessary  that  the </p>
<p>WdgM Stack runs on each processor core. It can be configured to run on a subset of them </p>
<p>only where monitoring of supervised entities is required. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>42 </p>
<p>based on template version 5.12.0 </p>
<p>Each WdgM instance runs independently of the others and must be initialized with its own </p>
<p>configuration. It has its own time base and calls the </p>
<p>WdgM_MainFunction()</p>
<p> separately. </p>
<p>If  the WdgM  is  configured  to  run  on  a  multi-core  system,  then  an  internal  preprocessor </p>
<p>option (</p>
<p>WDGM_MULTICORE_USAGE</p>
<p>) is automatically set to </p>
<p>STD_ON</p>
<p>. Thus, the embedded </p>
<p>code can handle several processor cores. Otherwise, this option is set to </p>
<p>STD_OFF</p>
<p>, which </p>
<p>optimizes the code for a single-core system. The optimizations are done even if the WdgM </p>
<p>is configured to run only on one core in a multi-core environment. </p>
<p>In order to configure the WdgM (ECU description file) to run on several processor cores in </p>
<p>a  multi-core  system,  a  separate </p>
<p>WdgMConfigSet</p>
<p>  container  needs  to  be  configured  for </p>
<p>each core. The WdgMConfigSet container has a WdgMMode subcontainer (note, that only </p>
<p>one is allowed), which identifies the processor core that it is configured to run on only one </p>
<p>core of a multi-core system. </p>
<p>Note,  that  the WdgMGeneral  container which  contains  general  configuration  parameters </p>
<p>as  well  as  the  supervised  entities  in  the  system  is  one  for  all  configured  cores.  Each </p>
<p>supervised entity can be used on one core only and must have a unique ID in the system. </p>
<p>As </p>
<p>the </p>
<p>WdgM </p>
<p>instances </p>
<p>run </p>
<p>independently </p>
<p>on </p>
<p>the </p>
<p>different </p>
<p>processor </p>
<p>cores, </p>
<p>each </p>
<p>supervised entity in the system is configured for one processor core and can be used only </p>
<p>on </p>
<p>that </p>
<p>core. </p>
<p>Global </p>
<p>transitions </p>
<p>between </p>
<p>supervised </p>
<p>entities </p>
<p>are </p>
<p>allowed </p>
<p>only </p>
<p>for </p>
<p>supervised entities running on the same processor core. </p>
<p>There are 2 different concepts on how the WdgM Stack can react to detected violations, </p>
<p>the independent and combined core reaction concept. </p>
<p>The  independent  core  reaction  concept  says  that  each  WdgM  instance  controls  one  or </p>
<p>more  watchdogs.  It  builds  an  independent  global  state  and  decides  on  triggering  its </p>
<p>watchdog(s) or causing a deliberate reset. Whether a processor core reset or system reset </p>
<p>is issued, depends on the hardware configuration and not on the WdgM. </p>
<p>Figure 2-21 shows the operation of the WdgM on a multi-core system (independent core </p>
<p>reaction). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>43 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-21 </p>
<p> </p>
<p>WdgM Stack on a multi-core system configured for independent core reaction </p>
<p>The  combined  core  reaction  concept  declares,  that  each WdgM  instance  independently </p>
<p>builds a global state of its processor core and the several global states are then combined </p>
<p><b>&gt; </b></p>
<p>either by hardware (e.g. a special hardware module in the microcontroller reading the </p>
<p>states of the internal watchdog devices of each processor core) </p>
<p><b>&gt; </b></p>
<p>by software (e.g. a special watchdog driver that is called on each processor core and </p>
<p>that combines the status of each core into a single reaction) </p>
<p>Combining the WdgM status on each core in hardware is strongly hardware- dependent, </p>
<p>and its applicability can vary from microcontroller to microcontroller. </p>
<p>Combining the WdgM status on each core in software can be done with the feature State </p>
<p>Combiner of the underlying WdgIf module. </p>
<p><b> </b></p>
<p><b>deployment WdgM stack on multi-core - independent core reaction</b></p>
<p>«device»</p>
<p><b>Microcontroller - independent core reaction</b></p>
<p>«device»</p>
<p><b>core 0</b></p>
<p>«device»</p>
<p><b>core 1</b></p>
<p><b>WdgM</b></p>
<p><b>WdgIf</b></p>
<p><b>Wdg</b></p>
<p>«device»</p>
<p><b>int Wdg 0</b></p>
<p>«device»</p>
<p><b>int Wdg 1</b></p>
<p><b>WdgM</b></p>
<p><b>WdgIf</b></p>
<p><b>Wdg</b></p>
<p>independet core reaction</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>44 </p>
<p>based on template version 5.12.0 </p>
<p><b>2.4.1 </b></p>
<p><b>State Combiner </b></p>
<p>The </p>
<p>State </p>
<p>Combiner </p>
<p>is </p>
<p>a </p>
<p>special </p>
<p>hardware-independent </p>
<p>peace </p>
<p>of </p>
<p>software </p>
<p>that </p>
<p>is </p>
<p>implemented  as  an  additional  feature  of  the  WdgIf  module.  On  one  core,  the  State </p>
<p>Combiner is configured  to  work in  master mode  in order to  control  the  actual  watchdog </p>
<p>device. The instances of the State Combiner on the other cores are configured to work in </p>
<p>slave mode. They do not trigger but communicate with the master State Combiner only via </p>
<p>shared  memory.  The  State  Combiner  on  the  master  core  will  only  allow  triggering  the </p>
<p>actual  watchdog device  if  the  global status of  the WdgM  instances  on  all  cores  is other </p>
<p>than </p>
<p>STOPPED</p>
<p>. In other words, as soon as at least one core has detected an irreparable </p>
<p>error and requests a reset, the actual watchdog device will not be serviced anymore (or an </p>
<p>explicit </p>
<p>reset </p>
<p>will </p>
<p>be </p>
<p>initiated </p>
<p>depending </p>
<p>on </p>
<p>the </p>
<p>ECUC </p>
<p>description </p>
<p>parameter </p>
<p>WdgMImmediateReset</p>
<p>). </p>
<p> </p>
<p>Figure 2-22 </p>
<p> </p>
<p>WdgM Stack on a multi-core system using the State Combiner for a combined core reaction </p>
<p>Figure  2-23  shows  the  dynamic  behavior  of  a  WdgM  running  on  2  cores  with  a  State </p>
<p>Combiner for a combined core reaction. </p>
<p><b> deployment WdgM stack on multi-core - combined core reaction</b></p>
<p>«device»</p>
<p><b>Microcontroller - combined core reaction</b></p>
<p>«device»</p>
<p><b>core 0</b></p>
<p><b>WdgM</b></p>
<p><b>WdgIf</b></p>
<p><b>Wdg ext.</b></p>
<p><b>State Combiner </b></p>
<p><b>(master)</b></p>
<p>«device»</p>
<p><b>core 1</b></p>
<p><b>WdgM</b></p>
<p><b>WdgIf</b></p>
<p><b>State Combiner </b></p>
<p><b>(slav e)</b></p>
<p>combined core reaction</p>
<p>«device»</p>
<p><b>core 2</b></p>
<p><b>WdgM</b></p>
<p><b>WdgIf</b></p>
<p><b>State Combiner </b></p>
<p><b>(slav e)</b></p>
<p>«device»</p>
<p><b>core 3</b></p>
<p><b>WdgM</b></p>
<p><b>WdgIf</b></p>
<p><b>Wdg int.</b></p>
<p>«device»</p>
<p><b>Wdg ext.</b></p>
<p>«device»</p>
<p><b>Wdg int.</b></p>
<p>«device»</p>
<p><b>Shared Memory</b></p>
<p>write core</p>
<p>2 state</p>
<p>write core 1</p>
<p>state</p>
<p>read state of</p>
<p>slave cores</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>45 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 2-23  </p>
<p>Dynamic Behavior on a multi-core system using the State Combiner for a combined core reaction </p>
<p>For more information on the State Combiner refer to the WdgIf User Manual [4]. </p>
<p> </p>
<p><b>2.4.2 </b></p>
<p><b>AUTOSAR Debugging </b></p>
<p>AUTOSAR Debugging allows debugging the WdgM module by granting it access to certain </p>
<p>module  internal  variables.  This AUTOSAR  feature  is  extended  for  the  WdgM  by  adding </p>
<p>special  functions  that  make  the  debugging  process  or  tracing  detected  by  the  WdgM </p>
<p>violations easier. </p>
<p>Variables accessible for debugging: </p>
<p><b>&gt; </b></p>
<p>The local monitoring status of each supervised entity is accessible through the API </p>
<p>WdgM_GetLocalStatus()</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>46 </p>
<p>based on template version 5.12.0 </p>
<p><b>&gt; </b></p>
<p>WdgMConfigPtr -&gt; WdgMSupervisedEntityRef[SEID] </p>
<p>.EntityStatusGRef -&gt; LocalMonitoringStatus </p>
<p><b>&gt; </b></p>
<p>The global monitoring status: accessible through the API </p>
<p>WdgM_GetGlobalStatus()</p>
<p> or </p>
<p>WdgMConfigPtr -&gt; DataGRef -&gt; </p>
<p>GlobalMonitoringStatus</p>
<p> </p>
<p><b>&gt; </b></p>
<p>The alive counters of each checkpoint of a supervised entity: </p>
<p>WdgMConfigPtr -&gt; </p>
<p>WdgMSupervisedEntityRef[SEID].WdgMCheckpointRef[CPID]. </p>
<p>WdgMAliveLRef -&gt; AliveCounter </p>
<p><b>&gt; </b></p>
<p>The time when the initial CP of an SE has been reached: </p>
<p>WdgMConfigPtr-&gt; </p>
<p>WdgMSupervisedEntityRef[SEID].EntityStatusLRef -&gt; </p>
<p>RememberedInitialCheckpointTime</p>
<p> </p>
<p><b>&gt; </b></p>
<p>The time when the most recent CP of an SE has been reached: </p>
<p>WdgMConfigPtr -&gt; </p>
<p>WdgMSupervisedEntityRef[SEID].EntityStatusLRef -&gt; </p>
<p>RememberedCheckpointTime</p>
<p> </p>
<p><b>&gt; </b></p>
<p>The most recently reached CP of an SE: WdgMConfigPtr -&gt; </p>
<p>WdgMSupervisedEntityRef[SEID].EntityStatusLRef -&gt; RememberedCheckpointId </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>SEID is the ID of an SE. CPID is the ID of a CP. WdgMConfigPtr is a pointer to the </p>
<p>configuration with which the WdgM was initialized. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Additional debugging feature (not defined in AUTOSAR): </p>
<p><b>&gt; </b></p>
<p>The  function  WdgM_  WdgM_GetFirstExpiredSEViolation()  provides  a  way  to  detect </p>
<p>what kind of violation caused the first SE in the system to change its local status to </p>
<p>WDGM_LOCAL_STATUS_EXPIRED:  program  flow,  deadline,  alive  supervision  or  a </p>
<p>combination between them. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>47 </p>
<p>based on template version 5.12.0 </p>
<p><b>3 </b></p>
<p><b>Functional Description </b></p>
<p>The  WdgM  monitors  safety-relevant  applications  on  the  ECU.  The  WdgM  is  a  basic </p>
<p>software  module  at  the  service  layer  of  the  standardized  basic  software  architecture  of </p>
<p>AUTOSAR. The WdgM monitors the program flow of a configurable number of so-called </p>
<p>supervised </p>
<p>entities </p>
<p>(SE).  When </p>
<p>the  WdgM </p>
<p>detects </p>
<p>a </p>
<p>violation </p>
<p>of </p>
<p>the </p>
<p>preconfigured </p>
<p>temporal  or  logical  constraints  in  the  program  flow,  it  takes  a  number  of  configurable </p>
<p>actions to log the fault and to go to a safe state after a configurable time delay. The safe </p>
<p>state is reached by resetting the watchdog or by omitting watchdog triggering. </p>
<p>Every supervised entity has a defined control flow. Significant points in this control flow are </p>
<p>represented by checkpoints (CP). This means the control flow can be modeled as a graph, </p>
<p>with  the  checkpoints  being  the  nodes  and  the  pieces  of  code  in  between  being  the </p>
<p>transitions (see Figure 2-4 for an example). </p>
<p>The WdgM configuration defines the allowed transitions between the checkpoints, and the </p>
<p>timing constraints for these transitions </p>
<p><b>&gt; </b></p>
<p>within every supervised entity (local transitions) </p>
<p><b>&gt; </b></p>
<p>between checkpoints of different supervised entities (global transitions) </p>
<p>The supervised entities have to report to the WdgM when they have reached a checkpoint. </p>
<p>Thus, the developer has to insert calls at the checkpoints that pass this information to the </p>
<p>WdgM. </p>
<p>The WdgM functionality  partially  deviates  from  the AUTOSAR  requirements.  For details, </p>
<p>refer to Section </p>
<p>Deviations from the AUTOSAR 4.0.1 Watchdog Manager</p>
<p>. </p>
<p><b>3.1 </b></p>
<p><b>Features </b></p>
<p>The features listed in the following tables cover the functionality specified for the WdgM. </p>
<p>The AUTOSAR  standard  functionality  is  specified  in  [1],  the  corresponding  features  are </p>
<p>listed in the tables </p>
<p><b>&gt; </b></p>
<p>Table 3-1   Supported AUTOSAR standard conform features  </p>
<p>Vector  Informatik  provides  further  WdgM  functionality  beyond  the  AUTOSAR  standard. </p>
<p>The corresponding features are listed in the table </p>
<p><b>&gt; </b></p>
<p>Table 3-2   Features provided beyond the AUTOSAR standard </p>
<p> </p>
<p>The following features specified in [1] are supported: </p>
<p><b>Supported AUTOSAR Standard Conform Features </b></p>
<p><b>&gt; </b></p>
<p>Services to initialize the WdgM </p>
<p><b>&gt; </b></p>
<p>Functionality for: </p>
<p><b>&gt; </b></p>
<p>Alive Supervision </p>
<p><b>&gt; </b></p>
<p>Deadline Supervision </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>48 </p>
<p>based on template version 5.12.0 </p>
<p><b>Supported AUTOSAR Standard Conform Features </b></p>
<p><b>&gt; </b></p>
<p>Program Flow Supervision </p>
<p>Table 3-1  </p>
<p>Supported AUTOSAR standard conform features </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Deadline Supervision and Program Flow Supervision can only be used if the additional </p>
<p>feature “WdgM_ProgramFlowAndDeadlineMonitoring” is licensed. </p>
<p>(See also sections Deadline Supervision and Program Flow Supervision) </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.1.1 </b></p>
<p><b>Deviations from the AUTOSAR 4.0.1 Watchdog Manager </b></p>
<p>The  WdgM  is  compatible  with  the  AUTOSAR  4.0.1  Watchdog  Manager,  but  not  fully </p>
<p>compliant. This has the following reasons: </p>
<p><b>&gt; </b></p>
<p>The </p>
<p>AUTOSAR </p>
<p>specification </p>
<p>does </p>
<p>not </p>
<p>define </p>
<p>functionality </p>
<p>comprehensively </p>
<p>and </p>
<p>precisely enough for implementation (e.g. global transitions). </p>
<p><b>&gt; </b></p>
<p>The AUTOSAR specification does not contain certain functionality (e.g. program flow, </p>
<p>deadline supervision recovering). </p>
<p><b>&gt; </b></p>
<p>The AUTOSAR specification defines an approach that is very complex to be handled </p>
<p>by the user or consumes too much run time (WdgM mode switching). </p>
<p><b>&gt; </b></p>
<p>The </p>
<p>AUTOSAR </p>
<p>specification </p>
<p>does </p>
<p>not </p>
<p>fully </p>
<p>consider </p>
<p>safety </p>
<p>requirements </p>
<p>(e.g. </p>
<p>windowed Watchdog Trigger). </p>
<p>Below you can find the deviations from the AUTOSAR 4.0.1 Watchdog Manager in detail: </p>
<p><b>3.1.1.1 </b></p>
<p><b>Entities, Checkpoints and Transitions </b></p>
<p><b>&gt; </b></p>
<p>For periodical watchdog triggering at least one supervised entity and one checkpoint </p>
<p>should be defined. </p>
<p><b>&gt; </b></p>
<p>In contrast to AUTOSAR, local activity flags of the supervised entities are set back to </p>
<p>FALSE</p>
<p> every time an end checkpoint of this supervised entity is reached as specified </p>
<p>in later versions of the WdgM. Analogously, the global activity flag is set back to </p>
<p>FALSE</p>
<p> </p>
<p>as soon as a global end checkpoint is reached. </p>
<p><b>&gt; </b></p>
<p>Local  initial  checkpoints  cannot  have  incoming  local  transitions,  but  they  can  have </p>
<p>incoming global transitions. </p>
<p><b>&gt; </b></p>
<p>Local  end  checkpoints  cannot  have  outgoing  local  transitions,  but  they  can  have </p>
<p>outgoing global transitions. </p>
<p><b>&gt; </b></p>
<p>If global transitions are used, then there must be exactly one global initial checkpoint. </p>
<p><b>&gt; </b></p>
<p>The  global  initial  checkpoint  should  be  called  before  any  other  global  checkpoint  is </p>
<p>invoked. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>49 </p>
<p>based on template version 5.12.0 </p>
<p><b>&gt; </b></p>
<p>If a non-initial checkpoint of a supervised entity is reached and this supervised entity is </p>
<p>not  active,  then  this  is  considered  to  be  a  program  flow  violation  in  this  supervised </p>
<p>entity. </p>
<p><b>&gt; </b></p>
<p>If a checkpoint is the source for a local and a global transition, then only one of the two </p>
<p>transitions  can  occur. The  other  one  is  considered  a  program  flow  violation.  This  is </p>
<p>because  the  program  flow  cannot  split  into  2  paths.  If,  for  example,  a  new  task  is </p>
<p>started from a CP1 (global transition to CPnew) and the original task continues (local </p>
<p>transition to CP2), then the sequence following the sequences of checkpoint hits is not </p>
<p>allowed: </p>
<p><b>&gt; </b></p>
<p>CP -&gt; CPnew -&gt; CP2 and </p>
<p><b>&gt; </b></p>
<p>CP -&gt; CP2 -&gt; CPnew. </p>
<p><b>&gt; </b></p>
<p>If a local initial checkpoint is the destination checkpoint for a global transition, then the </p>
<p>checkpoint must be hit by following the global transition. There is a dilemma, though: If </p>
<p>several  supervised  entities  form  a  cycle  of  transitions,  with  each  supervised  entity </p>
<p>entered via a global transition from the previous supervised entity, then there is no way </p>
<p>to start the cycle, because no local initial checkpoint is allowed to be hit in a way other </p>
<p>than via the global transition. The solution is an exception in the WdgM: A local initial </p>
<p>checkpoint can be hit, not coming through the global transition, if it is also the global </p>
<p>initial checkpoint. </p>
<p><b>&gt; </b></p>
<p>As  in  AUTOSAR,  the  WdgM  needs  a  time  source  in  order  to  measure  transition </p>
<p>deadlines. Whereas AUTOSAR does not define the source for ticks, the WdgM allows </p>
<p>the user to choose between two tick sources: </p>
<p><b>&gt; </b></p>
<p>Internal software source </p>
<p><b>&gt; </b></p>
<p>External tick source </p>
<p>For details see Section Deadline Measurement and Tick Counter. </p>
<p>The  checkpoint  and  entity  identifiers  are  zero-based  and  increase  the  list  of  integer </p>
<p>numbers without gaps. </p>
<p><b>&gt; </b></p>
<p>Deadline  supervision  is  bound  to  program  flow.  Only  if  program  flow  transitions  are </p>
<p>configured, it is possible to configure transition deadlines. </p>
<p><b>&gt; </b></p>
<p>The local/global end checkpoint does not need to be defined. </p>
<p><b>&gt; </b></p>
<p>Either zero or maximum one global initial checkpoint can be configured. So there can </p>
<p>be zero or one global graph. </p>
<p> </p>
<p><b>3.1.1.2 </b></p>
<p><b>Watchdog and Reset </b></p>
<p><b>&gt; </b></p>
<p>For safety reasons, the WdgM uses the primary watchdog reset as an immediate reset </p>
<p>(</p>
<p>WDGM_IMMEDIATE_RESET  =  STD_ON</p>
<p>). </p>
<p>In </p>
<p>contrast, </p>
<p>the </p>
<p>AUTOSAR </p>
<p>Watchdog </p>
<p>Manager uses the external function </p>
<p>Mcu_PerformReset()</p>
<p>. </p>
<p>The </p>
<p>WdgM </p>
<p>does </p>
<p>not </p>
<p>support </p>
<p>a </p>
<p>partition </p>
<p>reset </p>
<p>with </p>
<p>BswM_WdgM_RequestPartitionReset()</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>50 </p>
<p>based on template version 5.12.0 </p>
<p><b>3.1.1.3 </b></p>
<p><b>API </b></p>
<p><b>&gt; </b></p>
<p>The WdgM function </p>
<p>WdgM_SetMode()</p>
<p> switches the trigger mode only. This relates to </p>
<p>the fields </p>
<p><b>&gt; </b></p>
<p>WdgMTriggerConditionValue </p>
<p><b>&gt; </b></p>
<p>WdgMTriggerWindowStart </p>
<p><b>&gt; </b></p>
<p>WdgMWatchdogMode </p>
<p><b>&gt; </b></p>
<p>It does not change the set of supervised entities. This can be simulated by activating </p>
<p>and deactivating different sets of supervised entities for different modes. </p>
<p><b>&gt; </b></p>
<p>For safety and complexity reasons, the function </p>
<p>WdgM_DeInit()</p>
<p> is not implemented. </p>
<p><b>&gt; </b></p>
<p>The WdgM uses only direct callback notification for a local and global state change. </p>
<p>The RTE notification is not implemented. </p>
<p><b>&gt; </b></p>
<p>Due  to  implementation  complexity  and  verification  difficulty,  the  WdgM  does  not </p>
<p>support RTE Mode Ports. </p>
<p><b>&gt; </b></p>
<p>The  WdgM  checks  the  configuration  independently  of  the </p>
<p>WdgMDevErrorDetect </p>
<p>parameter. This parameter enables/disables the DET reporting only. </p>
<p><b>3.1.2 </b></p>
<p><b>Additions/ Extensions </b></p>
<p>The following features are provided beyond the AUTOSAR standard: </p>
<p><b>Features Provided Beyond The AUTOSAR Standard </b></p>
<p>Functionality for multi-core handling </p>
<p>The WdgM allows tolerance delay for all three monitoring features. In AUTOSAR, this is </p>
<p>restricted to alive supervision. Tolerance delay allows recovering from program flow and deadline </p>
<p>violations as well as from alive counter violations. </p>
<p>The interpretation of the AUTOSAR parameter </p>
<p>WdgMExpiredSupervisionCycleTol</p>
<p> </p>
<p>implements a delay of </p>
<p>(WdgMExpiredSupervisionCycleTol + 2)</p>
<p> supervision cycles. The </p>
<p>WdgM implements a delay of </p>
<p>WdgMExpiredSupervisionCycleTol</p>
<p> supervision cycles. This </p>
<p>allows configuring no delay, with the tolerance value set to 0. </p>
<p>The WdgM provides the following function in addition to the AUTOSAR Debugging features: </p>
<p>WdgM_GetFirstExpiredSEViolation()</p>
<p>. </p>
<p>The WdgM provides the functions </p>
<p>WdgM_DeactivateSupervisionEntity()</p>
<p> and </p>
<p>WdgM_ActivateSupervisionEntity()</p>
<p> for deactivating and activating of the SE. These </p>
<p>functions are not AUTOSAR 4.0.1 compatible. </p>
<p>Table 3-2  </p>
<p>Features provided beyond the AUTOSAR standard </p>
<p><b>3.2 </b></p>
<p><b>Initialization </b></p>
<p>In  a  safety-related  system,  the  initialization  of  the  Watchdog  device  should  be  done  as </p>
<p>soon  as  possible  after  system  start  (at  least  before  a  QM  task  may  compromise  the </p>
<p>initialization  process).  The  Watchdog  device  starts  the  counter  for  the  next  expected </p>
<p>trigger. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>51 </p>
<p>based on template version 5.12.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The  ways  how  the  Watchdog  device  is  initialized,  configured,  and  how  it  reacts  are </p>
<p>platform-dependent and can be different. See the corresponding Watchdog Driver User </p>
<p>Manual </p>
<p><b> </b></p>
<p><b> </b></p>
<p>The </p>
<p>time </p>
<p>between </p>
<p>the </p>
<p>initialization </p>
<p>of </p>
<p>the </p>
<p>Wdg </p>
<p>and </p>
<p>the </p>
<p>first </p>
<p>triggering </p>
<p>in </p>
<p>function </p>
<p>WdgM_MainFunction()</p>
<p>  (supervision  cycle  0) must  match  the Watchdog  requirements. </p>
<p>This  time  can  be  adapted  in  the  Wdg  configuration  by  changing  the  initial  Wdg  trigger </p>
<p>window to meet the operating system start time requirements (see Figure 3-1). </p>
<p> </p>
<p>Figure 3-1   Start phase of the WdgM </p>
<p>The y-axis in Figure 3-1 shows the Wdg counter value, which is reset after each trigger. </p>
<p>Then  the  countdown  runs  until  the Wdg  is  triggered  again  (within  the  Wdg  initial  trigger </p>
<p>window or Trigger window) or 0 (Wdg reset level) is reached (i.e. the window has been </p>
<p>missed) so that a reset is performed. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>52 </p>
<p>based on template version 5.12.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note</b> </p>
<p><b>&gt; </b></p>
<p>Not  all  hardware  platforms  can  configure  a  different  trigger  time  for  the  first </p>
<p>supervision cycle (cycle 0). </p>
<p><b>&gt; </b></p>
<p>In the first supervision cycle, the  alive counter evaluation can be  suppressed by </p>
<p>the parameter </p>
<p>WDGM_FIRSTCYCLE_ALIVECOUNTER_RESET</p>
<p>. </p>
<p><b>&gt; </b></p>
<p>The </p>
<p>functions </p>
<p>WdgM_Init()</p>
<p> </p>
<p>and </p>
<p>WdgM_MainFunction()</p>
<p> </p>
<p>functions </p>
<p>can </p>
<p>be </p>
<p>placed inside a task, too. </p>
<p><b>&gt; </b></p>
<p>The function </p>
<p>Wdg_&lt;...&gt;_Init()</p>
<p> can be placed before </p>
<p>main()</p>
<p>. </p>
<p><b>&gt; </b></p>
<p>For  a  multi-core  system  the </p>
<p>WdgM_Init()</p>
<p>  function  must  be  called  on  each </p>
<p>processor core once, with the valid configuration for this processor core. </p>
<p><b>&gt; </b></p>
<p>The </p>
<p>WdgM_MainFunction()</p>
<p>  called  periodically  on  each  processor  core,  on </p>
<p>which WdgM is running, with the configured period for this processor core. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>After  the  execution  of  function </p>
<p>WdgM_Init()</p>
<p>  the  supervision  of  configured  entities  is </p>
<p>activated and the checkpoints can be executed (called). </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>53 </p>
<p>based on template version 5.12.0 </p>
<p><b>3.3 </b></p>
<p><b>Memory Sections </b></p>
<p>Memory  segmentation  into  sections  is  especially  important  when  memory  protection  is </p>
<p>used in the system. </p>
<p>The WdgM uses three basic RAM data sections: </p>
<p>1. </p>
<p>Memory sections for local data of every SE: This section contains local information </p>
<p>about  every  supervised  entity  and,  if  defined,  also  the  alive  counters.  These </p>
<p>variables are used by the WdgM_CheckpointReached() function and are part of the </p>
<p>private SWC (task, application) memory and written only in the context of this SWC. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note</b> </p>
<p><b>&gt; </b></p>
<p>The WdgM does not protect this memory section. </p>
<p><b>&gt; </b></p>
<p>For  a  multi-core  system,  the  local  data  section  for  a  SE  must  be </p>
<p>accessible from the core for which this SE is configured. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>2. </p>
<p>Memory sections for global data: This section contains the WdgM global data such </p>
<p>as WdgM global status and timebase tick counter. It is a WdgM private memory.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In  the  AUTOSAR  environment,  where  QM  and  safety-related  modules  are </p>
<p>used together, the WdgM global data should be placed in a so-called trusted </p>
<p>memory section to guarantee its safety and integrity. </p>
<p><b>&gt; </b></p>
<p>For a multi-core system, the global data section is configured per mode, </p>
<p>i.e. separately for each processor core, on which the WdgM is running. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>3. </p>
<p>Memory sections for global shared data: This section contains data such as the last </p>
<p>active </p>
<p>entity. </p>
<p>This </p>
<p>memory </p>
<p>must </p>
<p>be </p>
<p>writable </p>
<p>for </p>
<p>all </p>
<p>SWCs </p>
<p>using </p>
<p>the </p>
<p>WdgM_CheckpointReached()</p>
<p>  function  and  for  the </p>
<p>WdgM_Init()</p>
<p>  function.  As </p>
<p>this  is  a  memory  where  all  the  QM  SWCs  could  write,  the  WdgM  variables  are </p>
<p>protected  (stored  double-inverted)  by  the  WdgM  itself.  The  WdgM  checks  the </p>
<p>correctness of these variables with read operations. If a fault is detected, the WdgM </p>
<p>initiates a reset </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For a multi-core system, where several cores are configured for the WdgM, </p>
<p>the global shared section must be accessible by each of these cores. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>54 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 3-2   Memory usage of the WdgM </p>
<p><b>3.3.1 </b></p>
<p><b>Memory Sections Details </b></p>
<p>Local entity memory:  </p>
<p>Local  entity  data  is  supervised  entity  private  data.  This  is  the  data  where  the  function </p>
<p>WdgM_CheckpointReached()</p>
<p> </p>
<p>writes. </p>
<p>The </p>
<p>WdgM </p>
<p>configuration </p>
<p>generator </p>
<p>provides </p>
<p>defines so that the status variables of every supervised entity can be placed in a separate </p>
<p>RAM </p>
<p>section. </p>
<p>The </p>
<p>declaration </p>
<p>of </p>
<p>every </p>
<p>entity </p>
<p>starts </p>
<p>with </p>
<p>defines </p>
<p>WDGM_SEi_START_SEC_VAR_*</p>
<p> and ends with </p>
<p>WDGM_SEi_STOP_SEC_VAR_*</p>
<p>, where </p>
<p>i</p>
<p> is </p>
<p>the </p>
<p>ID </p>
<p>of </p>
<p>the </p>
<p>supervised </p>
<p>entity. </p>
<p>Theses </p>
<p>defines </p>
<p>are </p>
<p>in </p>
<p>the </p>
<p>generated </p>
<p>file </p>
<p>WdgM_OsMemMap.h</p>
<p>. Hence, it must be included in the file </p>
<p>MemMap.h</p>
<p>. </p>
<p>If  the  entity  is  linked  to  an  OS  application  (through  its  ECU  description  parameter </p>
<p>WdgMAppTaskRef</p>
<p>),  then  the  supervised entity  data  is  placed  in  a  section embedded in </p>
<p>appl_name_START_SEC_VAR_*</p>
<p> </p>
<p>and </p>
<p>appl_name_STOP_SEC_VAR_* </p>
<p>or </p>
<p>OS_START_appl_name_VAR_*</p>
<p>  and </p>
<p>OS_STOP_appl_name_VAR</p>
<p>  (if  MICROSAR  OS  as </p>
<p>of  version  Gen7),  where </p>
<p>appl_name</p>
<p>  is  the  name  of  the  application.  In  this  case,  the </p>
<p>integrator must make sure to include the file </p>
<p>Os_MemMap.h</p>
<p> in file </p>
<p>MemMap.h</p>
<p> after the file </p>
<p>WdgM_OSMemMap.h</p>
<p>. </p>
<p>Global memory: Global data are private WdgM  variables. The memory mapping defines </p>
<p>are </p>
<p>WDGM_GLOBAL_START_SEC_VAR_*</p>
<p> and </p>
<p>WDGM_GLOBAL_STOP_SEC_VAR_*</p>
<p>.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>55 </p>
<p>based on template version 5.12.0 </p>
<p>This section can be mapped to an OS application (through its ECU description parameter </p>
<p>WdgMGlobalMemoryAppTaskRef</p>
<p>). </p>
<p>For </p>
<p>this </p>
<p>mapping, </p>
<p>defines </p>
<p>appl_name_START_SEC_VAR_*</p>
<p> </p>
<p>and </p>
<p>appl_name_STOP_SEC_VAR_*</p>
<p> </p>
<p>or </p>
<p>OS_START_appl_name_VAR_*</p>
<p>  and </p>
<p>OS_STOP_appl_name_VAR</p>
<p>  (if  MICROSAR  OS  as </p>
<p>of version Gen7) are used, where </p>
<p>appl_name</p>
<p> is the name of the application. In this case, </p>
<p>the integrator must make sure to include the file </p>
<p>Os_MemMap.h</p>
<p> in file </p>
<p>MemMap.h</p>
<p> after the </p>
<p>WdgM_OSMemMap.h</p>
<p>. </p>
<p>As  this  section  is  internally  not  protected  by  the  WdgM,  it  should  be  in  a  memory  area </p>
<p>where it cannot be corrupted. </p>
<p>Global shared memory: Global shared data should be placed in a RAM section where all </p>
<p>tasks  can  read  and  write  to  that  data.  For  a  multi-core  system,  the  global  shared  data </p>
<p>section must be accessible by each processor core. </p>
<p>The </p>
<p>memory </p>
<p>mapping </p>
<p>defines </p>
<p>are </p>
<p>WDGM_GLOBAL_SHARED_START_SEC_VAR_*</p>
<p> </p>
<p>and </p>
<p>WDGM_GLOBAL_SHARED_STOP_SEC_VAR_*</p>
<p>.  These  variables  are  internally  protected  by </p>
<p>the </p>
<p>WdgM. </p>
<p>For </p>
<p>this </p>
<p>mapping, </p>
<p>defines </p>
<p>GlobalShared_START_SEC_VAR_NOINIT_UNSPECIFIED</p>
<p> </p>
<p>and </p>
<p>GlobalShared_STOP_SEC_VAR_NOINIT_UNSPECIFIED</p>
<p> </p>
<p>or </p>
<p>OS</p>
<p> </p>
<p>OS_START_SEC_GLOBALSHARED_VAR_NOINIT_UNSPECIFIED</p>
<p> </p>
<p>and </p>
<p>OS_STOP_SEC_GLOBALSHARED_VAR_NOINIT_UNSPECIFIED</p>
<p>  (if  MICROSAR  OS  as  of </p>
<p>version Gen7) are used. </p>
<p><b>3.3.2 </b></p>
<p><b>Code and Constants </b></p>
<p>Following memory sections need to be set up for WdgM’s code: </p>
<p><b>Section </b></p>
<p><b>Description </b></p>
<p>WDGM_START_SEC_CODE / </p>
<p>WDGM_STOP_SEC_CODE </p>
<p> </p>
<p>Set up manually, e.g. in </p>
<p>MemMap.h</p>
<p>. </p>
<p> </p>
<p>Table 3-3  </p>
<p>Code and Constants </p>
<p>Following memory sections need to be set up for WdgM’s constants: </p>
<p><b>Section </b></p>
<p><b>Description </b></p>
<p>WDGM_START_SEC_CONST_32BIT / </p>
<p>WDGM_STOP_SEC_CONST_32BIT  </p>
<p>WDGM_START_SEC_CONST_UNSPECIFIED / </p>
<p>WDGM_STOP_SEC_CONST_UNSPECIFIED</p>
<p> </p>
<p>Set up manually, e.g. in </p>
<p>MemMap.h</p>
<p>. </p>
<p> </p>
<p>Table 3-4  </p>
<p>WdgM constants </p>
<p><b>3.3.3 </b></p>
<p><b>Module Variables </b></p>
<p><b>3.3.3.1 </b></p>
<p><b>Module Variables with MICROSAR Os Gen6 / AUTOSAR Os version 4.0 </b></p>
<p>Following memory sections need to be set up for WdgM’s module variables: </p>
<p><b>Section </b></p>
<p><b>Description </b></p>
<p>WDGM_GLOBAL_START_SEC_VAR_32BIT_ </p>
<p>COREn_PRIVATE / </p>
<p>If </p>
<p>the </p>
<p>ECU </p>
<p>description </p>
<p>parameter </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>56 </p>
<p>based on template version 5.12.0 </p>
<p><b>Section </b></p>
<p><b>Description </b></p>
<p>WDGM_GLOBAL_STOP_SEC_VAR_32BIT_ </p>
<p>COREn_PRIVATE </p>
<p>WDGM_GLOBAL_START_SEC_VAR_NOINIT_ </p>
<p>UNSPECIFIED_COREn_PRIVATE / </p>
<p>WDGM_GLOBAL_STOP_SEC_VAR_NOINIT_ </p>
<p>UNSPECIFIED_COREn_PRIVATE</p>
<p> </p>
<p>WdgMGlobalMemoryAppTaskRef</p>
<p> </p>
<p>is </p>
<p>set, </p>
<p>then these sections are renamed according to </p>
<p>the </p>
<p>configured </p>
<p>OS </p>
<p>application </p>
<p>(prefix </p>
<p>“</p>
<p>WDGM_GLOBAL_</p>
<p>” </p>
<p>is </p>
<p>converted </p>
<p>to </p>
<p>“</p>
<p>&lt;OSApp&gt;_</p>
<p>”,  where </p>
<p>&lt;OSApp&gt;</p>
<p>  is  the  name  of </p>
<p>the OS application; suffix “</p>
<p>_COREn_PRIVATE</p>
<p>” </p>
<p>is </p>
<p>removed) </p>
<p>and </p>
<p>generated </p>
<p>as </p>
<p>part </p>
<p>of </p>
<p>WdgM_OsMemMap.h</p>
<p>.  Otherwise  they  need  to </p>
<p>be set manually, e.g. in </p>
<p>MemMap.h</p>
<p>. </p>
<p>The suffix ”</p>
<p>_COREn_PRIVATE</p>
<p>“ corresponds to </p>
<p>the processor core for which the OS </p>
<p>application is configured. </p>
<p>WDGM_GLOBAL_SHARED_START_SEC_VAR_ </p>
<p>NOINIT_UNSPECIFIED / </p>
<p>WDGM_GLOBAL_SHARED_STOP_SEC_VAR_ </p>
<p>NOINIT_UNSPECIFIED</p>
<p> </p>
<p>These sections are always assigned in the </p>
<p>generated file </p>
<p>WdgM_OsMemMap.h</p>
<p> to OS </p>
<p>sections and renamed to: </p>
<p>GlobalShared_START_SEC_VAR_UNSPECI</p>
<p>FIED / </p>
<p>GlobalShared_STOP_SEC_VAR_UNSPECIF</p>
<p>IED </p>
<p>WDGM_START_SEC_VAR_NOINIT_16BIT / </p>
<p>WDGM_STOP_SEC_VAR_NOINIT_16BIT </p>
<p>WDGM_START_SEC_VAR_NOINIT_8BIT / </p>
<p>WDGM_STOP_SEC_VAR_NOINIT_8BIT </p>
<p> </p>
<p>Set up manually, e.g. in </p>
<p>MemMap.h</p>
<p>. Used only </p>
<p>for AUTOSAR Debugging. Must be read/write </p>
<p>accessible from the WdgM main functions </p>
<p>executed on each processor core. </p>
<p>Table 3-5  </p>
<p>Module variables with MICROSAR Os Gen6 / AUTOSAR Os version 4.0 </p>
<p><b>3.3.3.2 </b></p>
<p><b>Module Variables with MICROSAR Os Gen7 / AUTOSAR Os version 4.2 </b></p>
<p>Following memory sections need to be set up for WdgM’s module variables: </p>
<p><b>Section </b></p>
<p><b>Description </b></p>
<p>WDGM_GLOBAL_START_SEC_VAR_32BIT_ </p>
<p>COREn_PRIVATE / </p>
<p>WDGM_GLOBAL_STOP_SEC_VAR_32BIT_ </p>
<p>COREn_PRIVATE </p>
<p>WDGM_GLOBAL_START_SEC_VAR_NOINIT_ </p>
<p>UNSPECIFIED_COREn_PRIVATE / </p>
<p>WDGM_GLOBAL_STOP_SEC_VAR_NOINIT_ </p>
<p>UNSPECIFIED_COREn_PRIVATE</p>
<p> </p>
<p>If </p>
<p>the </p>
<p>ECU </p>
<p>description </p>
<p>parameter </p>
<p>WdgMGlobalMemoryAppTaskRef</p>
<p> </p>
<p>is </p>
<p>set, </p>
<p>then these sections are renamed according to </p>
<p>the </p>
<p>configured </p>
<p>OS </p>
<p>application. </p>
<p>“</p>
<p>WDGM_GLOBAL_START_SEC_ </p>
<p>/ </p>
<p>WDGM_GLOBAL_STOP_SEC_</p>
<p>”  is  converted  to </p>
<p>”</p>
<p>OS_START_SEC_</p>
<p>“</p>
<p>&lt;OSApp&gt;_</p>
<p> </p>
<p>/ </p>
<p>OS_STOP_SEC_</p>
<p>“</p>
<p>&lt;OSApp&gt;_</p>
<p>”, where </p>
<p>&lt;OSApp&gt;</p>
<p> </p>
<p>is </p>
<p>the </p>
<p>name </p>
<p>of </p>
<p>the </p>
<p>OS </p>
<p>application; </p>
<p>suffix </p>
<p>“</p>
<p>_COREn_PRIVATE</p>
<p>” </p>
<p>is </p>
<p>removed. </p>
<p>This </p>
<p>is </p>
<p>generated as part of </p>
<p>WdgM_OsMemMap.h</p>
<p>.  </p>
<p>WDGM_GLOBAL_SHARED_START_SEC_VAR_ </p>
<p>NOINIT_UNSPECIFIED / </p>
<p>WDGM_GLOBAL_SHARED_STOP_SEC_VAR_ </p>
<p>NOINIT_UNSPECIFIED</p>
<p> </p>
<p>These sections are always assigned in the </p>
<p>generated file </p>
<p>WdgM_OsMemMap.h</p>
<p> to OS </p>
<p>sections and renamed to: </p>
<p>OS_START_SEC_GLOBALSHARED_VAR_NOIN</p>
<p>IT_UNSPECIFIED / </p>
<p>OS_STOP_SEC_GLOBALSHARED_VAR_NOINI</p>
<p>T_UNSPECIFIED </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>57 </p>
<p>based on template version 5.12.0 </p>
<p><b>Section </b></p>
<p><b>Description </b></p>
<p>WDGM_START_SEC_VAR_NOINIT_16BIT / </p>
<p>WDGM_STOP_SEC_VAR_NOINIT_16BIT </p>
<p>WDGM_START_SEC_VAR_NOINIT_8BIT / </p>
<p>WDGM_STOP_SEC_VAR_NOINIT_8BIT </p>
<p> </p>
<p>Set up manually, e.g. in </p>
<p>MemMap.h</p>
<p>. Used only </p>
<p>for AUTOSAR Debugging. Must be read/write </p>
<p>accessible from the WdgM main functions </p>
<p>executed on each processor core. </p>
<p>Table 3-6  </p>
<p>Module variables MICROSAR Os Gen7 / AUTOSAR Os version 4.2 </p>
<p> </p>
<p><b>3.3.4 </b></p>
<p><b>Supervised Entity Variables </b></p>
<p><b>3.3.4.1 </b></p>
<p><b>Supervised Entity Variables with MICROSAR Os Gen6 / AUTOSAR Os </b></p>
<p><b>version 4.0 </b></p>
<p>Following memory sections need to be set up for WdgM’s supervised entity variables: </p>
<p><b>Section </b></p>
<p><b>Description </b></p>
<p>WDGM_SEi_START_SEC_VAR_NOINIT </p>
<p>_32BIT_COREn_PRIVATE / </p>
<p>WDGM_SEi_STOP_SEC_VAR_NOINIT_ </p>
<p>32BIT_COREn_PRIVATE </p>
<p>WDGM_SEi_START_SEC_VAR_NOINIT </p>
<p>_UNSPECIFIED_COREn_PRIVATE / </p>
<p>WDGM_SEi_STOP_SEC_VAR_NOINIT_ </p>
<p>UNSPECIFIED_COREn_PRIVATE</p>
<p> </p>
<p>If the ECU description parameter </p>
<p>WdgMAppTaskRef</p>
<p> corresponding to supervised </p>
<p>entity with ID “</p>
<p>i</p>
<p>” configured for</p>
<p> </p>
<p>core ID “</p>
<p>n</p>
<p>” is set, </p>
<p>then these sections are renamed according to the </p>
<p>configured OS application (prefix “</p>
<p>WDGM_SEi_</p>
<p>” is </p>
<p>converted to “</p>
<p>&lt;OSApp&gt;_</p>
<p>”, where </p>
<p>&lt;OSApp&gt;</p>
<p> is the </p>
<p>name of the OS application; suffix </p>
<p>“</p>
<p>_COREn_PRIVATE</p>
<p>” is removed) and generated as </p>
<p>part of </p>
<p>WdgM_OsMemMap.h</p>
<p>.</p>
<p> </p>
<p>Table 3-7  </p>
<p>Supervised Entity Variables MICROSAR Os Gen6 / AUTOSAR Os version 4.0 </p>
<p><b>3.3.4.2 </b></p>
<p><b>Supervised Entity Variables with MICROSAR Os Gen7 / AUTOSAR Os </b></p>
<p><b>version 4.2 </b></p>
<p>Following memory sections need to be set up for WdgM’s supervised entity variables: </p>
<p><b>Section </b></p>
<p><b>Description </b></p>
<p>WDGM_SEi_START_SEC_VAR_NOINIT </p>
<p>_32BIT_COREn_PRIVATE / </p>
<p>WDGM_SEi_STOP_SEC_VAR_NOINIT_ </p>
<p>32BIT_COREn_PRIVATE </p>
<p>WDGM_SEi_START_SEC_VAR_NOINIT </p>
<p>_UNSPECIFIED_COREn_PRIVATE / </p>
<p>WDGM_SEi_STOP_SEC_VAR_NOINIT_ </p>
<p>UNSPECIFIED_COREn_PRIVATE</p>
<p> </p>
<p>If the ECU description parameter </p>
<p>WdgMAppTaskRef</p>
<p> </p>
<p>corresponding to supervised entity with ID “</p>
<p>i</p>
<p>” </p>
<p>configured for core ID “</p>
<p>n</p>
<p>” is set, then these sections </p>
<p>are renamed according to the configured OS </p>
<p>application. </p>
<p>“</p>
<p>WDGM_SEi_START_SEC_ / </p>
<p>WDGM_SEi_STOP_SEC_</p>
<p>” is converted to </p>
<p>”</p>
<p>OS_START_SEC_</p>
<p>“</p>
<p>&lt;OSApp&gt;_</p>
<p>/ </p>
<p>OS_STOP_SEC_</p>
<p>“</p>
<p>&lt;OSApp&gt;_</p>
<p>”, where </p>
<p>&lt;OSApp&gt;</p>
<p> is the </p>
<p>name of the OS application; suffix </p>
<p>“</p>
<p>_COREn_PRIVATE</p>
<p>” is removed. This is generated </p>
<p>as part of </p>
<p>WdgM_OsMemMap.h</p>
<p>. </p>
<p>Table 3-8  </p>
<p>Supervised Entity Variables MICROSAR Os Gen7 / AUTOSAR Os version 4.2 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>58 </p>
<p>based on template version 5.12.0 </p>
<p><b>3.4 </b></p>
<p><b>Timing Setup </b></p>
<p>This  chapter  describes  the  WdgM  timing  configuration  parameters.  The  timing  of  the </p>
<p>WdgM is defined by </p>
<p><b>&gt; </b></p>
<p>the calling period of function </p>
<p>WdgM_MainFunction()</p>
<p> </p>
<p><b>&gt; </b></p>
<p>the count period of the WdgM tick counter (for deadline supervision) </p>
<p>Every time when the function </p>
<p>WdgM_MainFunction()</p>
<p> is invoked </p>
<p><b>&gt; </b></p>
<p>the alive counters are evaluated </p>
<p><b>&gt; </b></p>
<p>running deadlines are checked for violations </p>
<p><b>&gt; </b></p>
<p>checkpoint fault indications are evaluated and, finally </p>
<p><b>&gt; </b></p>
<p>the WdgM global status of all supervised entities is calculated </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The  time  period  during  which  the  function </p>
<p>WdgM_MainFunction()</p>
<p>  is  called,  is  the </p>
<p>WdgM  supervision  cycle. This  cycle  time  is  also  used  for  the  periodic  setting  of  the </p>
<p>trigger  condition  of  the  Watchdog  device.  The  period  of  this  cycle  determines  the </p>
<p>shortest WdgM reaction time. For example: If the WdgM reaction time should be not </p>
<p>more than 10 ms, the supervision cycle time should be set to 10 ms or shorter. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For a multi-core system, the calling period and the count period might be configured </p>
<p>differently for the WdgM instance running on each core. For reasons of simplicity, this </p>
<p>section covers the case for one processor core only. The WdgM instances in a multi-</p>
<p>core core setup act independently of each other. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Figure 3-3 shows the WdgM timing configuration parameters. The parameters can be set </p>
<p>by a Configuration Tool. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>59 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 3-3   Time base of WdgM </p>
<p>Two configuration parameters shown in Figure 3-3 are used by the System Environment </p>
<p>only. The Scheduler uses these parameters and periodically calls </p>
<p><b>&gt; </b></p>
<p>function </p>
<p>WdgM_MainFunction()</p>
<p> and </p>
<p><b>&gt; </b></p>
<p>if defined, also function </p>
<p>WdgM_UpdateTickCounter()</p>
<p> </p>
<p> </p>
<p>All the other parameters are used by the WdgM and Wdg. </p>
<p><b>Configuration Parameter </b></p>
<p><b>Description </b></p>
<p>WdgMSupervisionCycle </p>
<p>This  parameter  defines  the  time  period  in  which  the  WdgM </p>
<p>performs  cyclic  supervision.  This  is  the  time  period  in  which </p>
<p>function </p>
<p>WdgM_MainFunction() </p>
<p>is </p>
<p>called. </p>
<p>The </p>
<p>user </p>
<p>of </p>
<p>this </p>
<p>parameter </p>
<p>is </p>
<p>the </p>
<p>system </p>
<p>environment </p>
<p>that </p>
<p>periodically </p>
<p>calls </p>
<p>function WdgM_MainFunction(). </p>
<p>WdgMTicksPerSecond </p>
<p>This  parameter  defines  the  frequency  by  which  the WdgM  tick </p>
<p>counter is incremented. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>60 </p>
<p>based on template version 5.12.0 </p>
<p><b>Configuration Parameter </b></p>
<p><b>Description </b></p>
<p><b>&gt; </b></p>
<p>If  the  external  tick  counter  is  selected,  the  user  of  this </p>
<p>parameter is the system environment that periodically calls </p>
<p>function WdgM_UpdateTickCount(). </p>
<p><b>&gt; </b></p>
<p>The parameter WdgMTicksPerSecond must not be zero.</p>
<p> </p>
<p>WdgMTriggerWindowStart </p>
<p>This parameter is actually not used and should be set to 0. </p>
<p>WdgMTriggerConditionValue </p>
<p>This parameter defines, for all supervision cycles (except for the </p>
<p>first),  the  upper  limit  of  the  Watchdog  trigger  window.  If  the </p>
<p>Watchdog </p>
<p>is </p>
<p>not </p>
<p>triggered </p>
<p>in  time, </p>
<p>a </p>
<p>reset </p>
<p>is </p>
<p>caused.  This </p>
<p>parameter is in milliseconds. The user is the WdgM. </p>
<p>Table 3-9  </p>
<p>Configuration Parameters </p>
<p><b>3.4.1 </b></p>
<p><b>Deadline Measurement and Tick Counter </b></p>
<p>The transition time between two checkpoints is measured in ticks. The tick counter delivers </p>
<p>a time base for deadline supervision. The tick counter is the smallest deadline time unit for </p>
<p>the WdgM. There are two possible tick sources (see Figure 3-4  </p>
<p>WdgM </p>
<p>Tick </p>
<p>source </p>
<p>selection for deadline supervision): </p>
<p><b>&gt; </b></p>
<p>Internal software tick source: The tick source is software-based where the internal </p>
<p>counter is incremented every time the WdgM main function </p>
<p>(</p>
<p>WdgM_MainFunction()</p>
<p>) is called. If the internal software tick source is selected, the </p>
<p>frequency (WdgMTicksPerSecond) is the same as </p>
<p>WdgM_MainFunction()</p>
<p> is called. </p>
<p><b>&gt; </b></p>
<p>External tick source: The tick must be counted externally by calling the WdgM function </p>
<p>WdgM_UpdateTickCount()</p>
<p>.  If  the  external  tick  source  is  selected,  the  system </p>
<p>integrator  is  responsible  for  calling  this  function  on  a  regular  basis.  The  WdgM </p>
<p>internally checks if the number of ticks corresponds with the supervision cycle. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The tick source can be selected by setting the parameter </p>
<p>WdgMTimebaseSource</p>
<p>. The </p>
<p>default parameter value is </p>
<p>WDGM_INTERNAL_SOFTWARE_TICK</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>When you configure a multi-core system, it is possible to select only one tick source for </p>
<p>all the processor cores. However, ticks per second can be different. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>61 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 3-4   WdgM Tick source selection for deadline supervision </p>
<p> </p>
<p>The  ticks  per  second  must  be  configured  for  the  WdgM  to  translate  the  monitored </p>
<p>deadlines from seconds (as stored in the AUTOSAR ECU description files) to WdgM ticks. </p>
<p>This conversion is done during configuration generation for the WdgM, with the deadlines </p>
<p>being stored in the generated configuration as WdgM ticks. </p>
<p> </p>
<p>WdgM</p>
<p>Tick Counter</p>
<p>clock</p>
<p>external</p>
<p>internal software</p>
<p>Parameter Switch</p>
<p><b>WdgMTimebaseSource</b></p>
<p>System API:</p>
<p><i>WdgM_UpdateTickCount()</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>62 </p>
<p>based on template version 5.12.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note</b> </p>
<p><b>&gt; </b></p>
<p>Non-integer ticks are not allowed. If a deadline cannot be converted into an integer </p>
<p>number of WdgM ticks, the WdgM configuration generator will report an error. </p>
<p><b>&gt; </b></p>
<p>For  an  internal  software  tick  source  and  an  external  tick  source  the  internal  tick </p>
<p>counter is initialized to 1. </p>
<p>Examples </p>
<p><b>&gt; </b></p>
<p>Let a WdgM tick be 2 ms. If a deadline is 3 ms, it cannot be converted to WdgM </p>
<p>ticks without loss of accuracy. It will be between 1 and 2 WdgM ticks. </p>
<p><b>&gt; </b></p>
<p>Let  a  WdgM  tick  be  1  ms  (i.e.  the  parameter </p>
<p>WdgMTicksPerSecond</p>
<p>  is  set  to </p>
<p>1000</p>
<p>).  A  deadline  of </p>
<p>0.002s=2ms</p>
<p>  is  then  translated  to  2  WdgM  ticks.  But  a </p>
<p>deadline of </p>
<p>0.0005s=0.5ms</p>
<p> cannot be translated to an integer number of WdgM </p>
<p>ticks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>There is a trade-off between the WdgM tick resolution and performance. The shorter </p>
<p>the </p>
<p>tick </p>
<p>length, </p>
<p>the </p>
<p>finer </p>
<p>the </p>
<p>deadlines </p>
<p>that </p>
<p>can </p>
<p>be </p>
<p>monitored. </p>
<p>However, </p>
<p>the </p>
<p>performance </p>
<p>gets </p>
<p>worse </p>
<p>due </p>
<p>to </p>
<p>more </p>
<p>frequent </p>
<p>calls </p>
<p>to </p>
<p>the </p>
<p>WdgM_UpdateTickCount()</p>
<p> function.<b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>3.5 </b></p>
<p><b>Using Checkpoints in Interrupts </b></p>
<p>Generally,  the  call  of  the  function </p>
<p>WdgM_CheckpointReached()</p>
<p>  is  not  restricted  to  a </p>
<p>specific  context.  However,  if  it  is  called  from  an  interrupt,  the  system  designer  must  be </p>
<p>aware of the following: </p>
<p><b>&gt; </b></p>
<p>All  checkpoints  of  the  supervised  entity  which  runs  in  the  interrupt  context  must  be </p>
<p>called  from  the  same  interrupt  and  never  outside  of  it. This  is because  the  function </p>
<p>WdgM_CheckpointReached()</p>
<p> is allowed to interrupt itself only if called for different </p>
<p>supervised entities. </p>
<p><b>&gt; </b></p>
<p>The runtime of the function </p>
<p>WdgM_CheckpointReached()</p>
<p> must be considered. Note </p>
<p>that  the  runtime  can  vary  depending  on  the  platform  and  the  complexity  of  the </p>
<p>referenced supervised entity. </p>
<p><b>&gt; </b></p>
<p>The function </p>
<p>WdgM_CheckpointReached()</p>
<p> requests to disable/enable interrupts (by </p>
<p>calling </p>
<p>e.g. </p>
<p>SchM_Exit_WdgM()/SchM_Enter_WdgM()</p>
<p>) </p>
<p>– </p>
<p>the </p>
<p>usage </p>
<p>of </p>
<p>disable/enable interrupt routines must be allowed out of the interrupt context. </p>
<p><b>&gt; </b></p>
<p>The  interrupt  context  must  have  read/write  access  to  the  global  shared  memory </p>
<p>(memory mapping defines </p>
<p>WDGM_GLOBAL_SHARED_START_SEC_VAR_NOINIT_*</p>
<p>). </p>
<p><b>&gt; </b></p>
<p>The  interrupt  context  must  have  read/write  access  to  referenced  supervised  entity </p>
<p>local  memory  (memory  mapping  defines </p>
<p>WDGM_SEn_START_SEC_VAR_NOINIT_*</p>
<p>, </p>
<p>where </p>
<p>n </p>
<p>is </p>
<p>the </p>
<p>supervised </p>
<p>entity </p>
<p>ID </p>
<p>provided </p>
<p>to </p>
<p>the </p>
<p>function </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>63 </p>
<p>based on template version 5.12.0 </p>
<p>WdgM_CheckpointReached()</p>
<p>). The same rules apply to this SE local memory – it </p>
<p>might  be  write  accessible  from  contexts  which  have  the  same  quality  level  as  the </p>
<p>interrupt context or higher, but it must be protected from all other contexts. </p>
<p><b>3.6 </b></p>
<p><b>Integration into a Multi-Core System </b></p>
<p>The WdgM can be used on a single core and on multiple cores simultaneously. In order to </p>
<p>achieve </p>
<p>this </p>
<p>task </p>
<p>in </p>
<p>a </p>
<p>more </p>
<p>generic </p>
<p>and </p>
<p>hardware-independent </p>
<p>way </p>
<p>inter-core </p>
<p>communication  is  avoided.  Each  processor  core  on  which  the  WdgM  needs  to  do  its </p>
<p>monitoring  runs  a  separate WdgM  instance.  Each WdgM  instance  controls one  or more </p>
<p>watchdogs. It builds an independent global state and decides on triggering its watchdogs </p>
<p>or causing a deliberate reset. Everything that is valid for single-core integration is valid for </p>
<p>multi-core usage as well. However, each core must be handled as a separate processor. </p>
<p>The integration specifics for a multi-core system are as follows: </p>
<p><b>&gt; </b></p>
<p>Each </p>
<p>processor </p>
<p>core </p>
<p>runs </p>
<p>the </p>
<p>WdgM_Init()</p>
<p> </p>
<p>function </p>
<p>separately </p>
<p>with </p>
<p>its </p>
<p>own </p>
<p>configuration. </p>
<p><b>&gt; </b></p>
<p>The configuration for each processor core (which contains only its settings, supervised </p>
<p>entities, </p>
<p>etc.) </p>
<p>is </p>
<p>generated </p>
<p>in </p>
<p>a </p>
<p>separate </p>
<p>configuration </p>
<p>structure. </p>
<p>However, </p>
<p>the </p>
<p>preprocessor options are common for all cores. </p>
<p><b>&gt; </b></p>
<p>Each </p>
<p>processor </p>
<p>core </p>
<p>executes </p>
<p>the </p>
<p>WdgM_MainFunction()</p>
<p> </p>
<p>separately </p>
<p>and </p>
<p>periodically. The period for each processor core might be different and depends on the </p>
<p>configuration. </p>
<p><b>&gt; </b></p>
<p>The global memory data is configured separately for each processor core and must be </p>
<p>accessible  from  this  core  and  the  application  that  is  responsible  for  running  the </p>
<p>WdgM_MainFunction()</p>
<p>. </p>
<p><b>&gt; </b></p>
<p>The global shared memory section must be accessible by all processor cores. </p>
<p><b>3.7 </b></p>
<p><b>States </b></p>
<p>See WdgM Local Entity State (2.3.12) and WdgM Global State (2.3.13). </p>
<p><b>3.8 </b></p>
<p><b>Main Functions </b></p>
<p>See WdgM Supervision Cycle (2.3.8). </p>
<p><b>3.9 </b></p>
<p><b>Error Handling </b></p>
<p><b>3.9.1 </b></p>
<p><b>Development Error Reporting </b></p>
<p>By </p>
<p>default, </p>
<p>development </p>
<p>errors </p>
<p>are </p>
<p>reported </p>
<p>to </p>
<p>the </p>
<p>DET </p>
<p>using </p>
<p>the </p>
<p>service </p>
<p>Appl_Det_ReportError()</p>
<p> as specified in [2], if development error reporting is enabled </p>
<p>(i.e. pre-compile parameter </p>
<p>WdgM_DEV_ERROR_DETECT==STD_ON</p>
<p>). </p>
<p>If  another  module  is  used  for  development  error  reporting,  the  function  prototype  for </p>
<p>reporting the error can be configured by the integrator, but must have the same signature </p>
<p>as the service </p>
<p>Appl_Det_ReportError ()</p>
<p>. </p>
<p>The reported WdgM ID is 13. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>64 </p>
<p>based on template version 5.12.0 </p>
<p>The  reported  service  IDs  identify  the  services  which  are  described  in  5.2. The following </p>
<p>table presents the service IDs and the related services: </p>
<p><b>Service ID </b></p>
<p><b>Service </b></p>
<p>0x00 </p>
<p>WdgM_Init </p>
<p>0x02 </p>
<p>WdgM_GetVersionInfo </p>
<p>0x03 </p>
<p>WdgM_SetMode </p>
<p>0x04 </p>
<p>WdgM_UpdateAliveCounter </p>
<p>0x05 </p>
<p>WdgM_ActivateSupervisionEntity </p>
<p>0x06 </p>
<p>WdgM_DeactivateSupervisionEntity </p>
<p>0x08 </p>
<p>WdgM_MainFunction </p>
<p>0x0B </p>
<p>WdgM_GetMode </p>
<p>0x0C </p>
<p>WdgM_GetLocalStatus </p>
<p>0x0D </p>
<p>WdgM_GetGlobalStatus </p>
<p>0x0E </p>
<p>WdgM_CheckpointReached </p>
<p>0x0F </p>
<p>WdgM_PerformReset </p>
<p>0x10 </p>
<p>WdgM_GetFirstExpiredSEID </p>
<p>0x12 </p>
<p>WdgM_UpdateTickCount </p>
<p>0x13 </p>
<p>WdgM_GetFirstExpiredSEViolation </p>
<p>Table 3-10  </p>
<p>Service IDs </p>
<p>The errors reported to DET are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>(0x10u) </p>
<p>API service called if WdgM uninitialized  </p>
<p>(0x11u) </p>
<p>API service WdgM_Init() called with wrong parameter  </p>
<p>(0x12u) </p>
<p>API service WdgM_SetMode() called with wrong parameter  </p>
<p>(0x13u) </p>
<p>API service WdgM_Init() called and no supervised entity is configured </p>
<p>API service called with wrong supervised entity id  </p>
<p>(0x14u) </p>
<p>API service called with NULL_PTR as parameter  </p>
<p>(0x15u) </p>
<p>API service WdgM_Init() called and a trigger mode is erroneously configured to </p>
<p>be OFF and OFF mode is not allowed  </p>
<p>(0x16u) </p>
<p>API service WdgM_Init() called and on checkpoint is configured in a supervised </p>
<p>entity  </p>
<p>API service WdgM_CheckpointReached() called with wrong checkpoint id  </p>
<p>(0x17u) </p>
<p>Not used  </p>
<p>(0x28u) </p>
<p>API </p>
<p>service  WdgM_MainFunction() </p>
<p>detected </p>
<p>'stuck-in' </p>
<p>or </p>
<p>'negative </p>
<p>jump' </p>
<p>of </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>65 </p>
<p>based on template version 5.12.0 </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>timebase tick counter or timebase tick counter is out of configured range  </p>
<p>(0x29u) </p>
<p>API services WdgM_MainFunction() or WdgM_CheckpointReached is called and </p>
<p>local / global status is undefined  </p>
<p>(0x2Au) </p>
<p>API services of WdgIf called and return value is E_NOT_OK  </p>
<p>(0x2Bu) </p>
<p>API service WdgM_MainFunction() detected memory corruption  </p>
<p>(0x2Cu) </p>
<p>API service WdgM_MainFunction() called while already invoked  </p>
<p>(0x2Du) </p>
<p>Supervised entity shall be deactivate while supervised entity is active  </p>
<p>(0x2Eu) </p>
<p>API service and invalid processor core id is determined within the service  </p>
<p>Table 3-11  </p>
<p>Errors reported to DET </p>
<p><b>3.9.2 </b></p>
<p><b>Production Code Error Reporting </b></p>
<p>By  default,  production  code  related  errors  are  reported  to  the  DEM  using  the  service </p>
<p>Appl_Dem_ReportErrorStatus()</p>
<p>  as  specified  in  [3],  if  production  error  reporting  is </p>
<p>enabled (i.e. pre-compile parameter </p>
<p>WDGM_DEM_REPORT==STD_ON</p>
<p>). </p>
<p>If another module  is used for production  code  error reporting,  the  function  prototype for </p>
<p>reporting the error can be configured by the integrator, but must have the same signature </p>
<p>as the service </p>
<p>Appl_Dem_ReportErrorStatus ()</p>
<p>. </p>
<p>The errors reported to DEM are described in the following table: </p>
<p><b>Error Code </b></p>
<p><b>Description </b></p>
<p>WDGM_E_IMPROPER_CALLER </p>
<p>Service WdgM Set Mode called with invalid </p>
<p>caller id. </p>
<p>WDGM_E_MONITORING </p>
<p>Monitoring has failed (a watchdog reset will </p>
<p>occur). </p>
<p>Table 3-12  </p>
<p>Errors reported to DEM </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>66 </p>
<p>based on template version 5.12.0 </p>
<p><b>4 </b></p>
<p><b>Integration </b></p>
<p>This chapter gives necessary information for the integration of the MICROSAR WdgM into </p>
<p>an application environment of an ECU. </p>
<p><b>4.1 </b></p>
<p><b>Scope of Delivery </b></p>
<p>The delivery of the WdgM contains the files which are described in the chapters 4.1.1 and </p>
<p>4.1.2. </p>
<p><b>4.1.1 </b></p>
<p><b>Static Files </b></p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>WdgM.c </p>
<p>Implementation of the WdgM, defines the API for the Service Layer of </p>
<p>the BSW-Layer.</p>
<p> </p>
<p>WdgM_Checkpoint.c</p>
<p> </p>
<p>Implementation  of  the  WdgM,  defines  the  API  for  the  Application </p>
<p>Layer. </p>
<p>WdgM.h</p>
<p> </p>
<p>Header file of the WdgM, provides API function declarations.</p>
<p> </p>
<p>WdgM_Cfg.h</p>
<p> </p>
<p>Provides </p>
<p>defines </p>
<p>and </p>
<p>declarations </p>
<p>for </p>
<p>the </p>
<p>WdgM </p>
<p>configuration </p>
<p>identifiers. </p>
<p>Table 4-1  </p>
<p>Static files </p>
<p><b>4.1.2 </b></p>
<p><b>Dynamic Files </b></p>
<p>The dynamic files are generated by the configuration tool DaVinci Configurator. </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>WdgM_PBcfg.c </p>
<p>This  file  contains  the  main  configuration  structure  with  the  default </p>
<p>name WdgMConfig_Mode0. This configuration name should be used </p>
<p>by </p>
<p>the </p>
<p>initialization </p>
<p>function, </p>
<p>i.e. </p>
<p>by </p>
<p>call </p>
<p>WdgM_Init(&amp;WdgMConfig_Mode0)</p>
<p>. </p>
<p>If </p>
<p>necessary, </p>
<p>the </p>
<p>non-</p>
<p>standard AUTOSAR name WdgMConfig_Mode0 can be renamed to </p>
<p>WdgMConfigSet in the Configuration Tool (e.g., DaVinci). </p>
<p>WdgM_PBcfg.h </p>
<p>The file contains the declaration of the WdgM configuration. </p>
<p>WdgM_OSMemMap.h </p>
<p>The file contains defines of all used / necessary memory sections. </p>
<p>WdgM_Cfg_Features.h </p>
<p>The file contains WdgM precompile directives. </p>
<p>Table 4-2  </p>
<p>Generated files </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>67 </p>
<p>based on template version 5.12.0 </p>
<p><b>4.2 </b></p>
<p><b>Critical Sections </b></p>
<p>The WdgM implements the following critical section: </p>
<p><b>&gt; </b></p>
<p>WDGM_EXCLUSIVE_AREA_0</p>
<p>: This critical section is used to protect all uninterruptable </p>
<p>sequences. It shall lock all interrupt sources and task switches. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>68 </p>
<p>based on template version 5.12.0 </p>
<p><b>5 </b></p>
<p><b>API Description </b></p>
<p>The WdgM software module is the top level layer of the Watchdog Manager Stack. The </p>
<p>WdgM </p>
<p>software </p>
<p>module </p>
<p>contains </p>
<p>the </p>
<p>core </p>
<p>functionality </p>
<p>with </p>
<p>supervised </p>
<p>entity </p>
<p>state </p>
<p>machines  and  calculation  of  the  WdgM  global  state.  The  WdgM  communicates  on  one </p>
<p>side through its user API with the Application Layer (optionally using RTE) and through its </p>
<p>system API with the Basic Software Components (BSW) and, on the other side, with the </p>
<p>WdgIf layer. </p>
<p><b>5.1 </b></p>
<p><b>Type Definitions </b></p>
<p>The types defined by the WdgM are described in this chapter. </p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p>WdgM_ConfigType </p>
<p>struct </p>
<p>This is the type for the WdgM configuration </p>
<p>structure. This structure is generated by the </p>
<p>WdgM configuration generator. </p>
<p>N/A</p>
<p> </p>
<p>WdgM_Supervised </p>
<p>EntityIdType </p>
<p>uint16 </p>
<p>This is the type for an individual supervised </p>
<p>entity for the Watchdog Manager. </p>
<p><b>Note: </b></p>
<p>If </p>
<p>configuration </p>
<p>parameter </p>
<p>WDGM_USE_RTE  is  set  to  STD_ON,  then </p>
<p>this </p>
<p>type </p>
<p>is </p>
<p>imported, </p>
<p>otherwise </p>
<p>it </p>
<p>is </p>
<p>generated. </p>
<p>0...65534 </p>
<p>WdgM_Checkpoint </p>
<p>IdType </p>
<p>uint16 </p>
<p>This </p>
<p>is </p>
<p>the </p>
<p>type </p>
<p>for </p>
<p>a </p>
<p>checkpoint </p>
<p>in </p>
<p>the </p>
<p>context of a supervised entity for the WdgM. </p>
<p><b>Note: </b></p>
<p>If </p>
<p>configuration </p>
<p>parameter </p>
<p>WDGM_USE_RTE  is  set  to  STD_ON,  then </p>
<p>this </p>
<p>type </p>
<p>is </p>
<p>imported, </p>
<p>otherwise </p>
<p>it </p>
<p>is </p>
<p>generated. </p>
<p>0...65534 </p>
<p>WdgM_ModeType </p>
<p>uint8 </p>
<p>This is the type for the ID of a trigger mode </p>
<p>that </p>
<p>was </p>
<p>configured </p>
<p>for </p>
<p>the </p>
<p>WdgM. </p>
<p>The </p>
<p>current  trigger  mode  can  be  retrieved  with </p>
<p>WdgM_GetMode(). </p>
<p><b>Note: </b></p>
<p>If </p>
<p>configuration </p>
<p>parameter </p>
<p>WDGM_USE_RTE</p>
<p> is set to </p>
<p>STD_ON</p>
<p>, then this </p>
<p>type is imported, otherwise it is generated. </p>
<p>0...255 </p>
<p>WdgM_LocalStatus</p>
<p>Type </p>
<p>uint8 </p>
<p>This is the type for the local monitoring state </p>
<p>of a supervised entity. The current local state </p>
<p>of a supervised entity can  be retrieved  with </p>
<p>WdgM_GetLocalStatus(). </p>
<p><b>Note: </b></p>
<p>If </p>
<p>configuration </p>
<p>parameter </p>
<p>WDGM_USE_RTE  is  set  to  STD_ON,  then </p>
<p>this </p>
<p>type </p>
<p>is </p>
<p>imported, </p>
<p>otherwise </p>
<p>it </p>
<p>is </p>
<p>generated. </p>
<p>WDGM_LOCAL_STATUS</p>
<p>_OK = 0 </p>
<p>WDGM_LOCAL_STATUS</p>
<p>_FAILED = 1 </p>
<p>WDGM_LOCAL_STATUS</p>
<p>_EXPIRED = 2 </p>
<p>WDGM_LOCAL_STATUS</p>
<p>_DEACTIVATED = 4 </p>
<p>WdgM_GlobalStatus</p>
<p>Type </p>
<p>uint8 </p>
<p>This  is  the  type  for  the  global  monitoring </p>
<p>state.  It  summarizes  the  local  states  of  all </p>
<p>supervised entities. The current global state </p>
<p>can </p>
<p>be </p>
<p>retrieved </p>
<p>with </p>
<p>WdgM_GetGlobalStatus(). </p>
<p>WDGM_GLOBAL_STATU</p>
<p>S_OK = 0, </p>
<p>WDGM_GLOBAL_STATU</p>
<p>S_FAILED = 1, </p>
<p>WDGM_GLOBAL_STATU</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>69 </p>
<p>based on template version 5.12.0 </p>
<p><b>Type Name </b></p>
<p><b>C-Type </b></p>
<p><b>Description </b></p>
<p><b>Value Range </b></p>
<p><b>Note: </b></p>
<p>If </p>
<p>configuration </p>
<p>parameter </p>
<p>WDGM_USE_RTE  is  set  to  STD_ON,  then </p>
<p>this </p>
<p>type </p>
<p>is </p>
<p>imported, </p>
<p>otherwise </p>
<p>it </p>
<p>is </p>
<p>generated. </p>
<p>S_EXPIRED = 2, </p>
<p>WDGM_GLOBAL_STATU</p>
<p>S_STOPPED = 3, </p>
<p>WDGM_GLOBAL_STATU</p>
<p>S_DEACTIVATED = 4 </p>
<p>Std_VersionInfo </p>
<p>Type </p>
<p>struct </p>
<p>This </p>
<p>is </p>
<p>the </p>
<p>parameter </p>
<p>type </p>
<p>of </p>
<p>function </p>
<p>WdgM_GetVersionInfo() </p>
<p>N/A </p>
<p>WdgM_Violation </p>
<p>Type </p>
<p>uint8 </p>
<p>Used with AUTOSAR Debugging (parameter </p>
<p>WdgMAutosarDebugging). This parameter is </p>
<p>the </p>
<p>parameter </p>
<p>type </p>
<p>of </p>
<p>function </p>
<p>WdgM_GetFirstExpiredSEViolation() </p>
<p>WDGM_VIOLATION_NO</p>
<p>NE: No violations </p>
<p>WDGM_VIOLATION_PF: </p>
<p>Program flow violation </p>
<p>WDGM_VIOLATION_DM: </p>
<p>Deadline </p>
<p>supervision </p>
<p>violation </p>
<p>WDGM_VIOLATION_AS: </p>
<p>Alive supervision violation </p>
<p>WDGM_VIOLATION_PF_</p>
<p>DM: </p>
<p>Program </p>
<p>flow </p>
<p>and </p>
<p>deadline </p>
<p>supervision </p>
<p>violations </p>
<p>WDGM_VIOLATION_PF_</p>
<p>AS: </p>
<p>Program </p>
<p>flow </p>
<p>and </p>
<p>alive supervision violations </p>
<p>WDGM_VIOLATION_DM_</p>
<p>AS:  Deadline  supervision </p>
<p>and </p>
<p>alive </p>
<p>supervision </p>
<p>violations </p>
<p>WDGM_VIOLATION_PF_</p>
<p>DM_AS: </p>
<p>Program </p>
<p>flow, </p>
<p>deadline </p>
<p>supervision </p>
<p>and </p>
<p>alive </p>
<p>supervision </p>
<p>violationsmonitoring </p>
<p>and </p>
<p>alive supervision violations </p>
<p>Table 5-1  </p>
<p>Type definitions </p>
<p><b>5.2 </b></p>
<p><b>Services provided by WdgM </b></p>
<p><b>5.2.1 </b></p>
<p><b>WdgM_Init </b></p>
<p><b>Prototype </b></p>
<p>void <b>WdgM_Init</b>(const WdgM_ConfigType* WdgMConfigPtr)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>WdgMConfigPtr </p>
<p>Pointer to post-build configuration data </p>
<p><b>Return code </b></p>
<p>void  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>70 </p>
<p>based on template version 5.12.0 </p>
<p><b>Functional Description </b></p>
<p>The </p>
<p>WdgM_Init()</p>
<p>  function  initializes  the  WdgM.  After  the  execution  of  this  function,  monitoring  is </p>
<p>activated according to the configuration of </p>
<p>ConfigPtr</p>
<p>. This function can be used during monitoring, too, </p>
<p>but note that all pending violations are lost.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is non-reentrant. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>This service is expected to be called in application context. </p>
<p>Table 5-2  </p>
<p>WdgM_Init </p>
<p><b>5.2.2 </b></p>
<p><b>WdgM_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>void <b>WdgM_GetVersionInfo </b>(Std_VersionInfoType* VersionInfo)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>VersionInfo </p>
<p>Pointer to where to store the version information of the WdgM module. </p>
<p><b>Return code </b></p>
<p>void </p>
<p> </p>
<p><b>Functional Description </b></p>
<p>The WdgM_GetVersionInfo() function returns information about the  version of this module. This includes </p>
<p>the module ID, the vendor ID, and the vendor-specific version number. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is reentrant. </p>
<p>Table 5-3  </p>
<p>WdgM_GetVersionInfo </p>
<p><b>5.2.3 </b></p>
<p><b>WdgM_SetMode </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_SetMode </b>(WdgM_ModeType Mode, uint16 CallerID)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>Mode </p>
<p>The ID of the Trigger Mode to which the WdgM must be set. </p>
<p>CallerID </p>
<p>ID  of  the  caller  allowed  to  call  the  function </p>
<p>WdgM_SetMode()</p>
<p>.  The </p>
<p>allowed caller is defined in the configuration. The caller ID is checked if </p>
<p>WdgMDefensiveBehavior</p>
<p> is true. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>71 </p>
<p>based on template version 5.12.0 </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK</p>
<p>: The new Trigger Mode has been successfully set. </p>
<p>E_NOT_OK</p>
<p>: The setting of the new Trigger Mode failed.</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>This functions sets the Trigger Mode of the WdgM. The WdgM Trigger Mode is a set of Watchdog trigger </p>
<p>times  and  Watchdog  mode.  The  WdgM  can  have  one  or  more  Trigger  Modes  for  every  watchdog.  In </p>
<p>contrast to AUTOSAR, where the </p>
<p>Mode</p>
<p> represents a set of entities with all entity-specific parameters, the </p>
<p>WdgM Trigger Mode only sets the following parameters: </p>
<p><b>&gt; </b></p>
<p>WdgMTriggerConditionValue  </p>
<p><b>&gt; </b></p>
<p>WdgMTriggerWindowStart </p>
<p><b>&gt; </b></p>
<p>WdgMWatchdogMode</p>
<p> </p>
<p><b>Note: </b>A change to trigger mode with ID Mode sets all configured  watchdogs to the trigger mode with ID </p>
<p>Mode. As a consequence, all watchdogs must have configured the same number of Trigger Modes. </p>
<p>This function can be used to increase the WdgM supervision cycle in an MCU sleep mode.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This function is reentrant. </p>
<p>Table 5-4  </p>
<p>WdgM_SetMode </p>
<p><b>5.2.4 </b></p>
<p><b>WdgM_ActivateSupervisionEntity </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_ActivateSupervisionEntity </b>(WdgM_SupervisedEntityIdType </p>
<p>SEID)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>SEID </p>
<p>Supervised entity identifier. </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK</p>
<p>: Marking the supervised entity for activation was successful. </p>
<p>E_NOT_OK</p>
<p>: Marking the supervised entity for activation failed. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>72 </p>
<p>based on template version 5.12.0 </p>
<p><b>Functional Description </b></p>
<p>The  function  marks  an  entity  for  activation.  An  entity  can  only  be  activated  when  its  local  state  is </p>
<p>WDGM_LOCAL_STATUS_DEACTIVATED. The activation itself happens at the end of the supervision cycle </p>
<p>inside the </p>
<p>WdgM_MainFunction()</p>
<p>. </p>
<p><b>Note: </b></p>
<p><b>&gt; </b></p>
<p>This function can degrade system safety. The activation of entity supervision in safety-related products </p>
<p>needs special attention to avoid unintended supervised entity deactivation. </p>
<p><b>&gt; </b></p>
<p>In the same call of </p>
<p>WdgM_MainFunction()</p>
<p>, first the local states of all supervised entities and the </p>
<p>global state are set, then the supervised entity is activated. </p>
<p><b>&gt; </b></p>
<p>After SE activation the function </p>
<p>WdgM_GetLocalStatus()</p>
<p> can be used to check the SE local state. </p>
<p><b>&gt; </b></p>
<p>This function is only available if the preprocessor switch </p>
<p>WdgMEntityDeactivationEnabled</p>
<p> is set </p>
<p>to true and if the entity option </p>
<p>WdgMEnableEntityDeactivation</p>
<p> is set to true.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This function is reentrant (for different </p>
<p>SEID</p>
<p>). </p>
<p><b>&gt; </b></p>
<p>This function is an extension of the AUTOSAR specification </p>
<p>Table 5-5  </p>
<p>WdgM_ActivateSupervisionEntity </p>
<p><b>5.2.5 </b></p>
<p><b>WdgM_DeactivateSupervisionEntity </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_DeactivateSupervisionEntity </b>(WdgM_SupervisedEntityIdType </p>
<p>SEID)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>SEID </p>
<p>ID of the supervised entity to be deactivated. Range </p>
<p>[0...N]</p>
<p> </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK: Marking the supervised entity for deactivation was successful. </p>
<p>E_NOT_OK: Marking the supervised entity for deactivation failed. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>73 </p>
<p>based on template version 5.12.0 </p>
<p><b>Functional Description </b></p>
<p>The  function  marks  an  entity  for  deactivation. An  entity  can  only  be  deactivated  when  its  local  state  is </p>
<p>WDGM_LOCAL_STATUS_OK</p>
<p> or </p>
<p>WDGM_LOCAL_STATUS_FAILED</p>
<p>. The deactivation itself happens at the end </p>
<p>of  the  supervision  cycle  inside  the </p>
<p>WdgM_MainFunction()</p>
<p>.  When  an  entity  is  deactivated  then  its </p>
<p>checkpoints are not evaluated anymore and the entity local state is </p>
<p>WDGM_LOCAL_STATUS_DEACTIVATED</p>
<p>. </p>
<p><b>Note: </b></p>
<p><b>&gt; </b></p>
<p>When an entity is deactivated, the global transitions to this entity are not evaluated. </p>
<p><b>&gt; </b></p>
<p>Using this function can degrade system safety. The deactivation of entity supervision in safety-related </p>
<p>products needs special attention to avoid unintended supervised entity deactivation. </p>
<p><b>&gt; </b></p>
<p>The  function </p>
<p>WdgM_DeactivateSupervisionEntity()</p>
<p>  can  deactivate  a  supervised  entity  only </p>
<p>before its initial checkpoint was passed or after its end checkpoint was passed. The focus here is on </p>
<p>entities that are spread over more than one supervision cycle. </p>
<p>Note: The local program flow of a supervised entity may span over more than one supervision cycle. </p>
<p>Those active entities cannot be  deactivated  while running. Deactivating active  SEs  leads to a DEM </p>
<p>error report. </p>
<p><b>&gt; </b></p>
<p>In the same call of </p>
<p>WdgM_MainFunction()</p>
<p>, first the supervised entity is deactivated, then the local </p>
<p>states of all supervised entities and the global state are set. </p>
<p><b>&gt; </b></p>
<p>After  SE  deactivation  the  function </p>
<p>WdgM_GetLocalStatus()</p>
<p>  can  be  used  to  check  the  SE  local </p>
<p>state. </p>
<p><b>&gt; </b></p>
<p>This function is only available if the preprocessor switch </p>
<p>WdgMEntityDeactivationEnabled</p>
<p> is set </p>
<p>to true and if the entity option </p>
<p>WdgMEnableEntityDeactivation</p>
<p> is set to </p>
<p>true</p>
<p>.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is asynchronous. </p>
<p><b>&gt; </b></p>
<p>This function is reentrant (for different </p>
<p>SEID</p>
<p>). </p>
<p><b>&gt; </b></p>
<p>This function is an extension of the AUTOSAR specification </p>
<p>Table 5-6  </p>
<p>WdgM_DeactivateSupervisionEntity </p>
<p><b>5.2.6 </b></p>
<p><b>WdgM_MainFunction </b></p>
<p><b>Prototype </b></p>
<p>void <b>WdgM_MainFunction</b>(void)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>void </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>74 </p>
<p>based on template version 5.12.0 </p>
<p><b>Functional Description </b></p>
<p>This function evaluates monitoring data gathered from the hit checkpoints in all supervised entities during </p>
<p>the supervision cycle. Depending on the violation found (if there is any), the </p>
<p><b>&gt; </b></p>
<p>local state of the supervised entities and </p>
<p><b>&gt; </b></p>
<p>the WdgM global state </p>
<p>are determined again. </p>
<p>Depending on the resulting global state: </p>
<p><b>&gt; </b></p>
<p>the Wdg is triggered, or </p>
<p><b>&gt; </b></p>
<p>the Wdg trigger discontinues (safe state), or </p>
<p><b>&gt; </b></p>
<p>the Wdg is reset (safe state). </p>
<p>The  function  must  run  at  the  end  of  every  supervision  cycle.  It  may  be  called  by  the  Basic  Software </p>
<p>Scheduler or a task with a fixed period time. </p>
<p>The </p>
<p>WdgM_MainFunction()</p>
<p> function is not reentrant. To prevent data inconsistency when it is interrupted </p>
<p>by itself (e.g. due to schedule overload), the function checks if it is executed concurrently. If this function is </p>
<p>started before its last instance has finished, it raises a development error. </p>
<p><b>Note: </b></p>
<p><b>&gt; </b></p>
<p>Alive counter violations are detected at the end of every alive supervision reference cycle, </p>
<p><b>&gt; </b></p>
<p>Program flow violations are detected at the end of every supervision cycle, </p>
<p><b>&gt; </b></p>
<p>Continued program flow violations are detected at the end of every program flow supervision cycle. </p>
<p><b>&gt; </b></p>
<p>Deadline violations are detected at the end of every supervision cycle, </p>
<p><b>&gt; </b></p>
<p>Continued of deadline violations are detected at the end of every deadline supervision cycle. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is non-reentrant. </p>
<p><b>&gt; </b></p>
<p>This service is always available. </p>
<p>Table 5-7  </p>
<p>WdgM_MainFunction </p>
<p><b>5.2.7 </b></p>
<p><b>WdgM_GetMode </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_GetMode</b>(WdgM_ModeType* Mode)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>Mode </p>
<p>Pointer to the current Trigger Mode ID of the Watchdog Manager </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK</p>
<p>: Current Trigger Mode successfully returned. </p>
<p>E_NOT_OK</p>
<p>: Returning current Trigger Mode failed. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>75 </p>
<p>based on template version 5.12.0 </p>
<p><b>Functional Description </b></p>
<p>Returns the current Trigger Mode of the WdgM. The WdgM Trigger Mode represents one Watchdog trigger </p>
<p>time and mode setting. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is reentrant. </p>
<p>Table 5-8  </p>
<p>WdgM_GetMode </p>
<p><b>5.2.8 </b></p>
<p><b>WdgM_GetLocalStatus </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_GetLocalStatus </b>(WdgM_SupervisedEntityIdType SEID, </p>
<p>WdgM_LocalStatusType* Status)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>SEID </p>
<p>Identifier of the supervised entity whose monitoring state is returned. </p>
<p>Status </p>
<p>Pointer to the local monitoring state of the given supervised entity. </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK: Current monitoring state successfully returned. </p>
<p>E_NOT_OK: Returning the current monitoring state failed. </p>
<p><b>Functional Description </b></p>
<p>Returns the monitoring state of the given supervised entity. </p>
<p><b>Note: </b>The WdgM updates the state inside the WdgM_MainFunction() every supervision cycle. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is reentrant. </p>
<p>Table 5-9  </p>
<p>WdgM_GetLocalStatus </p>
<p><b>5.2.9 </b></p>
<p><b>WdgM_GetGlobalStatus </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_GetGlobalStatus </b>(WdgM_GlobalStatusType* Status)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>Status </p>
<p>Pointer to global monitoring state of the WdgM. </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK</p>
<p>: Current global monitoring state successfully returned. </p>
<p>E_NOT_OK</p>
<p>: Returning the current global monitoring state failed. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>76 </p>
<p>based on template version 5.12.0 </p>
<p><b>Functional Description </b></p>
<p>Returns the global monitoring state of the WdgM. </p>
<p><b>Note: </b>The WdgM updates the state inside the </p>
<p>WdgM_MainFunction()</p>
<p> every supervision cycle. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is reentrant. </p>
<p>Table 5-10  </p>
<p>WdgM_GetGlobalStatus </p>
<p><b>5.2.10 </b></p>
<p><b>WdgM_CheckpointReached </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_CheckpointReached </b>(WdgM_SupervisedEntityIdType SEID, </p>
<p>WdgM_CheckpointIdType CheckpointID)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>SEID </p>
<p>Identifier of the supervised entity that reports a checkpoint. </p>
<p>CheckpointID </p>
<p>Identifier of the checkpoint within a supervised entity that has been reached. </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK: Checkpoint monitoring successful. </p>
<p>E_NOT_OK: Checkpoint monitoring fault. Returned in the following cases </p>
<p><b>&gt; </b></p>
<p>WDGM_E_NO_INIT: Uninitialized WdgM (DET code 0x10) </p>
<p><b>&gt; </b></p>
<p>WDGM_E_PARAM_SEID:  Wrong  Id  number  of  the  supervised  entity </p>
<p>(DET code 0x13) </p>
<p><b>&gt; </b></p>
<p>WDGM_E_CPID: Invalid checkpoint ID number (DET code 0x16) </p>
<p><b>&gt; </b></p>
<p>WDGM_E_PARAM_STATE:  Invalid  WdgM  state.  Reset  will  be  invoked </p>
<p>(DET code 0x29).</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Indicates to the WdgM that a checkpoint within a supervised entity has been reached. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is reentrant (in the context of a different supervised entity). </p>
<p>Table 5-11  </p>
<p>WdgM_CheckpointReached </p>
<p><b>5.2.11 </b></p>
<p><b>WdgM_PerformReset </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_PerformReset</b>(void)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>void </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>77 </p>
<p>based on template version 5.12.0 </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK</p>
<p>: This value will not be returned because the reset is activated, and the </p>
<p>routine does not return. </p>
<p>E_NOT_OK</p>
<p>: The function has failed. </p>
<p><b>Functional Description </b></p>
<p>Instructs the WdgM to cause an immediate watchdog reset. </p>
<p><b>Note: </b></p>
<p>This function is hardware-dependent. Some watchdogs do not support an immediate reset. Check the Wdg </p>
<p>Driver documentation. </p>
<p>This  function  can  require  direct  access  to  hardware  registers.  Access  to  hardware  registers  can  be </p>
<p>dependent </p>
<p>on </p>
<p>hardware </p>
<p>platforms </p>
<p>and </p>
<p>software </p>
<p>architectures. </p>
<p>Hence, </p>
<p>the </p>
<p>application </p>
<p>that </p>
<p>calls </p>
<p>WdgM_PerformReset() must have the corresponding access rights. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is non-reentrant. </p>
<p><b>&gt; </b></p>
<p> Other particularities, limitations, post-conditions, pre-conditions </p>
<p>Table 5-12  </p>
<p>WdgM_PerformReset </p>
<p><b>5.2.12 </b></p>
<p><b>WdgM_GetFirstExpiredSEID </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_GetFirstExpiredSEID </b>(WdgM_SupervisedEntityIdType* SEID)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>SEID </p>
<p>A pointer to a variable that stores the ID of the first SE which has made a </p>
<p>transition to the state </p>
<p>WDGM_LOCAL_STATUS_EXPIRED</p>
<p> or </p>
<p>0</p>
<p> if the function did </p>
<p>not execute correctly. </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK</p>
<p>: The function could extract the record for the first expired supervised </p>
<p>entity successfully. </p>
<p>E_NOT_OK</p>
<p>: An error was detected (input parameter or memory corruption of </p>
<p>the record) </p>
<p><b>Functional Description </b></p>
<p>This  function  returns  the  ID  of  the  first  SE  that  reached  the  expired  state  and,  thus,  is  potentially </p>
<p>responsible for a system reset. It must be executed after at least one SE  reached the expired state, e.g. </p>
<p>after a reset, otherwise the returned result might not be correct. </p>
<p><b>Note: </b> The  record  for  the  first  expired  SE  is  stored  double  inverse  (so  that  memory  corruption  can  be </p>
<p>detected) and in a variable section that is not initialized (to preserve the data after a reset, but this also </p>
<p>means that there is initially no valid entry). </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is non-reentrant. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>78 </p>
<p>based on template version 5.12.0 </p>
<p>Table 5-13  </p>
<p>WdgM_GetFirstExpiredSEID </p>
<p><b>5.2.13 </b></p>
<p><b>WdgM_GetFirstExpiredSEViolation </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>WdgM_GetFirstExpiredSEViolation </b>(WdgM_ViolationType* </p>
<p>ViolationType)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>ViolationType </p>
<p>A pointer to a variable that stores the violation type that caused the first SE to </p>
<p>make a transition to state </p>
<p>WDGM_LOCAL_STATUS_EXPIRED</p>
<p> or </p>
<p>0</p>
<p> if the function </p>
<p>did not execute correctly. This parameter shows if the violation was a program </p>
<p>flow violation, a deadline supervision violation, an alive counter violation, or a </p>
<p>combination between them. </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>E_OK</p>
<p>:  The  function  was  able  to  successfully  extract  the  record  for  the  first </p>
<p>violation type. </p>
<p>E_NOT_OK</p>
<p>: An error was detected (input parameter or memory corruption of </p>
<p>the record). </p>
<p><b>Functional Description </b></p>
<p>This function returns the violation type of the first supervised entity which reached the expired state – and </p>
<p>thus is potentially responsible for a system reset. It must be executed after at least one supervised entity </p>
<p>reached the expired state, e.g. after a reset, otherwise the returned result might not be correct. Note, that </p>
<p>the record for the violation type is stored double inverse (so that memory corruption can be detected) and </p>
<p>in a variable section  which is not initialized (to  preserve the data after a reset,  but this also means that </p>
<p>initially there is no valid entry). </p>
<p>This function is enabled with the configuration option </p>
<p>WdgMAutosarDebugging</p>
<p>. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is non-reentrant. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Specify if it might be called from interrupt context </p>
<p>Table 5-14  </p>
<p>WdgM_GetFirstExpiredSEViolation </p>
<p><b>5.2.14 </b></p>
<p><b>WdgM_UpdateTickCount </b></p>
<p><b>Prototype </b></p>
<p>void <b>WdgM_UpdateTickCount</b>(void)</p>
<p> </p>
<p><b>Parameter </b></p>
<p>void </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>79 </p>
<p>based on template version 5.12.0 </p>
<p><b>Functional Description </b></p>
<p>This  function  increments  the  WdgM  timebase  tick  counter  by  one.  When  the  precompile  configuration </p>
<p>parameter </p>
<p>WdgMTimebaseSource</p>
<p> is set to </p>
<p>WDGM_EXTERNAL_TICK</p>
<p>, then this function needs to be called </p>
<p>periodically from outside the WdgM. </p>
<p>The timebase tick counter delivers the time base for deadline supervision. In the AUTOSAR environment. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is non-reentrant. </p>
<p><b>&gt; </b></p>
<p>This function can be called, for example, from a task with fixed time period and high priority. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>Specify if it might be called from interrupt context </p>
<p>Table 5-15  </p>
<p>WdgM_UpdateTickCount </p>
<p><b>5.3 </b></p>
<p><b>Services used by WdgM </b></p>
<p>In  the  following  table  services  provided  by  other  components,  which  are  used  by  the </p>
<p>WdgM are listed. For details about prototype and functionality refer to the documentation </p>
<p>of the providing component. </p>
<p><b>Component </b></p>
<p><b>API </b></p>
<p>Det </p>
<p>Det_ReportError() </p>
<p>Dem </p>
<p>Dem_ReportErrorStatus() </p>
<p>Mcu </p>
<p>Mcu_PerformReset() </p>
<p>Os </p>
<p>GetCoreID() </p>
<p>SchM </p>
<p><b>&gt; </b></p>
<p>SchM_Enter_WdgM_WDGM_EXCLUSIVE_AREA_0 </p>
<p><b>&gt; </b></p>
<p>SchM_Exit_WdgM_WDGM_EXCLUSIVE_AREA_0 </p>
<p>WdgIf </p>
<p><b>&gt; </b></p>
<p>WdgIf_SetMode() </p>
<p><b>&gt; </b></p>
<p>WdgIf_SetTriggerCondition() </p>
<p>Table 5-16  </p>
<p>Services used by the WdgM </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>80 </p>
<p>based on template version 5.12.0 </p>
<p> </p>
<p>Figure 5-1   Expected interfaces to external modules </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>81 </p>
<p>based on template version 5.12.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>If the precompile switches </p>
<p><b>&gt; </b></p>
<p>WdgMDevErrorDetect</p>
<p> </p>
<p><b>&gt; </b></p>
<p>WdgMDemReport</p>
<p> </p>
<p><b>&gt; </b></p>
<p>WdgMUseOsSuspendInterrupt</p>
<p> </p>
<p><b>&gt; </b></p>
<p>WdgMImmediateReset</p>
<p> </p>
<p><b>&gt; </b></p>
<p>WDGM_SECOND_RESET_PATH </p>
<p>are set to FALSE, the WdgM module does not call the corresponding function(s).</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The  functions  listed  in  the  table  above  may  not  meet  the  required  quality  level  and, </p>
<p>thus, must be wrapped in order to ensure freedom from interference with the WdgM. </p>
<p>The </p>
<p>integrator </p>
<p>must </p>
<p>implement </p>
<p>the </p>
<p>Appl_...() </p>
<p>functions </p>
<p>according </p>
<p>to </p>
<p>his </p>
<p>safety </p>
<p>requirements. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The system  integrator must  revise  the  necessity  of the  expected  interfaces. A called </p>
<p>external function may degrade the quality level of the WdgM below the required quality </p>
<p>level. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>5.4 </b></p>
<p><b>Configurable Interfaces </b></p>
<p><b>5.4.1 </b></p>
<p><b>Notifications </b></p>
<p>At  its  configurable  interfaces  the  WdgM  defines  notifications  that  can  be  mapped  to </p>
<p>callback functions provided by other modules. The mapping is not statically defined by the </p>
<p>WdgM  but  can  be  performed  at  configuration  time. The  function  prototypes  that  can  be </p>
<p>used  for  the  configuration  have  to  match  the  appropriate  function  prototype  signatures, </p>
<p>which are described in the following sub-chapters. </p>
<p><b>5.4.1.1 </b></p>
<p><b>Global state callback </b></p>
<p><b>Prototype </b></p>
<p>void <b>WdgM_GlobalStateChangeCbk </b>(WdgM_GlobalStatusType new_state); </p>
<p><b>Parameter </b></p>
<p>new_state </p>
<p>Contains the global state after the global state change. </p>
<p><b>Note: </b>In a multi-core system, the global state callback function can be set up </p>
<p>for each processor core separately. </p>
<p><b>Return code </b></p>
<p>void </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>82 </p>
<p>based on template version 5.12.0 </p>
<p><b>Functional Description </b></p>
<p>If </p>
<p>WDGM_STATE_CHANGE_NOTIFICATION == STD_ON</p>
<p>  and  the  WdgM  global  state  changes,  then  the </p>
<p>callback  routine  defined  by  the  parameter </p>
<p>WdgMGlobalStateChangeCbk</p>
<p>  is  called.  The  name  of  the </p>
<p>function can be arbitrary. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is non-reentrant. </p>
<p>Expected Caller Context </p>
<p><b>&gt; </b></p>
<p>May be called from task level. </p>
<p>Table 5-17  </p>
<p>Global state callback </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>83 </p>
<p>based on template version 5.12.0 </p>
<p><b>5.4.1.2 </b></p>
<p><b>Local state change notification </b></p>
<p><b>Prototype </b></p>
<p>void <b>WdgM_LocalStateChangeCbk </b>(WdgM_LocalStatusType new_state);</p>
<p> </p>
<p><b>Parameter </b></p>
<p>new_state </p>
<p>Contains the local state after the local state change. </p>
<p><b>Return code </b></p>
<p>void </p>
<p> </p>
<p><b>Functional Description </b></p>
<p>If </p>
<p>WDGM_STATE_CHANGE_NOTIFICATION == STD_ON</p>
<p> and the local state of a supervised entity changes, </p>
<p>then the callback routine defined by the parameter </p>
<p>WdgMLocalStateChangeCbk</p>
<p> is called. The name of </p>
<p>the function can be arbitrary (but of course different for each supervised entity). </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Service ID: see table 'Service IDs' (chapter 3.9.1) </p>
<p><b>&gt; </b></p>
<p>This function is synchronous. </p>
<p><b>&gt; </b></p>
<p>This function is non-reentrant. </p>
<p>Call context </p>
<p><b>&gt; </b></p>
<p>May be called from task level. </p>
<p>Table 5-18  </p>
<p>Local state change notification </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>84 </p>
<p>based on template version 5.12.0 </p>
<p><b>5.5 </b></p>
<p><b>Service Ports </b></p>
<p>A single SWC description file (WdgM_swc.arxml) is generated by the WdgM configuration </p>
<p>generator. </p>
<p>For </p>
<p>each </p>
<p>referenced </p>
<p>OsApplication </p>
<p>(referenced </p>
<p>by </p>
<p>WdgMGlobalMemoryAppTaskRef</p>
<p>  and </p>
<p>WdgMAppTaskRef</p>
<p>)  a  separate  component  type </p>
<p>element  is  generated  (named  WdgM_&lt;OsApplication&gt;)  within.  If  no  OsApplication  is </p>
<p>referenced at all, only one component type is generated (named WdgM). </p>
<p><b>5.5.1 </b></p>
<p><b>Client Server Interface </b></p>
<p>A client server interface is related to a Provide Port at the server side and a Require Port </p>
<p>at client side. </p>
<p>The following client server interfaces with corresponding operations are available: </p>
<p><b>&gt; </b></p>
<p>WdgM_AliveSupervision </p>
<p><b>&gt; </b></p>
<p>WdgM_IndividualMode </p>
<p><b>&gt; </b></p>
<p>WdgM_GlobalMode </p>
<p><b>&gt; </b></p>
<p>WdgM_LocalStatusCallbackInterface </p>
<p><b>&gt; </b></p>
<p>WdgM_GlobalStatusCallbackInterface </p>
<p><b>5.5.1.1 </b></p>
<p><b>Provide Ports on WdgM Side </b></p>
<p>At  the  Provide  Ports  of  the  WdgM  the API  functions  described  in  5.2  are  available  as </p>
<p>Runnable Entities. The Runnable Entities are invoked via operations. The mapping from a </p>
<p>SWC client call to an operation is performed by the RTE. In this mapping the RTE adds </p>
<p>port defined argument values to the client call of the SWC, if configured. </p>
<p>The  following  sub-chapters  present  the  Provide  Ports  defined  for  the  WdgM  and  the </p>
<p>operations defined for the Provide Ports, the API functions related to the  operations and </p>
<p>the port defined argument values to be added by the RTE. </p>
<p><b>5.5.1.1.1 </b></p>
<p><b>Port Prototype for WdgM_AliveSupervision </b></p>
<p>There are two possibilities for creation of a client server port prototype: </p>
<p><b>&gt; </b></p>
<p>For </p>
<p>each </p>
<p>checkpoint </p>
<p>(if </p>
<p>parameter </p>
<p>WdgMGenerateCPIdAsPortDefinedArgument</p>
<p> is set to </p>
<p>STD_ON</p>
<p>) </p>
<p><b>alive_&lt;WdgMSupervisedEntityShortname&gt;_&lt;WdgMCheckpointShortname&gt; </b></p>
<p>With this client server port prototype the following operation can be invoked: </p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>CheckpointReached </p>
<p>WdgM_CheckpointReached </p>
<p>WdgM_SupervisedEntityIdType </p>
<p>SEID, </p>
<p>WdgM_CheckpointIdType CPID </p>
<p>Table 5-19 </p>
<p>alive_&lt;WdgMSupervisedEntityShortname&gt;_&lt;WdgMCheckpointShortname&gt; </p>
<p><b>&gt; </b></p>
<p>For </p>
<p>each </p>
<p>supervised </p>
<p>entity </p>
<p>(if </p>
<p>parameter </p>
<p>WdgMGenerateCPIdAsPortDefinedArgument</p>
<p> is set to </p>
<p>STD_OFF</p>
<p>) </p>
<p><b>alive_&lt;WdgMSupervisedEntityShortname&gt; </b></p>
<p>With this client server port prototype the following operation can be invoked: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>85 </p>
<p>based on template version 5.12.0 </p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>CheckpointReached </p>
<p>WdgM_CheckpointReached </p>
<p>WdgM_SupervisedEntityIdType </p>
<p>SEID </p>
<p>Table 5-20  </p>
<p>alive_&lt;WdgMSupervisedEntityShortname&gt; </p>
<p><b>5.5.1.1.2 </b></p>
<p><b>Port Prototype for WdgM_IndividualMode </b></p>
<p>For each supervised entity a client server port prototypes is created: </p>
<p><b> </b></p>
<p><b>individual_&lt;WdgMSupervisedEntityShortname&gt; </b></p>
<p>With this client server port prototype the following operation can be invoked: </p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Port Defined Argument Values </b></p>
<p>GetLocalStatus </p>
<p>WdgM_GetLocalStatus </p>
<p>WdgM_SupervisedEntityIdType </p>
<p>SEID </p>
<p>Table 5-21  </p>
<p>individual_&lt;WdgMSupervisedEntityShortname&gt; </p>
<p><b>5.5.1.1.3 </b></p>
<p><b>Port Prototype for WdgM_GlobalMode </b></p>
<p>This client server port prototype is created only once. </p>
<p>If </p>
<p>OsApplications </p>
<p>are </p>
<p>referenced </p>
<p>by </p>
<p>WdgMGlobalMemoryAppTaskRef</p>
<p> </p>
<p>and </p>
<p>WdgMAppTaskRef</p>
<p>, the following port prototype is created: </p>
<p><b> </b></p>
<p><b>global_&lt;WdgMGlobalMemoryAppTaskRefShortname&gt; </b></p>
<p>If no OsApplications are referenced, the following port prototype is created </p>
<p><b> </b></p>
<p><b>global_WdgM </b></p>
<p>The related client server interface is WdgM_GlobalMode. No port defined argument values </p>
<p>are added. With this client server port prototype the following operations can be invoked: </p>
<p><b>Operation </b></p>
<p><b>API Function </b></p>
<p><b>Condition </b></p>
<p>GetMode </p>
<p>WdgM_GetMode </p>
<p>- </p>
<p>GetGlobalStatus </p>
<p>WdgM_GetGlobalStatus </p>
<p>- </p>
<p>GetLocalStatus </p>
<p>WdgM_GetLocalStatus </p>
<p>- </p>
<p>PerformReset </p>
<p>WdgM_PerformReset </p>
<p>- </p>
<p>GetFirstExpiredSEID </p>
<p>WdgM_GetFirstExpiredSEID </p>
<p>- </p>
<p>GetFirstExpiredSEViolation </p>
<p>WdgM_GetFirstExpiredSEViolation </p>
<p>AUTOSAR Debugging enabled </p>
<p>ActivateSupervisionEntity </p>
<p>WdgM_ActivateSupervisionEntity </p>
<p>EntityDeactivation enabled </p>
<p>DeactivateSupervisionEntity </p>
<p>WdgM_DeactivateSupervisionEntity </p>
<p>UpdateTickCount </p>
<p>WdgM_UpdateTickCount </p>
<p>Timebase is EXTERNAL_TICK </p>
<p>Table 5-22  </p>
<p>global_&lt;WdgMGlobalMemoryAppTaskRefShortname&gt; / global_WdgM </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>86 </p>
<p>based on template version 5.12.0 </p>
<p><b>5.5.1.2 </b></p>
<p><b>Require Ports on WdgM Side </b></p>
<p>At its Require Ports the WdgM calls operations. These operations have to be provided by </p>
<p>the SWCs by means of Runnable Entities. These runnable entities implement the callback </p>
<p>functions expected by the WdgM. </p>
<p>The following sub-chapter present the Require Ports defined for the WdgM, the operations </p>
<p>that are called from the WdgM and the related notifications, which are described in chapter </p>
<p>5.4. </p>
<p><b>5.5.1.2.1 </b></p>
<p><b>Port Prototype for WdgM_LocalStatusCallbackInterface </b></p>
<p>If a callback function is configured for a supervised entity (</p>
<p>WdgMLocalStateChangeCbk</p>
<p>), </p>
<p>for each of those supervised entities a client server port prototypes is created: </p>
<p><b> </b></p>
<p><b>localStateChangeCbk_&lt;WdgMSupervisedEntityShortname&gt; </b></p>
<p>With this client server port prototype the following operation shall be invoked: </p>
<p><b>Operation </b></p>
<p><b>Notification </b></p>
<p>LocalStatusCallback </p>
<p>Local state change notification </p>
<p>Table 5-23  </p>
<p>localStateChangeCbk_&lt;WdgMSupervisedEntityShortname&gt; </p>
<p><b>5.5.1.2.2 </b></p>
<p><b>Port Prototype for WdgM_GlobalStatusCallbackInterface </b></p>
<p>If  a  callback  function  is  configured  for  a  mode  (</p>
<p>WdgMGlobalMemoryAppTaskRef</p>
<p>),  for </p>
<p>each of those modes (/ cores) a client server port prototypes is created: </p>
<p><b> </b></p>
<p><b>globalStateChangeCbk_Core&lt;WdgMModeCoreAssignment&gt; </b></p>
<p>With this client server port prototype the following operation shall be invoked: </p>
<p><b>Operation </b></p>
<p><b>Notification </b></p>
<p>GlobalStatusCallback </p>
<p>Global state change notification </p>
<p>Table 5-24  </p>
<p>localStateChangeCbk_&lt;WdgMSupervisedEntityShortname&gt; </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>87 </p>
<p>based on template version 5.12.0 </p>
<p><b>6 </b></p>
<p><b>Configuration </b></p>
<p><b>6.1 </b></p>
<p><b>Configuration Variants </b></p>
<p>The WdgM supports the configuration variants </p>
<p><b>&gt; </b></p>
<p>VARIANT-PRE-COMPILE </p>
<p>The configuration classes of the WdgM parameters depend on the supported configuration </p>
<p>variants. For their definitions please see the WdgM_bswmd.arxml file. </p>
<p>The WdgM can be configured using the following tool:  </p>
<p><b>&gt; </b></p>
<p>DaVinci Configurator 5 (AUTOSAR 4 packages only). Parameters are explained within </p>
<p>the tool.  </p>
<p>The outputs of the configuration and generation process are the configuration source files. </p>
<p><b>6.2 </b></p>
<p><b>WdgM Configuration Verification </b></p>
<p>The WdgM Verifier is a tool for the verification of the generated WdgM configuration. The </p>
<p>WdgM  Verifier  is  delivered  as  a  DLL  (wdgm_verifier.dll)  that  must  be  compiled  with  the </p>
<p>configuration </p>
<p>files </p>
<p>produced </p>
<p>by </p>
<p>the </p>
<p>generator </p>
<p>and </p>
<p>the </p>
<p>files </p>
<p>produced </p>
<p>by </p>
<p>the </p>
<p>XSLT </p>
<p>Processor. The compilation result is a Windows Verifier.exe program. Running the Verifier </p>
<p>generates a report file (verifier_report.txt) that contains the result of the verification. </p>
<p>Figure 6-1 shows the workflow of the WdgM Verifier build.  </p>
<p> </p>
<p>Figure 6-1   Workflow of the WdgM Configuration Verifier build </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>88 </p>
<p>based on template version 5.12.0 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The WdgM generator is <b>not </b>ASIL D, therefore its output cannot be trusted, hence </p>
<p>additional checks are required by use of the WdgM Verifier. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The Verifier is only content of the delivery if the WdgM is ordered in safe context. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Practical Procedure </b></p>
<p>The verification process consists of the following steps, which are explained in detail in </p>
<p>the following sections: </p>
<p><b>&gt; </b></p>
<p>creation of WdgM Info files out of the ECU Description file (for the Verifier </p>
<p>build), </p>
<p><b>&gt; </b></p>
<p>build (compilation) of the Verifier, </p>
<p><b>&gt; </b></p>
<p>Verifier run and manual check of the Verifier report, </p>
<p><b>&gt; </b></p>
<p>manual checks (which cannot be performed by the Verifier) and </p>
<p><b>&gt; </b></p>
<p>check of system specifications against the WdgM Info files. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If OsApplications are referred by WdgMode and WdgMSupervisedEntity within the </p>
<p>configuration, the test with id ‘109’ of the verifier tool fails if an AUTOSAR OS version </p>
<p>greater than 4.0 is used. The Verifier assumes that OsApplication has a parameter </p>
<p>OsApplicationCoreAssignment which identifies the core, where the application runs. </p>
<p> </p>
<p>Due to the fact that AUTOSAR OS version 4.1 labels this parameter as obsolete and </p>
<p>due to the fact that since AUTOSAR OS version 4.2 this parameter is no more </p>
<p>available and replaced by a reference to an equivalent EcuC parameter, this test </p>
<p>verification step (test case) cannot be passed. </p>
<p> </p>
<p>A manual verification step has to be done in order to ensure, that all supervised entities </p>
<p>are configured to run on the correct core. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>89 </p>
<p>based on template version 5.12.0 </p>
<p><b>6.2.1.1 </b></p>
<p><b>Installing the WdgM Verifier </b></p>
<p>To run the WdgM Verifier an XSLT Processor and a working gcc environment are required. </p>
<p>The XSLT Processor is part of the delivery and located at “external\Misc\Wdg\xsltproc” and </p>
<p>contains of following files: </p>
<p><b>&gt; </b></p>
<p>iconv.dll, </p>
<p><b>&gt; </b></p>
<p>libexslt.dll, </p>
<p><b>&gt; </b></p>
<p>libxml2.dll, </p>
<p><b>&gt; </b></p>
<p>libxslt.dll, </p>
<p><b>&gt; </b></p>
<p>zlib1.dll, </p>
<p><b>&gt; </b></p>
<p>xsltproc.exe. </p>
<p>The recommended way to install gcc is to install the MinGW environment with the provided </p>
<p>installer </p>
<p>program </p>
<p>(</p>
<p>MinGW-5.1.6.exe</p>
<p> </p>
<p>– </p>
<p>located </p>
<p>at </p>
<p>“external\Misc\Wdg\MinGW”) </p>
<p>for </p>
<p>Windows 7. To install gcc proceed as follows: </p>
<p>1. </p>
<p>Start  the  installer  program,  accept  the  license  terms  and  click  “Next”  until  you  are </p>
<p>prompted to select a configuration. </p>
<p>2. </p>
<p>When prompted, select Minimal configuration. There is no need to select any check </p>
<p>boxes. </p>
<p>3. </p>
<p>Complete the installation process after accepting the default settings. </p>
<p>4. </p>
<p>Having  installed  gcc,  add  the </p>
<p>c:\MinGW\bin</p>
<p>  directory  to  your  search  path  by </p>
<p>entering  the  command </p>
<p>set PATH=%PATH%;c:\MinGW\bin</p>
<p>  in  a  command  prompt </p>
<p>window.  Alternatively  you  can  edit  Environment  Variables  in  the  System  Properties </p>
<p>dialog (Start &gt; Control Panel &gt; System). </p>
<p>To  verify  that  gcc  is working,  open  a new  command  prompt  window  and  enter </p>
<p>gcc -- </p>
<p>version</p>
<p> to let gcc show its version number. </p>
<p><b>6.2.1.2 </b></p>
<p><b>Creation of WdgM Info Files </b></p>
<p>This section describes how to extract the ECU description information for the verification. </p>
<p>The extraction results are the files </p>
<p><b>&gt; </b></p>
<p>wdgm_verifier_info.h and </p>
<p><b>&gt; </b></p>
<p>wdgm_verifier_info.c. </p>
<p>They </p>
<p>contain </p>
<p>the </p>
<p>ECU </p>
<p>description </p>
<p>information. </p>
<p>For </p>
<p>extracting </p>
<p>the </p>
<p>ECU </p>
<p>description </p>
<p>information, the integrator shall use the XSLT processor named &quot;xsltproc.exe&quot; (included in </p>
<p>the  delivery).  Further  the  following  XSL  stylesheets  shall  be  applied  for  the  information </p>
<p>extraction: </p>
<p><b>&gt; </b></p>
<p>verify_wdgm_header.xsl and </p>
<p><b>&gt; </b></p>
<p>verify_wdgm_source.xsl </p>
<p>The XSL stylesheets use XSLT 1.0 features only. </p>
<p>The integrator shall extract the ECU description information as follows: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>90 </p>
<p>based on template version 5.12.0 </p>
<p><b>&gt; </b></p>
<p>apply verify_wdgm_header.xsl to the ECU description file and store the output to </p>
<p>wdgm_verifier_info.h. </p>
<p><b>&gt; </b></p>
<p>apply verify_wdgm_source.xsl to the ECU description file and store the output to the </p>
<p>file wdgm_verifier_info.c. </p>
<p>In case of xsltproc.exe, the syntax is: </p>
<p><b>&gt; </b></p>
<p>xsltproc.exe verify_wdgm_header.xsl ECU-description-file &gt;wdgm_verifier_info.h </p>
<p><b>&gt; </b></p>
<p>xsltproc.exe verify_wdgm_source.xsl ECU-description-file &gt;wdgm_verifier_info.c </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The verifier tool and all necessary files are located at </p>
<p>“external\Generators\Wdg\Wdgm_Verifier”. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>6.2.1.3 </b></p>
<p><b>Verifier Compilation </b></p>
<p>The WdgM Verifier executable Verifier.exe is created as follows. </p>
<p>The integrator shall use a compiler/linker that fulfills the requirements in [ISO26262], part </p>
<p>8, clause 11.4. Gcc 3.4.5 was tested, which fulfills the ISO26262 requirements. </p>
<p>The  gcc  compiler  is  part  of  the  delivery  if  the  WdgM  was  ordered  in  safe  context.  It  is </p>
<p>highly recommended to use the delivered compiler. </p>
<p>For the compilation process, the following files must be compiled and linked: </p>
<p><b>&gt; </b></p>
<p>Generated C file: WdgM_PBcfg.c </p>
<p><b>&gt; </b></p>
<p>Generated WdgM “Info file” (XSLT result): wdgm_verifier_info.c </p>
<p><b>&gt; </b></p>
<p>Files from the WdgM verifier package: </p>
<p><b>&gt; </b></p>
<p>wdgm_verifier.dll </p>
<p><b>&gt; </b></p>
<p>libwdgm_verifierdll.a </p>
<p>The compiled files include the following files (more files may be required for compilation </p>
<p>depending on the environment and configuration options): </p>
<p><b>&gt; </b></p>
<p>WdgM header files: </p>
<p><b>&gt; </b></p>
<p>WdgM.h </p>
<p><b>&gt; </b></p>
<p>WdgM_Cfg.h </p>
<p><b>&gt; </b></p>
<p>WdgIf header file WdgIf_Types.h </p>
<p><b>&gt; </b></p>
<p>Created WdgM &quot;Info file&quot; (XSLT result): wdgm_verifier_info.h </p>
<p><b>&gt; </b></p>
<p>Generated WdgM header files: </p>
<p><b>&gt; </b></p>
<p>WdgM_Cfg_Features.h </p>
<p><b>&gt; </b></p>
<p>WdgM_OSMemMap.h </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>91 </p>
<p>based on template version 5.12.0 </p>
<p><b>&gt; </b></p>
<p>WdgM_PBcfg.h </p>
<p><b>&gt; </b></p>
<p>Files from the WdgM Stack package: </p>
<p><b>&gt; </b></p>
<p>wdgm_verifier.h </p>
<p><b>&gt; </b></p>
<p>wdgm_verifier_types.h </p>
<p><b>&gt; </b></p>
<p>wdgm_verifier_version.h </p>
<p><b>&gt; </b></p>
<p>List of platform specific files: </p>
<p><b>&gt; </b></p>
<p>Compiler.h </p>
<p><b>&gt; </b></p>
<p>Compiler_Cfg.h </p>
<p><b>&gt; </b></p>
<p>MemMap.h </p>
<p><b>&gt; </b></p>
<p>Os.h </p>
<p><b>&gt; </b></p>
<p>Os_MemMap.h </p>
<p><b>&gt; </b></p>
<p>Platform_Types.h </p>
<p><b>&gt; </b></p>
<p>Std_Types.h </p>
<p><b>&gt; </b></p>
<p>Rte_Compiler_Cfg.h (if RTE is used) </p>
<p><b>&gt; </b></p>
<p>Rte_MemMap.h (if RTE is used) </p>
<p><b>&gt; </b></p>
<p>Rte_Type.h (if RTE is used) </p>
<p>The set of include commands (-</p>
<p>I</p>
<p> path) for all include paths to these files is referred to as </p>
<p>verify-includes. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>The syntax for the compilation call is: </p>
<p><b>gcc </b>-Wall wdgm_verifier_info.c WdgM_PBcfg.c verify-includes –L dll-path –l </p>
<p>wdgm_verifier -o Verifier.exe </p>
<p>where  </p>
<p><b>&gt; </b></p>
<p><i>verify-includes </i>is a placeholder for the path(s) of include files as described </p>
<p>above and </p>
<p><b>&gt; </b></p>
<p><i>dll-path is a placeholder for the path where wdgm_verifier.dll and </i></p>
<p><i>libwdgm_verifierdll.a are located. </i></p>
<p>In case of an error free application of the compiler/linker the output is a WdgM Verifier </p>
<p>executable named Verifier.exe. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>6.2.1.4 </b></p>
<p><b>Verifier Run </b></p>
<p>After  the  WdgM  Verifier  executable  has  been  built,  it  has  to  be  executed.  The  WdgM </p>
<p>Verifier writes a verification report to standard output 'stdout'. This report must be reviewed </p>
<p>as stated in this section and manual verification check hast to be performed as described </p>
<p>in the Safety Manual [5]. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>92 </p>
<p>based on template version 5.12.0 </p>
<p>The integrator shall run the WdgM Verifier executable as follows: </p>
<p><b>&gt; </b></p>
<p>Verifier.exe &gt;verifier_report.txt. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>All other steps listed in section 6.2 are described in the Safety Manual [5]. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>93 </p>
<p>based on template version 5.12.0 </p>
<p><b>7 </b></p>
<p><b>Glossary and Abbreviations </b></p>
<p><b>7.1 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>Alive Indications </p>
<p>An  indication  provided  by  a  supervised  entity  alive  counter  to  signal  its </p>
<p>aliveness to the WdgM. </p>
<p>Alive Supervision </p>
<p>A  kind  of  WdgM  monitoring  (supervision)  that  checks  if  a  Supervised </p>
<p>Entity is executed sufficiently often and not too often. </p>
<p>Checkpoint </p>
<p>A  point  in  the  control  flow  of  a  supervised  entity  where  the  activity  is </p>
<p>reported to the WdgM. </p>
<p>Closed Graph </p>
<p>A closed graph is a directed graph where every checkpoint is reachable, </p>
<p>starting from the local initial Checkpoint. </p>
<p>Configuration Tool </p>
<p>A tool used for creating a WdgM configuration, e.g., DaVinci Configurator </p>
<p>Pro. </p>
<p>Container </p>
<p>Refers  to  the  AUTOSAR  term  &quot;container&quot;.  Represents  a  structure  with </p>
<p>different parameters. </p>
<p>Deadline Supervision </p>
<p>Kind of WdgM monitoring (supervision) that checks if the execution time </p>
<p>between two Checkpoints is lower or higher as the configured limits. </p>
<p>Destination </p>
<p>Checkpoint </p>
<p>End point of a transition. </p>
<p>End Checkpoint </p>
<p>The </p>
<p>last </p>
<p>checkpoint </p>
<p>that </p>
<p>is </p>
<p>monitored </p>
<p>for </p>
<p>a </p>
<p>supervised </p>
<p>entity. </p>
<p>After </p>
<p>passing  the  End  Checkpoint,  the  WdgM  expects  that  the  entity  is  not </p>
<p>monitored.  To  start  the  monitoring  again  the  Initial  checkpoint  must  be </p>
<p>passed first. A supervised entity can have zero or more End Checkpoints. </p>
<p>Error </p>
<p>Discrepancy </p>
<p>between </p>
<p>a </p>
<p>computed, </p>
<p>observed </p>
<p>or </p>
<p>measured </p>
<p>value </p>
<p>or </p>
<p>condition, </p>
<p>and </p>
<p>the </p>
<p>true, </p>
<p>specified </p>
<p>or </p>
<p>theoretically </p>
<p>correct </p>
<p>value </p>
<p>or </p>
<p>condition. </p>
<p>Failure </p>
<p>Termination of the ability of an element, to perform a function as required. </p>
<p>Fault </p>
<p>Abnormal condition that can cause an element or an item to fail. </p>
<p>Fault Detection Time </p>
<p>See. WdgM Fault Detection Time. </p>
<p>Fault Reaction Time </p>
<p>The Fault Reaction Time is the WdgM Fault Reaction Time plus the Wdg </p>
<p>Fault Reaction Time. </p>
<p>Global Monitoring </p>
<p>Status </p>
<p>Status  that  summarizes  the  Local  Monitoring  Status  of  all  supervised </p>
<p>entities. </p>
<p>Global Transition </p>
<p>A global transition is a transition between two checkpoints in the logical </p>
<p>program </p>
<p>flow </p>
<p>(i.e. </p>
<p>source </p>
<p>and </p>
<p>destination </p>
<p>checkpoint), </p>
<p>where </p>
<p>the </p>
<p>checkpoints belong to different supervised entities. </p>
<p>Initial Checkpoint </p>
<p>The  first  checkpoint </p>
<p>that </p>
<p>is  monitored </p>
<p>in  the </p>
<p>supervised </p>
<p>entity.  The </p>
<p>monitoring </p>
<p>of </p>
<p>a </p>
<p>supervised </p>
<p>entity </p>
<p>must </p>
<p>start </p>
<p>at </p>
<p>this </p>
<p>Checkpoint. </p>
<p>A </p>
<p>supervised entity has exactly one Initial Checkpoint. </p>
<p>Local Monitoring </p>
<p>Status </p>
<p>Status </p>
<p>that </p>
<p>represents </p>
<p>the </p>
<p>current </p>
<p>result </p>
<p>of </p>
<p>supervision </p>
<p>of </p>
<p>a </p>
<p>single </p>
<p>supervised entity. </p>
<p>Local Transition </p>
<p>A Local Transition is the transition between two checkpoints (i.e. source </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>94 </p>
<p>based on template version 5.12.0 </p>
<p>and  destination  checkpoint)  in  the  logical  program  flow  in  the  same </p>
<p>supervised entity. </p>
<p>Program Flow </p>
<p>Monitoring </p>
<p>Kind  of  WdgM  monitoring  (supervision)  that  checks  if  the  inspected </p>
<p>software is executed in a predefined sequence. This sequence is defined </p>
<p>by the user and collected in the WdgM configuration. </p>
<p>WdgM Fault </p>
<p>Detection Time </p>
<p>The time-span from the occurrence of a fault to the detection of the fault </p>
<p>by  the  WdgM.  The  detection  of  a  fault  is  indicated  by  a  change  of  the </p>
<p>state WDGM_LOCAL_STATE_OK or WDGM_GLOBAL_STATE_OK to a </p>
<p>different state. </p>
<p>WdgM Tick </p>
<p>(Counter) </p>
<p>Tick </p>
<p>counter </p>
<p>is </p>
<p>used </p>
<p>for </p>
<p>deadline </p>
<p>supervision </p>
<p>time </p>
<p>measurement. </p>
<p>Depending  on the  parameter WdgMTimebaseSource  the  tick  counter  is </p>
<p>incremented by 1 for each supervision cycle or, for higher precision, with </p>
<p>the API function WdgM_UpdateTickCounter() or with a hardware counter. </p>
<p>Safe State </p>
<p>The Safe State is the operating mode of an item without an unreasonable </p>
<p>level of risk [6], part1). </p>
<p>Watchdog </p>
<p>Manager Stack </p>
<p>The </p>
<p>software </p>
<p>module </p>
<p>consisting </p>
<p>of </p>
<p>Watchdog </p>
<p>Manager, </p>
<p>Watchdog </p>
<p>Interface and Watchdog Driver. </p>
<p>Watchdog </p>
<p>Manager </p>
<p>(WdgM) </p>
<p>The </p>
<p>hardware-independent </p>
<p>upper </p>
<p>software </p>
<p>layer </p>
<p>of </p>
<p>the </p>
<p>Watchdog </p>
<p>Manager Stack. </p>
<p>Watchdog </p>
<p>Interface </p>
<p>(WdgIf) </p>
<p>The </p>
<p>hardware-independent </p>
<p>middle </p>
<p>software </p>
<p>layer </p>
<p>of </p>
<p>the </p>
<p>Watchdog </p>
<p>Manager Stack. </p>
<p>Watchdog Driver </p>
<p>(Wdg) </p>
<p>The hardware-dependent lowest layer of the Watchdog Manager Stack. </p>
<p>Controls the Watchdog device. </p>
<p>Source Checkpoint </p>
<p>Start point of a transition. </p>
<p>Supervised Entity </p>
<p>A software entity that is monitored by the WdgM. Each supervised entity </p>
<p>has  exactly  one  identifier.  A  supervised  entity  denotes  a  collection  of </p>
<p>checkpoints  within  a  software  component  or  basic  software  module. </p>
<p>There  may  be  zero,  one  or  more  supervised  entities  in  a  software </p>
<p>component  or  basic  software  module.  Each  entity  has  a  state  that  is </p>
<p>based on the states reported from all its checkpoints. All checkpoints of </p>
<p>one entity belong to the same memory context. </p>
<p>Supervision Cycle </p>
<p>The time period of the WdgM in which the cyclic supervision algorithm is </p>
<p>performed. </p>
<p>Supervision </p>
<p>Reference Cycle </p>
<p>The number of supervision cycles used as a reference by Alive, Deadline </p>
<p>and  Program  Flow  Supervision  for  periodic  supervision.  Every  kind  of </p>
<p>supervision has its own reference cycle. </p>
<p>Timebase Tick </p>
<p>The WdgM  measures  the  deadline  of  a  Transition  in  timebase  ticks  (In </p>
<p>the context of this document also referred to as WdgM tick). </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The timebase tick is provided either by the WdgM itself, or it </p>
<p>can be provided by an external source. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>95 </p>
<p>based on template version 5.12.0 </p>
<p>Trigger Mode </p>
<p>The </p>
<p>WdgM </p>
<p>Trigger </p>
<p>Mode </p>
<p>is </p>
<p>a </p>
<p>set </p>
<p>of </p>
<p>Watchdog </p>
<p>trigger </p>
<p>times </p>
<p>and </p>
<p>Watchdog  mode.  One  Trigger  Mode  is  a  group  of  the  following  three </p>
<p>parameters: </p>
<p><b>&gt; </b></p>
<p>WdgMTriggerWindowStart </p>
<p><b>&gt; </b></p>
<p>WdgMTriggerConditionValue </p>
<p><b>&gt; </b></p>
<p>WdgMWatchdogMode </p>
<p>Each Watchdog device can have one or more Trigger Modes. </p>
<p>Watchdog Device </p>
<p>The </p>
<p>Watchdog </p>
<p>Device </p>
<p>is </p>
<p>the </p>
<p>hardware </p>
<p>part </p>
<p>which </p>
<p>represents </p>
<p>the </p>
<p>watchdog functionality. It can be an internal watchdog integrated on the </p>
<p>MCU chip, or it can be an external watchdog device outside the MCU. </p>
<p>Table 7-1  </p>
<p>Glossary </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>96 </p>
<p>based on template version 5.12.0 </p>
<p><b>7.2 </b></p>
<p><b>Abbreviations </b></p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>API </p>
<p>Application Programming Interface </p>
<p>ASIL </p>
<p>Automotive Safety Integrity Level </p>
<p>AUTOSAR </p>
<p>Automotive Open System Architecture </p>
<p>BSW </p>
<p>Basis Software </p>
<p>BswM </p>
<p>Basic Software Module </p>
<p>CP </p>
<p>Checkpoint </p>
<p>CPID </p>
<p>Checkpoint Id </p>
<p>DEM </p>
<p>Diagnostic Event Manager </p>
<p>DET </p>
<p>Development Error Tracer </p>
<p>EAD </p>
<p>Embedded Architecture Designer </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>EDF </p>
<p>ECU Description File </p>
<p>HIS </p>
<p>Hersteller Initiative Software </p>
<p>ISO </p>
<p>International Organization for Standardization </p>
<p>MCU </p>
<p>Microcontroller Unit </p>
<p>MICROSAR </p>
<p>Microcontroller Open System Architecture (the Vector AUTOSAR </p>
<p>solution) </p>
<p>QM </p>
<p>Quality Managed Software (software development process) </p>
<p>RTE </p>
<p>Runtime Environment </p>
<p>SCHM </p>
<p>Schedule Manager module (according AUTOSAR 4.0.1) </p>
<p>SE </p>
<p>Supervised entity </p>
<p>SEID </p>
<p>Supervised Entity Identifier </p>
<p>SW-C, SWC </p>
<p>Software Component </p>
<p>Wdg </p>
<p>Watchdog Driver </p>
<p>WdgIf </p>
<p>Watchdog Interface </p>
<p>WdgM </p>
<p>Watchdog Manager </p>
<p>SWS </p>
<p>Software Specification </p>
<p>Wdg </p>
<p>Watchdog </p>
<p>Table 7-2  </p>
<p>Abbreviations </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR WDGM </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.1.0 </p>
<p>97 </p>
<p>based on template version 5.12.0 </p>
<p><b>8 </b></p>
<p><b>Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b>&gt; </b></p>
<p>News </p>
<p><b>&gt; </b></p>
<p>Products </p>
<p><b>&gt; </b></p>
<p>Demo software </p>
<p><b>&gt; </b></p>
<p>Support </p>
<p><b>&gt; </b></p>
<p>Training data </p>
<p><b>&gt; </b></p>
<p>Addresses </p>
<p> </p>
<p>www.vector.com </p>
<p> </p>
<p> </p>
</body>
</html>
{% endraw %}