---
layout: default
title: debug
nav_order: 4
parent: Ide (TL121A)
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p><b>MULTI: Debugging</b></p>
<p><b>Green Hills Software</b></p>
<p><b>30 West Sola Street</b></p>
<p><b>Santa Barbara, California 93101</b></p>
<p><b>USA</b></p>
<p><b>Tel: 805-965-6044</b></p>
<p><b>Fax: 805-965-6343</b></p>
<p><b>www.ghs.com</b></p>
<h1 style="page-break-before:always; "></h1>
<p><b>DISCLAIMER</b></p>
<p>GREEN HILLS SOFTWARE MAKES NO REPRESENTATIONS OR WARRANTIES WITH RESPECT TO THE</p>
<p>CONTENTS HEREOF AND SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY</p>
<p>OR FITNESS FOR ANY PARTICULAR PURPOSE. Further, Green Hills Software reserves the right to revise this</p>
<p>publication and to make changes from time to time in the content hereof without obligation of Green Hills Software to</p>
<p>notify any person of such revision or changes.</p>
<p>Copyright Â© 1983-2014 by Green Hills Software. All rights reserved. No part of this publication may be reproduced, stored</p>
<p>in a retrieval system, or transmitted, in any form or by any means, electronic, mechanical, photocopying, recording, or</p>
<p>otherwise, without prior written permission from Green Hills Software.</p>
<p>Green Hills, the Green Hills logo, CodeBalance, GMART, GSTART, INTEGRITY, MULTI, and Slingshot are registered</p>
<p>trademarks of Green Hills Software. AdaMULTI, Built with INTEGRITY, EventAnalyzer, G-Cover, GHnet, GHnetLite,</p>
<p>Green Hills Probe, Integrate, ISIM, u-velOSity, PathAnalyzer, Quick Start, ResourceAnalyzer, Safety Critical Products,</p>
<p>SuperTrace Probe, TimeMachine, TotalDeveloper, DoubleCheck, and velOSity are trademarks of Green Hills Software.</p>
<p>All other company, product, or service names mentioned in this book may be trademarks or service marks of their respective</p>
<p>owners.</p>
<p>PubID: debug-525957</p>
<p>Branch: http://toolsvc/branches/release-branch-61</p>
<p>Date: February 19, 2015</p>
<h1 style="page-break-before:always; "></h1>
<p><b>Contents</b></p>
<p><b>Preface</b></p>
<p><b>xxiii</b></p>
<p>About This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>xxiv</p>
<p>The MULTI 6 Document Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>xxv</p>
<p>Conventions Used in the MULTI Document Set . . . . . . . . . . . . . . . . . . .</p>
<p>xxvi</p>
<p><b>Part I. Before You Begin Debugging</b></p>
<p><b>1</b></p>
<p><b>1. Introduction</b></p>
<p><b>3</b></p>
<p>The MULTI Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>4</p>
<p>Building Your Code for Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>5</p>
<p>Starting the MULTI Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>5</p>
<p>Starting the Debugger in GUI Mode . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>6</p>
<p>Starting the Debugger in Non-GUI Mode (Linux/Solaris</p>
<p>only) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>8</p>
<p>Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>9</p>
<p><b>2. The Main Debugger Window</b></p>
<p><b>11</b></p>
<p>Debugger Window Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>12</p>
<p>Setting Up Your Debugging Environment . . . . . . . . . . . . . . . . . . . . . .</p>
<p>14</p>
<p>Reusing the Debugger Window . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>14</p>
<p>Opening Multiple Debugger Windows . . . . . . . . . . . . . . . . . . . . .</p>
<p>14</p>
<p>The Target List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>15</p>
<p>Repositioning and Hiding the Target List . . . . . . . . . . . . . . . . . . .</p>
<p>15</p>
<p>Debugging Target List Items . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>16</p>
<p>Target Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>18</p>
<p>The Status Column . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>19</p>
<p>The CPU % Column . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>20</p>
<p>The Source Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>21</p>
<p>Source Pane Display Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>23</p>
<p><i>iii</i></p>
<p><i>Green Hills Software</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Source Pane Line Numbers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>24</p>
<p>The Navigation Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>25</p>
<p>The Cmd, Trg, I/O, Srl, Py, and Tfc Panes . . . . . . . . . . . . . . . . . . . . . .</p>
<p>26</p>
<p>The Command Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>28</p>
<p>The Target Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>30</p>
<p>The I/O Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>30</p>
<p>The Serial Terminal Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>31</p>
<p>The Python Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>32</p>
<p>The Traffic Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>33</p>
<p>The Status Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>36</p>
<p><b>3. Connecting to Your Target</b></p>
<p><b>39</b></p>
<p>Working with Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>40</p>
<p>Hardware Connections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>41</p>
<p>Simulator Connections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>41</p>
<p>Native Development Connections . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>41</p>
<p>Tools Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>42</p>
<p>Standard Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>42</p>
<p>Creating a Standard Connection Using the Project Wizard . . . .</p>
<p>42</p>
<p>Creating a Standard Connection Using the Connection</p>
<p>Chooser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>43</p>
<p>Configuring a Standard Connection with the Connection</p>
<p>Editor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>44</p>
<p>Connecting with a Standard Connection . . . . . . . . . . . . . . . . . . . .</p>
<p>45</p>
<p>Custom Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>47</p>
<p>Temporary Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>49</p>
<p>Using the Connection Organizer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>50</p>
<p>Opening the Connection Organizer . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>50</p>
<p>Creating a Connection Method . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>52</p>
<p>Editing a Connection Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>52</p>
<p>Creating and Managing Connection Files . . . . . . . . . . . . . . . . . . .</p>
<p>52</p>
<p>Connecting from the Connection Organizer . . . . . . . . . . . . . . . . .</p>
<p>54</p>
<p>Managing Your Connected Targets . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>54</p>
<p>Connection Organizer Menu and Action Reference . . . . . . . . . .</p>
<p>55</p>
<p>Disconnecting from Your Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>58</p>
<p><i>MULTI: Debugging</i></p>
<p><i>iv</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>4. INDRT2 (rtserv2) Connections</b></p>
<p><b>59</b></p>
<p>Introduction to rtserv2 and INDRT2 . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>60</p>
<p>Communication Media . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>60</p>
<p>Building in Run-Mode Debugging Support . . . . . . . . . . . . . . . . . . . . .</p>
<p>61</p>
<p>Connecting Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>62</p>
<p>INDRT2 Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>62</p>
<p>Using the INDRT2 (rtserv2) Connection Editor . . . . . . . . . . . . .</p>
<p>62</p>
<p>Using Custom INDRT2 (rtserv2) Connection Methods . . . . . . .</p>
<p>66</p>
<p>Automatically Establishing Run-Mode Connections . . . . . . . . . . . . .</p>
<p>69</p>
<p>Setting a Run-Mode Partner . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>70</p>
<p>The Set Run-Mode Partner Dialog Box . . . . . . . . . . . . . . . . . . . .</p>
<p>71</p>
<p>Disabling Automatically Established Run-Mode</p>
<p>Connections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>73</p>
<p>Troubleshooting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>73</p>
<p>Connecting to Multiple ISIM Targets . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>74</p>
<p><b>5. INDRT (rtserv) Connections</b></p>
<p><b>77</b></p>
<p>Introduction to rtserv and INDRT . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>78</p>
<p>Communication Media . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>78</p>
<p>Building in Run-Mode Debugging Support . . . . . . . . . . . . . . . . . . . . .</p>
<p>79</p>
<p>Connecting Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>80</p>
<p>INDRT Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>80</p>
<p>Using the INDRT (rtserv) Connection Editor . . . . . . . . . . . . . . .</p>
<p>80</p>
<p>Using Custom INDRT (rtserv) Connection Methods . . . . . . . . .</p>
<p>86</p>
<p>Connecting with rtserv over the ARM Debug Comm Channel . . . . .</p>
<p>88</p>
<p><b>6. Configuring Your Target Hardware</b></p>
<p><b>89</b></p>
<p>Installing Your Target Hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>90</p>
<p>Configuring Your Target Hardware for Debugging . . . . . . . . . . . . . . .</p>
<p>90</p>
<p>Customizing MULTI Board Setup Scripts . . . . . . . . . . . . . . . . . .</p>
<p>90</p>
<p>Testing Target Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>96</p>
<p>Customizing Linker Directives Files . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>98</p>
<p><i>v</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Specifying Setup Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>98</p>
<p>Using MULTI (.mbs) Setup Scripts When Connecting to Your</p>
<p>Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>99</p>
<p>Using Legacy (.dbs) Setup Scripts When Connecting to Your</p>
<p>Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>100</p>
<p>Running Setup Scripts Manually . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>101</p>
<p>Early MULTI Board Setup Scripts with Debugger Hooks . . . .</p>
<p>101</p>
<p><b>7. Preparing Your Target</b></p>
<p><b>103</b></p>
<p>Chapter Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>104</p>
<p>Associating Your Executable with a Connection . . . . . . . . . . . . . . . .</p>
<p>105</p>
<p>Updating MULTI 4 Target Connections . . . . . . . . . . . . . . . . . . .</p>
<p>107</p>
<p>Preparing Your Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>108</p>
<p>The Prepare Target Dialog Box . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>110</p>
<p>Program Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>111</p>
<p>Downloading Your Executable . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>114</p>
<p>Flashing Your Executable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>114</p>
<p>Verifying the Presence of Your Executable . . . . . . . . . . . . . . . .</p>
<p>114</p>
<p>Related Settings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>115</p>
<p>Memory Sensitive Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>115</p>
<p>No Stack Trace Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>116</p>
<p>Core File Debugging (Linux/Solaris only) . . . . . . . . . . . . . . . . . . . . .</p>
<p>117</p>
<p><b>Part II. Basic Debugging</b></p>
<p><b>119</b></p>
<p><b>8. Executing and Controlling Your Program from</b></p>
<p><b>the Debugger</b></p>
<p><b>121</b></p>
<p>Starting and Stopping a Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>122</p>
<p>Single-Stepping Through a Program . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>123</p>
<p>Using Breakpoints and Tracepoints . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>124</p>
<p>Breakdots, Breakpoint Markers, and Tracepoint Markers . . . .</p>
<p>125</p>
<p>Viewing Breakpoint and Tracepoint Information . . . . . . . . . . .</p>
<p>128</p>
<p>Working with Software Breakpoints . . . . . . . . . . . . . . . . . . . . . .</p>
<p>128</p>
<p>Working with Hardware Breakpoints . . . . . . . . . . . . . . . . . . . . .</p>
<p>133</p>
<p>Working with Shared Object Breakpoints . . . . . . . . . . . . . . . . .</p>
<p>136</p>
<p><i>MULTI: Debugging</i></p>
<p><i>vi</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Restoring Deleted Breakpoints . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>137</p>
<p>Advanced Breakpoint Topics . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>138</p>
<p>Software and Hardware Breakpoint Editors . . . . . . . . . . . . . . . . . . . .</p>
<p>139</p>
<p>The Breakpoints Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>146</p>
<p>Breakpoints Window Columns . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>146</p>
<p>Breakpoints Window Buttons . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>148</p>
<p>Breakpoints Window Mouse and Keyboard Actions . . . . . . . .</p>
<p>149</p>
<p>Breakpoints Window Shortcut Menu . . . . . . . . . . . . . . . . . . . . .</p>
<p>150</p>
<p>The Breakpoints Restore Window . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>152</p>
<p>Breakpoints Restore Window Columns . . . . . . . . . . . . . . . . . . .</p>
<p>152</p>
<p>Breakpoints Restore Window Buttons . . . . . . . . . . . . . . . . . . . .</p>
<p>153</p>
<p>Breakpoints Restore Window Shortcut Menu . . . . . . . . . . . . . .</p>
<p>153</p>
<p><b>9. Navigating Windows and Viewing</b></p>
<p><b>Information</b></p>
<p><b>155</b></p>
<p>Navigating and Searching Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>156</p>
<p>Using the Scroll Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>156</p>
<p>Incremental Searching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>156</p>
<p>Searching in Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>159</p>
<p>Selecting, Cutting, and Pasting Text . . . . . . . . . . . . . . . . . . . . . .</p>
<p>160</p>
<p>Navigating, Browsing, and Searching the Source Pane . . . . . . . . . .</p>
<p>162</p>
<p>Using the File Locator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>164</p>
<p>Using the Procedure Locator . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>165</p>
<p>Using Navigation History Buttons . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>167</p>
<p>Using the Source Pane Search Dialog Box . . . . . . . . . . . . . . . .</p>
<p>167</p>
<p>Viewing Program and Target Information . . . . . . . . . . . . . . . . . . . . .</p>
<p>168</p>
<p>Viewing Information in Stand-Alone Windows . . . . . . . . . . . .</p>
<p>168</p>
<p>Viewing Information in the Command Pane . . . . . . . . . . . . . . .</p>
<p>172</p>
<p><b>10. Using Debugger Notes</b></p>
<p><b>173</b></p>
<p>Creating and Editing Debugger Notes . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>174</p>
<p>Editing a Single Debugger Note . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>174</p>
<p>Editing Multiple Debugger Notes . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>176</p>
<p>Removing Debugger Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>176</p>
<p>Organizing Debugger Notes Into Groups . . . . . . . . . . . . . . . . . . . . . .</p>
<p>177</p>
<p><i>vii</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Viewing Debugger Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>177</p>
<p>The Note Browser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>178</p>
<p><b>Part III. Viewing Debugging Information</b></p>
<p><b>and Program Details</b></p>
<p><b>181</b></p>
<p><b>11. Viewing and Modifying Variables with the Data</b></p>
<p><b>Explorer</b></p>
<p><b>183</b></p>
<p>Opening a Data Explorer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>184</p>
<p>The Data Explorer Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>185</p>
<p>The Data Explorer Toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>186</p>
<p>The Edit Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>187</p>
<p>Viewing Multiple Items in a Data Explorer . . . . . . . . . . . . . . . . . . . .</p>
<p>188</p>
<p>Updating Data Explorer Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>189</p>
<p>Freezing Data Explorer Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>189</p>
<p>Types of Variable Displays in a Data Explorer . . . . . . . . . . . . . . . . .</p>
<p>190</p>
<p>Displaying Structures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>190</p>
<p>Displaying Linked Lists . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>191</p>
<p>Displaying Arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>193</p>
<p>Displaying C++ Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>195</p>
<p>Changing How Variables are Displayed in a Data Explorer . . . . . .</p>
<p>195</p>
<p>Changing the Type Used to Display a Variable . . . . . . . . . . . . .</p>
<p>195</p>
<p>Viewing Pointers to C++ Base Classes . . . . . . . . . . . . . . . . . . . .</p>
<p>196</p>
<p>Modifying Variables from a Data Explorer . . . . . . . . . . . . . . . . . . . .</p>
<p>198</p>
<p>Configuring Data Explorers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>198</p>
<p>Configuring Individual Data Explorer Dimensions . . . . . . . . . .</p>
<p>198</p>
<p>Setting Global Options for Data Explorers . . . . . . . . . . . . . . . . .</p>
<p>199</p>
<p>Data Explorer Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>200</p>
<p>Data Explorer Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>201</p>
<p>The Edit Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>202</p>
<p>The View Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>202</p>
<p>The Format Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>204</p>
<p>The Evaluate Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>206</p>
<p><i>MULTI: Debugging</i></p>
<p><i>viii</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The Tools Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>207</p>
<p>The Settings Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>208</p>
<p><b>12. Browsing Program Elements</b></p>
<p><b>211</b></p>
<p>Browsing Program Elements Overview . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>212</p>
<p>The Browse Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>214</p>
<p>Browse Window Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>214</p>
<p>Filtering Content in the Browse Window . . . . . . . . . . . . . . . . . .</p>
<p>216</p>
<p>Browse Window Headings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>220</p>
<p>Browsing Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>220</p>
<p>Browsing Global Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>228</p>
<p>Browsing Source Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>230</p>
<p>Browsing Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>233</p>
<p>Browsing Cross References . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>236</p>
<p>The Tree Browser Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>239</p>
<p>Opening a Tree Browser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>239</p>
<p>Using a Tree Browser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>239</p>
<p>Browsing Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>243</p>
<p>Browsing Static Calls By Function . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>244</p>
<p>Browsing Static Calls By File . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>245</p>
<p>Browsing Dynamic Calls by Function . . . . . . . . . . . . . . . . . . . .</p>
<p>246</p>
<p>The Graph View Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>247</p>
<p>Browsing Includes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>247</p>
<p>Controlling Layout and Navigating in Graph View . . . . . . . . .</p>
<p>248</p>
<p><b>13. Using the Register Explorer</b></p>
<p><b>253</b></p>
<p>The Register View Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>254</p>
<p>The Menu Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>256</p>
<p>Toolbar</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>259</p>
<p>Tabs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>260</p>
<p>Register Tree . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>260</p>
<p>Performing Actions on Registers Using the Shortcut</p>
<p>Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>262</p>
<p>Customizing the Register View Window . . . . . . . . . . . . . . . . . .</p>
<p>263</p>
<p>Copying Register Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>267</p>
<p>Editing Register Contents . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>267</p>
<p>Controlling Refresh of Register Values . . . . . . . . . . . . . . . . . . . .</p>
<p>268</p>
<p><i>ix</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Printing the Window Contents . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>269</p>
<p>Register View Window Configuration Files . . . . . . . . . . . . . . . .</p>
<p>269</p>
<p>The Register Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>270</p>
<p>Concise Display Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>272</p>
<p>Detailed Display Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>273</p>
<p>Help Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>274</p>
<p>Button Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>275</p>
<p>Changing a Register Value . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>275</p>
<p>The Modify Register Definition Dialog . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>276</p>
<p>Bitfield Editor Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>277</p>
<p>Bitfield List Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>278</p>
<p>The Register Setup Dialog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>279</p>
<p>The Register Search Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>280</p>
<p>Using Debugger Commands to Work with Registers . . . . . . . . . . . .</p>
<p>282</p>
<p>Customizing Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>285</p>
<p>Customizing Registers from the Command Line . . . . . . . . . . . .</p>
<p>285</p>
<p>Customizing Registers in Default .rc Files . . . . . . . . . . . . . . . . .</p>
<p>285</p>
<p>Customizing Default Register Definition Files . . . . . . . . . . . . .</p>
<p>285</p>
<p><b>14. Using Expressions, Variables, and Procedure</b></p>
<p><b>Calls</b></p>
<p><b>291</b></p>
<p>Evaluating Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>292</p>
<p>Expression Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>292</p>
<p>Expressing Source Addresses . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>293</p>
<p>Language-Independent Expressions . . . . . . . . . . . . . . . . . . . . . .</p>
<p>294</p>
<p>Language Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>294</p>
<p>Caveats for Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>294</p>
<p>Viewing Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>297</p>
<p>Variable Lifetimes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>299</p>
<p>Examining Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>300</p>
<p>Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>300</p>
<p>Expression Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>300</p>
<p>Language Dependencies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>303</p>
<p>Wildcards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>303</p>
<p><i>MULTI: Debugging</i></p>
<p><i>x</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Procedure Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>304</p>
<p>Caveats for Command Line Procedure Calls . . . . . . . . . . . . . . .</p>
<p>306</p>
<p>Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>307</p>
<p>MULTI Special Variables and Operators . . . . . . . . . . . . . . . . . . . . . .</p>
<p>309</p>
<p>User-Defined Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>309</p>
<p>System Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>310</p>
<p>Processor-Specific Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>317</p>
<p>Special Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>317</p>
<p>Syntax Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>320</p>
<p><b>15. Using the Memory View Window</b></p>
<p><b>323</b></p>
<p>Setting the Active Location . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>325</p>
<p>Locking the Current Symbol's Location . . . . . . . . . . . . . . . . . . .</p>
<p>325</p>
<p>The Memory Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>326</p>
<p>Formatting View Columns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>326</p>
<p>Managing View Columns . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>327</p>
<p>Controlling Memory Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>328</p>
<p>Freezing the Memory View Window . . . . . . . . . . . . . . . . . . . . .</p>
<p>328</p>
<p>Setting Access Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>328</p>
<p>Disabling Block Reads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>329</p>
<p>Editing Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>329</p>
<p>The Memory View Toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>330</p>
<p>Memory View Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>332</p>
<p>The Memory Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>332</p>
<p>The View Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>334</p>
<p>The Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>336</p>
<p><b>16. Viewing Memory Allocation Information</b></p>
<p><b>339</b></p>
<p>Using the Memory Allocations Window . . . . . . . . . . . . . . . . . . . . . .</p>
<p>340</p>
<p>Viewing the Memory Allocation Visualization . . . . . . . . . . . . .</p>
<p>343</p>
<p>Viewing Memory Leaks and Allocation Information . . . . . . . .</p>
<p>347</p>
<p><b>17. Collecting and Viewing Profiling Data</b></p>
<p><b>353</b></p>
<p>Types of Profiling Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>354</p>
<p><i>xi</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Overview of Profiling Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>355</p>
<p>Generating Profiling Data for a Task, AddressSpace, or</p>
<p>Stand-Alone Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>356</p>
<p>Collecting Profiling Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>356</p>
<p>Collecting Profiling Data for All Tasks in Your System . . . . . .</p>
<p>357</p>
<p>Collecting Profiling Data for a Trace-Enabled Target . . . . . . . .</p>
<p>358</p>
<p>Collecting Profiling Data for a Task, AddressSpace, or</p>
<p>Stand-Alone Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>359</p>
<p>Caveats for Profiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>360</p>
<p>Disabling the Collection of Profiling Data . . . . . . . . . . . . . . . . . . . . .</p>
<p>360</p>
<p>Viewing Profiling Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>361</p>
<p>The Profile Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>361</p>
<p>Continual Updates in the Profile Window . . . . . . . . . . . . . . . . .</p>
<p>363</p>
<p>Profiling Reports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>363</p>
<p>The Profile Window Reference . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>372</p>
<p>Viewing Profiling Information in the Debugger . . . . . . . . . . . . . . . .</p>
<p>377</p>
<p>Performing Range Analyses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>379</p>
<p>Managing Profiling Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>380</p>
<p>Adding to or Overwriting Existing Profiling Data . . . . . . . . . .</p>
<p>380</p>
<p>Manually Dumping Profiling Data . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>381</p>
<p>Manually Processing Profiling Data . . . . . . . . . . . . . . . . . . . . . .</p>
<p>383</p>
<p>Clearing Profiling Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>384</p>
<p>Caveats for Dumping and Clearing Profiling Data . . . . . . . . . .</p>
<p>385</p>
<p><b>18. Using Other View Windows</b></p>
<p><b>387</b></p>
<p>Viewing Call Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>388</p>
<p>The Call Stack Window and Command Line Procedure</p>
<p>Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>389</p>
<p>The Call Stack Window and Procedure Prologues and</p>
<p>Epilogues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>390</p>
<p>The Call Stack Window and Interrupt/Exception Handlers . . .</p>
<p>390</p>
<p>Viewing Native Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>390</p>
<p>Viewing Caches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>392</p>
<p>The Cache View Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>392</p>
<p>The Cache Find Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>396</p>
<p><i>MULTI: Debugging</i></p>
<p><i>xii</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Part IV. TimeMachine Debugging</b></p>
<p><b>399</b></p>
<p><b>19. Analyzing Trace Data with the TimeMachine</b></p>
<p><b>Tool Suite</b></p>
<p><b>401</b></p>
<p>Quick Start</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>403</p>
<p>Overview of Trace Analysis Tools . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>404</p>
<p>Managing Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>405</p>
<p>Enabling and Disabling Trace Collection . . . . . . . . . . . . . . . . . .</p>
<p>405</p>
<p>Collecting Operating System Trace Data . . . . . . . . . . . . . . . . . .</p>
<p>406</p>
<p>Retrieving Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>408</p>
<p>Discarding Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>410</p>
<p>Dealing with Incomplete Trace Data . . . . . . . . . . . . . . . . . . . . . .</p>
<p>411</p>
<p>The TimeMachine Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>413</p>
<p>Enabling and Disabling TimeMachine . . . . . . . . . . . . . . . . . . . .</p>
<p>414</p>
<p>The Location of the Program Counter in TimeMachine . . . . . .</p>
<p>416</p>
<p>TimeMachine Run-Control Buttons . . . . . . . . . . . . . . . . . . . . . .</p>
<p>416</p>
<p>Breakpoint</p>
<p>Sharing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>417</p>
<p>Using TimeMachine with OS Tasks . . . . . . . . . . . . . . . . . . . . . .</p>
<p>418</p>
<p>Using Separate Session TimeMachine . . . . . . . . . . . . . . . . . . . .</p>
<p>422</p>
<p>The PathAnalyzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>424</p>
<p>Opening the PathAnalyzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>424</p>
<p>The PathAnalyzer Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>425</p>
<p>Navigating Path Analysis Data . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>428</p>
<p>Searching Path Analysis Data . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>430</p>
<p>Viewing, Editing, and Adding Bookmarks in the</p>
<p>PathAnalyzer</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>432</p>
<p>Analyzing Operating System Trace Data . . . . . . . . . . . . . . . . . .</p>
<p>432</p>
<p>Viewing Trace Data in the Trace List . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>434</p>
<p>The Trace List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>435</p>
<p>Time Analysis . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>439</p>
<p>Navigating through Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>440</p>
<p>Filtering Trace Data in the Trace List . . . . . . . . . . . . . . . . . . . . .</p>
<p>442</p>
<p>Accessing TimeMachine Analysis Tools . . . . . . . . . . . . . . . . . .</p>
<p>444</p>
<p>Bookmarking Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>444</p>
<p><i>xiii</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Searching Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>446</p>
<p>Saving and Loading a Trace Session . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>448</p>
<p>Browsing Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>451</p>
<p>The Trace Memory Browser . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>452</p>
<p>The Trace Branch Browser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>454</p>
<p>The Trace Instruction Browser . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>456</p>
<p>The Trace Call Browser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>457</p>
<p>Trace Browsers Toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>459</p>
<p>Viewing Trace Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>460</p>
<p>Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>460</p>
<p>AddressSpace Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>462</p>
<p>Memory Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>463</p>
<p>Branch Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>464</p>
<p>Function Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>465</p>
<p>The TimeMachine API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>466</p>
<p>Accessing Trace Data via the Live TimeMachine Interface . . .</p>
<p>467</p>
<p>Accessing Trace Data via the TimeMachine File Interface . . .</p>
<p>469</p>
<p>Creating Trace Data via the TimeMachine File Interface . . . . .</p>
<p>470</p>
<p>Example Python Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>471</p>
<p>The Example C/C++ Application . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>473</p>
<p>Viewing Trace Events in the EventAnalyzer . . . . . . . . . . . . . . . . . . .</p>
<p>474</p>
<p>Using Trace Data to Profile Your Target . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>475</p>
<p>Viewing Reconstructed Register Values . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>476</p>
<p><b>20. Advanced Trace Configuration</b></p>
<p><b>479</b></p>
<p>The Trace Options Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>480</p>
<p>The Collection Tab . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>481</p>
<p>The Analysis Tab . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>485</p>
<p>The Debug Tab . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>487</p>
<p>The Target-Specific Tab . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>487</p>
<p>Action Buttons . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>488</p>
<p>Configuring Target-Specific Trace Options . . . . . . . . . . . . . . . . . . . .</p>
<p>488</p>
<p>Viewing Target-Specific Information . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>489</p>
<p>Configuring Trace Collection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>489</p>
<p>Configuring Trace Directly from MULTI . . . . . . . . . . . . . . . . . .</p>
<p>491</p>
<p><i>MULTI: Debugging</i></p>
<p><i>xiv</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The Set Triggers Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>493</p>
<p>Editing Complex Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>497</p>
<p><b>Part V. Advanced Debugging in Specific</b></p>
<p><b>Environments</b></p>
<p><b>509</b></p>
<p><b>21. Testing Target Memory</b></p>
<p><b>511</b></p>
<p>Quick Memory Testing: Using the Memory Test Wizard . . . . . . . . .</p>
<p>512</p>
<p>Advanced Memory Testing: Using the Perform Memory Test</p>
<p>Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>515</p>
<p>Defining Memory Areas to Test . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>516</p>
<p>Selecting Memory Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>518</p>
<p>Setting Test Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>520</p>
<p>Specifying Test Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>521</p>
<p>Running Memory Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>522</p>
<p>Viewing Memory Test Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>523</p>
<p>Continuous Memory Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>524</p>
<p>Memory Testing with a Target Agent . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>524</p>
<p>Types of Memory Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>525</p>
<p>Address Bus Walking Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>525</p>
<p>Data Bus Walking Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>527</p>
<p>Data Pattern Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>529</p>
<p>Memory Read Test . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>532</p>
<p>CRC Compute . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>532</p>
<p>CRC Compare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>533</p>
<p>Find Start/End Ranges . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>533</p>
<p>Efficient Testing Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>535</p>
<p>Running Memory Tests from the Command Line . . . . . . . . . . . . . . .</p>
<p>535</p>
<p>Detecting Coherency Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>536</p>
<p>Checking Coherency Manually . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>536</p>
<p>Checking Coherency Automatically . . . . . . . . . . . . . . . . . . . . . .</p>
<p>537</p>
<p><b>22. Programming Flash Memory</b></p>
<p><b>539</b></p>
<p>The MULTI Fast Flash Programmer Window . . . . . . . . . . . . . . . . . .</p>
<p>540</p>
<p><i>xv</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Prerequisites to Working with Flash . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>541</p>
<p>Using the MULTI Fast Flash Programmer . . . . . . . . . . . . . . . . . . . . .</p>
<p>541</p>
<p>Specifying Flash Banks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>541</p>
<p>Choosing a File for Flash Operations . . . . . . . . . . . . . . . . . . . . .</p>
<p>542</p>
<p>Setting a Write Offset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>542</p>
<p>Writing to Flash Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>543</p>
<p>Erasing Flash Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>544</p>
<p>Verifying Flash Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>544</p>
<p>The MULTI Fast Flash Programmer GUI Reference . . . . . . . . . . . .</p>
<p>545</p>
<p>Flash Configuration File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>546</p>
<p>Troubleshooting Flash Memory Operations . . . . . . . . . . . . . . . . . . . .</p>
<p>547</p>
<p><b>23. Working with ROM</b></p>
<p><b>549</b></p>
<p>Building an Executable for ROM . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>550</p>
<p>Creating a New Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>550</p>
<p>Configuring an Existing Program . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>551</p>
<p>Executing a ROM Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>552</p>
<p>Attaching to a Running ROM Process . . . . . . . . . . . . . . . . . . . .</p>
<p>552</p>
<p>Advanced: Starting a ROM Program from the Debugger . . . .</p>
<p>553</p>
<p>Debugging a ROM Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>554</p>
<p>Building an Executable for ROM-to-RAM . . . . . . . . . . . . . . . . . . . .</p>
<p>554</p>
<p>Creating a New Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>555</p>
<p>Configuring an Existing Program . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>555</p>
<p>Executing a ROM-to-RAM Program . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>556</p>
<p>Debugging a ROM-to-RAM Program . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>557</p>
<p><b>24. Non-Intrusive Debugging with Tracepoints</b></p>
<p><b>559</b></p>
<p>About Tracepoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>560</p>
<p>Working with Tracepoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>561</p>
<p>Setting a Tracepoint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>561</p>
<p>Editing a Tracepoint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>563</p>
<p>Listing Tracepoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>564</p>
<p>Deleting a Tracepoint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>564</p>
<p>Enabling or Disabling a Tracepoint . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>565</p>
<p><i>MULTI: Debugging</i></p>
<p><i>xvi</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Resetting a Tracepoint . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>565</p>
<p>Viewing the Tracepoint Buffer . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>566</p>
<p>Purging the Tracepoint Buffer . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>567</p>
<p>Collecting Debugging Information Non-Intrusively: Example . . . .</p>
<p>567</p>
<p>Source Code for the Sample Program . . . . . . . . . . . . . . . . . . . . .</p>
<p>567</p>
<p>Examples of Valid tpset Commands . . . . . . . . . . . . . . . . . . . . . .</p>
<p>568</p>
<p>Limitations: Information You Cannot Collect with</p>
<p>Tracepoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>570</p>
<p>The Tracepoints Tab of the Breakpoints Window . . . . . . . . . . . . . . .</p>
<p>571</p>
<p>Debugging in Passive Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>574</p>
<p>Entering and Exiting Passive Mode . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>574</p>
<p>Setting the Passive Mode Password . . . . . . . . . . . . . . . . . . . . . .</p>
<p>575</p>
<p><b>25. Run-Mode Debugging</b></p>
<p><b>577</b></p>
<p>Establishing Run-Mode Connections . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>578</p>
<p>Loading a Run-Mode Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>579</p>
<p>The Task Manager . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>580</p>
<p>Working with AddressSpaces and Tasks . . . . . . . . . . . . . . . . . . . . . .</p>
<p>581</p>
<p>Run-Mode AddressSpaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>581</p>
<p>Attaching to Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>582</p>
<p>Halting Tasks On Attach . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>583</p>
<p>Debugging Run-Mode Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>583</p>
<p>Freezing the Task Manager's Task List Display . . . . . . . . . . . . .</p>
<p>584</p>
<p>Working with Task Groups in the Task Manager . . . . . . . . . . . . . . .</p>
<p>584</p>
<p>Default Task Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>585</p>
<p>Configuring Task Group Settings . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>587</p>
<p>Working with Run-Mode Breakpoints . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>587</p>
<p>Task-Specific Breakpoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>587</p>
<p>Any-Task Breakpoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>587</p>
<p>Group Breakpoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>588</p>
<p>Synchronous Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>589</p>
<p>Task Manager GUI Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>592</p>
<p>Menu Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>592</p>
<p>Toolbar</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>595</p>
<p>Task List Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>596</p>
<p>Information Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>597</p>
<p><i>xvii</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The Task Manager Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>598</p>
<p>Task Group Configuration File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>600</p>
<p>OS-Awareness in Run Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>601</p>
<p>The OSA Explorer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>602</p>
<p>The OSA Object Viewer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>602</p>
<p>Profiling All Tasks in Your System . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>603</p>
<p><b>26. Freeze-Mode Debugging and</b></p>
<p><b>OS-Awareness</b></p>
<p><b>605</b></p>
<p>Starting MULTI for Freeze-Mode Debugging and</p>
<p>OS-Awareness . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>607</p>
<p>The OSA Explorer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>609</p>
<p>Displaying an OSA Explorer . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>609</p>
<p>The OSA Explorer GUI Reference . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>611</p>
<p>Customizing the Object List . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>612</p>
<p>Object List Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>612</p>
<p>Debugging in Freeze Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>613</p>
<p>Master Debugger Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>614</p>
<p>Task Debugger Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>615</p>
<p>Working with Freeze-Mode Breakpoints . . . . . . . . . . . . . . . . . .</p>
<p>618</p>
<p>Program I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>620</p>
<p>Multi-Core Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>620</p>
<p>Freeze-Mode and OSA Configuration File . . . . . . . . . . . . . . . . . . . .</p>
<p>632</p>
<p>General Settings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>633</p>
<p>The Object Type Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>636</p>
<p>The Object Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>636</p>
<p>Example: Configuration File . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>639</p>
<p><b>27. Establishing Serial Connections</b></p>
<p><b>643</b></p>
<p>Starting the Serial Terminal Emulator (MTerminal) . . . . . . . . . . . . .</p>
<p>644</p>
<p>Using Quick Connect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>645</p>
<p>Creating and Configuring Serial Connections . . . . . . . . . . . . . . . . . .</p>
<p>646</p>
<p>Using the Serial Connection Chooser . . . . . . . . . . . . . . . . . . . . .</p>
<p>646</p>
<p>Using the Serial Connection Settings Dialog . . . . . . . . . . . . . . .</p>
<p>647</p>
<p><i>MULTI: Debugging</i></p>
<p><i>xviii</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The MTerminal Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>650</p>
<p>The MTerminal Menu Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>650</p>
<p>The MTerminal Toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>652</p>
<p>The MTerminal Status Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>653</p>
<p>Running the Serial Terminal Emulator in Console Mode . . . . . . . . .</p>
<p>653</p>
<p>mterminal Syntax and Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>654</p>
<p><b>Part VI. Appendices</b></p>
<p><b>657</b></p>
<p><b>A. Debugger GUI Reference</b></p>
<p><b>659</b></p>
<p>Debugger Window Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>660</p>
<p>The File Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>661</p>
<p>The Debug Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>665</p>
<p>The View Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>673</p>
<p>The Browse Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>679</p>
<p>The Target Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>680</p>
<p>The TimeMachine Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>683</p>
<p>The Tools Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>685</p>
<p>The Config Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>687</p>
<p>The Windows Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>690</p>
<p>The Help Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>691</p>
<p>The Debugger Window Toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>691</p>
<p>Configuring the Debugger Toolbar . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>698</p>
<p>The Target List Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>702</p>
<p>Source Pane Shortcut Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>704</p>
<p>Common Shortcut Menu Options . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>704</p>
<p>The Source Line Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>705</p>
<p>The Breakdot Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>707</p>
<p>The Procedure Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>708</p>
<p>The Variable Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>709</p>
<p>The Type Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>710</p>
<p>The Type Member Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>711</p>
<p>The C/C++ Macro Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>711</p>
<p>The Command Pane Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>712</p>
<p>The Source Pane Search Dialog Box . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>712</p>
<p><i>xix</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The File Chooser Dialog Box (Linux/Solaris) . . . . . . . . . . . . . . . . . .</p>
<p>713</p>
<p><b>B. Keyboard Shortcut Reference</b></p>
<p><b>715</b></p>
<p>Main Debugger Window Shortcuts . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>716</p>
<p>Source Pane Shortcuts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>717</p>
<p>Command Pane Shortcuts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>718</p>
<p><b>C. Command Line Reference</b></p>
<p><b>721</b></p>
<p>Using a Specification File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>727</p>
<p><b>D. Using Third-Party Tools with the MULTI</b></p>
<p><b>Debugger</b></p>
<p><b>729</b></p>
<p>Using the Debugger with Third-Party Compilers . . . . . . . . . . . . . . .</p>
<p>730</p>
<p>Running Third-Party Tools from the Debugger . . . . . . . . . . . . . . . . .</p>
<p>731</p>
<p>Using MULTI with Rhapsody . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>732</p>
<p>Supported Environments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>732</p>
<p>Integration Description . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>733</p>
<p>Installation and Configuration . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>733</p>
<p>Licensing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>734</p>
<p>Additional</p>
<p>Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>734</p>
<p>Example: Using MULTI 6, INTEGRITY 10, and Rhapsody</p>
<p>7 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>736</p>
<p><b>E. Creating Custom Data Visualizations</b></p>
<p><b>741</b></p>
<p>Using MULTI Data Visualization (.mdv) Files . . . . . . . . . . . . . . . . .</p>
<p>743</p>
<p>Loading and Clearing MULTI Data Visualization (.mdv)</p>
<p>Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>745</p>
<p>Invoking Customized Data Visualizations . . . . . . . . . . . . . . . . . . . . .</p>
<p>746</p>
<p>MULTI Data Visualization (.mdv) File Format . . . . . . . . . . . . . . . . .</p>
<p>747</p>
<p>Data Descriptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>747</p>
<p>Profile Descriptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>766</p>
<p>View Descriptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>768</p>
<p>Using Expressions in MULTI Data Visualization (.mdv)</p>
<p>Files . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>770</p>
<p><i>MULTI: Debugging</i></p>
<p><i>xx</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>.mdv File Examples . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>770</p>
<p><b>F. Register Definition and Configuration</b></p>
<p><b>Reference</b></p>
<p><b>775</b></p>
<p>The GRD Register Definition Format . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>776</p>
<p>The general Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>777</p>
<p>The enum Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>784</p>
<p>The structure Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>786</p>
<p>The bitfield Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>788</p>
<p>The register Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>791</p>
<p>The group Section . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>797</p>
<p><b>G. Integrate Views</b></p>
<p><b>801</b></p>
<p>Integrate Security View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>802</p>
<p>Integrate Relationship View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>802</p>
<p><b>Index</b></p>
<p><b>805</b></p>
<p><i>xxi</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Preface</b></p>
<p><b>Contents</b></p>
<p>About This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>xxiv</p>
<p>The MULTI 6 Document Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>xxv</p>
<p>Conventions Used in the MULTI Document Set . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>xxvi</p>
<h1 style="page-break-before:always; "></h1>
<p>This preface discusses the purpose of the manual, the MULTI documentation set,</p>
<p>and typographical conventions used.</p>
<p><b>About This Book</b></p>
<p>The<i> MULTI: Debugging</i> book is divided into the following parts:</p>
<p>â¢</p>
<p><i>Part I: Before You Begin Debugging</i> documents the basic components of the</p>
<p>Debugger and describes how to connect to your target and prepare it for</p>
<p>debugging. See Part I. Before You Begin Debugging on page 1.</p>
<p>â¢</p>
<p><i>Part II: Basic Debugging</i> describes how to execute embedded programs and</p>
<p>navigate the Debugger window. See Part II. Basic Debugging on page 119.</p>
<p>â¢</p>
<p><i>Part III: Viewing Debugging Information and Program Details</i> documents</p>
<p>how to examine program code and view debugging information. See</p>
<p>Part III. Viewing Debugging Information and Program Details on page 181.</p>
<p>â¢</p>
<p><i>Part IV: TimeMachine Debugging</i> describes how to collect and analyze trace</p>
<p>data and documents the separately licensed TimeMachine tool suite. See</p>
<p>Part IV. TimeMachine Debugging on page 399.</p>
<p>â¢</p>
<p><i>Part V: Advanced Debugging in Specific Environments</i> documents how to test</p>
<p>target memory; use flash memory; use the MULTI Debugger with ROM;</p>
<p>perform field debugging, run-mode and freeze-mode debugging, and OS-aware</p>
<p>debugging; and establish serial connections. See Part V. Advanced Debugging</p>
<p>in Specific Environments on page 509.</p>
<p>â¢</p>
<p><i>Part VI: Appendices</i> contains reference material, including comprehensive</p>
<p>documentation of the Debugger's menus, keyboard shortcuts, and command</p>
<p>line options. This part also contains instructions about how to use the Debugger</p>
<p>with third-party tools and how to create custom data visualizations.</p>
<p>Specifications for the register definition format supported by this release are</p>
<p>included, as are descriptions of Integrate features new in this release. See</p>
<p>Part VI. Appendices on page 657.</p>
<p><b>Note</b></p>
<p>New or updated information may have become available while this book</p>
<p>was in production. For additional material that was not available at press</p>
<p>time, or for revisions that may have become necessary since this book</p>
<p><i>MULTI: Debugging</i></p>
<p><i>xxiv</i></p>
<p><i>Preface</i></p>
<h1 style="page-break-before:always; "></h1>
<p>was printed, please check your installation directory for release notes,</p>
<p><b>README</b> files, and other supplementary documentation.</p>
<p><b>The MULTI 6 Document Set</b></p>
<p>The primary documentation for using MULTI is provided in the following books:</p>
<p>â¢</p>
<p><i>MULTI: Getting Started</i> â Provides an introduction to the MULTI Integrated</p>
<p>Development Environment and leads you through a simple tutorial.</p>
<p>â¢</p>
<p><i>MULTI: Licensing</i> â Describes how to obtain, install, and administer MULTI</p>
<p>licenses.</p>
<p>â¢</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> â Describes how to</p>
<p>create and manage projects and how to configure the MULTI IDE.</p>
<p>â¢</p>
<p><i>MULTI: Building Applications</i> â Describes how to use the compiler driver</p>
<p>and the tools that compile, assemble, and link your code. Also describes the</p>
<p>Green Hills implementation of supported high-level languages.</p>
<p>â¢</p>
<p><i>MULTI: Configuring Connections</i> â Describes how to configure connections</p>
<p>to your target.</p>
<p>â¢</p>
<p><i>MULTI: Debugging</i> â Describes how to set up your target debugging interface</p>
<p>for use with MULTI and how to use the MULTI Debugger and associated tools.</p>
<p>â¢</p>
<p><i>MULTI: Debugging Command Reference</i> â Explains how to use Debugger</p>
<p>commands and provides a comprehensive reference of Debugger commands.</p>
<p>â¢</p>
<p><i>MULTI: Scripting</i> â Describes how to create MULTI scripts. Also contains</p>
<p>information about the MULTI-Python integration.</p>
<p>For a comprehensive list of the books provided with your MULTI installation, see</p>
<p>the<b> Help</b> â<b> Manuals</b> menu accessible from most MULTI windows.</p>
<p>Most books are available in the following formats:</p>
<p>â¢</p>
<p>A printed book (select books are not available in print).</p>
<p>â¢</p>
<p>Online help, accessible from most MULTI windows via the<b> Help</b> â<b> Manuals</b></p>
<p>menu.</p>
<p>â¢</p>
<p>An electronic PDF, available in the<b> manuals</b> subdirectory of your IDE or</p>
<p>Compiler installation.</p>
<p><i>xxv</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The MULTI 6 Document Set</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Conventions Used in the MULTI Document Set</b></p>
<p>All Green Hills documentation assumes that you have a working knowledge of your</p>
<p>host operating system and its conventions, including its command line and graphical</p>
<p>user interface (GUI) modes.</p>
<p>Green Hills documentation uses a variety of notational conventions to present</p>
<p>information and describe procedures. These conventions are described below.</p>
<p><b>Example</b></p>
<p><b>Indication</b></p>
<p><b>Convention</b></p>
<p><b>C:\MyProjects</b></p>
<p>Filename or pathname</p>
<p><b>bold</b> type</p>
<p><b>setup</b> command</p>
<p>Command</p>
<p><b>-G</b> option</p>
<p>Option</p>
<p>The<b> Breakpoints</b> window</p>
<p>Window title</p>
<p>The<b> File</b> menu</p>
<p>Menu name or menu choice</p>
<p><b>Working Directory:</b></p>
<p>Field name</p>
<p>The<b> Browse</b> button</p>
<p>Button name</p>
<p><b>-o<i> filename</b></i></p>
<p>Replaceable text</p>
<p><i>italic</i> type</p>
<p>A task may be called a<i> process</i></p>
<p>or a<i> thread</i></p>
<p>A new term</p>
<p><i>MULTI: Debugging</i></p>
<p>A book title</p>
<p>Type</p>
<p>help<i> command_name</i></p>
<p>Text you should enter as presented</p>
<p>monospace</p>
<p>type</p>
<p>The<b> wait</b> [-global] command</p>
<p>blocks command processing,</p>
<p>where</p>
<p>-global</p>
<p>blocks</p>
<p>command processing for all</p>
<p>MULTI processes.</p>
<p>A word or words used in a</p>
<p>command or example</p>
<p>int a = 3;</p>
<p>Source code</p>
<p>&gt; print Test</p>
<p>Test</p>
<p>Input/output</p>
<p>GHS_System()</p>
<p>A function</p>
<p><b>debugbutton</b> [<i>name</i>]...</p>
<p>The preceding argument or option</p>
<p>can be repeated zero or more times.</p>
<p>ellipsis (...)</p>
<p>(in command line</p>
<p>instructions)</p>
<p><i>MULTI: Debugging</i></p>
<p><i>xxvi</i></p>
<p><i>Preface</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Example</b></p>
<p><b>Indication</b></p>
<p><b>Convention</b></p>
<p>&gt; print Test</p>
<p>Test</p>
<p>Represents a prompt. Your actual</p>
<p>prompt may be a different symbol</p>
<p>or string. The &gt; prompt helps to</p>
<p>distinguish input from output in</p>
<p>examples of screen displays.</p>
<p>greater than sign ( &gt; )</p>
<p><b>call<i></b> proc</i> |<i> expr</i></p>
<p>One (and only one) of the</p>
<p>parameters or options separated by</p>
<p>the pipe or pipes should be</p>
<p>specified.</p>
<p>pipe ( | )</p>
<p>(in command line</p>
<p>instructions)</p>
<p>.macro<i> name</i> [<i>list</i>]</p>
<p>Optional argument, command,</p>
<p>option, and so on. You can either</p>
<p>include or omit the enclosed</p>
<p>elements. The square brackets</p>
<p>should not appear in your actual</p>
<p>command.</p>
<p>square brackets ( [ ] )</p>
<p>(in command line</p>
<p>instructions)</p>
<p>The following command description demonstrates the use of some of these</p>
<p>typographical conventions.</p>
<p><b>gxyz</b> [<i>-option</i>]...<i> filename</i></p>
<p>The formatting of this command indicates that:</p>
<p>â¢</p>
<p>The command<b> gxyz</b> should be entered as shown.</p>
<p>â¢</p>
<p>The option</p>
<p><i>-option</i></p>
<p>should either be replaced with one or more appropriate</p>
<p>options or be omitted.</p>
<p>â¢</p>
<p>The word</p>
<p><i>filename</i></p>
<p>should be replaced with the actual filename of an</p>
<p>appropriate file.</p>
<p>The square brackets and the ellipsis should not appear in the actual command you</p>
<p>enter.</p>
<p><i>xxvii</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Conventions Used in the MULTI Document Set</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Part I</b></p>
<p><b>Before You Begin</b></p>
<p><b>Debugging</b></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 1</b></p>
<p><b>Introduction</b></p>
<p><b>Contents</b></p>
<p>The MULTI Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>4</p>
<p>Building Your Code for Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>5</p>
<p>Starting the MULTI Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>5</p>
<p>Next Steps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>9</p>
<h1 style="page-break-before:always; "></h1>
<p><b>The MULTI Debugger</b></p>
<p>The MULTI Debugger is a powerful graphical debugger that supports source,</p>
<p>assembly, and mixed-language debugging.</p>
<p>The MULTI Debugger's graphical interface makes it possible to view information</p>
<p>about multiple processes and program elements simultaneously. The GUI also makes</p>
<p>it easy to perform various debugging tasks, since most tasks can be invoked with</p>
<p>a simple mouse click or keyboard shortcut. Most tasks can also be performed by</p>
<p>typing commands into the Debugger's command pane.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>4</i></p>
<p><i>Chapter 1. Introduction</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The MULTI Debugger allows you to perform the following tasks quickly and easily:</p>
<p>â¢</p>
<p>Download, execute, control, and debug embedded applications written in C,</p>
<p>C++, assembly, or a combination of these languages.</p>
<p>â¢</p>
<p>Browse, view, and search all aspects of your program code using graphical</p>
<p>windows.</p>
<p>â¢</p>
<p>View and edit variables, pointers, structures, registers, and memory ranges.</p>
<p>â¢</p>
<p>Create, view, edit, and remove conditional breakpoints, non-intrusive</p>
<p>tracepoints, data watchpoints, and Debugger Notes.</p>
<p>â¢</p>
<p>View profiling, memory allocation, code coverage, and stack trace information.</p>
<p>â¢</p>
<p>Analyze collected trace data.</p>
<p>â¢</p>
<p>Interface seamlessly with the TimeMachine tool suite, the MULTI Editor, the</p>
<p>MULTI Builder, the Eclipse environment, and with third-party editors and</p>
<p>compilers.</p>
<p>â¢</p>
<p>Perform multiprocess debugging through a single JTAG connection, even when</p>
<p>those processes are running on multiple processors.</p>
<p>â¢</p>
<p>Perform non-intrusive field debugging of live systems.</p>
<p><b>Building Your Code for Debugging</b></p>
<p>To make the most of the MULTI Debugger, you should enable generation of</p>
<p>debugging information before compiling your code. See the<i> MULTI: Building</i></p>
<p><i>Applications</i> book for information about how to generate debugging information.</p>
<p>Profiling and run-time error checking are advanced Debugger features that are also</p>
<p>enabled via the compiler. See the<i> MULTI: Building Applications</i> book for</p>
<p>information about enabling run-time error checking and obtaining profiling</p>
<p>information.</p>
<p><b>Starting the MULTI Debugger</b></p>
<p>You can open the MULTI Debugger from within the MULTI IDE or from the</p>
<p>command line. The sections below provide brief instructions about how to start the</p>
<p>Debugger. For instructions about starting MULTI, see the<i> MULTI: Getting Started</i></p>
<p>book.</p>
<p><i>5</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Building Your Code for Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Starting the Debugger in GUI Mode</b></p>
<p>To start the MULTI Debugger in GUI mode, do one of the following:</p>
<p>â¢</p>
<p>From the MULTI Launcher, click the<b> Debug</b> button (</p>
<p>) and select an</p>
<p>executable from the drop-down list of recently accessed programs. If the</p>
<p>executable you want to debug does not appear on the list, click<b> Open Debugger</b>,</p>
<p>navigate to the file in the chooser that appears, and click<b> Debug</b>. Performing</p>
<p>either of these procedures repeatedly adds the specified executables to the open</p>
<p>Debugger window.</p>
<p>â¢</p>
<p>From the MULTI Project Manager, select a compiled program and click the</p>
<p><b>Debug</b> button (</p>
<p>). If the<b> Debug</b> button appears dimmed, you have not selected</p>
<p>a compiled application. Performing this procedure repeatedly adds the specified</p>
<p>executables to the open Debugger window.</p>
<p>â¢</p>
<p>From the command line of your host system, start MULTI:</p>
<p>â</p>
<p>On a compiled program. For example, enter the command:</p>
<p>multi [<i>options</i>...]<i> program</i></p>
<p>For information about compiling a program for debugging, see the</p>
<p>documentation about enabling debugging features in the<i> MULTI: Building</i></p>
<p><i>Applications</i> book.</p>
<p>â</p>
<p>By attaching MULTI to a target on which the target operating system is</p>
<p>already running. For example, enter the command:</p>
<p>multi [<i>options</i>...] -connect=&quot;rtserv2 myboard&quot;</p>
<p>to connect via<b> rtserv2</b> to an operating system running on</p>
<p>myboard</p>
<p>. For</p>
<p>more information, see Chapter 25, âRun-Mode Debuggingâ on page 577.</p>
<p>â</p>
<p>On a trace session file. For example, enter the command:</p>
<p>multi [<i>options</i>...]<i> trace_session</i>.trs</p>
<p>For information about trace session files, see âSaving and Loading a Trace</p>
<p>Sessionâ on page 448</p>
<p>where</p>
<p><i>options</i></p>
<p>is any non-conflicting combination of command line options.</p>
<p>The most common options are listed in the following table. For a full list, see</p>
<p>Appendix C, âCommand Line Referenceâ on page 721.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>6</i></p>
<p><i>Chapter 1. Introduction</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>-connect[=<i>target</i> | =<i>connection_method_name</i>]</b></p>
<p>Connects to the target debug server specified by</p>
<p><i>target</i></p>
<p>; connects using the specified</p>
<p>Connection Method; or, if neither a target nor a Connection Method is specified, opens</p>
<p>the<b> Connection Chooser</b>.</p>
<p>For more information about connecting to targets, see Chapter 3, âConnecting to Your</p>
<p>Targetâ on page 39. For information about the<b> connect</b> command, which corresponds to</p>
<p>this option, see âGeneral Target Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b>: The Debugger ignores the deprecated</p>
<p>mode</p>
<p>argument in Connection Methods that</p>
<p>specify it. To remove the</p>
<p>mode</p>
<p>argument from a MULTI 4 Connection Method, edit and</p>
<p>save the Connection Method in MULTI 6. For more information, see the<b> connect</b> command</p>
<p>in âGeneral Target Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>-display<i> disp</b></i></p>
<p><b>Linux/Solaris only</b></p>
<p>Specifies that the Debugger will open in the alternative display</p>
<p><i>disp</i></p>
<p>.</p>
<p><b>-h</b></p>
<p>Displays a concise description of all command line options.</p>
<p><b>-H</b></p>
<p><b>-help</b></p>
<p>Opens the MULTI Help Viewer on the<i> MULTI: Debugging</i> book.</p>
<p><b>-norc</b></p>
<p>Causes MULTI to ignore all<b> .rc</b> script files upon startup except for those specified with</p>
<p><b>-rc</b>. For information about the<b> -rc</b> option, see Appendix C, âCommand Line Referenceâ</p>
<p>on page 721.</p>
<p>For more information, see âUsing Script Filesâ in Chapter 7, âConfiguring and Customizing</p>
<p>MULTIâ in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>-p<i> file</b></i></p>
<p>Runs the commands in the playback file</p>
<p><i>file</i></p>
<p>on startup.</p>
<p>For more information, see âRecord and Playback Commandsâ in Chapter 15, âScripting</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Each time you start MULTI from the command line, a new Debugger window</p>
<p>opens.</p>
<p>For a description of the main features of the Debugger window, see Chapter 2, âThe</p>
<p>Main Debugger Windowâ on page 11.</p>
<p><i>7</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Starting the Debugger in GUI Mode</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>If you load an executable whose debug information files are out of date</p>
<p>(that is, the executable is newer than the debug information), the</p>
<p><b>Translate debug information?</b> dialog box appears. The executable may</p>
<p>be newer than the debug information if, for example, you customarily</p>
<p>build your program and then move it to a new location, but at some point</p>
<p>forget to move the debug information files along with the executable. If</p>
<p>you know why the debug information files are out of date, try to remedy</p>
<p>the problem and then click<b> Check Again</b>. The dialog box closes if the</p>
<p>executable has an older timestamp than the debug information files. If</p>
<p>you do not know the reason for the out-of-sync files, you can click</p>
<p><b>Translate</b> to extract debug information from the executable. If the</p>
<p>executable was built with DWARF or Stabs information, a reasonable</p>
<p>amount of debug information is extracted. However, if the executable</p>
<p>was built without DWARF of Stabs information, debug information inside</p>
<p>the executable is limited. In the latter case, MULTI will be able to open</p>
<p>the executable, but source-level debugging will not be available.</p>
<p><b>Starting the Debugger in Non-GUI Mode (Linux/Solaris only)</b></p>
<p>On certain versions of Linux/Solaris, you can run the MULTI Debugger in a</p>
<p>non-GUI mode. Non-GUI mode does not support all of the features of the GUI</p>
<p>mode and may not be sufficient for debugging some target systems.</p>
<p>To run the Debugger in non-GUI mode, start MULTI from the command line and</p>
<p>use the<b> -nodisplay</b> option, as follows:</p>
<p>multi -nodisplay<i> program</i></p>
<p>For information about compiling a program for debugging, see the documentation</p>
<p>about enabling debugging features in the<i> MULTI: Building Applications</i> book.</p>
<p><b>Tip</b></p>
<p>If you want to script Debugger actions without bringing up a GUI, you</p>
<p>may want to use the<b> -run</b> command line option. See Appendix C,</p>
<p>âCommand Line Referenceâ on page 721.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>8</i></p>
<p><i>Chapter 1. Introduction</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Next Steps</b></p>
<p>The next chapter contains a detailed description of the main Debugger window and</p>
<p>a summary of the key features that can be accessed from it.</p>
<p>While you can open a Debugger window and view your program code without</p>
<p>connecting to your target, you will be unable to perform certain MULTI Debugger</p>
<p>operations until you have connected MULTI to a target. These operations include</p>
<p>viewing memory or registers and setting certain types of hardware breakpoints. For</p>
<p>instructions about connecting MULTI to a target, see Chapter 3, âConnecting to</p>
<p>Your Targetâ on page 39 and Chapter 6, âConfiguring Your Target Hardwareâ</p>
<p>on page 89. After you have established a connection, see Chapter 7, âPreparing</p>
<p>Your Targetâ on page 103 for information about running a program on your target.</p>
<p><i>9</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Next Steps</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 2</b></p>
<p><b>The Main Debugger Window</b></p>
<p><b>Contents</b></p>
<p>Debugger Window Components . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>12</p>
<p>Setting Up Your Debugging Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>14</p>
<p>The Target List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>15</p>
<p>The Source Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>21</p>
<p>The Navigation Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>25</p>
<p>The Cmd, Trg, I/O, Srl, Py, and Tfc Panes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>26</p>
<p>The Status Bar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>36</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes the main Debugger window, which opens when you first</p>
<p>start the MULTI Debugger. For instructions about starting the Debugger, see</p>
<p>âStarting the MULTI Debuggerâ on page 5.</p>
<p><b>Debugger Window Components</b></p>
<p>The following graphic displays the main Debugger window. The topmost pane</p>
<p>displays all items available for debugging and shows how these items are related.</p>
<p>The middle pane displays source code for the item you are debugging. The bottom</p>
<p>pane functions as a command prompt by default, but also allows you to view other</p>
<p>panes.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>12</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The major components of the Debugger window are described below.</p>
<p>â¢</p>
<p><i>Title bar</i> â Displays the name of the executable being debugged. In this</p>
<p>example, the executable name is<b> basic_dbg</b>.</p>
<p>â¢</p>
<p><i>Menu bar</i> â Contains drop-down menus with the Debugger's most commonly</p>
<p>used features. Specific menu options are documented throughout Parts I, II,</p>
<p>and III of this manual, in the context of the tools or actions they are associated</p>
<p>with. For a comprehensive description of Debugger menus and menu choices</p>
<p>arranged by menu, see âDebugger Window Menusâ on page 660. For information</p>
<p>about how to customize menus, see âConfiguring and Customizing Menusâ in</p>
<p>Chapter 7, âConfiguring and Customizing MULTIâ in the<i> MULTI: Managing</i></p>
<p><i>Projects and Configuring the IDE</i> book.</p>
<p>â¢</p>
<p><i>Toolbar</i> â Contains buttons with the Debugger's most commonly used features.</p>
<p>Positioning your mouse pointer over a button displays the button's function.</p>
<p>For a full description of each default button and its command equivalent, see</p>
<p>âThe Debugger Window Toolbarâ on page 691. For instructions about how to</p>
<p>add or remove buttons from the toolbar or customize buttons, see âConfiguring</p>
<p>the Debugger Toolbarâ on page 698.</p>
<p>â¢</p>
<p><i>Target list</i> â Displays items that are currently available for debugging and</p>
<p>shows the relationships among these items. For more information, see âThe</p>
<p>Target Listâ on page 15.</p>
<p>â¢</p>
<p><i>Source pane</i> â Displays the source code of your program. For more</p>
<p>information, see âThe Source Paneâ on page 21. From the source pane, you</p>
<p>can also open special windows to view variables, registers, target memory, the</p>
<p>call stack, and other process and debugging information. For more information,</p>
<p>see âViewing Program and Target Informationâ on page 168.</p>
<p>â¢</p>
<p><i>Navigation bar</i> â Contains buttons and tools for changing the display mode</p>
<p>of the source pane, browsing through the files and procedures of the program</p>
<p>you are debugging, and jumping to previous or subsequent source pane views.</p>
<p>For more information about these tools, see âThe Navigation Barâ on page 25.</p>
<p>â¢</p>
<p><i>Command</i>,<i> Target</i>,<i> I/O</i>,<i> Serial Terminal</i>,<i> Python</i>, and<i> Traffic</i> panes â Functions</p>
<p>as the command pane by default. The command pane accepts Debugger</p>
<p>commands and displays the output of debugging activity. You can use the tabs</p>
<p>beneath the pane to display a target pane, I/O pane, serial terminal pane, Python</p>
<p>pane, or traffic pane instead of the command pane. For more information about</p>
<p>each pane and how to switch among them, see âThe Cmd, Trg, I/O, Srl, Py,</p>
<p>and Tfc Panesâ on page 26.</p>
<p><i>13</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Debugger Window Components</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><i>Status Bar</i> â Displays process status and various informational messages. For</p>
<p>more information, see âThe Status Barâ on page 36.</p>
<p><b>Setting Up Your Debugging Environment</b></p>
<p>When you are debugging, you can reuse the Debugger window and certain other</p>
<p>windows or you can open new windows and debug different executables side by</p>
<p>side. The following sections describe how to set up each of these debugging</p>
<p>environments.</p>
<p><b>Reusing the Debugger Window</b></p>
<p>MULTI allows you to debug multiple items using one Debugger window. To debug</p>
<p>a different executable in the current Debugger window, simply single-click the</p>
<p>executable in the target list. The code for that executable appears in the source pane.</p>
<p>Additionally, certain windows automatically update to display information relevant</p>
<p>to the new executable. MULTI's ability to remember this information as you switch</p>
<p>between executables reduces the number of windows required for debugging,</p>
<p>especially when you are debugging multi-core or multi-threaded systems.</p>
<p>MULTI reuses the following windows:</p>
<p>â¢</p>
<p><b>Call Stack</b> window</p>
<p>â¢</p>
<p><b>Breakpoints</b> window</p>
<p>â¢</p>
<p><b>Memory View</b> window</p>
<p>â¢</p>
<p><b>Register View</b> window</p>
<p>â¢</p>
<p><b>Data Explorer</b></p>
<p>â¢</p>
<p><b>Note Browser</b></p>
<p><b>Opening Multiple Debugger Windows</b></p>
<p>The ability to open multiple Debugger windows is useful when you want to debug</p>
<p>different executables side by side. To open a new Debugger window on an</p>
<p>executable, perform one of the following actions in the target list:</p>
<p>â¢</p>
<p>Double-click the executable.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>14</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Right-click the executable and select<b> Open in New Window</b> from the shortcut</p>
<p>menu that appears.</p>
<p><b>Note</b></p>
<p>It is not possible to debug the same process in two windows.</p>
<p>If you open multiple Debugger windows, the background colors are different to</p>
<p>help you distinguish among the windows. In the target list located in the original</p>
<p>Debugger window, the names of executables that are open in another Debugger</p>
<p>window are highlighted in the same color as the corresponding Debugger window.</p>
<p>The target list does not appear in secondary Debugger windows.</p>
<p>The original Debugger window functions as a control window; when it is closed,</p>
<p>any secondary Debugger windows that were launched from it are also closed.</p>
<p><b>The Target List</b></p>
<p>The target list displays all the items that are currently available for debugging. It</p>
<p>may also list items that are not available for debugging (you cannot attach to any</p>
<p>items that appear dimmed). The following sections provide information about</p>
<p>repositioning the target list and about target list entries and terminology.</p>
<p><b>Note</b></p>
<p>For the following sections, the term<i> executable</i> is used to mean any</p>
<p>executable; thread; or INTEGRITY application, module, or kernel that</p>
<p>you can select for debugging.</p>
<p><b>Repositioning and Hiding the Target List</b></p>
<p>The first time you open the Debugger, the target list is located at the top of the</p>
<p>window, above the source pane. If the target list takes up a lot of screen real estate</p>
<p>(often the case when it contains many target list entries), you may want to move it</p>
<p>to the left side of the Debugger window. To do so, click the<b> Move target list to</b></p>
<p><b>left</b> button (</p>
<p>), which is located to the right of the<b> Status</b> column. To move it back</p>
<p>to the top of the window, click the<b> Move target list to top</b> button (</p>
<p>). MULTI</p>
<p>remembers the location of the target list across sessions.</p>
<p><i>15</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Target List</i></p>
<h1 style="page-break-before:always; "></h1>
<p>When you change the target list location, MULTI attempts to preserve the width of</p>
<p>the source pane by resizing the window. If the source pane area is too small, MULTI</p>
<p>does not change the window size.</p>
<p><b>Tip</b></p>
<p>As an alternative to moving the target list, you can maximize the target</p>
<p>list area and then debug every executable in a separate window. To</p>
<p>maximize the target list area, click the<b> Move splitter down</b> button (</p>
<p>)</p>
<p>or the<b> Move splitter right</b> button (</p>
<p>) (depending on the position of the</p>
<p>target list). For information about debugging executables in separate</p>
<p>windows, see âOpening Multiple Debugger Windowsâ on page 14.</p>
<p>By default, the target list is auto-sized when it occupies the top pane of the Debugger</p>
<p>window, but you can also size it manually. To do so, drag the splitter that separates</p>
<p>the target list from the source pane. To revert to the default auto-sizing behavior,</p>
<p>click the<b> Auto-size splitter</b> button (</p>
<p>), which is located to the right of the<b> Status</b></p>
<p>column.</p>
<p>To hide the target list completely, click the<b> Move splitter up</b> button (</p>
<p>) or the</p>
<p><b>Move splitter left</b> button (</p>
<p>) (depending on the position of the target list), or drag</p>
<p>the splitter.</p>
<p><b>Debugging Target List Items</b></p>
<p>The content of the source pane varies depending on the item you select in the target</p>
<p>list. The following list describes what appears in the source pane when you select</p>
<p>a particular item in the target list.</p>
<p>â¢</p>
<p>An executable â The executable's source code appears in the source pane.</p>
<p>â¢</p>
<p>An OSA AddressSpace â The source pane is empty. OSA AddressSpaces are</p>
<p>located under CPU nodes, and their names begin with<b> OSA</b>.</p>
<p>â¢</p>
<p>An OSA master process â The kernel's source code appears in the source</p>
<p>pane. The master process is listed under the CPU node of a freeze-mode</p>
<p>connection. For more information, see âMaster Debugger Modeâ on page 614.</p>
<p>â¢</p>
<p>An OSA task â The task's source code appears in the source pane. OSA tasks</p>
<p>are located under OSA AddressSpaces (AddressSpaces whose names begin</p>
<p>with<b> OSA</b>). MULTI refreshes OSA tasks in the target list when the<b> OSA</b></p>
<p><b>Explorer</b> is refreshed or when trace data is retrieved. If you have frozen or</p>
<p><i>MULTI: Debugging</i></p>
<p><i>16</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>closed the<b> OSA Explorer</b> and disabled the retrieval of trace data, MULTI does</p>
<p>not refresh OSA tasks when the target halts. For more information, see</p>
<p>âDebugging in Freeze Modeâ on page 613 and âTask Debugger Modeâ</p>
<p>on page 615.</p>
<p>â¢</p>
<p>A run-mode AddressSpace â If you are using INTEGRITY version 10 or later,</p>
<p>the AddressSpace's source code appears in the source pane. Otherwise, the</p>
<p>source pane is empty. Run-mode AddressSpaces are located under a CPU node</p>
<p>of a run-mode connection to the target, or they are located under an application</p>
<p>(kernel image or dynamically downloaded module), which is in turn located</p>
<p>under a CPU node. A run-mode connection to a target is usually denoted by</p>
<p><b>Run mode target</b>. For more information, see âRun-Mode AddressSpacesâ</p>
<p>on page 581.</p>
<p>â¢</p>
<p>A run-mode task â The task's source code appears in the source pane.</p>
<p>Run-mode tasks are located under run-mode AddressSpaces. For information</p>
<p>about run-mode debugging, see Chapter 25, âRun-Mode Debuggingâ</p>
<p>on page 577.</p>
<p>â¢</p>
<p>A program or task in TimeMachine mode â The program's or task's source</p>
<p>code appears in the source pane. The<b> Status</b> column indicates target list entries</p>
<p>for which TimeMachine is enabled. For information about debugging in</p>
<p>TimeMachine mode, see âThe TimeMachine Debuggerâ on page 413.</p>
<p>Any commands you give via menu selections, buttons, or the command pane are</p>
<p>performed on the item that is selected in the target list (if applicable).</p>
<p>For information about how the above items are arranged in the target list, see the</p>
<p>next section.</p>
<p><b>The Target List Display</b></p>
<p>Related executables, CPUs, and debug servers are arranged hierarchically on several</p>
<p>lines or compressed onto one line. Both views illustrate the relationships among</p>
<p>items. Which items appear and the style of grouping is dependent upon your current</p>
<p>environment. The two views available are described below:</p>
<p>â¢</p>
<p>Compressed â The Debugger compresses all related items onto a single line</p>
<p>when the resulting line contains only one of each item. For example, suppose</p>
<p>you are connected to a PowerPC 860 CPU that is running a kernel. The debug</p>
<p>server, CPU, and kernel are all compressed onto one line, as shown next.</p>
<p><i>17</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Debugging Target List Items</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Hierarchical â The Debugger arranges related items as a hierarchy when the</p>
<p>resulting hierarchy contains multiple occurrences of any item. For example, if</p>
<p>a kernel contains multiple tasks, the items are arranged as shown next.</p>
<p>In both compressed and hierarchical view mode, you can change the display by</p>
<p>expanding or collapsing nodes. If you collapse a node that encompasses multiple</p>
<p>items of the same type (for example, a CPU that contains multiple applications),</p>
<p>the source pane is generally empty and the target list does not display status or CPU</p>
<p>information for the parent object. Displaying a single status for the parent object</p>
<p>would be ambiguous in this case because multiple child objects, each of which have</p>
<p>a valid status, are encompassed by the parent object.</p>
<p>As the previous samples illustrate, executables appear after the CPU that they are</p>
<p>associated with. The CPU in turn appears after the appropriate debug server.</p>
<p><b>Target Terminology</b></p>
<p>The following list defines the phrases that are used in the<b> Target</b> section of the</p>
<p>target list.</p>
<p>â¢</p>
<p><b>Direct hardware access</b> â Appears under a CPU name in the target list when</p>
<p>you are not actively debugging an executable on that CPU. For information</p>
<p>about preparing to debug an executable on your target, see Chapter 7, âPreparing</p>
<p>Your Targetâ on page 103.</p>
<p>â¢</p>
<p><b>Unconnected Executables</b> â The executables that appear under this heading</p>
<p>are not associated with a connection. For more information, see âAssociating</p>
<p>Your Executable with a Connectionâ on page 105.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>18</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Status Column</b></p>
<p>The Debugger lists the statuses of certain items in the target list's<b> Status</b> column</p>
<p>and automatically updates these statuses when appropriate. The following table</p>
<p>defines common statuses. Not all statuses are supported by all operating systems.</p>
<p><b>Meaning</b></p>
<p><b>Status</b></p>
<p>The task has been stopped due to a MULTI breakpoint or</p>
<p>single-stepping.</p>
<p><b>DebugBrk</b></p>
<p>The process has just performed an</p>
<p>exec()</p>
<p>callâa kernel call via</p>
<p>a software interrupt.</p>
<p><b>Execing</b></p>
<p>The task has exited (usually by calling</p>
<p>exit()</p>
<p>).</p>
<p><b>Exited</b></p>
<p>The task, which is part of a task group, has been halted by a group</p>
<p>breakpoint. For more information see, âGroup Breakpointsâ</p>
<p>on page 588.</p>
<p><b>GrpHalt</b></p>
<p>The run-mode task has been halted by the operating system.</p>
<p><b>Halted</b></p>
<p>The task is writing to or reading from a file on the host system or</p>
<p>the<b> I/O</b> pane. This status may also signify that the target process</p>
<p>is waiting for input from</p>
<p>stdin</p>
<p>. In this case, select the process in</p>
<p>the target list, click in the<b> I/O</b> pane, and type the input you want</p>
<p>the process to receive.</p>
<p><b>HostIO</b></p>
<p>Trace data was not saved for the loaded task.</p>
<p><b>No TimeMachine Data</b></p>
<p>The executable has not been downloaded or flashed onto a target</p>
<p>or is not currently running on the target system. For information</p>
<p>about loading the executable on a target, see âPreparing Your</p>
<p>Targetâ on page 108.</p>
<p><b>Not loaded</b></p>
<p>The exact meaning is OS-specific. In general, this status signifies</p>
<p>that the run-mode task is waiting for something to happen, such</p>
<p>as the release of a semaphore or message on a socket.</p>
<p><b>Pended</b></p>
<p>The task is running.</p>
<p><b>Running</b></p>
<p>TimeMachine mode is enabled. For information about</p>
<p>TimeMachine, see âThe TimeMachine Debuggerâ on page 413.</p>
<p><i><b>status</i>(TimeMachine)</b></p>
<p>The task is stopped.</p>
<p><b>Stopped</b></p>
<p>All tasks on the target system are halted, and the target is frozen.</p>
<p><b>SysHalt</b></p>
<p>The task has exited (usually by calling</p>
<p>exit()</p>
<p>), but data structures</p>
<p>describing the task still exist on the target.</p>
<p><b>Zombied</b></p>
<p><i>19</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Status Column</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The CPU % Column</b></p>
<p>In specific debugging environments, a<b> CPU %</b> column appears in the Debugger</p>
<p>window's target list. It displays the percentage of the CPU that each task and</p>
<p>AddressSpace is currently using. For more information, see âProfiling All Tasks</p>
<p>in Your Systemâ on page 603.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>20</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Source Pane</b></p>
<p>The source pane displays the source code of your program. Your program's source</p>
<p>code can be in C, C++, or assembly language.</p>
<p>The main features of the source pane are described below.</p>
<p>â¢</p>
<p><i>Source pane display modes</i> â The source pane can display your program code</p>
<p>in high-level language, mixed high-level and assembly language, or assembly</p>
<p>language. You can use the Display Mode Selector in the navigation bar or the</p>
<p><b>View</b> â<b> Display Mode</b> menu option to switch among these display modes.</p>
<p>For more information, see âSource Pane Display Modesâ on page 23.</p>
<p>â¢</p>
<p><i>Line numbers</i> â By default, file-relative line numbers appear in the left-most</p>
<p>column of the source pane, and procedure-relative line numbers appear to the</p>
<p><i>21</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Source Pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p>right of the file-relative numbers. You can configure the Debugger to display</p>
<p>either, both, or neither of the columns or to display the columns in opposite</p>
<p>orientation. See âSource Pane Line Numbersâ on page 24.</p>
<p>â¢</p>
<p><i>Breakdots</i> â A breakdot (</p>
<p>) is a small dot located to the left of any line of</p>
<p>code that corresponds to an executable instruction. You can set a software</p>
<p>breakpoint simply by clicking a breakdot. You can also use breakdots to set</p>
<p>hardware breakpoints or tracepoints, if your target supports them. For more</p>
<p>information, see âBreakdots, Breakpoint Markers, and Tracepoint Markersâ</p>
<p>on page 125.</p>
<p>â¢</p>
<p><i>Breakpoint markers</i> â A breakpoint marker is an icon that appears in place</p>
<p>of a breakdot when you set a breakpoint. Hardware breakpoints are indicated</p>
<p>by a small purple cube (</p>
<p>). Software breakpoints are indicated by a small red</p>
<p>stop sign (</p>
<p>). The stop sign may contain a symbol indicating that certain</p>
<p>conditions are associated with the breakpoint. If a breakpoint is disabled, the</p>
<p>breakpoint marker is gray. For more details, see âBreakdots, Breakpoint</p>
<p>Markers, and Tracepoint Markersâ on page 125.</p>
<p>â¢</p>
<p><i>Debugger Notes</i> â Debugger Notes are free form notes that can be associated</p>
<p>with any line of code. The line number column(s) of lines associated with</p>
<p>Debugger Notes are shaded gray. For more information, see Chapter 10, âUsing</p>
<p>Debugger Notesâ on page 173.</p>
<p>â¢</p>
<p><i>Current line pointer</i> â The blue current line pointer (</p>
<p>) jumps to any line</p>
<p>you type in the command pane, select with a mouse click, or navigate to with</p>
<p>commands. If you run or step a process, the pointer jumps to the location where</p>
<p>the process halts. Many Debugger commands operate at the line pointer location</p>
<p>if no other location is specified.</p>
<p>When you open a program, the line pointer is located at the entry point. If you</p>
<p>stop a running process, the line pointer jumps to the code where the process</p>
<p>has stopped. You can also navigate to other locations easily. For more</p>
<p>information about how to navigate to different locations, see Chapter 9,</p>
<p>âNavigating Windows and Viewing Informationâ on page 155.</p>
<p>â¢</p>
<p><i>Program counter (PC) pointer</i> â The program counter (PC) pointer is a red</p>
<p>arrow marked with the word<b> STOPPED</b> (</p>
<p>). When a process stops, the PC</p>
<p>pointer identifies the line that will execute next when you resume the process.</p>
<p>When the Debugger stops on a conditionally not-executed instruction, or when</p>
<p>the PC is not in the selected image, the PC pointer turns gray (</p>
<p>). When you</p>
<p>step backward in the Debugger or launch TimeMachine, the PC pointer turns</p>
<p><i>MULTI: Debugging</i></p>
<p><i>22</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>blue (</p>
<p>). When you move up or down the call stack, the PC pointer becomes</p>
<p>a hollow arrow outlined in red (</p>
<p>).</p>
<p>â¢</p>
<p><i>Shortcut menus</i> â Shortcut menus are available when you right-click a source</p>
<p>line, a breakpoint, a procedure, a variable, a type, or a member of a type. See</p>
<p>âSource Pane Shortcut Menusâ on page 704 for more specific information about</p>
<p>these menus.</p>
<p><b>Note</b></p>
<p>You can open other windows to view details about certain program</p>
<p>elements, such as variables, by double-clicking them in the source pane.</p>
<p>For more information, see âViewing Program and Target Informationâ</p>
<p>on page 168.</p>
<p><b>Source Pane Display Modes</b></p>
<p>The Debugger source pane has three modes for code display:</p>
<p>â¢</p>
<p>Source only â Displays only high-level source code. This is the default display</p>
<p>mode.</p>
<p>â¢</p>
<p>Interlaced assembly â Displays high-level source code interlaced with the</p>
<p>corresponding machine instructions.</p>
<p>â¢</p>
<p>Assembly only â Displays only assembly code.</p>
<p>You can change the source pane display mode in any of the following ways:</p>
<p>â¢</p>
<p>From the Display Mode Selector's drop-down menu, select<b> Source</b>,<b> Mixed</b>, or</p>
<p><b>Assem</b>. The Display Mode Selector (</p>
<p>) appears on the navigation bar.</p>
<p>â¢</p>
<p>Press the<b> Assembly</b> button (</p>
<p>) located on the toolbar to toggle between</p>
<p>source-only mode and interlaced assembly mode.</p>
<p>â¢</p>
<p>From the<b> View</b> â<b> Display Mode</b> menu, select<b> Source Only</b>,<b> Interlaced</b></p>
<p><b>Assembly</b>, or<b> Assembly Only</b>.</p>
<p>â¢</p>
<p>Use the<b> assem</b> Debugger command. For information about this command, see</p>
<p>Chapter 8, âDisplay and Print Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><i>23</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Source Pane Display Modes</i></p>
<h1 style="page-break-before:always; "></h1>
<p>When assembly code is displayed (interlaced assembly or assembly-only mode),</p>
<p>the hexadecimal address of each machine instruction appears in the source pane.</p>
<p>When the process stops at a line in the high-level source code, the PC pointer (</p>
<p>)</p>
<p>appears at the first machine instruction associated with that high-level source line.</p>
<p>Note that not all high-level source lines generate executable code.</p>
<p>If no high-level source code is available to the Debugger, or if the module was not</p>
<p>compiled with sufficient debugging information, the Debugger only displays</p>
<p>assembly code, regardless of the display mode setting. See the<i> MULTI: Building</i></p>
<p><i>Applications</i> book for information about how to generate debugging information.</p>
<p><b>Source Pane Line Numbers</b></p>
<p>The Debugger supports both procedure-relative and file-relative line numbers. You</p>
<p>can configure the Debugger source pane to display either, both, or neither of these</p>
<p>line numbers. To configure the appearance of procedure-relative and file-relative</p>
<p>line numbers, select<b> Config</b> â<b> Options</b> â<b> Debugger</b> tab. From the<b> Line numbers</b></p>
<p><b>in source pane</b> text box, choose<b> No Number</b>,<b> File Number</b>,<b> Proc Number</b>, or</p>
<p><b>Both Numbers</b>.</p>
<p>When both file-relative and procedure-relative line numbers are displayed, they</p>
<p>appear as two separate columns on the left side of the source pane. By default,</p>
<p>file-relative line numbers appear in the left-most column, and procedure-relative</p>
<p>line numbers appear to the right of the file-relative numbers and to the left of the</p>
<p>breakdots. You can change the orientation of the column display with one of the</p>
<p>following methods:</p>
<p>â¢</p>
<p>Select<b> Config</b> â<b> Options</b> â<b> Debugger</b> tab. If you check the<b> Use procedure</b></p>
<p><b>relative line numbers (vs. file relative)</b> box, file-relative numbers appear in</p>
<p>the left column and procedure-relative numbers in the right column. This is the</p>
<p>default setting. If you clear this check box, file-relative numbers appear in the</p>
<p>right column and procedure-relative numbers in the left column. This option</p>
<p>also affects how line numbers in Debugger commands are interpreted. See</p>
<p>âSpecifying Line Numbersâ in Chapter 1, âUsing Debugger Commandsâ in</p>
<p>the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>Use the<b> configure</b> command to set the option<b> ProcRelativeLines</b> to</p>
<p>on</p>
<p>or</p>
<p>off</p>
<p>(for more information, see âUsing the configure Commandâ in Chapter 7,</p>
<p>âConfiguring and Customizing MULTIâ in the<i> MULTI: Managing Projects</i></p>
<p><i>and Configuring the IDE</i> book).</p>
<p><i>MULTI: Debugging</i></p>
<p><i>24</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For example:</p>
<p>&gt; configure ProcRelativeLines on</p>
<p>Setting this option to</p>
<p>on</p>
<p>causes file-relative numbers to appear in the left column</p>
<p>and procedure-relative numbers to appear in the right column. This is the default</p>
<p>setting. Setting this option to</p>
<p>off</p>
<p>causes file-relative numbers to appear in the</p>
<p>right column and procedure-relative numbers to appear in the left column. This</p>
<p>option also affects how line numbers in Debugger commands are interpreted.</p>
<p>See âSpecifying Line Numbersâ in Chapter 1, âUsing Debugger Commandsâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>The Navigation Bar</b></p>
<p>With the navigation bar, you can change the display mode of the source pane; browse</p>
<p>through the output, files, and procedures of the program you are debugging; and</p>
<p>jump to previous or subsequent source pane views. The navigation bar is located</p>
<p>below the source pane and above the command pane in the Debugger window.</p>
<p>The navigation bar contains the following buttons and tools.</p>
<p>â¢</p>
<p>Display Mode Selector (</p>
<p>) â Changes the source pane's display mode</p>
<p>to source only (<b>Source</b>), interlaced assembly (<b>Mixed</b>), or assembly only</p>
<p>(<b>Assem</b>). For more information, see âSource Pane Display Modesâ on page 23.</p>
<p>â¢</p>
<p>File Locator (</p>
<p>) â Shows the name of the file currently</p>
<p>displayed in the Debugger and allows you to quickly navigate to other files in</p>
<p>your program. For a full description of how to use this tool, see âUsing the File</p>
<p>Locatorâ on page 164.</p>
<p>â¢</p>
<p>Procedure Locator (</p>
<p>) â Shows the name of the procedure currently</p>
<p>displayed in the Debugger and allows you to quickly navigate to other</p>
<p>procedures in your program. For a full description of how to use this tool, see</p>
<p>âUsing the Procedure Locatorâ on page 165.</p>
<p>â¢</p>
<p><b>Back</b> (</p>
<p>) and<b> Forward</b> (</p>
<p>) buttons â Allow you to jump to files and</p>
<p>procedures you have viewed before or after the current view. For more</p>
<p>information, see âUsing Navigation History Buttonsâ on page 167.</p>
<p><i>25</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Navigation Bar</i></p>
<h1 style="page-break-before:always; "></h1>
<p>You can change the relative sizes of the source pane and the command pane by</p>
<p>dragging the navigation bar up or down.</p>
<p><b>Note</b></p>
<p>The pane-switching buttons that appeared on the navigation bar in</p>
<p>previous releases and that allowed you to switch between the command,</p>
<p>target, and I/O panes have been replaced by tabs under the command</p>
<p>pane. For more detailed information, see the next section.</p>
<p><b>The Cmd, Trg, I/O, Srl, Py, and Tfc Panes</b></p>
<p>The pane located below the navigation bar in the Debugger window functions as</p>
<p>the command pane by default. But it can also display a target pane, I/O pane, serial</p>
<p>terminal pane, Python pane, or traffic pane. The availability of individual panes</p>
<p>depends upon the current environment.</p>
<p>To change which pane is displayed in this area, click the appropriate tab located in</p>
<p>the lower-left corner of the pane. The following table describes each tab and pane.</p>
<p><b>Description</b></p>
<p><b>Pane</b></p>
<p><b>Tab</b></p>
<p>Allows you to enter Debugger commands and view the output</p>
<p>of debugging activity. This is the default pane.</p>
<p>For more information about using the command pane, see âThe</p>
<p>Command Paneâ on page 28.</p>
<p>Command</p>
<p><b>Cmd</b></p>
<p>Allows you to send commands to your debug server. This tab</p>
<p>and pane are only available if your debug server supports this</p>
<p>feature and you are connected to a target.</p>
<p>For more information about using the target pane, see âThe</p>
<p>Target Paneâ on page 30.</p>
<p>Target</p>
<p><b>Trg</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>26</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Pane</b></p>
<p><b>Tab</b></p>
<p>Provides basic I/O for the process you are debugging. This tab</p>
<p>and pane are only available if your debug server supports this</p>
<p>feature and you are connected to a target. If input is not possible</p>
<p>for the currently selected target, the pane is labeled<b> Out</b>.</p>
<p>For more information about using the I/O pane, see âThe I/O</p>
<p>Paneâ on page 30.</p>
<p>I/O (input/output)</p>
<p><b>I/O</b></p>
<p>Allows you to send commands to a serial port and receive input</p>
<p>back from it. This tab and pane are only available if you are</p>
<p>connected to an active serial port.</p>
<p>For more information about using the serial terminal pane, see</p>
<p>âThe Serial Terminal Paneâ on page 31.</p>
<p>Serial terminal</p>
<p><b>Srl</b></p>
<p>Allows you to execute Python statements and view</p>
<p>MULTI-Python output. This pane only remembers Python</p>
<p>history for the current Debugger's debugging session.</p>
<p>For more information about using the Python pane, see âThe</p>
<p>Python Paneâ on page 32.</p>
<p>Python</p>
<p><b>Py</b></p>
<p>Provides messages detailing interactions between MULTI and</p>
<p>your target. This pane only contains meaningful messages if</p>
<p>you have connected to a target.</p>
<p>For more information about using the traffic pane, see âThe</p>
<p>Traffic Paneâ on page 33.</p>
<p>Traffic</p>
<p><b>Tfc</b></p>
<p>If a pane is not available in your current context, the tab for that pane does not</p>
<p>appear. If a tab is not selected but new output is available in the corresponding pane,</p>
<p>the tab is marked with an asterisk (*). The asterisk indicates that output is available</p>
<p>for viewing.</p>
<p><b>Tip</b></p>
<p>For information about limiting the number of scroll back lines available</p>
<p>in these panes, see the<b> CTextSize</b> option in âOther Debugger</p>
<p>Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ in the</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><i>27</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Cmd, Trg, I/O, Srl, Py, and Tfc Panes</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Command Pane</b></p>
<p>The command pane accepts Debugger commands for the process you are debugging</p>
<p>and displays the output of those commands. By default, the command pane also</p>
<p>displays color-coded output from the target, I/O, and serial terminal panes. When</p>
<p>the<b> Cmd</b> tab is selected, the command pane appears below the navigation bar in</p>
<p>the Debugger window. This is the default tab setting.</p>
<p>If the<b> Cmd</b> tab is not selected, but new output is available in the command pane,</p>
<p>the tab is marked with an asterisk (*).</p>
<p>In the Debugger window, most keystrokes you make go into the command pane,</p>
<p>unless you have clicked in the File Locator or the Procedure Locator text box. The</p>
<p>command pane automatically evaluates expressions using the syntax of the source</p>
<p>code language currently being debugged. For general information about using</p>
<p>Debugger commands and for a detailed description of the Debugger commands that</p>
<p>can be entered in the command pane, see the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Note</b></p>
<p>The default prompt in the command pane is</p>
<p>MULTI&gt;</p>
<p>. You can specify a</p>
<p>different prompt by entering the command<b> configure prompt</b></p>
<p><i><b>new_prompt</b></i> in the command pane, or by setting the<b> Command pane</b></p>
<p><b>prompt</b> configuration option. For information about the<b> configure</b></p>
<p>command, see âGeneral Configuration Commandsâ in Chapter 6,</p>
<p>âConfiguration Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book. For information about the<b> Command pane</b></p>
<p><b>prompt</b> option, see âThe Debugger Options Tabâ in Chapter 8,</p>
<p>âConfiguration Optionsâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book. For information about saving your prompt,</p>
<p>see âSaving Configuration Settingsâ in Chapter 7, âConfiguring and</p>
<p>Customizing MULTIâ in the<i> MULTI: Managing Projects and Configuring</i></p>
<p><i>the IDE</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>28</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The Debugger keeps a history of all the Debugger commands entered in the</p>
<p>command pane. You can use history commands, such as the<b> !</b> and<b> !!</b> commands, to</p>
<p>search the command history and execute previously entered commands. For more</p>
<p>information, see âHistory Commandsâ in Chapter 15, âScripting Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book. You can also</p>
<p>record and play back sequences of Debugger commands. For more information,</p>
<p>see âRecord and Playback Commandsâ in Chapter 15, âScripting Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Command Pane Shortcuts</b></p>
<p>In the Debugger window, some key combinations, such as<b> Ctrl</b>+<b>UpArrow</b>, function</p>
<p>as shortcuts that invoke actions in the command pane. The following table lists</p>
<p>common shortcuts that affect the command pane. For a comprehensive list of</p>
<p>shortcuts, see âCommand Pane Shortcutsâ on page 718.</p>
<p><b>Effect</b></p>
<p><b>Shortcut</b></p>
<p>Retrieve the previous command from the command history, moving</p>
<p>back in the list. Press repeatedly to retrieve older commands.</p>
<p><b>UpArrow</b></p>
<p>Retrieve the next command from the command history, moving</p>
<p>forward in the list. Press repeatedly to retrieve more recent commands.</p>
<p><b>DownArrow</b></p>
<p>Scroll up four lines.</p>
<p><b>Ctrl</b>+<b>UpArrow</b></p>
<p>Scroll down four lines.</p>
<p><b>Ctrl</b>+<b>DownArrow</b></p>
<p>Cuts to the beginning of the current line or the selection.</p>
<p><b>Ctrl</b>+<b>U</b></p>
<p>Accept auto-completion of the current word.</p>
<p>Tab</p>
<p>Attempt to auto-complete the current string, working backwards</p>
<p>through the command history for commands beginning with the typed</p>
<p>characters.</p>
<p><b>Ctrl</b>+<b>P</b></p>
<p>Display a list of possible completions for the current word.</p>
<p><b>Ctrl</b>+<b>D</b></p>
<p>Cycle between the available panes in the command pane area. For</p>
<p>more information, see âThe Cmd, Trg, I/O, Srl, Py, and Tfc Panesâ</p>
<p>on page 26.</p>
<p><b>F6</b></p>
<p>Open a shortcut menu. For a full description of the shortcut menu,</p>
<p>see the âThe Command Pane Shortcut Menuâ on page 712.</p>
<p>Click with the right</p>
<p>mouse button</p>
<p><i>29</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Command Pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>The procedures for copying, cutting, and pasting text in the command</p>
<p>pane differ slightly from the procedures used in other windows. For more</p>
<p>information, see âSelecting, Copying, and Pasting Text in the Main</p>
<p>Debugger Windowâ on page 161.</p>
<p>For a full list of default shortcuts, see Appendix B, âKeyboard Shortcut Referenceâ</p>
<p>on page 715. For information about reconfiguring the MULTI IDE's default shortcut</p>
<p>keys and mouse clicks, see âCustomizing Keys and Mouse Behaviorâ in Chapter</p>
<p>7, âConfiguring and Customizing MULTIâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book.</p>
<p><b>The Target Pane</b></p>
<p>The target pane allows you to send commands to your debug server. When the<b> Trg</b></p>
<p>tab is selected, the target pane appears below the navigation bar in the Debugger</p>
<p>window.</p>
<p>If the<b> Trg</b> tab is not selected, but new output is available in the target pane, the tab</p>
<p>is marked with an asterisk (*).</p>
<p>This tab and pane are only available if your debug server supports this feature and</p>
<p>you are connected to a target. For more information about debug servers, see the</p>
<p><i>MULTI: Configuring Connections</i> book for your target processor family. For</p>
<p>instructions about connecting to your target, see Chapter 3, âConnecting to Your</p>
<p>Targetâ on page 39.</p>
<p><b>The I/O Pane</b></p>
<p>The I/O pane provides basic I/O for the process you are debugging. When the<b> I/O</b></p>
<p>tab is selected, the I/O pane appears below the navigation bar in the Debugger</p>
<p>window.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>30</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If the<b> I/O</b> tab is not selected, but new output is available in the I/O pane, the tab is</p>
<p>marked with an asterisk (*). If input is not possible for the currently selected target,</p>
<p>the pane is labeled<b> Out</b>.</p>
<p>This tab and pane are only available if your debug server supports this feature and</p>
<p>you are connected to a target. For more information about debug servers, see the</p>
<p><i>MULTI: Configuring Connections</i> book for your target processor family. For</p>
<p>instructions about connecting to your target, see Chapter 3, âConnecting to Your</p>
<p>Targetâ on page 39.</p>
<p><b>The Serial Terminal Pane</b></p>
<p>The serial terminal pane allows you to send commands to a serial port and receive</p>
<p>input back from it. When the<b> Srl</b> tab is selected, the serial terminal pane appears</p>
<p>below the navigation bar in the Debugger window.</p>
<p>If the<b> Srl</b> tab is not selected, but new output is available in the serial terminal pane,</p>
<p>the tab is marked with an asterisk (*).</p>
<p>This tab and pane are only available if you are connected to an active serial port.</p>
<p>There are two ways to connect to a serial port:</p>
<p>â¢</p>
<p>Select<b> Tools</b> â<b> Serial Terminal</b>. From the submenu that appears, you can</p>
<p>open recent connections or create a new serial connection using the<b> Serial</b></p>
<p><b>Connection Chooser</b>. For more information, see âUsing the Serial Connection</p>
<p>Chooserâ on page 646.</p>
<p>â¢</p>
<p>In the Debugger command pane, issue the<b> serialconnect</b> command with</p>
<p>appropriate arguments. For information about this command, see âSerial</p>
<p><i>31</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Serial Terminal Pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Once you have established a serial connection, the serial terminal pane is available.</p>
<p>Input to this pane is sent to the serial port; output from the serial port is sent to this</p>
<p>pane.</p>
<p><b>Note</b></p>
<p>Only one serial connection exists per debugging session. If you open a</p>
<p>second Debugger window and a serial connection is already active, the</p>
<p>new window displays a<b> Srl</b> pane, but you cannot make a second,</p>
<p>simultaneous serial connection. All Debugger windows in a debugging</p>
<p>session show views of the same serial connection in their<b> Srl</b> panes. If</p>
<p>you require multiple serial connections at the same time, see Chapter 27,</p>
<p>âEstablishing Serial Connectionsâ on page 643, for alternate ways to use</p>
<p>serial connections.</p>
<p>The serial terminal pane provides partial<b> VT100</b> support.</p>
<p><b>The Python Pane</b></p>
<p>The Python pane allows you to execute Python statements and view MULTI-Python</p>
<p>output. When the<b> Py</b> tab is selected, the Python pane appears below the navigation</p>
<p>bar in the Debugger window.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>32</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If the<b> Py</b> tab is not selected, but new output is available in the Python pane, the tab</p>
<p>is marked with an asterisk (*).</p>
<p>This tab and pane are always available, but the Python pane only remembers Python</p>
<p>history for the current Debugger's debugging session. For more information about</p>
<p>this pane, see âMULTI-Python Interfacesâ in Chapter 2, âIntroduction to the</p>
<p>MULTI-Python Integrationâ in the<i> MULTI: Scripting</i> book.</p>
<p>To open the Python pane as a separate window, right-click in the Python pane area</p>
<p>and select<b> Show Separate Py Window</b> from the shortcut menu.</p>
<p><b>The Traffic Pane</b></p>
<p>The traffic pane displays messages that detail the interactions between MULTI and</p>
<p>your target. When the<b> Tfc</b> tab is selected, the traffic pane appears below the</p>
<p>navigation bar in the Debugger window.</p>
<p>If the<b> Tfc</b> tab is not selected, but new output is available in the traffic pane, the tab</p>
<p>is marked with an asterisk (*).</p>
<p>This tab and pane are always available. However, you will only see meaningful</p>
<p>messages if you have connected to a target during the current MULTI session.</p>
<p>Viewing traffic information may be useful if you see unexpected results while</p>
<p>working in MULTI or if your target crashes. You can examine traffic pane messages</p>
<p>to see what commands MULTI has issued to the target and to see how the target</p>
<p>has responded.</p>
<p>Each line of information in the traffic pane is referred to as a<i> traffic report</i>. When</p>
<p>you are debugging native processes, each traffic report begins with</p>
<p>pid</p>
<p>âfor</p>
<p>âprocess IDââfollowed by the process ID number. When you are debugging</p>
<p>INTEGRITY tasks, each traffic report begins with</p>
<p>task</p>
<p>followed by a hexadecimal</p>
<p>number. These numbers and either</p>
<p>pid</p>
<p>or</p>
<p>task</p>
<p>are always enclosed in parentheses.</p>
<p>The target gives every process a new process ID number and every task a new task</p>
<p><i>33</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Traffic Pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p>number, making it easy to tell processes and tasks apart. If the target does not know</p>
<p>the process ID or task number, or if none exists, the traffic report does not list any</p>
<p>number.</p>
<p>The traffic pane displays MULTI commands that result in target traffic, requests</p>
<p>that MULTI makes to the target, and resulting target responses or actions. The</p>
<p>following example typifies what you might see in the traffic pane.</p>
<p>Suppose you are debugging an ARM stand-alone program on a<b> simarm</b> simulator.</p>
<p>The simulator just executed the instruction</p>
<p>MOV R0, 20</p>
<p>, and you type the following</p>
<p>into MULTI's command pane.</p>
<p>MULTI&gt; print $r0</p>
<p>The following result appears.</p>
<p>0x00000014</p>
<p>If you view the traffic pane contents, you see the following.</p>
<p>MULTI command: print $r0</p>
<p>| Read register (#0) r0 as 0x14</p>
<p>As a result of you typing the<b> print</b> command, MULTI asked the target (in this case,</p>
<p><b>simarm</b>) to read register R0.</p>
<p>Most MULTI buttons and menu items correspond to MULTI commands. Therefore,</p>
<p>if you click a button or select a menu item, the traffic pane displays the command</p>
<p>associated with your action. For example, suppose you click the</p>
<p>button or press</p>
<p><b>F10</b> to single-step a Linux x86 native process. If you view the traffic pane contents,</p>
<p>you might see something like the following.</p>
<p>MULTI command: __ntwcommand next</p>
<p>\_ MULTI command: n</p>
<p>| (pid 22434) Set software breakpoint at 0x8049448 (foo.cc:main#12)</p>
<p>| (pid 22434) Resume process at 0x8049437 (foo.cc:main#11), in source step</p>
<p>| (pid 22434) Read memory block (64 bytes @ 0xbfece180)</p>
<p>| (pid 22434) Remove breakpoint from 0x8049448 (foo.cc:main#12)</p>
<p>The</p>
<p>button and the<b> F10</b> key are linked to MULTI's<b> n</b> command. As a result,</p>
<p>MULTI executes the<b> n</b> command when you click</p>
<p>or press<b> F10</b>. The<b> n</b> command</p>
<p>causes MULTI to set a temporary breakpoint at the next source line (in this case,</p>
<p>line 12 of</p>
<p>main()</p>
<p>), and then resume the process from the current source line (in</p>
<p><i>MULTI: Debugging</i></p>
<p><i>34</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>this case, line 11 of</p>
<p>main()</p>
<p>). When it reaches line 12, it removes the temporary</p>
<p>breakpoint.</p>
<p>In addition to displaying interactions between your target and MULTI, the traffic</p>
<p>pane also displays the chain of commands (if any) that causes target traffic. You</p>
<p>might not explicitly specify multiple commands; however, some MULTI commands</p>
<p>execute others as a part of their operation. For example, suppose that while a process</p>
<p>is running, you enter the<b> tog</b> command to inactivate a breakpoint. You might see</p>
<p>something like the following.</p>
<p>MULTI command: tog off main#2</p>
<p>| (pid 22807) Halt remote process (stop thread)</p>
<p>| (pid 22807) Status is StatHalted</p>
<p>| (pid 22807) Remove breakpoint from 0x80491bf (foo.cc:main#2)</p>
<p>\_ MULTI command: c</p>
<p>| (pid 22807) Resume process at 0xb7f85402</p>
<p>| (pid 22807) Status is StatRunning</p>
<p>In this case, MULTI halts the process and later executes the<b> c</b> command to continue</p>
<p>it. When one command executes another as shown, the commands appear nested</p>
<p>in the traffic pane. A backslash followed by an underscore (\_) signifies a nested</p>
<p>command. In this example, the<b> c</b> command is nested within the<b> tog</b> command. For</p>
<p>each additional nested command, the traffic pane indents the backslash-underscore</p>
<p>pair further right.</p>
<p>The traffic pane only displays messages for the current MULTI session. Within one</p>
<p>session, you can view all the messages that MULTI has printedâeven if you have</p>
<p>disconnected from your target. Scroll up to see the beginning of the message log.</p>
<p>To clear the messages, right-click in the traffic pane and select<b> Clear Pane</b> from</p>
<p>the shortcut menu.</p>
<p>For more information about the commands included in the preceding examples, see</p>
<p>the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>35</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Traffic Pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Status Bar</b></p>
<p>The Debugger window status bar is located below the command pane, to the right</p>
<p>of the pane-switching tabs.</p>
<p>The bar is divided into two areas. The box on the left displays informational</p>
<p>messages. The following table lists the most common messages and their meanings.</p>
<p><b>Meaning</b></p>
<p><b>Message</b></p>
<p>Displays the name of the program section where the PC</p>
<p>pointer is currently located.</p>
<p><b>In section:<i> section</b></i></p>
<p>Explains the function of the button or field under your mouse</p>
<p>pointer.</p>
<p>For example, if you place your mouse pointer over the</p>
<p>button on the toolbar, the message</p>
<p>Go on selected items</p>
<p>appears in the status bar.</p>
<p><i><b>item_description</b></i></p>
<p>Indicates that the incremental search utility is searching the</p>
<p>source pane for the pattern<i> string</i>. See âIncremental</p>
<p>Searchingâ on page 156.</p>
<p><b>Srch:<i> string</b></i></p>
<p>The box on the right displays process state information, such as that listed in the</p>
<p>following table.</p>
<p><b>Meaning</b></p>
<p><b>Process State Message</b></p>
<p>The program being debugged is preparing to resume</p>
<p>execution.</p>
<p>CONTINUING</p>
<p>The process being debugged is dying.</p>
<p>DYING</p>
<p>The process being debugged is performing an<b> exec</b> or is still</p>
<p>executing startup code.</p>
<p>EXEC'ING</p>
<p>The process to be debugged has not started.</p>
<p>NO PROCESS</p>
<p>The process being debugged is running.</p>
<p>RUNNING</p>
<p>The process being debugged is stopped.</p>
<p>STOPPED</p>
<p><i>MULTI: Debugging</i></p>
<p><i>36</i></p>
<p><i>Chapter 2. The Main Debugger Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Process State Message</b></p>
<p>The process being debugged is stopped at a machine</p>
<p>instruction other than the first one on the current source line.</p>
<p>STOPPED INSIDE</p>
<p>The process being debugged has exited, but data structures</p>
<p>describing it still exist on the target.</p>
<p>ZOMBIE</p>
<p><i>37</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Status Bar</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 3</b></p>
<p><b>Connecting to Your Target</b></p>
<p><b>Contents</b></p>
<p>Working with Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>40</p>
<p>Standard Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>42</p>
<p>Custom Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>47</p>
<p>Temporary Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>49</p>
<p>Using the Connection Organizer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>50</p>
<p>Disconnecting from Your Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>58</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes how to use the tools listed below to create, save, view,</p>
<p>manage, and use Connection Methods. It also describes how to view information</p>
<p>about your targets and manage them.</p>
<p>â¢</p>
<p><b>Connection Editor</b> â Allows you to create, save, and edit Connection</p>
<p>Methods.</p>
<p>â¢</p>
<p><b>Connection Chooser</b> â Allows you to create or use Connection Methods to</p>
<p>connect to your target.</p>
<p>â¢</p>
<p><b>Connection Organizer</b> â Allows you to manage all of your Connection</p>
<p>Methods.</p>
<p>Chapter 6, âConfiguring Your Target Hardwareâ on page 89 and Chapter 7,</p>
<p>âPreparing Your Targetâ on page 103 outline the steps you must take before you</p>
<p>can run a program on the target you are connected to.</p>
<p><b>Working with Connection Methods</b></p>
<p>Before you can run your program, you must connect MULTI to your target.</p>
<p>Configuring your debugging interface so that MULTI can connect to your target</p>
<p>can be a complicated process. However, MULTI provides several graphical tools</p>
<p>that simplify this process by allowing you to create as many<i> Connection Methods</i></p>
<p>as you need. A Connection Method contains a template that MULTI uses to connect</p>
<p>to your target hardware or simulator. Whether you are using an on-chip debugging</p>
<p>solution, an in-circuit emulator, a ROM monitor, an embedded RTOS, or a simulator</p>
<p>to perform debugging, you need to create a Connection Method that contains all of</p>
<p>the configuration settings required for connecting to your target.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>40</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Hardware Connections</b></p>
<p>In addition to configuring at least one Connection Method, you may also need to</p>
<p>configure your target board and/or hardware debugging device (if applicable) before</p>
<p>you can download and debug code. For information about configuring your target</p>
<p>hardware, see Chapter 6, âConfiguring Your Target Hardwareâ on page 89. For</p>
<p>information about the specific options available for:</p>
<p>â¢</p>
<p>INTEGRITY run-mode target connections, see Chapter 4, âINDRT2 (rtserv2)</p>
<p>Connectionsâ on page 59 or Chapter 5, âINDRT (rtserv) Connectionsâ</p>
<p>on page 77.</p>
<p>â¢</p>
<p>Green Hills Probe or SuperTrace Probe target connections, see the<i> Green Hills</i></p>
<p><i>Debug Probes User's Guide</i>.</p>
<p>â¢</p>
<p>Other target connections, see the<i> MULTI: Configuring Connections</i> book for</p>
<p>your target processor.</p>
<p><b>Simulator Connections</b></p>
<p>Even if your hardware is unavailable during development, you can still debug your</p>
<p>program with the MULTI Debugger by connecting to a simulator for your target</p>
<p>architecture type. A simulator is installed automatically when you install a Green</p>
<p>Hills Compiler, and the procedure for connecting to it from the MULTI Debugger</p>
<p>is similar to the procedure for connecting to an external target. In this chapter, the</p>
<p>word<i> target</i> indicates either a hardware target or a simulated target. For more</p>
<p>information about the simulator(s) available for your target, see the<i> MULTI:</i></p>
<p><i>Configuring Connections</i> book for your specific processor.</p>
<p><b>Native Development Connections</b></p>
<p>If you are developing in a native environment, MULTI generally âconnectsâ</p>
<p>transparently through a simple debug server. Because this happens automatically</p>
<p>and because configuration options cannot usually be set for such connections, native</p>
<p>connections are not discussed in this book. If useful connection options are available</p>
<p>for your particular native connection type, they are documented in the<i> MULTI:</i></p>
<p><i>Building Applications</i> book for your specific native environment.</p>
<p><i>41</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Hardware Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Tools Overview</b></p>
<p>The simplest way to create and edit Connection Methods is to use the<b> Connection</b></p>
<p><b>Editor</b>, which allows you to make selections and enter settings through a graphical</p>
<p>interface. The<b> Connection Editor</b> translates your selections and input into the</p>
<p>appropriate command line options to the<i> debug server</i> that MULTI uses to connect</p>
<p>to your specific target. Connection Methods created using the<b> Connection Editor</b></p>
<p>are referred to as<i> Standard Connection Methods</i>. Standard Connection Methods</p>
<p>can be saved, invoked quickly using the<b> Connection Chooser</b>, and managed using</p>
<p>the<b> Connection Organizer</b>. For more information about creating, configuring, and</p>
<p>using Standard Connection Methods, see âStandard Connection Methodsâ</p>
<p>on page 42.</p>
<p><b>Tip</b></p>
<p>Users who prefer to enter command line options rather than use the GUI</p>
<p>interface can create<i> Custom Connection Methods</i>. Like Standard</p>
<p>Connection Methods, Custom Connection Methods can be saved, invoked</p>
<p>quickly using the<b> Connection Chooser</b>, and managed using the</p>
<p><b>Connection Organizer</b>. For more information about using Custom</p>
<p>Connection Methods, see âCustom Connection Methodsâ on page 47.</p>
<p>After you have created one or more Connection Methods, you can connect to your</p>
<p>target from the<b> Connection Chooser</b> or<b> Connection Organizer</b>. You can use the</p>
<p><b>Connection Organizer</b> to save Connection Methods and organize them into</p>
<p>Connection Files in your projects.</p>
<p><b>Standard Connection Methods</b></p>
<p>The following sections explain how to use MULTI to create, configure, save, edit,</p>
<p>and use Standard Connection Methods.</p>
<p><b>Creating a Standard Connection Using the Project Wizard</b></p>
<p>If you use the<b> Project Wizard</b> to create a project, one or more Standard Connection</p>
<p>Methods are created for you automatically. The new project contains a<b> default.con</b></p>
<p>Connection File that contains these Methods. (The<b> default.con</b> file is located in the</p>
<p><b>Target Resources</b> project in the Project Manager.) You may need to use the</p>
<p><b>Connection Editor</b> to edit the settings of automatically created Connection Methods</p>
<p><i>MULTI: Debugging</i></p>
<p><i>42</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p>before you can use them to connect to your target. For instructions about how to</p>
<p>edit new or existing Standard Connection Methods, see âConfiguring a Standard</p>
<p>Connection with the Connection Editorâ on page 44.</p>
<p><b>Creating a Standard Connection Using the Connection Chooser</b></p>
<p>You can create a new Standard Connection Method using the<b> Connection Chooser</b>.</p>
<p>To do so, perform the following steps.</p>
<p>1.</p>
<p>Open the<b> Connection Chooser</b>.</p>
<p>You can open the<b> Connection Chooser</b> from the MULTI Project Manager,</p>
<p>Debugger, or Launcher. Perform one of the following steps to open the</p>
<p><b>Connection Chooser</b>:</p>
<p>â¢</p>
<p>From the MULTI Launcher, click</p>
<p>and select<b> Connect</b>, or select</p>
<p><b>Components</b> â<b> Connect</b>.</p>
<p>â¢</p>
<p>From the MULTI Project Manager, click</p>
<p>, or select<b> Connect</b> â</p>
<p><b>Connect</b>.</p>
<p>â¢</p>
<p>From the MULTI Debugger, click</p>
<p>, or select<b> Target</b> â<b> Connect</b>.</p>
<p><b>Note</b></p>
<p>In a native environment, opening the<b> Connection Chooser</b></p>
<p>from the Debugger automatically connects to a native debug</p>
<p>server. Instead, open the<b> Connection Editor</b> by selecting</p>
<p><b>Method</b> â<b> New</b> in the<b> Connection Organizer</b>.</p>
<p>2.</p>
<p>Click</p>
<p>to open the<b> Create New Connection Method</b> dialog box.</p>
<p><i>43</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Creating a Standard Connection Using the Connection Chooser</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Enter a name for your Connection Method (for example,</p>
<p>Green Hills Probe</p>
<p>to my board</p>
<p>). If you do not enter a name, the Method you create is a</p>
<p>Temporary Connection Method (see âTemporary Connection Methodsâ</p>
<p>on page 49).</p>
<p>4.</p>
<p>Select an appropriate connection type from the drop-down list. The types listed</p>
<p>depend on your particular Compiler installation. Select the type that best</p>
<p>describes your debug connectivity method.</p>
<p>5.</p>
<p>Click<b> Create</b>. The Connection Method is stored in the<b> [User Methods]</b> file.</p>
<p>For more information, see âThe Default Connection File [User Methods]â</p>
<p>on page 53.</p>
<p>When you click<b> Create</b>, a<b> Connection Editor</b> window opens for your new Standard</p>
<p>Connection Method. You may need to edit the new Method before you use it for</p>
<p>the first time. The next section describes how to do this.</p>
<p><b>Configuring a Standard Connection with the Connection Editor</b></p>
<p>Before you can use a Standard Connection Method for the first time, you may need</p>
<p>to configure it for your specific target system and debugging options. You can use</p>
<p>the<b> Connection Editor</b> to configure a Standard Connection Method.</p>
<p><b>Opening the Connection Editor</b></p>
<p>If you create a new Standard Connection Method from the<b> Create New Connection</b></p>
<p><b>Method</b> dialog box, the<b> Connection Editor</b> appears automatically when you click</p>
<p><b>Create</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>44</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If you used the<b> Project Wizard</b> to create a project and you need to edit a default</p>
<p>Connection Method created by the wizard, or if you want to edit a Standard</p>
<p>Connection Method you have previously created and saved, perform the following</p>
<p>steps to open the<b> Connection Editor</b>.</p>
<p>1.</p>
<p>Open the<b> Connection Chooser</b> (see âCreating a Standard Connection Using</p>
<p>the Connection Chooserâ on page 43).</p>
<p>2.</p>
<p>From the drop-down list, select the Connection Method you want to edit.</p>
<p>3.</p>
<p>Click</p>
<p>to open the<b> Connection Editor</b> for the selected Connection Method.</p>
<p>For information about the basic features of the<b> Connection Editor</b>, see the</p>
<p>documentation about the Connection Editor in the<i> MULTI: Configuring Connections</i></p>
<p>book.</p>
<p><b>Connecting with a Standard Connection</b></p>
<p>After you have created and configured a Connection Method, you can use it to</p>
<p>connect to your target from the MULTI Launcher, the MULTI Project Manager,</p>
<p>the MULTI Debugger, the<b> Connection Chooser</b>, the<b> Connection Editor</b>, or the</p>
<p><b>Connection Organizer</b>, as described in the following table.</p>
<p><b>Perform These Steps</b></p>
<p><b>From the</b></p>
<p>Click the</p>
<p>button, and select the Connection Method you want to</p>
<p>use.</p>
<p>MULTI Launcher</p>
<p>Select<b> Connect</b> â<b> Connect</b>, or click</p>
<p>to open the<b> Connection</b></p>
<p><b>Chooser</b>. Use the<b> Connection Chooser</b> to connect to your target.</p>
<p>(See<b> Connection Chooser</b> below.)</p>
<p>MULTI Project</p>
<p>Manager</p>
<p><i>45</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Connecting with a Standard Connection</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Perform These Steps</b></p>
<p><b>From the</b></p>
<p>Select<b> Target</b> â<b> Connect</b>, or click</p>
<p>to open the<b> Connection</b></p>
<p><b>Chooser</b>. Use the<b> Connection Chooser</b> to connect to your target.</p>
<p>(See<b> Connection Chooser</b> below.)</p>
<p>In a native environment, the Debugger automatically connects to a</p>
<p>native debug server without opening the<b> Connection Chooser</b>.</p>
<p>MULTI Debugger</p>
<p>Select the Connection Method from the drop-down list, and click</p>
<p><b>Connect</b>.</p>
<p><b>Connection Chooser</b></p>
<p>Click the<b> Connect</b> button if it is available. If the<b> Connect</b> button</p>
<p>appears dimmed, click<b> OK</b> and use the<b> Connection Chooser</b> to</p>
<p>connect to your target. (See<b> Connection Chooser</b> above.)</p>
<p><b>Connection Editor</b></p>
<p>Select a Connection Method. Then select<b> Method</b> â<b> Connect to</b></p>
<p><b>Target</b>.</p>
<p><b>Connection Organizer</b></p>
<p>If your attempt to connect is unsuccessful, MULTI displays diagnostic information</p>
<p>to help you understand the problem. The amount of the diagnostic information that</p>
<p>MULTI can provide depends on the nature of your target. When you know what</p>
<p>changes you need to make to your Connection Method, you can use the<b> Connection</b></p>
<p><b>Editor</b>. For general information about using the<b> Connection Editor</b>, see</p>
<p>âConfiguring a Standard Connection with the Connection Editorâ on page 44. For</p>
<p>more information about diagnosing connection problems and for more information</p>
<p>about the<b> Connection Editor</b> settings available for:</p>
<p>â¢</p>
<p>INTEGRITY run-mode target connections, see Chapter 4, âINDRT2 (rtserv2)</p>
<p>Connectionsâ on page 59 or Chapter 5, âINDRT (rtserv) Connectionsâ</p>
<p>on page 77.</p>
<p>â¢</p>
<p>Green Hills Probe or SuperTrace Probe target connections, see the<i> Green Hills</i></p>
<p><i>Debug Probes User's Guide</i>.</p>
<p>â¢</p>
<p>Other target connections, see the<i> MULTI: Configuring Connections</i> book for</p>
<p>your target processor.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>46</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Custom Connection Methods</b></p>
<p>To create a Custom Connection Method, do one of the following:</p>
<p>â¢</p>
<p>Use the<b> connect</b> Debugger command. For information about this command,</p>
<p>see âGeneral Target Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>Choose<b> Custom</b> as the connection type in the<b> Create New Connection Method</b></p>
<p>dialog box. For remaining steps about how to create a Custom Connection</p>
<p>Method from the<b> Create New Connection Method</b> dialog box, see the</p>
<p>instructions that follow the appearance of this dialog box in âCreating a Standard</p>
<p>Connection Using the Connection Chooserâ on page 43.</p>
<p>â¢</p>
<p>Manually enter commands and options into the<b> Connection Chooser</b>. For more</p>
<p>information, see below.</p>
<p>To create a Custom Connection Method from the<b> Connection Chooser</b>, perform</p>
<p>the following steps:</p>
<p>1.</p>
<p>Open the<b> Connection Chooser</b> (see âCreating a Standard Connection Using</p>
<p>the Connection Chooserâ on page 43).</p>
<p>2.</p>
<p>Click<b> Custom</b>.</p>
<p><i>47</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Custom Connection Methods</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>In the<b> Start a Custom Connection</b> text field, enter the connection command</p>
<p>for your particular target connection.</p>
<p>The general format of the command that starts a debug server and connects to</p>
<p>a target is:</p>
<p>[setup=<i>setup_script</i>]<i> xserv required_arguments</i> ... [<i>options</i>]...</p>
<p>where:</p>
<p>â¢</p>
<p><i>setup_script</i></p>
<p>is the filename of the target setup script written in the</p>
<p>MULTI scripting language.</p>
<p>setup=<i>setup_script</i></p>
<p>may not be required</p>
<p>for your target.</p>
<p>â¢</p>
<p><i>xserv</i></p>
<p>is the name of the Green Hills debug server that supports your</p>
<p>debugging interface, monitor, or simulator. For example, the<b> mpserv</b></p>
<p>debug server supports the Green Hills Probe. For the name of the correct</p>
<p>debug server, see the<i> MULTI: Configuring Connections</i> book for your</p>
<p>target processor.</p>
<p>â¢</p>
<p><i>required_arguments</i></p>
<p>and available</p>
<p><i>options</i></p>
<p>for:</p>
<p>â</p>
<p>INTEGRITY run-mode target connections are documented in</p>
<p>Chapter 4, âINDRT2 (rtserv2) Connectionsâ on page 59 and</p>
<p>Chapter 5, âINDRT (rtserv) Connectionsâ on page 77.</p>
<p>â</p>
<p>Green Hills Probe or SuperTrace Probe target connections are</p>
<p>documented in the<i> Green Hills Debug Probes User's Guide</i>.</p>
<p>â</p>
<p>Other target connections are documented in the<i> MULTI: Configuring</i></p>
<p><i>Connections</i> book for your target processor.</p>
<p>4.</p>
<p>Click<b> Connect</b>.</p>
<p>MULTI connects to your target and saves your Custom Connection Method.</p>
<p>In the future, the Method you entered in the text field will appear in the list of</p>
<p>Connection Methods available in the<b> Connection Chooser</b> and<b> Connection</b></p>
<p><b>Organizer</b>.</p>
<p>For more information about using and managing existing Connection Methods,</p>
<p>see âUsing the Connection Organizerâ on page 50. To troubleshoot a</p>
<p>connection problem, see the<i> MULTI: Configuring Connections</i> book for your</p>
<p>target processor or, for Green Hills Probe or SuperTrace Probe users, the<i> Green</i></p>
<p><i>Hills Debug Probes User's Guide</i>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>48</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Temporary Connection Methods</b></p>
<p>You can create a connection that only exists for your current MULTI session, even</p>
<p>if you save the file containing it, by creating a<i> Temporary Connection Method</i>.</p>
<p>Temporary Connection Methods can be either Standard or Custom Connection</p>
<p>Methods. To create a Temporary Connection Method, perform the following steps:</p>
<p>1.</p>
<p>Open the<b> Connection Chooser</b> (see âCreating a Standard Connection Using</p>
<p>the Connection Chooserâ on page 43).</p>
<p>2.</p>
<p>Click</p>
<p>to open the<b> Create New Connection Method</b> dialog box.</p>
<p>3.</p>
<p>Leave the name field blank, and select the appropriate connection type from</p>
<p>the drop-down list. To create a Custom Connection Method, select<b> Custom</b></p>
<p>from the drop-down list.</p>
<p>4.</p>
<p>Click<b> Create</b>.</p>
<p>5.</p>
<p>The new Connection Method is named</p>
<p>Temporary Connection (<i>#</i>)</p>
<p>. Use</p>
<p>the<b> Connection Editor</b> to configure the connection. For information about</p>
<p>the<b> Connection Editor</b>, see âConfiguring a Standard Connection with the</p>
<p>Connection Editorâ on page 44.</p>
<p><i>49</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Temporary Connection Methods</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To convert a Temporary Connection Method to a permanent Standard or Custom</p>
<p>Connection Method, open the<b> Connection Organizer</b>, right-click the Temporary</p>
<p>Connection Method you want to change, and select<b> Make Permanent</b> from the</p>
<p>shortcut menu. The method is saved and the name is changed to</p>
<p>Connection (<i>#</i>)</p>
<p>.</p>
<p><b>Using the Connection Organizer</b></p>
<p>The<b> Connection Organizer</b> allows you to create, edit, copy, load, and save</p>
<p>Connection Methods and connect to your target using Connection Methods. The</p>
<p>following sections describe how to use the various features of the<b> Connection</b></p>
<p><b>Organizer</b>. For more information about Connection Methods, see âWorking with</p>
<p>Connection Methodsâ on page 40.</p>
<p><b>Opening the Connection Organizer</b></p>
<p>You can open the<b> Connection Organizer</b> in any of the following ways:</p>
<p>â¢</p>
<p>From the Launcher, click</p>
<p>and select<b> Open Connection Organizer</b>, or select</p>
<p><b>Components</b> â<b> Open Connection Organizer</b>.</p>
<p>â¢</p>
<p>From the Project Manager, select<b> Connect</b> â<b> Connection Organizer</b>.</p>
<p>â¢</p>
<p>From the Debugger, select<b> Target</b> â<b> Show Connection Organizer</b>.</p>
<p>â¢</p>
<p>From the Debugger command pane, enter the<b> connectionview</b> command. For</p>
<p>information about the<b> connectionview</b> command, see âGeneral Target</p>
<p>Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>From the<b> Connection Chooser</b> dialog box, click</p>
<p>. If the<b> Connection Chooser</b></p>
<p>dialog box automatically appeared as the result of an action you took (such as</p>
<p>trying to run your program without first connecting), clicking the</p>
<p>button</p>
<p>aborts the action and opens the<b> Connection Organizer</b>.</p>
<p>A sample<b> Connection Organizer</b> follows.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>50</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Connection Organizer</b> has three sections:</p>
<p>â¢</p>
<p><b>Opened Connection Files</b> â Lists all the Connection Files currently open.</p>
<p>Each Connection File contains one or more Connection Methods. You can use</p>
<p>Connection Files to save, restore, and transport your connection configurations.</p>
<p>The<b> Connection Organizer</b> always has at least one Connection File open: the</p>
<p><b>[User Methods]</b> file. The<b> Opened Connection Files</b> list may also contain</p>
<p><b>default.con</b> files created by the<b> Project Wizard</b>, or it may contain other<b> .con</b></p>
<p>files you have created. For more detailed information about Connection Files,</p>
<p>see âCreating and Managing Connection Filesâ on page 52.</p>
<p>â¢</p>
<p><b>Methods in<i> selected file</b></i> â Lists all the Connection Methods present in the</p>
<p>Connection File that is selected in the<b> Opened Connection Files</b> list. You can</p>
<p>use the<b> Connection Organizer</b>'s menu choices and shortcuts to start, copy,</p>
<p>edit, move, or delete Connection Methods from this list.</p>
<p>â¢</p>
<p><b>Connected Targets</b> â Lists all the currently established target hardware or</p>
<p>simulator connections. For more detailed information about connected targets,</p>
<p>see âManaging Your Connected Targetsâ on page 54.</p>
<p><i>51</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Opening the Connection Organizer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Creating a Connection Method</b></p>
<p>You can create a new Connection Method from the<b> Connection Organizer</b>. To do</p>
<p>this, select<b> Method</b> â<b> New</b> from the menu bar. The<b> Create New Connection</b></p>
<p><b>Method</b> dialog box appears. For remaining steps, see the instructions that follow</p>
<p>the appearance of this dialog box in âCreating a Standard Connection Using the</p>
<p>Connection Chooserâ on page 43. The Connection Method is stored in the file</p>
<p>selected in the<b> Connection Organizer</b>'s<b> Opened Connection Files</b> list.</p>
<p><b>Editing a Connection Method</b></p>
<p>To edit a previously saved Connection Method from the<b> Connection Organizer</b>:</p>
<p>1.</p>
<p>From the<b> Opened Connection Files</b> list, select the Connection File that</p>
<p>contains your desired Connection Method.</p>
<p>2.</p>
<p>From the<b> Methods in<i> selected file</b></i> list, select a Connection Method.</p>
<p>3.</p>
<p>From the<b> Connection Organizer</b>'s menu, select<b> Method</b> â<b> Edit</b> or right-click</p>
<p>the selected method and select<b> Edit</b> from the shortcut menu.</p>
<p>4.</p>
<p>Using the<b> Connection Editor</b> that appears, modify your Connection Method</p>
<p>settings. For general information about using the<b> Connection Editor</b>, see the</p>
<p>documentation about the Connection Editor in the<i> MULTI: Configuring</i></p>
<p><i>Connections</i> book. For detailed information about the settings available for:</p>
<p>â¢</p>
<p>INTEGRITY run-mode target connections, see Chapter 4, âINDRT2</p>
<p>(rtserv2) Connectionsâ on page 59 or Chapter 5, âINDRT (rtserv)</p>
<p>Connectionsâ on page 77.</p>
<p>â¢</p>
<p>Green Hills Probe or SuperTrace Probe target connections, see the<i> Green</i></p>
<p><i>Hills Debug Probes User's Guide</i>.</p>
<p>â¢</p>
<p>Other target connections, see the<i> MULTI: Configuring Connections</i> book</p>
<p>for your target processor.</p>
<p>5.</p>
<p>Click<b> OK</b> to save your changes.</p>
<p><b>Creating and Managing Connection Files</b></p>
<p>You can save one or more Connection Methods in a Connection File, which is a</p>
<p>regular text file that usually ends with a<b> .con</b> extension. The Connection Methods</p>
<p>stored in a Connection File are self-contained and portable. As a result, you can</p>
<p><i>MULTI: Debugging</i></p>
<p><i>52</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p>open and use Connection Files created by other installations. You can even email</p>
<p>Connection Files to other users and computers.</p>
<p>You can open any number of Connection Files in the<b> Connection Organizer</b>. Some</p>
<p>are opened for you automatically. The default Connection File,<b> [User Methods]</b> is</p>
<p>always open. If the<b> Connection Chooser</b> appears, the<b> Connection Organizer</b> also</p>
<p>opens the Connection File that contains the Connection Method selected by default</p>
<p>in the<b> Connection Chooser</b>.</p>
<p>To view the Connection Methods stored in an open Connection File, select the</p>
<p>Connection File in the<b> Opened Connection Files</b> list.</p>
<p>By default, changes to open Connection Files are saved immediately. If you change</p>
<p>the default setting, you must manually save your Connection Files via the</p>
<p><b>Connection Organizer</b>. For information about changing the default settings, see</p>
<p>the<b> autoSaveConnectionsinFiles</b> and<b> autoSaveUserConnections</b> options in the</p>
<p>âSession Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ in the</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>The Default Connection File [User Methods]</b></p>
<p>The first file in the<b> Opened Connection Files</b> list is always the<b> [User Methods]</b></p>
<p>file. It cannot be closed or renamed. This file serves as a default location for new</p>
<p>Connection Methods when you do not explicitly create a Connection File for them.</p>
<p>The contents of<b> [User Methods]</b> are stored in your Green Hills user directory as</p>
<p><b>multiconnections.con</b>. By default, changes to<b> [User Methods]</b> are immediately</p>
<p>saved. This behavior is configured separately from automatically saving other</p>
<p>Connection Files. For more information, see the<b> autoSaveUserConnections</b> option</p>
<p>in âSession Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ in the</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>Connection Files in a Project</b></p>
<p>You can use the MULTI Project Manager to add Connection Files with the<b> .con</b></p>
<p>extension to your<b> .gpj</b> projects. By default, the<b> Connection Organizer</b> automatically</p>
<p>opens any Connection Files in a project when the Project Manager opens that project.</p>
<p>You can select the Connection File from the<b> Opened Connection Files</b> list and</p>
<p>work with the Connection Methods that it contains.</p>
<p><i>53</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Creating and Managing Connection Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To add a Connection File to a project:</p>
<p>1.</p>
<p>Open the Project Manager, select<b> File</b> â<b> Open Project</b>. Select the filename</p>
<p>of the project you want to work with.</p>
<p>2.</p>
<p>Select<b> Edit</b> â<b> Add File into<i> project</i>.gpj</b>. Select the filename of the Connection</p>
<p>File you want associated with this project. You can specify a Connection File</p>
<p>that does not exist; the<b> Connection Organizer</b> simply creates it for you.</p>
<p><b>Connecting from the Connection Organizer</b></p>
<p>To connect to your target, you can use any appropriate Connection Method listed</p>
<p>in the<b> Connection Organizer</b>. To connect from the<b> Connection Organizer</b>:</p>
<p>1.</p>
<p>From the<b> Opened Connection Files</b> list, select the Connection File that</p>
<p>contains your desired Connection Method.</p>
<p>2.</p>
<p>From the<b> Methods in<i> selected file</b></i> list, select a Connection Method.</p>
<p>3.</p>
<p>From the<b> Connection Organizer</b> menu bar, select<b> Method</b> â<b> Connect to</b></p>
<p><b>Target</b>, or right-click the method and select<b> Connect to Target</b> from the</p>
<p>shortcut menu.</p>
<p>4.</p>
<p>If the connection is successful, a new connection appears in the<b> Connected</b></p>
<p><b>Targets</b> list. For information about connected targets, see âManaging Your</p>
<p>Connected Targetsâ on page 54.</p>
<p>To troubleshoot a connection problem, see the<i> MULTI: Configuring Connections</i></p>
<p>book for your target processor or, for Green Hills Probe or SuperTrace Probe users,</p>
<p>the<i> Green Hills Debug Probes User's Guide</i>.</p>
<p><b>Managing Your Connected Targets</b></p>
<p>After you have connected using a Connection Method, the connected target appears</p>
<p>in the<b> Connected Targets</b> list. The<b> Connected Targets</b> list is located at the bottom</p>
<p>of the<b> Connection Organizer</b>. From the<b> Connected Targets</b> list, you can find</p>
<p>information about the target and control the target.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>54</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Connection Organizer Menu and Action Reference</b></p>
<p>The primary interface for working with Connection Files is the list of<b> Opened</b></p>
<p><b>Connection Files</b> located in the<b> Connection Organizer</b>.</p>
<p>You can select Connection Files from this list and perform the following actions</p>
<p>by using the<b> File</b> menu. Most of the<b> File</b> menu options are also available via the</p>
<p>right-click menu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a dialog box that prompts you to name a new Connection File.</p>
<p>When you click the<b> Create</b> button, the Connection File is created and</p>
<p>added to the<b> Opened Connection Files</b> list.</p>
<p><b>New</b></p>
<p>Opens a dialog box that prompts you to open an existing<b> .con</b> file.</p>
<p>After you open it, the file appears in the<b> Opened Connection Files</b></p>
<p>list, and you can work with the Connection Methods contained in it.</p>
<p><b>Open</b></p>
<p>Closes the selected Connection File. Note that the<b> [User Methods]</b></p>
<p>Connection File is always open and cannot be closed.</p>
<p><b>Close</b></p>
<p>Saves any changes to the selected Connection File.</p>
<p><b>Save</b></p>
<p>Opens a dialog box that prompts you to choose a different filename</p>
<p>for the selected Connection File before saving it.</p>
<p><b>Save a copy</b></p>
<p>Saves all changes to all open Connection Files.</p>
<p><b>Save all</b></p>
<p><i>55</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Connection Organizer Menu and Action Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Closes the window. This menu item does not affect the Connection</p>
<p>File.</p>
<p><b>Close Window</b></p>
<p>The primary interface for working with Connection Methods is the list of Connection</p>
<p>Methods located under<b> Methods in<i> selected file</b></i> in the<b> Connection Organizer</b>.</p>
<p>You can select Connection Methods from this list and perform the following actions</p>
<p>by using the<b> Method</b> menu or the right-click menu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a dialog box that prompts you to define a new Connection</p>
<p>Method with a name, a type, and options that you specify.</p>
<p><b>New</b></p>
<p>Uses the settings of the selected Connection Method to connect to</p>
<p>the target. If the connection is successful, the connected target appears</p>
<p>in the<b> Connected Targets</b> list. If the connection is unsuccessful, an</p>
<p>error message and diagnostic information appear.</p>
<p><b>Connect to Target</b></p>
<p>Opens the<b> MULTI Fast Flash Programmer</b> after connecting to the</p>
<p>target selected under<b> Methods in<i> selected file</b></i>. This window allows</p>
<p>you to enter parameters for downloading a file to flash memory on</p>
<p>the target. See Chapter 22, âProgramming Flash Memoryâ on page 539.</p>
<p><b>Connect and Flash</b></p>
<p>Opens a<b> Connection Editor</b> that allows you to change the settings</p>
<p>of the selected Connection Method. See the documentation about the</p>
<p>Connection Editor in the<i> MULTI: Configuring Connections</i> book.</p>
<p><b>Edit</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>56</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a dialog box that allows you to copy the selected Connection</p>
<p>Method into either the same or a different Connection File. If a</p>
<p>Connection Method with the same name already exists in the</p>
<p>Connection File you copy to, the copy you create is named</p>
<p><i>method_name</i> (2)</p>
<p>or</p>
<p><i>method_name</i> (3)</p>
<p>, etc.</p>
<p><b>Copy</b></p>
<p>Opens a dialog box that allows you to move the selected Connection</p>
<p>Method into another Connection File. If a Connection Method with</p>
<p>the same name already exists in the Connection File you move the</p>
<p>selected Connection Method into, the Method you move is renamed</p>
<p><i>method_name</i> (2)</p>
<p>or</p>
<p><i>method_name</i> (3)</p>
<p>, etc.</p>
<p><b>Move</b></p>
<p>Deletes the Connection Method selected in<b> Methods in<i> selected file</b></i></p>
<p>from the current Connection File.</p>
<p><b>Delete</b></p>
<p>The primary interface for working with connected targets is the list of<b> Connected</b></p>
<p><b>Targets</b> located in the<b> Connection Organizer</b>.</p>
<p>You can select connected targets from this list and perform the following actions</p>
<p>by using the<b> Target</b> menu. Most of the following<b> Target</b> menu options are also</p>
<p>available via the right-click menu.</p>
<p><i>57</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Connection Organizer Menu and Action Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the<b> MULTI Fast Flash Programmer</b>. This window allows</p>
<p>you to use the selected target connection to write a file located on the</p>
<p>host to flash memory on the target. See Chapter 22, âProgramming</p>
<p>Flash Memoryâ on page 539.</p>
<p><b>Flash</b></p>
<p>Displays the Task Manager associated with the selected target. This</p>
<p>option is only available if the target supports multiple tasks. For more</p>
<p>information about the Task Manager, see âThe Task Managerâ</p>
<p>on page 580.</p>
<p><b>Show Task Manager</b></p>
<p>Opens the<b> Target Logging Settings</b> dialog box, which allows you</p>
<p>to capture communications between MULTI and the target's debug</p>
<p>agent.</p>
<p><b>Set Logging</b></p>
<p>Disconnects the selected target from MULTI. Processes that are</p>
<p>running or being debugged on the target may be halted or may</p>
<p>continue running undisturbed. The exact behavior of<b> Disconnect</b> is</p>
<p>dependent on your target and connection. For example, when you</p>
<p>disconnect from a simulator, the simulator exits, ending all processes</p>
<p>it is running. However, an RTOS debug agent detaches and allows</p>
<p>the underlying RTOS to continue running.</p>
<p><b>Disconnect</b></p>
<p><b>Disconnecting from Your Target</b></p>
<p>To disconnect from your target, do one of the following:</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> disconnect</b> command. For</p>
<p>information about the<b> disconnect</b> command, see âGeneral Target Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>In the target list, select a connected executable. Click the<b> Disconnect</b> button</p>
<p>(</p>
<p>) or select<b> Target</b> â<b> Disconnect from Target</b>.</p>
<p>â¢</p>
<p>In the target list, right-click a connected executable and then select<b> Disconnect</b></p>
<p><b>from Target</b> from the shortcut menu that appears.</p>
<p>â¢</p>
<p>In the<b> Connection Organizer</b>, select a connection from the<b> Connected Targets</b></p>
<p>list and then select<b> Target</b> â<b> Disconnect</b>.</p>
<p>â¢</p>
<p>In the<b> Connection Organizer</b>, right-click a connection in the<b> Connected</b></p>
<p><b>Targets</b> list and then select<b> Disconnect</b> from the shortcut menu that appears.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>58</i></p>
<p><i>Chapter 3. Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 4</b></p>
<p><b>INDRT2 (rtserv2)</b></p>
<p><b>Connections</b></p>
<p><b>Contents</b></p>
<p>Introduction to rtserv2 and INDRT2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>60</p>
<p>Building in Run-Mode Debugging Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>61</p>
<p>Connecting Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>62</p>
<p>INDRT2 Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>62</p>
<p>Automatically Establishing Run-Mode Connections . . . . . . . . . . . . . . . . . . . . .</p>
<p>69</p>
<p>Connecting to Multiple ISIM Targets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>74</p>
<h1 style="page-break-before:always; "></h1>
<p>INDRT2 is a software interface provided by Green Hills that facilitates run-mode</p>
<p>debugging of the INTEGRITY real-time operating system (version 10 or later).</p>
<p>INDRT2 and<b> rtserv2</b>, the debug server that supports INDRT2 connections, are</p>
<p>installed automatically when you install a distribution of the MULTI IDE that</p>
<p>supports INDRT2 connections.</p>
<p>This chapter supplements the general target connection information in Chapter 3,</p>
<p>âConnecting to Your Targetâ on page 39 with specific information for INDRT2</p>
<p>connections.</p>
<p>For more information about run-mode connections, including a caveat to</p>
<p>simultaneously debugging multiple targets in run mode, see âEstablishing Run-Mode</p>
<p>Connectionsâ on page 578.</p>
<p><b>Introduction to rtserv2 and INDRT2</b></p>
<p>Debug servers such as<b> rtserv2</b> enable communication between the host and the</p>
<p>target. During a debugging session, the MULTI Debugger sends<b> rtserv2</b>, a</p>
<p>host-resident debug server, requests to read registers, write to memory, etc. In turn,</p>
<p><b>rtserv2</b> sends the debugging requests to the target. You can use the<b> rtserv2</b> debug</p>
<p>server to connect to a running INTEGRITY system (version 10 or later) to perform</p>
<p>run-mode debugging.</p>
<p><b>rtserv2</b> enables advanced features such as dynamic downloading of virtual</p>
<p>AddressSpaces, and use of tools such as the<b> Profile</b> window and the EventAnalyzer.</p>
<p>When you are connected to<b> rtserv2</b>, the target list displays all the tasks in the system.</p>
<p>Any user task in the target list can be selected and individually debugged.</p>
<p><b>Communication Media</b></p>
<p>An INDRT2 (<b>rtserv2</b>) connection can be established over an IP network (typically</p>
<p>Ethernet) or a serial link. A BSP typically provides drivers to support an Ethernet</p>
<p>or serial device. For information about configuring INTEGRITY's network settings,</p>
<p>see the<i> INTEGRITY Networking Guide</i>.</p>
<p>The following are general recommendations for INDRT2 (<b>rtserv2</b>) connections:</p>
<p>â¢</p>
<p>Use a fast and reliable IP network (such as Ethernet) whenever possible for</p>
<p>better performance.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>60</i></p>
<p><i>Chapter 4. INDRT2 (rtserv2) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>For BSPs that support only one serial port, the port cannot be used for debugging</p>
<p>when it is being used for diagnostics. If the serial port is already in use, close</p>
<p>the terminal program used to view the serial port output before establishing</p>
<p>your run-mode connection.</p>
<p>â¢</p>
<p>The baud rate at which a particular BSP communicates over a serial port varies.</p>
<p>For details, see the documentation that came with your BSP.</p>
<p><b>Building in Run-Mode Debugging Support</b></p>
<p>To enable run-mode debugging support, an INTEGRITY kernel program must be</p>
<p>linked with a debug library supplied by Green Hills. To include this library in an</p>
<p>existing kernel or monolith project:</p>
<p>1.</p>
<p>In the Project Manager, locate the<b> .gpj</b> file for the kernel within the project</p>
<p>(by default,<b> myproject_kernel.gpj</b>).</p>
<p>2.</p>
<p>Right-click the file, and select<b> Configure</b>.</p>
<p>3.</p>
<p>In the<b> Settings for Kernel</b> window that appears, select the<b> Debugging</b> check</p>
<p>box.</p>
<p><i>61</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Building in Run-Mode Debugging Support</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Connecting Overview</b></p>
<p>You can establish a debug server connection in any of the following ways. Each is</p>
<p>discussed in more detail later in this chapter.</p>
<p>â¢</p>
<p>Graphically configure a Connection Method. For a set of steps to follow, see</p>
<p>âConnecting to rtserv2 via the Connection Organizer and Connection Editorâ</p>
<p>on page 65. For reference information that supplements the general information</p>
<p>in Chapter 3, âConnecting to Your Targetâ on page 39, see the next section.</p>
<p>â¢</p>
<p>Use a custom connection command. See âUsing Custom INDRT2 (rtserv2)</p>
<p>Connection Methodsâ on page 66.</p>
<p>â¢</p>
<p>Set up a run-mode partner. See âAutomatically Establishing Run-Mode</p>
<p>Connectionsâ on page 69.</p>
<p><b>INDRT2 Connection Methods</b></p>
<p>To help you connect to your target quickly and easily, MULTI allows you to create</p>
<p>and save Connection Methods that correspond to your particular host and target</p>
<p>systems and your desired debugging options.</p>
<p>For general instructions that explain how to create and use Connection Methods,</p>
<p>see Chapter 3, âConnecting to Your Targetâ on page 39. The information in the</p>
<p>following sections supplements the instructions provided there with information</p>
<p>that is specific to INDRT2 connections.</p>
<p><b>Using the INDRT2 (rtserv2) Connection Editor</b></p>
<p>In addition to the generic fields that appear on all<b> Connection Editors</b> for Standard</p>
<p>Connection Methods (see the documentation about the Connection Editor in the</p>
<p><i>MULTI: Configuring Connections</i> book), the<b> INDRT2 (rtserv2) Connection Editor</b></p>
<p>includes<b> Connection</b> and<b> Debug</b> tabs that provide settings and options specific to</p>
<p>your target and host operating systems.</p>
<p>When the<b> Connection Editor</b> is first displayed after you create a new Connection</p>
<p>Method, the settings and options are set to default values. Settings and options that</p>
<p>are not available on your host operating system may appear dimmed. Some of the</p>
<p>fields may require user input before the Connection Method can be used.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>62</i></p>
<p><i>Chapter 4. INDRT2 (rtserv2) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Each field is described in the following sections.</p>
<p><b>INDRT2 (rtserv2) Connection Settings</b></p>
<p><b>Ethernet/IP Connection</b></p>
<p>Sets your desired connection type as Ethernet/IP. This radio button is mutually exclusive with</p>
<p>the<b> Serial Connection</b> button. If you select an Ethernet/IP connection (this is the default), the</p>
<p>following field will also be available:</p>
<p>â¢</p>
<p><b>Target Name or Address</b> â Specifies the host name or IP address of your target. You</p>
<p>must specify a host name or IP address to create a valid Ethernet/IP connection.</p>
<p><b>Note</b>: If you need to connect to your target using a non-standard UDP port number (that is, not</p>
<p>2220), you must use a Custom Connection Method. See âCustom INDRT2 (rtserv2) Connections</p>
<p>Over an IP Networkâ on page 67 for instructions.</p>
<p><b>Serial Connection</b></p>
<p>Specifies that a serial connection to the target should be used. This radio button is mutually</p>
<p>exclusive with the<b> Ethernet/IP Connection</b> button and is not supported on Solaris. If you select</p>
<p>a serial connection, the following option fields will also be available:</p>
<p>â¢</p>
<p><b>Serial Port</b> â Specifies which host serial port to use for your serial INDRT2 connection.</p>
<p>In the event that you do not specify a port, the default serial port for each supported host</p>
<p>operating system is listed below:</p>
<p>â</p>
<p>Windows â<b> COM1</b></p>
<p>â</p>
<p>Linux â<b> ttyS0</b></p>
<p>â¢</p>
<p><b>Baud Rate</b> â Specifies the serial port communication speed. The default baud rate is</p>
<p>9600</p>
<p>.</p>
<p><i>63</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the INDRT2 (rtserv2) Connection Editor</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>INDRT2 (rtserv2) Debug Settings</b></p>
<p><b>Warning</b></p>
<p>Do not change the settings on the<b> Debug</b> tab unless you are instructed to</p>
<p>do so by Green Hills Technical Support.</p>
<p><b>Log Host-Target Debug Output</b></p>
<p>Enables logging of all communications between<b> rtserv2</b> and your target. Logging is disabled</p>
<p>by default.</p>
<p><b>StdErr/StdOut</b></p>
<p><b>File</b></p>
<p>Allows you to specify the destination for host-target debug output. These fields will be dimmed</p>
<p>unless<b> Log Host-Target Debug Output</b> is selected.</p>
<p>If you choose<b> StdErr/StdOut</b>, host-target debug output will be directed to the console. This</p>
<p>setting is not supported on Windows hosts. To log debug output on Windows, select<b> File</b>.</p>
<p>If you select<b> File</b>, host-target debug output will be directed to the file you specify in the text</p>
<p>field. You may enter a filename directly into this text field, or click<b> Choose</b> to browse the file</p>
<p>system.</p>
<p><b>Other Options</b></p>
<p>Allows you to add other optional arguments directly to the command used for connecting. You</p>
<p>should only use this field if directed to do so by Green Hills Technical Support.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>64</i></p>
<p><i>Chapter 4. INDRT2 (rtserv2) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Connecting to rtserv2 via the Connection Organizer and</b></p>
<p><b>Connection Editor</b></p>
<p>This section provides a practical set of steps that you can follow to connect to your</p>
<p>INTEGRITY target. This set of steps, which uses the<b> Connection Organizer</b> and</p>
<p><b>Connection Editor</b>, outlines one of the many possible ways in which you can</p>
<p>connect. For information about other ways to connect to your target, see Chapter 3,</p>
<p>âConnecting to Your Targetâ on page 39.</p>
<p>1.</p>
<p>In the MULTI Project Manager, open the Top Project that came with your</p>
<p>BSP, or, if you already have an existing project for your BSP, open its Top</p>
<p>Project.</p>
<p>Each BSP contains example connections that you can customize for your own</p>
<p>use. These same connections are used by the<b> Project Wizard</b> for every project</p>
<p>created for that BSP.</p>
<p>2.</p>
<p>In the MULTI Project Manager, select<b> Connect</b> â<b> Connection Organizer</b>.</p>
<p>3.</p>
<p>In the<b> Opened Connection Files</b> list, select<b> default.con</b>.</p>
<p><i>65</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the INDRT2 (rtserv2) Connection Editor</i></p>
<h1 style="page-break-before:always; "></h1>
<p>4.</p>
<p>Modify or create a connection:</p>
<p>â¢</p>
<p>To modify an existing connection (recommended) â Double-click the</p>
<p><b>Dynamic Download/INDRT2 Connection</b> to open the<b> Connection</b></p>
<p><b>Editor</b>.</p>
<p>â¢</p>
<p>To create a new connection â Select<b> Method</b> â<b> New</b>. In the<b> Create</b></p>
<p><b>New Connection Method</b> dialog box, specify a<b> Name</b>, and select</p>
<p><b>INDRT2 (rtserv2)</b> as the<b> Type</b>. Click<b> Create</b> to open the<b> Connection</b></p>
<p><b>Editor</b>.</p>
<p>5.</p>
<p>The<b> INDRT2 (rtserv2) Connection Editor</b> includes<b> Connection</b> and<b> Debug</b></p>
<p>tabs to set options specific to your target and host operating systems. When</p>
<p>you first open the<b> Connection Editor</b>, the options are set to default values.</p>
<p>Some fields may require user input. For a description of each field, see</p>
<p>âINDRT2 (rtserv2) Connection Settingsâ on page 63 and âINDRT2 (rtserv2)</p>
<p>Debug Settingsâ on page 64.</p>
<p>6.</p>
<p>After customizing the connection, click<b> OK</b> to return to the<b> Connection</b></p>
<p><b>Organizer</b>.</p>
<p>7.</p>
<p>Ensure that you are running a properly configured INTEGRITY kernel (see</p>
<p>âBuilding in Run-Mode Debugging Supportâ on page 61).</p>
<p>8.</p>
<p>Right-click the<b> Dynamic Download/INDRT2 Connection</b>, and select<b> Connect</b></p>
<p><b>to Target</b>.</p>
<p><b>Using Custom INDRT2 (rtserv2) Connection Methods</b></p>
<p>You can create a Custom INDRT2 (<b>rtserv2</b>) Connection Method by manually</p>
<p>entering a connection command into the<b> Connection Chooser</b> instead of using the</p>
<p>graphical<b> Connection Editor</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>66</i></p>
<p><i>Chapter 4. INDRT2 (rtserv2) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The appropriate commands for Custom INDRT2 Connection Methods are described</p>
<p>in the following sections.</p>
<p><b>Custom INDRT2 (rtserv2) Connections Over an IP Network</b></p>
<p>To use a Custom Connection Method to establish an INDRT2 connection over an</p>
<p>IP network:</p>
<p>1.</p>
<p>Open the<b> Connection Chooser</b>. One way to do so is to click the<b> Connect</b></p>
<p>button (</p>
<p>) in the MULTI Project Manager.</p>
<p>2.</p>
<p>In the<b> Connection Chooser</b>, click<b> Custom</b>.</p>
<p>3.</p>
<p>In the<b> Start a Custom Connection</b> field, enter a connection command with</p>
<p>appropriate options. The following graphic is only an example. The complete</p>
<p>syntax is provided below.</p>
<p>4.</p>
<p>Click<b> Connect</b>.</p>
<p>The syntax of the command that should be entered into the<b> Start a Custom</b></p>
<p><b>Connection</b> field is:</p>
<p><b>rtserv2</b> [-log=<i>filename</i>]<i> hostname</i>[:<i>portnumber</i>]</p>
<p>where:</p>
<p>â¢</p>
<p>-log=<i>filename</i></p>
<p>enables logging of communications between<b> rtserv2</b> and</p>
<p>your target.</p>
<p>â¢</p>
<p><i>hostname</i></p>
<p>and</p>
<p>:<i>portnumber</i></p>
<p>should not be separated by spaces.</p>
<p><b>Note</b></p>
<p>You can also issue the above connection command from the Debugger's</p>
<p>command pane, where it must be preceded by the<b> connect</b> command.</p>
<p><i>67</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using Custom INDRT2 (rtserv2) Connection Methods</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For more information, see âCustom Connection Methodsâ on page 47.</p>
<p><b>Example 4.1. Establishing a Connection Over an IP Network</b></p>
<p>To establish an IP connection to an INTEGRITY board named</p>
<p>integrity1</p>
<p>, you</p>
<p>could enter the following text in the<b> Start a Custom Connection</b> field:</p>
<p>rtserv2 integrity1</p>
<p><b>Example 4.2. Logging Communications</b></p>
<p>To enable logging of communications between<b> rtserv2</b> and your target, use the<b> -log</b></p>
<p>option in your custom connection command. For example, to enable logging of the</p>
<p>example connection above, you would enter the following text in the<b> Start a Custom</b></p>
<p><b>Connection</b> field:</p>
<p>rtserv2 -log=myfile integrity1</p>
<p><b>Custom INDRT2 (rtserv2) Connections Over a Serial Link</b></p>
<p><b>Note</b></p>
<p>Serial connections using<b> rtserv2</b> are not supported on Solaris.</p>
<p>To use a Custom Connection Method to establish an INDRT2 connection over a</p>
<p>serial link, follow the steps listed at the beginning of âCustom INDRT2 (rtserv2)</p>
<p>Connections Over an IP Networkâ on page 67. However, when entering a connection</p>
<p>command, use the syntax provided next.</p>
<p><b>rtserv2</b> [-log=<i>filename</i>] -serial<i> device</i> [<i>baud_rate</i>]</p>
<p>where:</p>
<p>â¢</p>
<p>-log=<i>filename</i></p>
<p>enables logging of communications between<b> rtserv2</b> and</p>
<p>your target.</p>
<p>â¢</p>
<p>-serial</p>
<p>specifies a serial connection.</p>
<p>â¢</p>
<p><i>device</i></p>
<p>specifies the serial port device to use when connecting to the target.</p>
<p><i>device</i></p>
<p>can be the name of a device or the path to a device. For example,</p>
<p>ttyS0</p>
<p>and</p>
<p>/dev/ttyS0</p>
<p>are equivalent.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>68</i></p>
<p><i>Chapter 4. INDRT2 (rtserv2) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><i>baud_rate</i></p>
<p>sets the serial port communication speed. The default baud rate is</p>
<p>9600</p>
<p>.</p>
<p><b>Note</b></p>
<p>You can also issue the above connection command from the Debugger's</p>
<p>command pane, where it must be preceded by the<b> connect</b> command.</p>
<p>For more information, see âCustom Connection Methodsâ on page 47.</p>
<p><b>Example 4.3. Establishing a Serial Connection</b></p>
<p>To establish a serial connection on Windows, you might enter the following text in</p>
<p>the<b> Start a Custom Connection</b> field:</p>
<p>rtserv2 -serial com1 9600</p>
<p>On Linux, you might enter:</p>
<p>rtserv2 -serial /dev/ttyS0 9600</p>
<p><b>Automatically Establishing Run-Mode Connections</b></p>
<p>The Debugger allows you to define an INDRT2 or INDRT connection, called a</p>
<p><i>run-mode partner</i> that it will automatically establish when you download and run</p>
<p>an INTEGRITY kernel. The INTEGRITY kernel must be run via a freeze-mode</p>
<p>connection to a GHS simulator or GHS hardware debug solution (Green Hills Probe</p>
<p>or SuperTrace Probe). After INTEGRITY has booted, the run-mode partner is</p>
<p>established in the same Debugger window as the freeze-mode connection.</p>
<p>Run-mode partnering puts certain measures in place to prevent INDRT2/INDRT</p>
<p>connections from being closed prematurely. If you halt a freeze-mode connection</p>
<p>or step through source code while in freeze mode, the run-mode partner becomes</p>
<p>inaccessible: you cannot attach to or otherwise control tasks, nor can you read or</p>
<p>write registers or memory. In addition, host I/O calls issued over run mode will not</p>
<p>be serviced. (You may be able to continue browsing source code in tasks that you</p>
<p>are already attached to.) These measures reduce the chance that the Debugger will</p>
<p>erroneously attempt to communicate with<b> rtserv2</b> or<b> rtserv</b> while the target is halted</p>
<p>via the freeze-mode connection.</p>
<p><i>69</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Automatically Establishing Run-Mode Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If you kill, restart, or disconnect from a freeze-mode connection, the Debugger</p>
<p>automatically disconnects from any run-mode partner set on the same target.</p>
<p><b>Note</b></p>
<p>Run-mode partnering is only supported if you are debugging an</p>
<p>INTEGRITY target and if you are connected to a GHS simulator or to</p>
<p>one of the GHS hardware debug solutions (Green Hills Probe or</p>
<p>SuperTrace Probe) via a freeze-mode connection. The run-mode partner</p>
<p>requires an Ethernet connection to the target, and is not triggered by</p>
<p>INTEGRITY until after the target has an IP address. (If your target is</p>
<p>using DHCP, the connection is not triggered if the target cannot</p>
<p>communicate with the DHCP server.)</p>
<p>The following limitations apply to run-mode partnering:</p>
<p>â¢</p>
<p>Automatic establishment of the INDRT2/INDRT connection is aborted if you</p>
<p>are stepping through kernel startup code or if any breakpoints are set on the</p>
<p>freeze-mode connection when MULTI initializes the INDRT2/INDRT</p>
<p>connection.</p>
<p>â¢</p>
<p>If you are running a pre-INTEGRITY-10 kernel, the INDRT connection is only</p>
<p>automatically established if the Idle Task gets to runâthat is, if your system</p>
<p>has at least some idle time and the processor is not being fully scheduled by</p>
<p>the kernel.</p>
<p>See also âTroubleshootingâ on page 73.</p>
<p><b>Setting a Run-Mode Partner</b></p>
<p>The<b> Set Run-Mode Partner</b> dialog box appears automatically the first time you</p>
<p>download and run your INTEGRITY kernel using a freeze-mode Connection</p>
<p>Method. Select an existing INDRT2/INDRT Connection Method in the drop-down</p>
<p>list, or create a new INDRT2/INDRT Connection Method by clicking the<b> Create</b></p>
<p><b>a new Connection Method</b> (</p>
<p>) button. The INDRT2/INDRT connection is</p>
<p>automatically established when your INTEGRITY kernel boots.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>70</i></p>
<p><i>Chapter 4. INDRT2 (rtserv2) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To modify the run-mode partner setting for your freeze-mode Connection Method,</p>
<p>perform one of the following actions:</p>
<p>â¢</p>
<p>Select a freeze-mode connection in the target list, and choose<b> Target</b> â<b> Set</b></p>
<p><b>Run-Mode Partner</b>, or enter<b> set_runmode_partner</b> in the command pane.</p>
<p>(For information about the<b> set_runmode_partner</b> command, see âGeneral</p>
<p>Target Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.) Select or</p>
<p>create a run-mode Connection Method.</p>
<p>â¢</p>
<p>Use the<b> Connection Editor</b> to edit the freeze-mode Connection Method. Select</p>
<p>the<b> INTEGRITY</b> or<b> Connection</b> tab, and enter the name of an existing</p>
<p>INDRT2/INDRT Connection Method in the text field labeled<b> Run-Mode</b></p>
<p><b>Partner Connection</b>. For information about the<b> Connection Editor</b>, see</p>
<p>âConfiguring a Standard Connection with the Connection Editorâ on page 44.</p>
<p>The INDRT2/INDRT connection you specify is automatically established when</p>
<p>your INTEGRITY kernel boots.</p>
<p><b>Tip</b></p>
<p>If you lose your INDRT2/INDRT connection, you can enter the command</p>
<p><b>connect -restart_runmode</b> in the Debugger command pane to try to</p>
<p>reconnect. For more information, see the<b> connect</b> command in âGeneral</p>
<p>Target Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p><b>The Set Run-Mode Partner Dialog Box</b></p>
<p>The<b> Set Run-Mode Partner</b> dialog box allows you to configure the automatically</p>
<p>established INDRT2/INDRT connection for your current freeze-mode connection.</p>
<p>For information about accessing the<b> Set Run-Mode Partner</b> dialog box, see âSetting</p>
<p>a Run-Mode Partnerâ on page 70.</p>
<p><i>71</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Set Run-Mode Partner Dialog Box</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Set Run-Mode Partner</b> dialog box contains the following options:</p>
<p>â¢</p>
<p><b>Yes, use</b> â Specifies the INDRT2/INDRT Connection Method that the</p>
<p>Debugger automatically attempts to establish when you boot an INTEGRITY</p>
<p>kernel via the current freeze-mode connection. The drop-down list contains</p>
<p>known INDRT2/INDRT Connection Methods and, for versions 10 and later</p>
<p>of INTEGRITY, an additional entry labeled<b> Automatically Constructed</b>.</p>
<p>When you select<b> Automatically Constructed</b>, the operating system itself</p>
<p>attempts to tell the Debugger what address and Method to use to create an</p>
<p>INDRT2 connection to the target.</p>
<p>â¢</p>
<p><b>No</b> â Disables the automatic establishment of an INDRT2/INDRT connection</p>
<p>when you boot an INTEGRITY kernel via the current freeze-mode connection.</p>
<p>â¢</p>
<p><b>Save this choice across sessions</b> â If selected, the settings in the dialog box</p>
<p>are associated with the current freeze-mode debug connection and used in</p>
<p>future debug sessions. If cleared, the dialog box settings are used only until</p>
<p>you exit MULTI, after which the freeze-mode connection reverts to whatever</p>
<p>run-mode partner it had last (if any).</p>
<p><i>MULTI: Debugging</i></p>
<p><i>72</i></p>
<p><i>Chapter 4. INDRT2 (rtserv2) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Disabling Automatically Established Run-Mode Connections</b></p>
<p>To disable run-mode partnering for a particular freeze-mode connection, perform</p>
<p>the following steps:</p>
<p>1.</p>
<p>In the target list, select the freeze-mode connection.</p>
<p>2.</p>
<p>Select<b> Target</b> â<b> Set Run-Mode Partner</b>.</p>
<p>3.</p>
<p>In the<b> Set Run-Mode Partner</b> dialog box, select<b> No</b>.</p>
<p>4.</p>
<p>Optionally select<b> Save this choice across sessions</b>.</p>
<p>5.</p>
<p>Click<b> OK</b>.</p>
<p>Alternatively, you can select the freeze-mode connection in the target list and enter</p>
<p><b>set_runmode_partner -none</b> in the Debugger command pane. For information</p>
<p>about the<b> set_runmode_partner</b> command, see âGeneral Target Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Troubleshooting</b></p>
<p>You may encounter the following problems while debugging via a simultaneous</p>
<p>freeze-mode connection and an INDRT2/INDRT (run-mode) connection to the</p>
<p>same target, regardless of whether or not the INDRT2/INDRT connection was</p>
<p>created automatically via the run-mode partner functionality, or whether or not the</p>
<p>freeze-mode and INDRT2/INDRT connections were created within the same</p>
<p>Debugger process.</p>
<p>â¢</p>
<p>Host I/O calls made on a freeze-mode connection can cause an INDRT2/INDRT</p>
<p>connection to the same target to become unresponsive for the duration of the</p>
<p>host I/O call. Note that some host I/O calls (for example, large block reads</p>
<p>from, or writes to, host files) can take a long time for the Debugger to process.</p>
<p>Also note that some host I/O calls, such as reads from standard input, may</p>
<p>block indefinitely, waiting for you to type input in the I/O pane. To avoid this</p>
<p>problem, do not write code that makes freeze-mode host I/O calls.</p>
<p>â¢</p>
<p>Host I/O calls made on an INDRT2/INDRT connection can cause your program</p>
<p>to hang. To remedy this, disconnect from the INDRT2/INDRT connection.</p>
<p>â¢</p>
<p>Breakpoints that are set on a freeze-mode connection can cause the</p>
<p>INDRT2/INDRT connection to the same target to become unresponsive until</p>
<p><i>73</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Disabling Automatically Established Run-Mode Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>the freeze-mode connection is resumed. This applies regardless of whether</p>
<p>hitting the breakpoint leaves the target halted, as in the case of a regular software</p>
<p>breakpoint, or whether it resumes the target, as in the case of a conditional</p>
<p>breakpoint whose condition is false. To avoid this problem, remove all</p>
<p>freeze-mode breakpoints before initiating the INDRT2/INDRT connection.</p>
<p>â¢</p>
<p>A single instance of the MULTI Debugger can deadlock between a freeze-mode</p>
<p>connection and an INDRT2/INDRT connection to the same target, even though</p>
<p>various safeguards have been introduced to prevent this problem in common</p>
<p>cases. If you encounter this problem, after a short delay (configurable via</p>
<p>MULTI's</p>
<p>SERVERTIMEOUT</p>
<p>system variable), you may see a dialog box saying</p>
<p><b>Server message timed out. Terminate Connection?</b> with buttons labeled</p>
<p><b>Continue</b> and<b> Terminate</b>. To regain control of the Debugger and freeze-mode</p>
<p>connection, click<b> Terminate</b>. You may also be able to re-initiate the</p>
<p>INDRT2/INDRT connection request after this. To avoid this problem, launch</p>
<p>a separate instance of the MULTI Debugger to connect to the target via the</p>
<p>INDRT2/INDRT Connection Method.</p>
<p>Using the run-mode partner functionality is preferable to manually establishing an</p>
<p>INDRT2/INDRT connection. However, if you must manually establish an</p>
<p>INDRT2/INDRT connection, do so several seconds after booting your kernel via</p>
<p>the freeze-mode connection. For example, wait for the INTEGRITY kernel banner</p>
<p>to appear on your target's serial port before connecting via a run-mode debug server</p>
<p>such as<b> rtserv</b> or<b> rtserv2</b>.</p>
<p><b>Connecting to Multiple ISIM Targets</b></p>
<p>By default, the INTEGRITY simulator (ISIM) accepts INDRT2 connections on the</p>
<p>default UDP socket port of 2220. Only one ISIM instance on a given host can listen</p>
<p>on a particular port. To connect to multiple ISIM instances on the same host, some</p>
<p>of the ISIM instances must listen on different ports.</p>
<p>For example, to create an ISIM connection that listens on port 3330 instead of port</p>
<p>2220, first configure a connection to the simulator:</p>
<p>1.</p>
<p>In the<b> Connection Chooser</b>, click the<b> Create a New Connection Method</b></p>
<p>(</p>
<p>) button.</p>
<p>2.</p>
<p>For the connection type, select<b> INTEGRITY Simulator (isim)</b> and click</p>
<p><b>Create</b>. The<b> Connection Editor</b> will open.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>74</i></p>
<p><i>Chapter 4. INDRT2 (rtserv2) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Select the<b> Debug</b> tab. In the<b> Other Options</b> field enter:</p>
<p>-host_indrt_port 3330</p>
<p>Then configure an INDRT2 (<b>rtserv2</b>) connection to work with the simulator</p>
<p>connection you just set up:</p>
<p>1.</p>
<p>Create a custom INDRT2 connection in the following format:</p>
<p><b>rtserv2</b> [-log=<i>filename</i>] localhost[:<i>portnumber</i>]</p>
<p>2.</p>
<p>Select your INDRT2 connection in the<b> Connection Chooser</b>, and click the</p>
<p><b>Edit the selected Connection Method</b> button (</p>
<p>).</p>
<p>3.</p>
<p>In the<b> Connection Editor</b>, select the<b> Connection</b> tab and enter</p>
<p>localhost:3330</p>
<p>in the<b> Target Name or Address</b> field.</p>
<p>When using socket emulation for TCP/IP communications on an ISIM target, those</p>
<p>emulated socket ports may also conflict with other ISIM instances or with the hostâs</p>
<p>reserved ports or running services. These ports can also be remapped. For more</p>
<p>information, see the documentation about ISIM socket port remapping in the</p>
<p><i>INTEGRITY Development Guide</i>.</p>
<p><i>75</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Connecting to Multiple ISIM Targets</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 5</b></p>
<p><b>INDRT (rtserv) Connections</b></p>
<p><b>Contents</b></p>
<p>Introduction to rtserv and INDRT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>78</p>
<p>Building in Run-Mode Debugging Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>79</p>
<p>Connecting Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>80</p>
<p>INDRT Connection Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>80</p>
<p>Connecting with rtserv over the ARM Debug Comm Channel . . . . . . . . . . . . .</p>
<p>88</p>
<h1 style="page-break-before:always; "></h1>
<p>INDRT is a software interface provided by Green Hills that facilitates run-mode</p>
<p>debugging of the INTEGRITY real-time operating system (version 5). INDRT and</p>
<p><b>rtserv</b>, the debug server that supports INDRT connections, are installed automatically</p>
<p>when you install a distribution of the MULTI IDE that supports INDRT connections.</p>
<p>This chapter supplements the general target connection information in Chapter 3,</p>
<p>âConnecting to Your Targetâ on page 39 with specific information for INDRT</p>
<p>connections.</p>
<p>For more information about run-mode connections, including a caveat to</p>
<p>simultaneously debugging multiple targets in run mode, see âEstablishing Run-Mode</p>
<p>Connectionsâ on page 578.</p>
<p><b>Introduction to rtserv and INDRT</b></p>
<p>Debug servers such as<b> rtserv</b> enable communication between the host and the target.</p>
<p>During a debugging session, the MULTI Debugger sends<b> rtserv</b>, a host-resident</p>
<p>debug server, requests to read registers, write to memory, etc. In turn,<b> rtserv</b> sends</p>
<p>the debugging requests to the target. You can use the<b> rtserv</b> debug server to connect</p>
<p>to a running INTEGRITY system (version 5) to perform run-mode debugging.</p>
<p><b>rtserv</b> enables advanced features such as dynamic downloading of virtual</p>
<p>AddressSpaces, and use of tools such as the<b> Profile</b> window. When you are</p>
<p>connected to<b> rtserv</b>, the target list displays all the tasks in the system. Any user</p>
<p>task in the target list can be selected and individually debugged.</p>
<p><b>Communication Media</b></p>
<p>An INDRT (<b>rtserv</b>) connection can be established over an IP network (typically</p>
<p>Ethernet) or a serial link. A BSP typically provides drivers to support an Ethernet</p>
<p>or serial device.</p>
<p>The following are general recommendations for INDRT (<b>rtserv</b>) connections:</p>
<p>â¢</p>
<p>Use a fast and reliable IP network (such as Ethernet) whenever possible for</p>
<p>better performance.</p>
<p>â¢</p>
<p>For BSPs that support only one serial port, the port cannot be used for debugging</p>
<p>when it is being used for diagnostics. If the serial port is already in use, close</p>
<p><i>MULTI: Debugging</i></p>
<p><i>78</i></p>
<p><i>Chapter 5. INDRT (rtserv) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>the terminal program used to view the serial port output before establishing</p>
<p>your run-mode connection.</p>
<p>â¢</p>
<p>The baud rate at which a particular BSP communicates over a serial port varies.</p>
<p>For details, see the documentation that came with your BSP.</p>
<p><b>Building in Run-Mode Debugging Support</b></p>
<p>To enable run-mode debugging support, an INTEGRITY kernel program must be</p>
<p>linked with a debug library supplied by Green Hills. To include this library in an</p>
<p>existing kernel or monolith project:</p>
<p>1.</p>
<p>In the Project Manager, locate the<b> .gpj</b> file for the kernel within the project</p>
<p>(by default,<b> myproject_kernel.gpj</b>).</p>
<p>2.</p>
<p>Right-click the file, and select<b> Configure</b>.</p>
<p>3.</p>
<p>In the<b> Settings for Kernel</b> window that appears, select the<b> Debugging</b> check</p>
<p>box.</p>
<p><i>79</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Building in Run-Mode Debugging Support</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Connecting Overview</b></p>
<p>You can establish a debug server connection in any of the following ways. Each is</p>
<p>discussed in more detail in the section referenced.</p>
<p>â¢</p>
<p>Graphically configure a Connection Method. For a set of steps to follow, see</p>
<p>âConnecting to rtserv via the Connection Organizer and Connection Editorâ</p>
<p>on page 84. For reference information that supplements the general information</p>
<p>in Chapter 3, âConnecting to Your Targetâ on page 39, see the next section.</p>
<p>â¢</p>
<p>Use a custom connection command. See âUsing Custom INDRT (rtserv)</p>
<p>Connection Methodsâ on page 86.</p>
<p>â¢</p>
<p>Set up a run-mode partner. See âAutomatically Establishing Run-Mode</p>
<p>Connectionsâ on page 69.</p>
<p><b>INDRT Connection Methods</b></p>
<p>To help you connect to your target quickly and easily, MULTI allows you to create</p>
<p>and save Connection Methods that correspond to your particular host and target</p>
<p>systems and your desired debugging options.</p>
<p>For general instructions that explain how to create and use Connection Methods,</p>
<p>see Chapter 3, âConnecting to Your Targetâ on page 39. The information in the</p>
<p>following sections supplements the instructions provided there with information</p>
<p>that is specific to INDRT connections.</p>
<p><b>Using the INDRT (rtserv) Connection Editor</b></p>
<p>In addition to the generic fields that appear on all<b> Connection Editors</b> for Standard</p>
<p>Connection Methods (see the documentation about the Connection Editor in the</p>
<p><i>MULTI: Configuring Connections</i> book), the<b> INDRT (rtserv) Connection Editor</b></p>
<p>includes<b> Connection</b>,<b> Advanced</b>, and<b> Debug</b> tabs that provide settings and options</p>
<p>specific to your target and host operating systems.</p>
<p>When the<b> Connection Editor</b> is first displayed after you create a new Connection</p>
<p>Method, the settings and options are set to default values. Settings and options that</p>
<p>are not available on your host operating system may appear dimmed. Some of the</p>
<p>fields may require user input before the Connection Method can be used.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>80</i></p>
<p><i>Chapter 5. INDRT (rtserv) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Each field is described in the following sections.</p>
<p><b>INDRT (rtserv) Connection Settings</b></p>
<p><b>Ethernet/IP Connection</b></p>
<p>Sets your desired connection type as Ethernet/IP. This radio button is mutually exclusive with</p>
<p>the<b> Serial Connection</b> button. If you select an Ethernet/IP connection (this is the default), the</p>
<p>following fields will also be available:</p>
<p>â¢</p>
<p><b>Target Name or Address</b> â Specifies the host name or IP address of your target. You</p>
<p>must specify a host name or IP address to create a valid Ethernet/IP connection.</p>
<p>â¢</p>
<p><b>TFTP Load Directory</b> â Specifies a load directory for dynamic downloading via TFTP.</p>
<p>This is the directory to which<b> rtserv</b> will copy a file before requesting a download. Enter</p>
<p>the name of your desired TFTP load directory or click<b> Choose</b> to browse to it. The specified</p>
<p>directory must be accessible by the TFTP server.</p>
<p><b>Note</b>: If you need to connect to your target using a non-standard UDP port number (that is, not</p>
<p>2220), you must use a Custom Connection Method. See âUsing Custom INDRT (rtserv)</p>
<p>Connection Methodsâ on page 86 for instructions.</p>
<p><i>81</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the INDRT (rtserv) Connection Editor</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Serial Connection</b></p>
<p>Specifies that a serial connection to the target should be used. This radio button is mutually</p>
<p>exclusive with the<b> Ethernet/IP Connection</b> button. If you select a serial connection, the</p>
<p>following option fields will also be available:</p>
<p>â¢</p>
<p><b>Serial Port</b> â Specifies which host serial port to use for your serial INDRT connection.</p>
<p>In the event that you do not specify a port, the default serial port for each supported host</p>
<p>operating system is listed below:</p>
<p>â</p>
<p>Windows â<b> COM1</b></p>
<p>â</p>
<p>Linux â<b> /dev/ttyS0</b></p>
<p>â</p>
<p>Solaris â<b> /dev/ttya</b></p>
<p>â¢</p>
<p><b>Baud Rate</b> â Specifies the serial port communication speed. The default baud rate is</p>
<p>9600</p>
<p>.</p>
<p><b>INDRT (rtserv) Advanced Settings</b></p>
<p><b>Warning</b></p>
<p>Use this tab carefully, since changing the advanced options from their</p>
<p>default settings can cause problems with your connection.</p>
<p><b>BSD Exclusive Serial Port Access</b></p>
<p>Solaris only</p>
<p>Enables exclusive serial port access.</p>
<p>By default, the serial port is opened in exclusive, or locked, mode. If you are connecting through</p>
<p>a terminal server, clear this box to disable exclusive serial port access.</p>
<p><b>Always Use TFTP for Load</b></p>
<p>Forces<b> rtserv</b> to use TFTP for downloads, even when the system defaults to a different download</p>
<p>method (for example, host I/O).</p>
<p><i>MULTI: Debugging</i></p>
<p><i>82</i></p>
<p><i>Chapter 5. INDRT (rtserv) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>INDRT (rtserv) Debug Settings</b></p>
<p><b>Warning</b></p>
<p>Do not change the settings on the<b> Debug</b> tab unless you are instructed to</p>
<p>do so by Green Hills Technical Support.</p>
<p><b>Log Host-Target Debug Output</b></p>
<p>Enables logging of all communications between<b> rtserv</b> and your target. Logging is disabled by</p>
<p>default.</p>
<p><b>StdErr/StdOut</b></p>
<p><b>File</b></p>
<p>Allows you to specify the destination for host-target debug output. These fields will be dimmed</p>
<p>unless<b> Log Host-Target Debug Output</b> is selected.</p>
<p>If you choose<b> StdErr/StdOut</b>, host-target debug output will be directed to the console. This</p>
<p>setting is not supported on Windows hosts. To log debug output on Windows, select<b> File</b>.</p>
<p>If you select<b> File</b>, host-target debug output will be directed to the file you specify in the text</p>
<p>field. You may enter a filename directly into this text field, or click<b> Choose</b> to browse the file</p>
<p>system.</p>
<p><b>Other Options</b></p>
<p>Allows you to add other optional arguments directly to the command used for connecting. You</p>
<p>should only use this field if directed to do so by Green Hills Technical Support.</p>
<p><i>83</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the INDRT (rtserv) Connection Editor</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Connecting to rtserv via the Connection Organizer and Connection</b></p>
<p><b>Editor</b></p>
<p>This section provides a practical set of steps that you can follow to connect to your</p>
<p>INTEGRITY target. This set of steps, which uses the<b> Connection Organizer</b> and</p>
<p><b>Connection Editor</b>, outlines one of the many possible ways in which you can</p>
<p>connect. For information about other ways to connect to your target, see Chapter 3,</p>
<p>âConnecting to Your Targetâ on page 39.</p>
<p>1.</p>
<p>In the MULTI Project Manager, open the Top Project that came with your</p>
<p>BSP, or, if you already have an existing project for your BSP, open its Top</p>
<p>Project.</p>
<p>Each BSP contains example connections that you can customize for your own</p>
<p>use. These same connections are used by the<b> Project Wizard</b> for every project</p>
<p>created for that BSP.</p>
<p>2.</p>
<p>In the MULTI Project Manager, select<b> Connect</b> â<b> Connection Organizer</b>.</p>
<p>3.</p>
<p>In the<b> Opened Connection Files</b> list, select<b> default.con</b>.</p>
<p>4.</p>
<p>Modify or create a connection:</p>
<p>â¢</p>
<p>To modify an existing connection (recommended) â Double-click the</p>
<p><b>Dynamic Download/INDRT Connection</b> to open the<b> Connection Editor</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>84</i></p>
<p><i>Chapter 5. INDRT (rtserv) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>To create a new connection â Select<b> Method</b> â<b> New</b>. In the<b> Create</b></p>
<p><b>New Connection Method</b> dialog box, specify a<b> Name</b>, and select<b> INDRT</b></p>
<p><b>(rtserv)</b> as the<b> Type</b>. Click<b> Create</b> to open the<b> Connection Editor</b>.</p>
<p>5.</p>
<p>The<b> INDRT (rtserv) Connection Editor</b> includes<b> Connection</b>,<b> Advanced</b>,</p>
<p>and<b> Debug</b> tabs to set options specific to your target and host operating systems.</p>
<p>When you first open the<b> Connection Editor</b>, the options are set to default</p>
<p>values. Some fields may require user input. For a description of each field, see</p>
<p>âINDRT (rtserv) Connection Settingsâ on page 81, âINDRT (rtserv) Advanced</p>
<p>Settingsâ on page 82, and âINDRT (rtserv) Debug Settingsâ on page 83.</p>
<p>6.</p>
<p>After customizing the connection, click<b> OK</b> to return to the<b> Connection</b></p>
<p><b>Organizer</b>.</p>
<p>7.</p>
<p>Ensure that you are running a properly configured INTEGRITY kernel (see</p>
<p>âBuilding in Run-Mode Debugging Supportâ on page 79).</p>
<p>8.</p>
<p>Right-click the<b> Dynamic Download/INDRT Connection</b>, and select<b> Connect</b></p>
<p><b>to Target</b>.</p>
<p><b>Using TFTP</b></p>
<p>In releases of INTEGRITY prior to version 5, TFTP was used for fast dynamic</p>
<p>downloads. In INTEGRITY 5, fast downloads are accomplished via the built-in</p>
<p>INDRT protocol, and TFTP is no longer necessary. However, there may be situations</p>
<p>where you want to force the use of TFTP. To do so:</p>
<p>1.</p>
<p>On the<b> Connection</b> tab of the<b> Connection Editor</b>, set the<b> TFTP Load</b></p>
<p><b>Directory</b>.</p>
<p>2.</p>
<p>On the<b> Advanced</b> tab, select<b> Always Use TFTP for Load</b>.</p>
<p>3.</p>
<p>Click<b> OK</b> or<b> Apply</b>.</p>
<p><i>85</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the INDRT (rtserv) Connection Editor</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Using Custom INDRT (rtserv) Connection Methods</b></p>
<p>You can create a Custom INDRT (<b>rtserv</b>) Connection Method by manually entering</p>
<p>a connection command into the<b> Connection Chooser</b> instead of using the graphical</p>
<p><b>Connection Editor</b>.</p>
<p>To establish an INDRT connection using a Custom Connection Method:</p>
<p>1.</p>
<p>Open the<b> Connection Chooser</b>. One way to do so is to click the<b> Connect</b></p>
<p>button (</p>
<p>) in the MULTI Project Manager.</p>
<p>2.</p>
<p>In the<b> Connection Chooser</b>, click<b> Custom</b>.</p>
<p>3.</p>
<p>In the<b> Start a Custom Connection</b> field, enter a connection command with</p>
<p>appropriate options.</p>
<p>â¢</p>
<p>To establish an IP connection to a board running INTEGRITY with a BSP</p>
<p>that supports Ethernet, enter a command similar to the following.</p>
<p>rtserv -port udp@integrity1</p>
<p>In this example,</p>
<p>integrity1</p>
<p>is the host name that the system</p>
<p>administrator has set up for the board.</p>
<p>â¢</p>
<p>To establish a serial debugging connection, enter the following command</p>
<p>(port selection may vary):</p>
<p>rtserv com1 9600 (Windows)</p>
<p>rtserv /dev/ttya 9600 (Solaris)</p>
<p>â¢</p>
<p>To establish a debugging connection over the ARM debug comm channel</p>
<p>using the Green Hills Probe or Slingshot as a communications channel,</p>
<p>simply connect as if over an IP network to the IP address of the host that</p>
<p>is running<b> mpserv</b>, after configuring<b> mpserv</b> and the target system</p>
<p><i>MULTI: Debugging</i></p>
<p><i>86</i></p>
<p><i>Chapter 5. INDRT (rtserv) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>appropriately. For more details, see âConnecting with rtserv over the ARM</p>
<p>Debug Comm Channelâ on page 88.</p>
<p><b>Always Connect Mode</b></p>
<p><b>rtserv</b> accepts the<b> -alwaysconnect</b> option, which enables always connect mode. A</p>
<p>Custom Connection Method must be used to specify this option (it is not accessible</p>
<p>from the<b> Connection Organizer</b> GUI).</p>
<p>In always connect mode:</p>
<p>â¢</p>
<p>An<b> rtserv</b> session is always established, even if the user-specified target is not</p>
<p>up and running yet.</p>
<p>â¢</p>
<p>The target list provides an indication that a target is not up yet with a task entry</p>
<p>named<b> NOT CONNECTED</b>.</p>
<p>â¢</p>
<p>When the target does come up,<b> rtserv</b> automatically connects (the target is</p>
<p>polled periodically).</p>
<p>â¢</p>
<p>While one or more targets are in the<b> NOT CONNECTED</b> state, debugging of</p>
<p>the connected targets is slower because of the background polling of the</p>
<p>unconnected targets.</p>
<p>This mode is useful when you want to establish an<b> rtserv</b> session without necessarily</p>
<p>knowing or caring whether the target is up yet (or if you tend to forget to boot a</p>
<p>target first).</p>
<p><b>Note</b></p>
<p>This is simply a method for delaying connection. Targets that go down</p>
<p>do not revert to the<b> NOT CONNECTED</b> status.</p>
<p><i>87</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using Custom INDRT (rtserv) Connection Methods</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Connecting with rtserv over the ARM Debug Comm Channel</b></p>
<p>To enable forwarding of<b> rtserv</b> communications over the ARM debug comm channel</p>
<p>using the Green Hills Probe, run the<b> mpserv</b> debug server with a special option as</p>
<p>follows:</p>
<p>-runmode_port 2220</p>
<p>This instructs<b> mpserv</b> to forward<b> rtserv</b> packets between the ARM debug comm</p>
<p>channel and UDP port 2220 (the standard INDRT target connection port). To connect</p>
<p>with<b> rtserv</b> over this port, specify a connection using the hostâs IP address.</p>
<p>Debugging performance over the ARM debug comm channel is adequate for most</p>
<p>debugging tasks, but dynamic downloading of applications can take a long time to</p>
<p>complete.</p>
<p>The ARM debug comm channel interface is further described in the<i> INTEGRITY</i></p>
<p><i>Development Guide</i>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>88</i></p>
<p><i>Chapter 5. INDRT (rtserv) Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 6</b></p>
<p><b>Configuring Your Target</b></p>
<p><b>Hardware</b></p>
<p><b>Contents</b></p>
<p>Installing Your Target Hardware . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>90</p>
<p>Configuring Your Target Hardware for Debugging . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>90</p>
<p>Specifying Setup Scripts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>98</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes how to set up your target hardware for use with MULTI.</p>
<p>This chapter is not relevant if you are connecting to a simulated target.</p>
<p><b>Installing Your Target Hardware</b></p>
<p>Before you can configure your embedded target for use with MULTI, you must</p>
<p>install your hardware and any necessary software. Installation details depend on</p>
<p>your particular system. For detailed instructions, see your hardware documentation</p>
<p>and the chapter in the<i> MULTI: Configuring Connections</i> book that discusses your</p>
<p>debug server.</p>
<p><b>Configuring Your Target Hardware for Debugging</b></p>
<p>Before beginning your first debugging session, you should ensure that your target</p>
<p>board is configured properly. For many targets, you will need to run a board setup</p>
<p>script to initialize your target before downloading and running a program. This</p>
<p>script, along with required linker directives files that provide MULTI with</p>
<p>information about your target's memory map, are typically generated for you when</p>
<p>you create a new Top Project using the<b> Project Wizard</b> and Project Manager.</p>
<p>To create an example âHello Worldâ project for your target, follow the steps provided</p>
<p>in Chapter 1, âCreating a Projectâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book. If you can build and download the example (see âQuick</p>
<p>Start: Building and Running Hello Worldâ in Chapter 1, âCreating a Projectâ in the</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> book), the default board setup</p>
<p>script and linker directives file configured your target board properly and no</p>
<p>additional configuration is required. However, if you are using custom hardware,</p>
<p>or if you experience problems when downloading the program, you may need to</p>
<p>create or customize the setup script and/or customize the linker directives file in</p>
<p>use. The following sections provide customization guidelines and diagnostics that</p>
<p>you can use to make sure that these target resources are configured correctly.</p>
<p><b>Customizing MULTI Board Setup Scripts</b></p>
<p>A board setup script is a file that MULTI uses to initialize your target before</p>
<p>downloading and debugging a program. The default board setup script (if any) for</p>
<p>your target is copied in by the Project Manager when you create a new project.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>90</i></p>
<p><i>Chapter 6. Configuring Your Target Hardware</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Setup scripts in MULTI 6 use the following conventions and commands:</p>
<p>â¢</p>
<p>The MULTI scripting conventions described in Chapter 1, âUsing MULTI</p>
<p>Scriptsâ in the<i> MULTI: Scripting</i> book.</p>
<p>â¢</p>
<p>MULTI Debugger commands described in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book. You can find an overview of useful board setup script</p>
<p>commands in âUseful Commands for MULTI Board Setup Scriptsâ on page 94.</p>
<p>â¢</p>
<p>Debug server commands listed in the<i> MULTI: Configuring Connections</i> book</p>
<p>or, if you are using a Green Hills Debug Probe, in the documentation about</p>
<p>probe commands in the<i> Green Hills Debug Probes User's Guide</i>. You must</p>
<p>prefix debug server commands with the MULTI Debugger<b> target</b> command</p>
<p>(see âGeneral Target Connection Commandsâ in Chapter 18, âTarget</p>
<p>Connection Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>Note</b></p>
<p>Green Hills Monitor targets usually do not require a setup script.</p>
<p><b>Note</b></p>
<p>The following sections assume that you are using a MULTI board setup</p>
<p>script (<b>.mbs</b>). If you want to use a legacy setup script (<b>.dbs</b>) generated</p>
<p>by MULTI 4 or older, see âSpecifying Setup Scriptsâ on page 98 and</p>
<p>the documentation about Green Hills debug server scripts and commands</p>
<p>in the<i> MULTI: Configuring Connections</i> book.</p>
<p>To edit a MULTI board setup script to make it suitable for your system:</p>
<p>1.</p>
<p>Obtain your board and processor's documentation. You will need it to gather</p>
<p>information about memory resources, registers, interrupts, etc.</p>
<p>2.</p>
<p>Double-click the default setup script in your target resources project to open</p>
<p>it in an editor. If there are multiple setup scripts, choose the one containing</p>
<p>the name of the debug server that supports your specific debugging interface.</p>
<p>For example, if you are using the<b> mpserv</b> debug server, which supports Green</p>
<p>Hills Debug Probe connections, the default setup script file is</p>
<p><b>mpserv_standard.mbs</b>.</p>
<p><i>91</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Customizing MULTI Board Setup Scripts</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Determine whether your board can initialize itself, and then proceed as follows:</p>
<p>â¢</p>
<p>If your target does not have a valid ROM image that initializes the target</p>
<p>upon reset, skip to the next step.</p>
<p>â¢</p>
<p>If your target has a valid ROM image that initializes the target upon reset,</p>
<p>comment out the contents of the MULTI board setup script you are editing</p>
<p>by adding two forward slashes (</p>
<p>//</p>
<p>) to the beginning of each line. Replace</p>
<p>the script with the command sequence shown in the following (or with</p>
<p>an equivalent command sequence).</p>
<p>// Reset and halt the board</p>
<p>reset</p>
<p>// Let the ROM image run the target</p>
<p>c</p>
<p>// Give the ROM image 3 seconds to set up the board</p>
<p>wait -time 3000</p>
<p>// Halt the board to get ready for debugging</p>
<p>halt</p>
<p><b>Note</b></p>
<p>You may need to alter the<b> wait</b> command, depending on how</p>
<p>long your board takes to set itself up (for information about this</p>
<p>command, see Chapter 2, âGeneral Debugger Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p>If you need to initialize your board further, continue to the next step.</p>
<p>Otherwise, save the setup script and skip to âCustomizing Linker</p>
<p>Directives Filesâ on page 98.</p>
<p>4.</p>
<p>Verify that your setup script begins with a command that resets the target, such</p>
<p>as the MULTI Debugger<b> reset</b> command or the debug server<b> target tr</b></p>
<p>command. (For information about these commands, see âGeneral Target</p>
<p>Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book and the</p>
<p>documentation about probe commands in the<i> Green Hills Debug Probes User's</i></p>
<p><i>Guide</i>.)</p>
<p>Ensure that your target is halted before continuing initialization, or the state</p>
<p>of the target might be unpredictable.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>92</i></p>
<p><i>Chapter 6. Configuring Your Target Hardware</i></p>
<h1 style="page-break-before:always; "></h1>
<p>5.</p>
<p>Disable any interrupt sources that can disrupt the setup or destabilize the board's</p>
<p>memory. (For example, if you are using a PowerPC 860 processor, disable the</p>
<p>watchdog timer to prevent it from interrupting your target board setup.) The</p>
<p>following steps provide a general procedure for disabling interrupt sources:</p>
<p>a.</p>
<p>Determine whether your processor has any interrupt sources that might</p>
<p>disturb your debugging session.</p>
<p>b.</p>
<p>Using your processor's documentation, determine which registers affect</p>
<p>interrupt sources. Then determine the values those registers must have</p>
<p>to disable the interrupt sources.</p>
<p>c.</p>
<p>Enter the commands necessary to configure your memory resources into</p>
<p>your setup script. See âUseful Commands for MULTI Board Setup</p>
<p>Scriptsâ on page 94.</p>
<p>6.</p>
<p>Configure your target's memory controller based on your board's memory</p>
<p>resources. If your memory controller and memory resources are already</p>
<p>properly configured, skip to the next step. The following are general steps for</p>
<p>configuring memory using a setup script:</p>
<p>a.</p>
<p>Determine what memory resources your board has by answering the</p>
<p>following:</p>
<p>â¢</p>
<p>How fast and how big is the board's memory, and where do you want</p>
<p>to map it?</p>
<p>â¢</p>
<p>Does the board have SRAM? If so, where is it?</p>
<p>â¢</p>
<p>Does the board have DRAM? If so, where is it, and where is the</p>
<p>DRAM controller for it?</p>
<p>â¢</p>
<p>Does the DRAM controller need refresh timing information or</p>
<p>knowledge of any special modes the DRAM chips may have, such</p>
<p>as Synchronous DRAM?</p>
<p>â¢</p>
<p>Does the board require a peripheral memory base register to access</p>
<p>memory controllers or other on-chip peripherals?</p>
<p>b.</p>
<p>If your processor requires you to set up the base register before you can</p>
<p>access your memory controllers or other on-chip peripherals, set the base</p>
<p>register.</p>
<p>c.</p>
<p>Using your processor's documentation and memory resources, determine</p>
<p>which memory-related registers you must set. Additionally, determine</p>
<p>what values those registers must have to properly configure your memory</p>
<p>resources.</p>
<p><i>93</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Customizing MULTI Board Setup Scripts</i></p>
<h1 style="page-break-before:always; "></h1>
<p>d.</p>
<p>Enter the commands necessary to configure your memory resources into</p>
<p>your setup script (for more information, see âUseful Commands for</p>
<p>MULTI Board Setup Scriptsâ on page 94).</p>
<p>7.</p>
<p>Save your setup script. For information about specifying and running the script,</p>
<p>see âSpecifying Setup Scriptsâ on page 98.</p>
<p><b>Testing Individual Commands</b></p>
<p>If you have connected MULTI to your target, you can use the MULTI Debugger's</p>
<p>command pane to confirm the success or failure of each command individually</p>
<p>instead of trying to debug an entire setup script.</p>
<p>Some commands cannot be tested individually because they must be executed within</p>
<p>a certain time period in relation to other commands. In this case, put the relevant</p>
<p>commands into a small script and run the script from the Debugger's command pane</p>
<p>using the<b> &lt;</b> command, or type them in the same command line, separated by</p>
<p>semicolons (</p>
<p>;</p>
<p>). (For information about the<b> &lt;</b> command, see âRecord and Playback</p>
<p>Commandsâ in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.)</p>
<p><b>Useful Commands for MULTI Board Setup Scripts</b></p>
<p>You can find complete documentation for all MULTI Debugger commands in the</p>
<p><i>MULTI: Debugging Command Reference</i> book. However, only a small subset of</p>
<p>these commands are needed for most setup scripts. The following table outlines</p>
<p>these commands.</p>
<p><b>addhook</b></p>
<p>Adds a hook to a Debugger action.</p>
<p><b>c</b></p>
<p>Continues a stopped target.</p>
<p><b>clearhooks</b></p>
<p>Removes hooks.</p>
<p><b>eval</b></p>
<p>Evaluates an expression without printing the result.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>94</i></p>
<p><i>Chapter 6. Configuring Your Target Hardware</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>halt</b></p>
<p>Halts the target.</p>
<p><b>memread</b></p>
<p>Performs a sized memory read from the target, and prints the result.</p>
<p><b>memwrite</b></p>
<p>Performs a sized memory write to the target.</p>
<p><b>reset</b></p>
<p>Resets the target.</p>
<p><b>target</b></p>
<p>Transmits commands directly to the debug server. Use this command before a debug server</p>
<p>command. For example, to pass the<b> tr</b> Green Hills Debug Probe command to<b> mpserv</b> using the</p>
<p>Debugger, type:</p>
<p>target tr</p>
<p>To pass the output of a MULTI command to a debug server command, use the following syntax:</p>
<p>target<i> command</i> %EVAL{<i>multi_command</i>}</p>
<p><b>wait</b></p>
<p>Blocks command processing.</p>
<p>$<i>register</i> =<i> value</i></p>
<p>Sets a register named<i> register</i> on your target board to<i> value</i>. For example:</p>
<p>&gt; $ivor0 = 0x10</p>
<p>$<i>register</i>.<i>field</i> =<i> value</i></p>
<p>Sets a field in<i> register</i> to<i> value</i>. For example:</p>
<p>&gt; $CPSR.F = 1</p>
<p>If the name you specify for<i> register</i> is not a named register, MULTI creates a new variable using</p>
<p>the name provided. For example, the following command creates a new variable called</p>
<p>$FOO</p>
<p>and sets its value to</p>
<p>6</p>
<p>:</p>
<p>&gt; $FOO = 6</p>
<p>You can also use C-style expressions for complex memory manipulation. For example:</p>
<p>&gt; *((unsigned int *) 0x8000) |= 0x10</p>
<p><i>95</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Customizing MULTI Board Setup Scripts</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Example MULTI Board Setup Script</b></p>
<p>This example script sets up the Motorola MBX for running programs. Even if you</p>
<p>are not using this board, this example contains techniques that may be useful when</p>
<p>you write a script for your hardware.</p>
<p>// delay slow</p>
<p>// Reset the processor</p>
<p>target rst</p>
<p>// set the internal register space to 0xff000000</p>
<p>$immr=0xff000000</p>
<p>// turn off the watchdog timer --- disable always</p>
<p>memwrite 4</p>
<p>0xff000004 0xffffff88</p>
<p>// disable the cache</p>
<p>$dc_cst=0x04000000</p>
<p>// The board is configured to run at 40 MHz</p>
<p>// init set_clock=1 cpu_speed=40000000</p>
<p>// delay fast</p>
<p>// Setup memory</p>
<p>memwrite 4</p>
<p>0xFF00017C</p>
<p>0xCFAFC004</p>
<p>memwrite 4</p>
<p>0xFF000168</p>
<p>0x00000000</p>
<p>...</p>
<p>memwrite 2</p>
<p>0xFF00017A</p>
<p>0x0200</p>
<p><b>Testing Target Access</b></p>
<p>After you have created your new setup script, open your project in the MULTI</p>
<p>Debugger. At the bottom of the Debugger window is the command pane, which</p>
<p>you can use to send commands to MULTI. To run your project's default setup script:</p>
<p>â¢</p>
<p>Type<b> setup</b> in the command pane.</p>
<p>After running this command, test that your target is correctly initialized by</p>
<p>performing the diagnostics documented in the following sections.</p>
<p><b>Testing Register Access</b></p>
<p>To test your ability to access a register:</p>
<p>1.</p>
<p>Select a general purpose register (for example,</p>
<p>r1</p>
<p>on many targets).</p>
<p><i>MULTI: Debugging</i></p>
<p><i>96</i></p>
<p><i>Chapter 6. Configuring Your Target Hardware</i></p>
<h1 style="page-break-before:always; "></h1>
<p>2.</p>
<p>Read the register. For example:</p>
<p>&gt; $r1</p>
<p>3.</p>
<p>Write a different value to the same register. For example:</p>
<p>&gt; $r1=0xdeadbeef</p>
<p>4.</p>
<p>Read the register again and see if it has changed to the new value.</p>
<p>For information about testing the ability of a Green Hills Probe or SuperTrace Probe</p>
<p>to access your target's registers, see the documentation about configuring target</p>
<p>resources in the<i> Green Hills Debug Probes User's Guide</i>.</p>
<p><b>Testing Memory Access</b></p>
<p>To test your ability to access the target's memory:</p>
<p>1.</p>
<p>If you have not run your setup script, enter<b> setup</b> in the Debugger's command</p>
<p>pane.</p>
<p>2.</p>
<p>Select a location in memory where you plan to download a program (for</p>
<p>example,</p>
<p>0x8000</p>
<p>).</p>
<p>3.</p>
<p>Read the memory at this location by entering the following command:</p>
<p>&gt; memread 4 0x8000</p>
<p>4.</p>
<p>Write a different value to the same memory location:</p>
<p>&gt; memwrite 4 0x8000 0xdeadbeef</p>
<p>5.</p>
<p>Read the memory location again and see if it has changed to the new value. If</p>
<p>it has, the debugging interface is successfully accessing your target's memory.</p>
<p><b>Note</b></p>
<p>You can also use the graphical<b> Memory Tester</b> to test your target</p>
<p>memory. For more information, see Chapter 21, âTesting Target Memoryâ</p>
<p>on page 511.</p>
<p><i>97</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Testing Target Access</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For information about additional tests you can perform if you using a Green Hills</p>
<p>Probe or SuperTrace Probe, see the documentation about configuring target resources</p>
<p>in the<i> Green Hills Debug Probes User's Guide</i>.</p>
<p><b>Customizing Linker Directives Files</b></p>
<p>A linker directives (<b>.ld</b>) file controls how the linker links your executable and loads</p>
<p>it into memory. When you create a project for a target running stand-alone programs</p>
<p>using the<b> Project Wizard</b>, it creates several linker directives files and places them</p>
<p>in the target resources project (<b>tgt/resources.gpj</b>). The linker links any project you</p>
<p>add to your Top Project using one of these files, depending on that project's<b> Program</b></p>
<p><b>Layout</b> setting.</p>
<p>By default, the<b> Project Wizard</b> sets the<b> Program Layout</b> setting for new</p>
<p>stand-alone program projects to<b> Link to and Execute out of RAM</b>.</p>
<p><b>Note</b></p>
<p>You can change the<b> Program Layout</b> for your project by right-clicking</p>
<p>the program in the Project Manager and selecting<b> Configure</b>.</p>
<p>To edit your linker directives file:</p>
<p>1.</p>
<p>In the Project Manager, double-click the linker directives file in your program's</p>
<p>project to open it in an editor.</p>
<p>2.</p>
<p>Modify and save the edited linker directives file.</p>
<p>3.</p>
<p>Select the project (<b>.gpj</b>) file in the Project Manager and click</p>
<p>to rebuild it.</p>
<p>For more information, see the documentation about linker directives files in the</p>
<p><i>MULTI: Building Applications</i> book.</p>
<p><b>Specifying Setup Scripts</b></p>
<p>After you have a working setup script, you should run it prior to every download</p>
<p>to ensure that your target is properly configured. The following sections explain</p>
<p>how to specify and run board setup scripts depending on how you are connecting</p>
<p>to your target and whether you are using a MULTI (<b>.mbs</b>) or legacy (<b>.dbs</b>) board</p>
<p>setup script.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>98</i></p>
<p><i>Chapter 6. Configuring Your Target Hardware</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Using MULTI (.mbs) Setup Scripts When Connecting to Your Target</b></p>
<p>The method for specifying an<b> .mbs</b> setup script at the time of connection varies</p>
<p>depending upon the procedure you use to connect MULTI to your target:</p>
<p>â¢</p>
<p>To run an<b> .mbs</b> setup script every time you connect using a particular Standard</p>
<p>Connection Method, specify the filename of the script in the<b> Target Setup</b></p>
<p><b>script</b> field of the<b> Connection Editor</b> for the Connection Method and select</p>
<p>the<b> MULTI</b> radio button immediately below the field.</p>
<p>If you are using a default Connection Method created by the<b> Project Wizard</b>,</p>
<p>the necessary setup script file for your processor-board combination (if</p>
<p>applicable) is specified automatically and the<b> MULTI</b> button will be selected.</p>
<p>â¢</p>
<p>To run an<b> .mbs</b> setup script and connect to your target using a Custom</p>
<p>Connection Method:</p>
<p>â</p>
<p>If you are editing the Custom Connection Method using the<b> Connection</b></p>
<p><b>Editor</b>, specify the filename of the target setup script in the<b> Target Setup</b></p>
<p><b>script</b> field.</p>
<p>â</p>
<p>If you are entering the connection command using the<b> Start a Custom</b></p>
<p><b>Connection</b> field of the<b> Connection Chooser</b>, precede the debug server</p>
<p>command with the option<b> setup=<i>filename</b></i> (where<i> filename</i> is the<b> .mbs</b></p>
<p>setup script filename). Click<b> Connect</b> to continue.</p>
<p>â¢</p>
<p>To run an<b> .mbs</b> setup script when connecting from the Debugger command</p>
<p>pane, use the following syntax:</p>
<p><b>connect setup=<i>filename</i>.mbs<i> dbserv</b></i> [<i>args</i>]... [<i>opts</i>]...</p>
<p>where<i><b> filename</i>.mbs</b> is the setup script filename,<i> dbserv</i> is the name of the</p>
<p>debug server to be used, and<i> args</i> and<i> opts</i> are appropriate arguments for your</p>
<p>debug server and target.</p>
<p>For more information about the<b> connect</b> command, see âGeneral Target</p>
<p>Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p><i>99</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using MULTI (.mbs) Setup Scripts When Connecting to Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book and Chapter 3,</p>
<p>âConnecting to Your Targetâ on page 39.</p>
<p><b>Using Legacy (.dbs) Setup Scripts When Connecting to Your Target</b></p>
<p><b>Note</b></p>
<p>Support for legacy (<b>.dbs</b>) setup scripts is deprecated and may be removed</p>
<p>in a future release.</p>
<p>The method for specifying a legacy (<b>.dbs</b>) setup script at the time of connection</p>
<p>varies depending upon the procedure you use to connect MULTI to your target.</p>
<p>The various methods are:</p>
<p>â¢</p>
<p>To run a legacy setup script every time you connect using a particular Standard</p>
<p>Connection Method, specify the filename of the target setup script in the<b> Target</b></p>
<p><b>Setup script</b> field of the<b> Connection Editor</b> for the Connection Method. Select</p>
<p>the<b> Legacy</b> radio button immediately below the field.</p>
<p>â¢</p>
<p>To run a<b> .dbs</b> setup script and connect to your target using a Custom Connection</p>
<p>Method:</p>
<p>â</p>
<p>If you are editing the Custom Connection Method using the<b> Connection</b></p>
<p><b>Editor</b>, include the<b> -setup<i> filename</i>.dbs</b> debug server option in the</p>
<p><b>Arguments</b> field.</p>
<p>â</p>
<p>If you are entering the connection command using the<b> Start a Custom</b></p>
<p><b>Connection</b> field of the<b> Connection Chooser</b>, include the<b> -setup</b></p>
<p><i><b>filename</i>.dbs</b> debug server option in the command you enter and click</p>
<p><b>Connect</b>. For more information about connecting to your specific target</p>
<p>this way, see the appropriate debug server chapter in the<i> MULTI:</i></p>
<p><i>Configuring Connections</i> book.</p>
<p>â¢</p>
<p>To run a<b> .dbs</b> setup script from the Debugger command pane, use the following</p>
<p>syntax:</p>
<p><b>connect<i> dbserv</b></i> -setup<i> filename<b></i>.dbs</b> [<i>args</i>]... [<i>opts</i>]...</p>
<p><i>MULTI: Debugging</i></p>
<p><i>100</i></p>
<p><i>Chapter 6. Configuring Your Target Hardware</i></p>
<h1 style="page-break-before:always; "></h1>
<p>where<i><b> filename</i>.dbs</b> is the setup script filename,<i> dbserv</i> is the name of the</p>
<p>debug server to be used, and<i> args</i> and<i> opts</i> are appropriate arguments for your</p>
<p>debug server and target.</p>
<p><b>Running Setup Scripts Manually</b></p>
<p>In addition to running setup scripts as part of the connecting process, you can also</p>
<p>run setup scripts manually at other times using any of the following methods:</p>
<p>â¢</p>
<p>(MULTI<b> .mbs</b> scripts) Run your setup script file manually from the Debugger</p>
<p>command pane using the<b> &lt;</b> command. (For information about the<b> &lt;</b> command,</p>
<p>see âRecord and Playback Commandsâ in Chapter 15, âScripting Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.)</p>
<p>â¢</p>
<p>(MULTI<b> .mbs</b> scripts) Use the MULTI<b> setup<i> filename</i>.mbs</b> command. If this</p>
<p>command is used with a connection command, the setup script runs prior to</p>
<p>downloading and debugging. The<b> setup</b> command can also be used without a</p>
<p>specific script name if you are connected and specified a setup script when you</p>
<p>connected. The script you specified for the connection is run if you issue the</p>
<p><b>setup</b> command with no specified file. For more information about the<b> setup</b></p>
<p>command, see âGeneral Target Connection Commandsâ in Chapter 18, âTarget</p>
<p>Connection Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>â¢</p>
<p>(Legacy<b> .dbs</b> scripts) Use the<b> target script<i> filename</i>.dbs</b> command from the</p>
<p>Debugger command pane. (For more information, see the documentation about</p>
<p>Green Hills debug server commands in the<i> MULTI: Configuring Connections</i></p>
<p>book.)</p>
<p><b>Early MULTI Board Setup Scripts with Debugger Hooks</b></p>
<p>Ordinarily, MULTI (<b>.mbs</b>) board setup scripts are run every time you download a</p>
<p>program to your target, just before the download begins. However, in certain</p>
<p>circumstances and for certain targets (such as multi-core boards), it is not appropriate</p>
<p>to re-initialize the entire board every time you download a program to a given CPU</p>
<p>on that board.</p>
<p>If you write a setup script with a comment on the first line containing the marker</p>
<p>MBS_OPT=&quot;early&quot;</p>
<p>, the entire board setup script will be run once immediately</p>
<p><i>101</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Running Setup Scripts Manually</i></p>
<h1 style="page-break-before:always; "></h1>
<p>after you connect to your target instead of every time just before you download a</p>
<p>program. The comment should look similar to the following:</p>
<p>// MBS_OPT=&quot;early&quot;</p>
<p>When combined with the hook commands described in âHook Commandsâ in</p>
<p>Chapter 15, âScripting Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book, the &quot;early&quot; MULTI board setup script mechanism gives you</p>
<p>fine-grained control over how and when MULTI will set up your target. For example,</p>
<p>you can install hooks in your setup script to reinitialize the entire board upon reset</p>
<p>by using reset hooks to cause certain initializations to take place before reset and</p>
<p>certain others to take place afterwards.</p>
<p>addhook -before reset { /* Before reset work */ }</p>
<p>addhook -after reset -core 0 { /* After reset, core 0 work */ }</p>
<p>addhook -after reset -core 1 { /* After reset, core 1 work */ }</p>
<p>You can also add a hook to reset the board upon connecting, which causes your</p>
<p>reset hooks to run whenever you connect to the target with MULTI.</p>
<p>addhook -after connect { reset }</p>
<p>Lastly, you might decide to reinitialize a selected subset of the board circuitry every</p>
<p>time you download a program to one of the CPUs, while leaving the other CPUs</p>
<p>alone.</p>
<p>addhook -before download -core 0 { /* Core 0's initialization commands */ }</p>
<p>addhook -before download -core 1 { /* Core 1's initialization commands */ }</p>
<p><i>MULTI: Debugging</i></p>
<p><i>102</i></p>
<p><i>Chapter 6. Configuring Your Target Hardware</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 7</b></p>
<p><b>Preparing Your Target</b></p>
<p><b>Contents</b></p>
<p>Chapter Terminology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>104</p>
<p>Associating Your Executable with a Connection . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>105</p>
<p>Preparing Your Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>108</p>
<p>Related Settings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>115</p>
<p>Core File Debugging (Linux/Solaris only) . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>117</p>
<h1 style="page-break-before:always; "></h1>
<p>Before you can run or debug a program on your target, you must download it to the</p>
<p>target's RAM, program it into the target's flash memory, or verify through the</p>
<p>Debugger that it is already present on the target. This chapter describes how you</p>
<p>can prepare your target to be debugged using one of these methods.</p>
<p>In addition, this chapter discusses how to open the Debugger on a core file that</p>
<p>represents the state of your target at the time of a fatal signal. When you open the</p>
<p>Debugger on a core file, MULTI automatically establishes a connection and prepares</p>
<p>the target for you.</p>
<p><b>Chapter Terminology</b></p>
<p>This chapter uses terms that have specific meanings in the following sections. These</p>
<p>terms are defined in the list below:</p>
<p>â¢</p>
<p>Executable â Any executable; thread; or INTEGRITY application, module,</p>
<p>or kernel that you can select from the target list for debugging. This definition</p>
<p>only applies to this chapter.</p>
<p>â¢</p>
<p>CPU â An entity that an executable runs on. When debugging in freeze mode,</p>
<p>this is an actual CPU. When debugging in run mode, it is the CPU abstraction</p>
<p>provided by the operating system, which in some cases corresponds to more</p>
<p>than one actual CPU.</p>
<p>â¢</p>
<p>Downloading â Writing the executable into RAM on your target.</p>
<p>â¢</p>
<p>Flashing â Writing the executable into flash memory on your target.</p>
<p>â¢</p>
<p>Verifying â Reading memory (either RAM or flash) from your target and</p>
<p>comparing it to the contents of the executable, thus ensuring that the executable</p>
<p>loaded into the Debugger is the same as the executable loaded onto your target.</p>
<p>For information about phrases that are used in the target list, see âTarget</p>
<p>Terminologyâ on page 18. For information about statuses that appear in the target</p>
<p>list, see âThe Status Columnâ on page 19.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>104</i></p>
<p><i>Chapter 7. Preparing Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Associating Your Executable with a Connection</b></p>
<p>When you open an executable in the Debugger, the Debugger automatically</p>
<p>associates it with a connection if one is available and applicable to the executable.</p>
<p>Otherwise, the executable is not associated with any connection and appears in the</p>
<p>target list under the heading<b> Unconnected Executables</b>. Before you are able to</p>
<p>download, flash, or verify the executable, you must establish a connection to your</p>
<p>target and associate the executable with the connection.</p>
<p>To do so, select the executable in the target list and then perform one of the following</p>
<p>actions.</p>
<p>â¢</p>
<p>Click the<b> Connect</b> button (</p>
<p>). Using the<b> Connection Chooser</b> that appears,</p>
<p>connect to a target that contains a CPU compatible with the executable.</p>
<p>â¢</p>
<p>Select<b> Debug</b> â<b> Use Connection</b>. The submenu that appears lists compatible,</p>
<p>currently active connections. If a connection appears dimmed, the current</p>
<p>executable cannot be associated with that connection. Select an<b> Available</b></p>
<p>connection (if any) from the top of the menu, or select<b> Create New Connection</b>.</p>
<p>(<b>Available</b> indicates that the connection can accept more executables.<b> Current</b></p>
<p>indicates that the connection is associated with the current executable.<b> Full</b></p>
<p>indicates that using the connection will cause another executable to stop using</p>
<p>it. See âThe Use Connection Submenuâ on page 670.)</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> change_binding bind</b> command.</p>
<p>The<b> Connection Chooser</b> prompts you to establish a connection. For more</p>
<p>information, see the<b> change_binding</b> command in âGeneral Target Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>After you perform one of the preceding operations, the executable is automatically</p>
<p>associated with the connection if only one compatible CPU exists on the target you</p>
<p>connected to. (This is usually the case.) If the selected executable is compatible</p>
<p>with more than one CPU on the target, the<b> Use Which Connection/CPU?</b> dialog</p>
<p>box appears. The following graphic is an example of the<b> Use Which</b></p>
<p><b>Connection/CPU?</b> dialog box for a multi-core QorIQ P4080 target connected via</p>
<p>a Green Hills Probe.</p>
<p><i>105</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Associating Your Executable with a Connection</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Select the connection that contains the correct CPU.</p>
<p>To disassociate the executable from the connection, select the executable and then</p>
<p>perform one of the following actions:</p>
<p>â¢</p>
<p>Click the<b> Disconnect</b> button (</p>
<p>) to disconnect from the target.</p>
<p>â¢</p>
<p>Select<b> Debug</b> â<b> Use Connection</b> â<b> Stop Using Current Connection</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter<b> change_binding unbind</b>. For more</p>
<p>information, see the<b> change_binding</b> command in âGeneral Target Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>All the menu items listed in this section are also accessible from the</p>
<p>shortcut menu that appears when you right-click an executable.</p>
<p>For more information about connecting, see Chapter 3, âConnecting to Your Targetâ</p>
<p>on page 39. For information about how items are arranged in the target list after</p>
<p>the executable is associated with the connection, see âThe Target List Displayâ</p>
<p>on page 17. For information about loading the executable on the target, see</p>
<p>âPreparing Your Targetâ on page 108.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>106</i></p>
<p><i>Chapter 7. Preparing Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Updating MULTI 4 Target Connections</b></p>
<p>If you were a previous user of MULTI 4, you may need to convert your connections.</p>
<p>Specifying a download, attach, or board setup connection mode for your target</p>
<p>connection, as was required in MULTI 4, is not supported in MULTI 6. This section</p>
<p>summarizes how to obtain results similar to those of:</p>
<p>â¢</p>
<p>Selecting<b> Download</b>,<b> Attach</b>, or<b> Board Setup</b> in MULTI 4's<b> Connection</b></p>
<p><b>Editor</b> or<b> Connection Chooser</b></p>
<p>â¢</p>
<p>Specifying</p>
<p>mode=download</p>
<p>,</p>
<p>mode=attach</p>
<p>, or</p>
<p>mode=boardsetup</p>
<p>in a</p>
<p>MULTI 4 Custom Connection Method,<b> connect</b> command, or<b> -connect</b></p>
<p>command line option.</p>
<p><b>Tip</b></p>
<p>To remove the deprecated</p>
<p>mode=<i>setting</i></p>
<p>argument from a MULTI 4</p>
<p>Connection Method, edit and save the connection in MULTI 6.</p>
<p><b>Download Mode (mode=download)</b></p>
<p>Downloading your program in MULTI 6 works in roughly the same way as in</p>
<p>previous versions. You can open a Debugger window on your executable, connect</p>
<p>to your target, and download your program to your target just as you could before.</p>
<p>In MULTI 6, you do not have to specify that your connection is a download mode</p>
<p>connection.</p>
<p><b>Attach Mode (mode=attach)</b></p>
<p>After connecting to your target, select<b> &lt;Direct hardware access&gt;</b> from the target</p>
<p>list to get run control of your target, to read and write registers and memory, and</p>
<p>to see the raw disassembly view of whatever your target is running (as on a newly</p>
<p>opened MULTI 4 attach mode connection with no executable). You no longer have</p>
<p>to specify that your connection is an attach mode connection.</p>
<p>If an executable that you would like to debug is already loaded onto your target,</p>
<p>open your executable in the Debugger and do one of the following:</p>
<p>â¢</p>
<p>Select<b> Debug</b> â<b> Prepare Target</b>, and specify<b> Program already present on</b></p>
<p><b>target. Verify: Not at all</b>.</p>
<p><i>107</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Updating MULTI 4 Target Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Run the Debugger command<b> prepare_target -verify=none</b> in the Debugger</p>
<p>command pane. For information about the<b> prepare_target</b> command, see</p>
<p>âGeneral Target Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Performing either of the preceding operations allows MULTI to assume that the</p>
<p>program loaded on your target is the same as the executable you opened. In the</p>
<p>target list, the<b> &lt;Direct hardware access&gt;</b> entry and your executable will merge</p>
<p>together, allowing you to run, halt, and/or step your target with reference to your</p>
<p>executable's source code in the source pane.</p>
<p><b>Board Setup Mode (mode=boardsetup)</b></p>
<p>Because MULTI 4's board setup mode is an extension of attach mode, you can</p>
<p>connect to your target without an executable, and click<b> &lt;Direct hardware access&gt;</b></p>
<p>as described in âAttach Mode (mode=attach)â on page 107. To get some of the other</p>
<p>effects of the deprecated board setup mode, try enabling no stack trace mode and</p>
<p>memory sensitive mode and disabling automatic coherency checkingâsettings for</p>
<p>all of which appear under<b> Debug</b> â<b> Debug Settings</b>.</p>
<p>If you are connected via a Green Hills Probe, you can also disallow access to memory</p>
<p>(or specific areas thereof) with the<b> ma</b> command. For information about the<b> ma</b></p>
<p>command, see the documentation about probe commands in the<i> Green Hills Debug</i></p>
<p><i>Probes User's Guide</i>.</p>
<p><b>Preparing Your Target</b></p>
<p>Before you can run or debug a program on your target, you must download it to the</p>
<p>target's RAM, program it into the target's flash memory, or verify through the</p>
<p>Debugger that it is already present on the target. To do so, select an executable in</p>
<p>the target list and then perform one of the following operations:</p>
<p>â¢</p>
<p>Perform a run-control operation such as stepping or running your program.</p>
<p>â¢</p>
<p>Click the<b> Prepare Target</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>Select the<b> Prepare Target</b> menu item from the<b> Debug</b> menu or the right-click</p>
<p>menu.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>108</i></p>
<p><i>Chapter 7. Preparing Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> prepare_target</b> command. For more</p>
<p>information and options to this command, see âGeneral Target Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>If you have not connected to a target, the<b> Connection Chooser</b> prompts</p>
<p>you to connect. If the selected executable is not automatically associated</p>
<p>with the connection, the<b> Use Which Connection/CPU?</b> dialog box</p>
<p>prompts you to pick a connection. For more information, see âAssociating</p>
<p>Your Executable with a Connectionâ on page 105.</p>
<p>After you perform one of the preceding operations, MULTI either opens the<b> Prepare</b></p>
<p><b>Target</b> dialog box, which allows you to choose whether to download, flash, or</p>
<p>verify the executable, or MULTI prepares your target for you by automatically</p>
<p>executing one of these actions. For information about how MULTI determines</p>
<p>which action to execute automatically, see âProgram Typesâ on page 111.</p>
<p>If you want to specify which action is performed (that is, you do not want MULTI</p>
<p>to automatically download, flash, or verify the executable), select the<b> Prepare</b></p>
<p><b>Target</b> menu item from the<b> Debug</b> menu or the right-click menu, or pass the<b> -ask</b></p>
<p>option to the<b> prepare_target</b> command. If you prepare the target by another means</p>
<p>and at least one of the following items is true, MULTI automatically executes an</p>
<p>action:</p>
<p>â¢</p>
<p>Only one action is appropriate and MULTI does not require input (such as the</p>
<p>text offset of a PIC program).</p>
<p>â¢</p>
<p>The last time you prepared the target for the selected program, the option</p>
<p><b>Automatically use these settings for this program next time</b> was selected</p>
<p>in the<b> Prepare Target</b> dialog box, and the program's memory layout has not</p>
<p>changed since then. (This option is selected by default.)</p>
<p>For more information about the<b> Prepare Target</b> dialog box, see the next section.</p>
<p><i>109</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Preparing Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Prepare Target Dialog Box</b></p>
<p>The<b> Prepare Target</b> dialog box contains options for specifying that MULTI</p>
<p>downloads the executable, flashes the executable, or verifies the presence of the</p>
<p>executable on the target.</p>
<p>Each option in the<b> Prepare Target</b> dialog box is listed below:</p>
<p>â¢</p>
<p><b>Download to RAM</b> â Writes the executable into RAM on your target. For</p>
<p>more information, see âDownloading Your Executableâ on page 114.</p>
<p>â</p>
<p><b>Text Offset</b> â Allows you to specify where the text section will be located</p>
<p>when the executable is downloaded. This option is only available for</p>
<p>programs using position-independent code. For more information, see</p>
<p>âDownloading Your Executableâ on page 114.</p>
<p>â</p>
<p><b>Data Offset</b> â Allows you to specify where the data section will be located</p>
<p>when the executable is downloaded. This option is only available for</p>
<p>programs using position-independent data. For more information, see</p>
<p>âDownloading Your Executableâ on page 114.</p>
<p>â¢</p>
<p><b>Program Flash ROM</b> â Writes the executable into flash memory on your</p>
<p>target. For more information, see âFlashing Your Executableâ on page 114.</p>
<p>â¢</p>
<p><b>Program already present on target. Verify</b> â Specifies that the executable</p>
<p>is already present in your target's memory. Depending on the<b> Verify</b> option</p>
<p>that you choose from the drop-down menu, MULTI may check to ensure that</p>
<p>the executable is on your target. For more information, see âVerifying the</p>
<p>Presence of Your Executableâ on page 114.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>110</i></p>
<p><i>Chapter 7. Preparing Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><b>Automatically use these settings for this program next time</b> â Remembers</p>
<p>the<b> Prepare Target</b> dialog box settings for this executable. If the settings</p>
<p>remain applicable, MULTI uses them automatically and does not open the</p>
<p><b>Prepare Target</b> dialog box unless you request otherwise. For more information,</p>
<p>see âPreparing Your Targetâ on page 108.</p>
<p>The options that are available in the<b> Prepare Target</b> dialog box vary according to</p>
<p>the item you are debugging. For more information, see the next section.</p>
<p>When you are finished making your selections, click<b> OK</b>. MULTI prepares your</p>
<p>target.</p>
<p><b>Program Types</b></p>
<p>MULTI understands a number of general program types, and is able to determine</p>
<p>the action (download, flash, or verify) that should either be selected by default in</p>
<p>the<b> Prepare Target</b> dialog box or automatically executed (for more information,</p>
<p>see âPreparing Your Targetâ on page 108). The following sections provide specific</p>
<p>information about how MULTI determines a program's type, what each type means,</p>
<p>and what action MULTI defaults to for each type.</p>
<p><b>Note</b></p>
<p>If you are using an instruction set simulator, MULTI may determine that</p>
<p><b>Download to RAM</b> is the only action possible, regardless of what</p>
<p>program type is detected. In this situation, all other options in the<b> Prepare</b></p>
<p><b>Target</b> dialog box are disabled, and even programs built to load from</p>
<p>ROM (that is, ROM run and ROM copy programs) should be</p>
<p>âdownloaded.â</p>
<p><b>RAM Download Programs</b></p>
<p>If MULTI is unable to locate certain special symbols that indicate the program is</p>
<p>ROM run or ROM copy (see the following sections), it determines that the program</p>
<p>is a RAM download program. In this case, MULTI expects that all sections marked</p>
<p>as allocated in the ELF file should be present on the target.</p>
<p>The<b> Prepare Target</b> dialog box defaults to<b> Download to RAM</b> for programs of</p>
<p>this type. No other option is generally applicable, though if the program has already</p>
<p><i>111</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Program Types</i></p>
<h1 style="page-break-before:always; "></h1>
<p>been downloaded to the target, it may be possible to verify that this is the case</p>
<p>instead of re-downloading. If you are debugging a native target or a Dynamic</p>
<p>Download INTEGRITY application, downloading is the only action possible. For</p>
<p>information about downloading, see âDownloading Your Executableâ on page 114.</p>
<p>For information about verifying, see âVerifying the Presence of Your Executableâ</p>
<p>on page 114.</p>
<p>Only RAM download programs can have position-independent code or data, and</p>
<p>if MULTI determines that either or both of those is present, the<b> Text Offset</b> and/or</p>
<p><b>Data Offset</b> text fields are available for input and must be filled in. For more</p>
<p>information, see âDownloading Your Executableâ on page 114.</p>
<p><b>ROM Run Programs</b></p>
<p>A ROM run program is stored to ROM and runs solely out of ROM (using RAM</p>
<p>only for stack and heap space).</p>
<p>MULTI determines that a given program has this type if the special symbols</p>
<p>__ghs_rombootcodestart</p>
<p>and</p>
<p>__ghs_rombootcodeend</p>
<p>exist, and the symbols</p>
<p>__ghs_rambootcodestart</p>
<p>and</p>
<p>__ghs_rambootcodeend</p>
<p>do not exist. (Note</p>
<p>that MULTI also searches for and uses various other special symbols, such as</p>
<p>__ghs_romstart</p>
<p>,</p>
<p>__ghs_romend</p>
<p>,</p>
<p>__ghs_ramstart</p>
<p>, and</p>
<p>__ghs_ramend</p>
<p>, to</p>
<p>improve the debugging experience.)</p>
<p>If a program is of type ROM run, MULTI expects that the sections marked as</p>
<p>allocated in the program's ELF file should be loaded into the target's ROM. This is</p>
<p>generally achieved by programming the flash ROM on the target.</p>
<p>The<b> Prepare Target</b> dialog box defaults to<b> Program Flash ROM</b> for programs</p>
<p>of this type. Any of the<b> Verify</b> options may also be appropriate if the program has</p>
<p>already been programmed into the target's flash ROM. Downloading is generally</p>
<p>not applicable, unless the program is being run on a simulator (see âProgram Typesâ</p>
<p>on page 111). For information about flashing, see âFlashing Your Executableâ</p>
<p>on page 114. For information about verifying, see âVerifying the Presence of Your</p>
<p>Executableâ on page 114.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>112</i></p>
<p><i>Chapter 7. Preparing Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>ROM Copy Programs</b></p>
<p>ROM copy programs are initially located in ROM, but copy themselves to RAM</p>
<p>during startup, and then execute partially or completely from RAM.</p>
<p>MULTI determines that a given program has this type if the linker-inserted symbols</p>
<p>__ghs_rombootcodestart</p>
<p>,</p>
<p>__ghs_rombootcodeend</p>
<p>,</p>
<p>__ghs_rambootcodestart</p>
<p>, and</p>
<p>__ghs_rambootcodeend</p>
<p>exist. (Note that</p>
<p>MULTI also searches for and uses various other special symbols, such as</p>
<p>__ghs_romstart</p>
<p>,</p>
<p>__ghs_romend</p>
<p>,</p>
<p>__ghs_ramstart</p>
<p>, and</p>
<p>__ghs_ramend</p>
<p>, to</p>
<p>improve the debugging experience.) If the special symbol</p>
<p>__ghs_after_romcopy</p>
<p>exists, MULTI is able to restore software breakpoints in the RAM image of the</p>
<p>program after the ROM copy is completed.</p>
<p>If a program is of type ROM copy, MULTI expects that the sections marked as</p>
<p>allocated in the program's ELF file should be loaded into the target's ROM. This is</p>
<p>generally achieved by programming the flash ROM on the target.</p>
<p>The<b> Prepare Target</b> dialog box defaults to<b> Program Flash ROM</b> for programs</p>
<p>of this type. Any of the<b> Verify</b> options may also be appropriate if the program has</p>
<p>already been programmed into the target's flash ROM. Downloading is generally</p>
<p>not applicable, unless the program is being run on a simulator (see âProgram Typesâ</p>
<p>on page 111). For information about flashing, see âFlashing Your Executableâ</p>
<p>on page 114. For information about verifying, see âVerifying the Presence of Your</p>
<p>Executableâ on page 114.</p>
<p><b>Unknown Programs</b></p>
<p>If MULTI is unable to determine anything about a program, the default action is</p>
<p><b>Download to RAM</b>. For information about downloading, see âDownloading Your</p>
<p>Executableâ on page 114.</p>
<p>When MULTI cannot detect any program information, it is generally the case that</p>
<p>something is wrong with the program or its debug information.</p>
<p><i>113</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Program Types</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Downloading Your Executable</b></p>
<p>To download your executable to your target's memory, select<b> Download to RAM</b></p>
<p>in the<b> Prepare Target</b> dialog box. This is the most commonly selected option for</p>
<p>debugging embedded programs with MULTI.</p>
<p>If a board setup script is associated with the target connection, it is executed</p>
<p>immediately before the executable is downloaded.</p>
<p>When the<b> Download to RAM</b> action is available and MULTI detects that your</p>
<p>program has been linked with position-independent code and/or data, the<b> Text</b></p>
<p><b>Offset</b> and/or<b> Data Offset</b> fields become available. These fields set the</p>
<p>_TEXT</p>
<p>and</p>
<p>_DATA</p>
<p>system variables, which allow you to specify where the text and data sections</p>
<p>will be located when they are downloaded. If MULTI fails to detect that a program</p>
<p>contains position-independent code or data, you can manually set the offsets using</p>
<p>_TEXT</p>
<p>and</p>
<p>_DATA</p>
<p>. For more information, see âSystem Variablesâ on page 310.</p>
<p><b>Flashing Your Executable</b></p>
<p>To flash your executable to ROM, select<b> Program Flash ROM</b> in the<b> Prepare</b></p>
<p><b>Target</b> dialog box. The<b> MULTI Fast Flash Programmer</b> appears. This window</p>
<p>allows you to write a memory image from the host to flash memory on the target.</p>
<p>For more information, see Chapter 22, âProgramming Flash Memoryâ on page 539.</p>
<p>After you have flashed your executable to ROM, reset your target and perform any</p>
<p>other operations that are required for booting code from flash, such as interacting</p>
<p>with the ROM monitor.</p>
<p><b>Note</b></p>
<p>If you flash your executable to ROM by selecting<b> Program Flash ROM</b></p>
<p>and<b> Automatically use these settings for this program next time</b>,</p>
<p>clicking the<b> Restart</b> (</p>
<p>) or<b> Prepare Target</b> button (</p>
<p>) or issuing an</p>
<p>equivalent command reflashes your target.</p>
<p><b>Verifying the Presence of Your Executable</b></p>
<p>To specify that your executable is already present in the target's memory, select</p>
<p><b>Program already present on target. Verify</b>. Depending on the<b> Verify</b> option you</p>
<p><i>MULTI: Debugging</i></p>
<p><i>114</i></p>
<p><i>Chapter 7. Preparing Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p>choose from the drop-down menu, MULTI may check to ensure that the contents</p>
<p>of target memory match the contents of the executable program file.</p>
<p>The following list describes the<b> Verify</b> options:</p>
<p>â¢</p>
<p><b>Sparsely</b> â Verifies a few bytes at the beginning, middle, and end of all</p>
<p>downloaded non-data sections that cannot be written to. The</p>
<p>.text</p>
<p>section is</p>
<p>an example of one such section. Because certain sections of memory, such as</p>
<p>.bss</p>
<p>,</p>
<p>.data</p>
<p>, and</p>
<p>.heap</p>
<p>, may be written to during program execution, you</p>
<p>can expect them to differ from the executable program file. When you specify</p>
<p>this option, MULTI does not check these sections.</p>
<p>This option halts your target if it is running.</p>
<p>â¢</p>
<p><b>Completely</b> â Verifies (in entirety) all downloaded non-data sections that</p>
<p>cannot be written to. This may take a long time.</p>
<p>This option halts your target if it is running.</p>
<p>For information about downloaded sections, see the preceding bullet point.</p>
<p>â¢</p>
<p><b>Not at all</b> â Assumes, but does not verify that the contents of target memory</p>
<p>match the contents of the executable program file. This option does not halt</p>
<p>your target.</p>
<p><b>Related Settings</b></p>
<p><b>Memory Sensitive Mode</b></p>
<p>To enable memory sensitive mode in the Debugger, select<b> Debug</b> â<b> Debug Settings</b></p>
<p>â<b> Memory Sensitive</b>. You can also select this mode by setting the system variable</p>
<p>$_VOLATILE=1</p>
<p>. For more information about system variables, see âSystem</p>
<p>Variablesâ on page 310.</p>
<p>Memory sensitive mode is used when debugging targets whose memory can change</p>
<p>in ways unexpected to the Debugger or while examining memory-mapped I/O to</p>
<p>avoid unexpected memory references. Some ways that a target could cause such</p>
<p>unexpected changes are self-modifying code and references to dual-port memory</p>
<p>or memory-mapped I/O that can be changed in ways asynchronous to the program</p>
<p>execution.</p>
<p><i>115</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Related Settings</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Memory sensitive mode has the following effects:</p>
<p>â¢</p>
<p>Memory in areas where executable code resides is read from the target. When</p>
<p>not in memory sensitive mode, MULTI assumes that executable code does not</p>
<p>change and uses the contents of the executable file when displaying disassembly</p>
<p>at such addresses.</p>
<p>â¢</p>
<p>MULTI avoids reading more memory than necessary by only reading the</p>
<p>memory locations requested and by using the specified access size. When not</p>
<p>in memory sensitive mode, MULTI may cache some of the target memory by</p>
<p>reading 64-byte blocks, even if only a small part of memory is actually needed.</p>
<p>â¢</p>
<p>Only one target instruction in the Debugger pane is read and displayed at the</p>
<p>current program location. If you want to expand the allowed range in which</p>
<p>the Debugger can display target machine instructions, set the system variable</p>
<p>$_VOLATILEDISPMAX</p>
<p>to the desired maximum number of instruction bytes</p>
<p>to display.</p>
<p>The MULTI commands<b> memread</b> and<b> memwrite</b> can also be used to perform</p>
<p>precise memory references, even when not in memory sensitive mode. For</p>
<p>information about these commands, see âGeneral Memory Commandsâ in Chapter</p>
<p>10, âMemory Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p><b>No Stack Trace Mode</b></p>
<p>To enable no stack trace mode in the Debugger, select<b> Debug</b> â<b> Debug Settings</b></p>
<p>â<b> No Stack Trace</b>.</p>
<p>No stack trace mode disables call stack viewing and related functionality. You can</p>
<p>also select this mode by setting the system variable</p>
<p>$_NOSTACKTRACE=1</p>
<p>.</p>
<p>Call stacks and local variables on a call stack are not displayed because generating</p>
<p>a call stack could cause unexpected memory references in the case where the stack</p>
<p>pointer is either uninitialized or points to a nonstandard stack frame. As a</p>
<p>consequence of this, certain debugging features are also disabled. You can perform</p>
<p>instruction single-stepping, set and hit breakpoints, and start the target executing.</p>
<p>Other debugging functionality, such as stepping over function calls, returning from</p>
<p>function calls, and source-level single-stepping, is not supported in this mode. Once</p>
<p><i>MULTI: Debugging</i></p>
<p><i>116</i></p>
<p><i>Chapter 7. Preparing Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p>the target's stack is correctly set up, you can enable stack traces and the related</p>
<p>Debugger features.</p>
<p>No stack trace mode is typically used in combination with memory sensitive mode</p>
<p>(âMemory Sensitive Modeâ on page 115) although it can be selected independently.</p>
<p><b>Core File Debugging (Linux/Solaris only)</b></p>
<p>Core file debugging allows you to perform static analysis of your target. The target's</p>
<p>state is dumped into a core file when the program running on the target encounters</p>
<p>a fatal signal.</p>
<p><b>Note</b></p>
<p>The state of the target is not dumped into a core file if you have disabled</p>
<p>core dumps or if your program is being run under the control of a</p>
<p>debugger.</p>
<p>To perform core file debugging, you can run one of the following commands from</p>
<p>the command line, or you can enter the Debugger command<b> debug</b> or<b> new</b> in the</p>
<p>MULTI command pane. Both the command line and Debugger commands specify</p>
<p>the program to be debugged and its core image. When you open the Debugger on</p>
<p>a core file, MULTI automatically establishes a connection and prepares the target.</p>
<p>If you are debugging a native Linux program, use the following command to start</p>
<p>the MULTI Debugger from the command line:</p>
<p>multi<i> program_name</i> -C<i> core_file</i></p>
<p>where:</p>
<p>â¢</p>
<p><i>program_name</i></p>
<p>is the name of the crashed program you want to debug.</p>
<p>â¢</p>
<p><b>-C</b> is a MULTI command line option. See Appendix C, âCommand Line</p>
<p>Referenceâ on page 721.</p>
<p>â¢</p>
<p><i>core_file</i></p>
<p>is the Linux/Solaris core image of the program to be debugged.</p>
<p>You can also use one of the following Debugger commands to open the MULTI</p>
<p>Debugger on a core file:</p>
<p>â¢</p>
<p><b>debug<i> program_name core_file</b></i></p>
<p><i>117</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Core File Debugging (Linux/Solaris only)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><b>new<i> program_name core_file</b></i></p>
<p>See the<b> debug</b> and<b> new</b> commands in Chapter 2, âGeneral Debugger Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Once you are attached to the process, you can view the call stack and locate the</p>
<p>procedure that caused the dump to occur. All the operations for inspecting data</p>
<p>(reading process registers, the stack, local and global variables, and whatever portions</p>
<p>of memory were dumped into the core file) are available.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>118</i></p>
<p><i>Chapter 7. Preparing Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Part II</b></p>
<p><b>Basic Debugging</b></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 8</b></p>
<p><b>Executing and Controlling</b></p>
<p><b>Your Program from the</b></p>
<p><b>Debugger</b></p>
<p><b>Contents</b></p>
<p>Starting and Stopping a Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>122</p>
<p>Single-Stepping Through a Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>123</p>
<p>Using Breakpoints and Tracepoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>124</p>
<p>Software and Hardware Breakpoint Editors . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>139</p>
<p>The Breakpoints Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>146</p>
<p>The Breakpoints Restore Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>152</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter explains how to use the MULTI Debugger to run programs and control</p>
<p>and monitor processes on embedded and simulated targets. You can examine program</p>
<p>details at different points during execution by halting the process manually,</p>
<p>single-stepping through the program, and setting breakpoints.</p>
<p><b>Note</b></p>
<p>This chapter focuses primarily on how to use MULTI Debugger features</p>
<p>through the GUI interface. However, you can also perform most of the</p>
<p>procedures described by issuing Debugger commands in the command</p>
<p>pane of the Debugger window. In some situations, using Debugger</p>
<p>commands provides more specific control or more options. For a full</p>
<p>description of the Debugger commands, which are grouped by function,</p>
<p>see the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Starting and Stopping a Program</b></p>
<p>Before you can run a program, you must be connected to an embedded target, a</p>
<p>simulator, or a native debug server; your executable must be associated with a</p>
<p>connection; and your target must be prepared. If you are not connected to a target</p>
<p>or simulator and you try to run a program, the<b> Connection Chooser</b> appears and</p>
<p>prompts you to connect. For more information, see Chapter 3, âConnecting to Your</p>
<p>Targetâ on page 39. In many cases, your executable is automatically associated</p>
<p>with a connection and your target automatically prepared after you connect. If these</p>
<p>things are not automatically done, MULTI prompts you to do them. For more</p>
<p>information, see Chapter 7, âPreparing Your Targetâ on page 103.</p>
<p>The simplest way to run a program is to click</p>
<p>on the MULTI Debugger toolbar.</p>
<p>The process executes and runs until it terminates successfully, encounters a serious</p>
<p>error, is halted manually, or hits a breakpoint.</p>
<p>To halt a process manually, click</p>
<p>. For instructions about using breakpoints to</p>
<p>stop a process, see âUsing Breakpoints and Tracepointsâ on page 124. Click</p>
<p>to</p>
<p>restart a halted process from the location where it stopped.</p>
<p>For an overview of the information you can view about your program and target</p>
<p>during execution or while the process is halted, see âViewing Program and Target</p>
<p>Informationâ on page 168.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>122</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>You can also control execution of a programâsometimes more</p>
<p>preciselyâusing Debugger commands. For more information, see Chapter</p>
<p>13, âProgram Execution Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Single-Stepping Through a Program</b></p>
<p>Before you can single-step through a program, you must meet the same prerequisites</p>
<p>that are listed in âStarting and Stopping a Programâ on page 122.</p>
<p>The</p>
<p>and</p>
<p>buttons allow you to step through your program, executing one</p>
<p>statement at a time. Both buttons execute the next single statement. The</p>
<p>button</p>
<p>steps into function calls. It follows the execution of every individual instruction,</p>
<p>even when functions are called. Conversely, the</p>
<p>button steps over function calls.</p>
<p>It does not step into called functions. If the program halts within a called function,</p>
<p>click</p>
<p>to step out of the called function.</p>
<p>You can also single-step through your program using Debugger commands. For</p>
<p>more information, see âSingle-Stepping Commandsâ in Chapter 13, âProgram</p>
<p>Execution Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p><b>Note</b></p>
<p>When the Debugger stops on a conditionally not-executed instruction,</p>
<p>the Debugger dims both the instruction and the PC pointer. (The PC</p>
<p>pointer is the arrow marked with the word<b> STOPPED</b>.) In source display</p>
<p>mode, a source instruction is dimmed if the current machine instruction</p>
<p>that the Debugger is stopped on, as well as any remaining machine</p>
<p>instructions that make up the current source statement, are conditionally</p>
<p>not executed. In assembly display mode, the Debugger dims the</p>
<p>instruction it is currently stopped on if the instruction is conditionally</p>
<p>not executed. Conditionally not-executed instructions are only available</p>
<p>on certain architectures, such as ARM.</p>
<p><i>123</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Single-Stepping Through a Program</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>The Debugger generally completes a source-line single-step when it</p>
<p>reaches the first instruction of a source line. The code for certain kinds</p>
<p>of loops, such as</p>
<p>do {...} while</p>
<p>loops and infinite loops, may be</p>
<p>generated with a backwards branch to the beginning of the loop. If debug</p>
<p>information indicates that such a loop appears by itself on a single source</p>
<p>line, the Debugger stops stepping after traversing the branchâeven</p>
<p>though the program may not have finished executing the entire</p>
<p>loopâbecause the first instruction of the loop is also the first instruction</p>
<p>of the source line. This is true even if the loop appears by itself on a line</p>
<p>because of compiler or linker code transformations such as macro</p>
<p>expansion, inlining, or code factoring. To advance past such loops with</p>
<p>a single command, consider using the<b> c</b> or<b> cb</b> commands with an address</p>
<p>expression. For information about these commands, see âContinue</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Using Breakpoints and Tracepoints</b></p>
<p>Breakpoints halt a process and allow you to examine your code and the state of</p>
<p>your target at various points during program execution. You can specify conditions</p>
<p>that trigger the breakpoint, and you can specify one or more commands to run after</p>
<p>the breakpoint halts the process. There are two main types of breakpoints:</p>
<p>â¢</p>
<p><i>Software breakpoints</i> â Can be set on any executable line of code in RAM.</p>
<p>Your process halts when it hits the software breakpoint. For more information,</p>
<p>see âWorking with Software Breakpointsâ on page 128.</p>
<p>â¢</p>
<p><i>Hardware breakpoints</i> â Can be set on data memory locations or on executable</p>
<p>lines of code located in RAM or ROM. When set on data memory locations,</p>
<p>the hardware breakpoint halts your process if it reads or writes data to the</p>
<p>specified location. Hardware breakpoint support varies by target type. For more</p>
<p>information, see âWorking with Hardware Breakpointsâ on page 133.</p>
<p>Breakpoints can be either temporary or permanent. MULTI deletes temporary</p>
<p>breakpoints after your process hits them. MULTI does not automatically delete</p>
<p>permanent breakpoints.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>124</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>You can easily set both software and hardware breakpoints by clicking the breakdots</p>
<p>(</p>
<p>) that appear in the Debugger source pane. For more information, see âBreakdots,</p>
<p>Breakpoint Markers, and Tracepoint Markersâ on page 125.</p>
<p>On targets that use shared objects, MULTI supports breakpoints that are set in</p>
<p>shared object code. For more information, see âWorking with Shared Object</p>
<p>Breakpointsâ on page 136.</p>
<p>On some targets, you can also use tracepoints to collect debugging data without</p>
<p>halting your process. For more information, see Chapter 24, âNon-Intrusive</p>
<p>Debugging with Tracepointsâ on page 559.</p>
<p><b>Note</b></p>
<p>The MULTI Debugger also supports Debugger Notes, which allow you</p>
<p>to attach notes to any line of code. Unlike breakpoints, Debugger Notes</p>
<p>do not halt your process or execute commands. For more information,</p>
<p>see Chapter 10, âUsing Debugger Notesâ on page 173.</p>
<p><b>Breakdots, Breakpoint Markers, and Tracepoint Markers</b></p>
<p>A breakdot (</p>
<p>) is a small dot located directly to the left of any line of source code</p>
<p>that corresponds to an executable instruction. A breakdot indicates that you can set</p>
<p>one or more of a software breakpoint, hardware breakpoint, or tracepoint on the</p>
<p>line marked with the breakdot.</p>
<p>By default, most breakdots in the source pane are green. But you may also encounter</p>
<p>blue, red, or gray breakdots in the following situations:</p>
<p>â¢</p>
<p><i>Blue breakdots</i> (</p>
<p>) â Indicate source lines for which the compiler generated</p>
<p>reordered code. For example, if you step through a function with blue breakdots</p>
<p>at the top, you will see that the program counter starts at the first green breakdot</p>
<p>and then goes backwards to the blue breakdots before continuing on to the rest</p>
<p>of the green breakdots. This can happen when the compiler delays the</p>
<p>initialization of variables for a function.</p>
<p>â¢</p>
<p><i>Red breakdots</i> (</p>
<p>) â Indicate source lines that the linker removed during</p>
<p>link-time optimization. For example, the linker may use subroutine calls and</p>
<p>tail merges to remove redundant segments of code from object files. Because</p>
<p>this code has been removed, you cannot set breakpoints on these source lines.</p>
<p><i>125</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Breakdots, Breakpoint Markers, and Tracepoint Markers</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>Link-time optimization is not available for all target processors. For</p>
<p>more information, see the<i> MULTI: Building Applications</i> book for</p>
<p>your target processor family.</p>
<p>â¢</p>
<p><i>Gray breakdots</i> (</p>
<p>) â Indicate source lines for which the compiler has merged</p>
<p>the code associated with the line into another source line. This can happen</p>
<p>when a particular source statement appears multiple times within a function.</p>
<p>Because the code has been merged to a different source line, you cannot set</p>
<p>breakpoints on a line with a gray breakdot. If a breakpoint is set at a source</p>
<p>line where the code has been merged, it will be hit anytime the merged code</p>
<p>is executed.</p>
<p>To set a software breakpoint on any source or assembly line marked by a breakdot,</p>
<p>click the breakdot. To set a hardware breakpoint or a tracepoint on targets that</p>
<p>support them, right-click any breakdot and select the appropriate action from the</p>
<p>shortcut menu that appears.</p>
<p>When you set a breakpoint or tracepoint, you replace the breakdot with a breakpoint</p>
<p>or tracepoint marker. The following table describes these markers.</p>
<p><b>Type of Breakpoint</b></p>
<p><b>Breakpoint</b></p>
<p><b>Marker</b></p>
<p>Software breakpoint</p>
<p>Software breakpoint with conditions</p>
<p>Software breakpoint with a bell activated</p>
<p>Software breakpoint with a command list</p>
<p>Software breakpoint with a breakpoint count greater than 1</p>
<p>Jump breakpoint</p>
<p>Any-task breakpoint (for information about any-task breakpoints in run</p>
<p>mode, see âAny-Task Breakpointsâ on page 587; for information about</p>
<p>any-task breakpoints in freeze mode, see âWorking with Freeze-Mode</p>
<p>Breakpointsâ on page 618)</p>
<p>Task-specific breakpoint in freeze mode (for more information, see âWorking</p>
<p>with Freeze-Mode Breakpointsâ on page 618)</p>
<p><i>MULTI: Debugging</i></p>
<p><i>126</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Type of Breakpoint</b></p>
<p><b>Breakpoint</b></p>
<p><b>Marker</b></p>
<p>Group breakpoint for synchronized halts (for more information, see âGroup</p>
<p>Breakpointsâ on page 588)</p>
<p>Hardware breakpoint</p>
<p>Tracepoint</p>
<p>If you set multiple software breakpoints on a source line, MULTI displays the</p>
<p>marker for the enabled breakpoint that was most recently set or modified. If none</p>
<p>of the breakpoints on the line are enabled, MULTI displays the marker for the</p>
<p>disabled breakpoint that was most recently set or modified.</p>
<p>Positioning your mouse pointer over a breakpoint or tracepoint marker displays the</p>
<p>properties of the breakpoint or tracepoint. Clicking an active breakpoint or tracepoint</p>
<p>marker clears the breakpoint or tracepoint and changes the marker back to a breakdot.</p>
<p>Clicking an inactive breakpoint or tracepoint marker enables the breakpoint or</p>
<p>tracepoint. For information about clearing and enabling multiple breakpoints and</p>
<p>tracepoints set on a single source line, see âMultiple Breakpoints and Tracepoints</p>
<p>on a Single Lineâ on page 138.</p>
<p>Inactive breakpoints and tracepoints have gray markers. To disable a breakpoint or</p>
<p>tracepoint, right-click the breakpoint or tracepoint marker and select<b> Disable</b></p>
<p><b>Breakpoint</b>,<b> Disable Hardware Breakpoint</b>, or<b> Disable Tracepoint</b>. To re-enable</p>
<p>a disabled breakpoint or tracepoint, click the gray marker. Middle-clicking a marker</p>
<p>toggles the breakpoint or tracepoint between active and inactive status.</p>
<p>For more information about software breakpoints, see âWorking with Software</p>
<p>Breakpointsâ on page 128. For more information about hardware breakpoints, see</p>
<p>âWorking with Hardware Breakpointsâ on page 133. For more information about</p>
<p>tracepoints, see Chapter 24, âNon-Intrusive Debugging with Tracepointsâ</p>
<p>on page 559.</p>
<p><i>127</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Breakdots, Breakpoint Markers, and Tracepoint Markers</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Breakpoint and Tracepoint Information</b></p>
<p>The MULTI Debugger provides several ways for you to view information about</p>
<p>the breakpoints and tracepoints you have set:</p>
<p>â¢</p>
<p><b>Tooltips</b> â In the source pane, positioning your mouse pointer over a</p>
<p>breakpoint or tracepoint displays the properties of that breakpoint or tracepoint.</p>
<p>â¢</p>
<p><b>Breakpoints window</b> â The<b> Breakpoints</b> window displays and allows you</p>
<p>to configure software breakpoints and, for targets that support them, hardware</p>
<p>breakpoints, tracepoints, and shared object breakpoints. To open this window,</p>
<p>do one of the following:</p>
<p>â</p>
<p>Click the<b> Breakpoints</b> button (</p>
<p>).</p>
<p>â</p>
<p>In the Debugger command pane, enter the<b> bpview</b> command. For</p>
<p>information about the<b> bpview</b> command, see Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>â</p>
<p>Select<b> View</b> â<b> Breakpoints</b>.</p>
<p>Software breakpoints, hardware breakpoints, and tracepoints are displayed on</p>
<p>separate tabs of the<b> Breakpoints</b> window. For more information, see âViewing</p>
<p>and Managing Software Breakpointsâ on page 131, âViewing and Managing</p>
<p>Hardware Breakpointsâ on page 135, and âThe Tracepoints Tab of the</p>
<p>Breakpoints Windowâ on page 571. For a comprehensive description of the</p>
<p>columns, buttons, and shortcut menus available in the<b> Breakpoints</b> window,</p>
<p>as well as the actions you can perform from this window, see âThe Breakpoints</p>
<p>Windowâ on page 146.</p>
<p>â¢</p>
<p><b>Breakpoint list commands</b> â You can enter breakpoint commands such as</p>
<p><b>B</b> to print information about specific breakpoints, or all breakpoints, to the</p>
<p>command pane. For more information about the<b> B</b> command, see Chapter 3,</p>
<p>âBreakpoint Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Working with Software Breakpoints</b></p>
<p>Software breakpoints halt your process when it reaches a specified line of code and</p>
<p>meets the conditions you have specified. When the process is stopped, you can</p>
<p>inspect the state of your program and track down problems. For an overview of the</p>
<p><i>MULTI: Debugging</i></p>
<p><i>128</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>types of information you can view about your program and target, see âViewing</p>
<p>Program and Target Informationâ on page 168. You can also specify that MULTI</p>
<p>runs a list of commands when your process hits a breakpoint.</p>
<p><b>Note</b></p>
<p>You cannot set software breakpoints in your target's ROM because</p>
<p>software breakpoint instructions cannot be inserted into read-only</p>
<p>memory. However, some targets support hardware breakpoints, which</p>
<p>can be used for debugging ROM. For more information, see âWorking</p>
<p>with Hardware Breakpointsâ on page 133.</p>
<p>MULTI denotes a software breakpoint in the source pane with a small red stop sign</p>
<p>(</p>
<p>). To set a software breakpoint, click a breakdot; the breakpoint marker replaces</p>
<p>the breakdot. To move a software breakpoint, right-click the breakpoint marker and</p>
<p>select<b> Move Breakpoint</b> (for more information, see âMoving Software Breakpointsâ</p>
<p>on page 132). To remove a breakpoint, click it; the breakpoint marker reverts to a</p>
<p>breakdot.</p>
<p><b>Note</b></p>
<p>You can also set and delete breakpoints using breakpoint commands. For</p>
<p>a full description of these commands, see Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>If you set a breakpoint by clicking a breakdot, the breakpoint halts your process</p>
<p>every time the process reaches the line of code marked with the breakpoint. After</p>
<p>you have created a breakpoint, you can use the command pane or the<b> Software</b></p>
<p><b>Breakpoint Editor</b> to set parameters that associate conditions and commands with</p>
<p>the breakpoint. If you set any of these additional features, the breakpoint's stop sign</p>
<p>icon contains a symbol within it. Even if a breakpoint has more than one property,</p>
<p>only one of these icons is displayed. To view these unique breakpoint icons, see</p>
<p>the table in âBreakdots, Breakpoint Markers, and Tracepoint Markersâ on page 125.</p>
<p>For more information about the software breakpoint parameters you can set, see</p>
<p>âCreating and Editing Software Breakpointsâ on page 130.</p>
<p><i>129</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Working with Software Breakpoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Creating and Editing Software Breakpoints</b></p>
<p>You can set a basic software breakpoint quickly and easily:</p>
<p>â¢</p>
<p>In the source pane, click a breakdot (</p>
<p>). For information about breakdots, see</p>
<p>âBreakdots, Breakpoint Markers, and Tracepoint Markersâ on page 125.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> b</b> command. If you do not specify</p>
<p>a location, MULTI sets the breakpoint at the location of the current line pointer.</p>
<p>For more information about this command, see Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>After you have created a software breakpoint, you can add conditions and command</p>
<p>lists to it by using the<b> Software Breakpoint Editor</b>. To open a<b> Software</b></p>
<p><b>Breakpoint Editor</b>, do one of the following.</p>
<p>â¢</p>
<p>In the Debugger source pane, right-click the breakpoint's stop sign icon and</p>
<p>choose<b> Edit Breakpoint</b> from the shortcut menu.</p>
<p>â¢</p>
<p>Click the<b> Breakpoints</b> button (</p>
<p>) to open the<b> Breakpoints</b> window, select</p>
<p>the<b> Software</b> tab, and double-click the breakpoint you want to edit. For</p>
<p>alternative ways to open the<b> Breakpoints</b> window, see âViewing Breakpoint</p>
<p>and Tracepoint Informationâ on page 128.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> editswbp</b> command. For more</p>
<p>information about this command, see Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>130</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>You can set and modify all the basic properties of a software breakpoint by using</p>
<p>the fields in this window, which are described in âSoftware and Hardware Breakpoint</p>
<p>Editorsâ on page 139.</p>
<p><b>Note</b></p>
<p>You can also set software breakpoints by entering breakpoint commands</p>
<p>in the Debugger command pane. For detailed information about these</p>
<p>commands, see Chapter 3, âBreakpoint Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Viewing and Managing Software Breakpoints</b></p>
<p>To view all software breakpoints for a program and access them for editing, use the</p>
<p><b>Software</b> tab of the<b> Breakpoints</b> window. To open the<b> Breakpoints</b> window, click</p>
<p>the<b> Breakpoints</b> button (</p>
<p>) located on the toolbar. (For alternative ways to open</p>
<p>the<b> Breakpoints</b> window, see âViewing Breakpoint and Tracepoint Informationâ</p>
<p>on page 128.)</p>
<p><i>131</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Working with Software Breakpoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Software</b> tab contains a list of your program's software breakpoints and their</p>
<p>properties. The information displayed for each breakpoint corresponds to the</p>
<p>breakpoint properties displayed in the<b> Software Breakpoint Editor</b>. For a</p>
<p>description of the columns and buttons that appear in the<b> Breakpoints</b> window and</p>
<p>the actions and shortcuts available from the window, see âThe Breakpoints Windowâ</p>
<p>on page 146.</p>
<p><b>Moving Software Breakpoints</b></p>
<p>You can move software breakpoints easily. To move a software breakpoint,</p>
<p>right-click the breakpoint marker and select<b> Move Breakpoint</b>. A dialog box</p>
<p>prompts you to either click the source line where you want to move the breakpoint</p>
<p>or cancel the operation. MULTI signifies the source line where your mouse is</p>
<p>currently positioned by enclosing that line's breakdot with a small square. Click</p>
<p>one of these locations (either on the source line or on the breakdot itself) to move</p>
<p>the breakpoint to that line. The following list provides caveats for moving</p>
<p>breakpoints.</p>
<p>â¢</p>
<p>You cannot move a breakpoint out of the current function in which it resides.</p>
<p>â¢</p>
<p>In source-only mode (<b>View</b> â<b> Display Mode</b> â<b> Source Only</b>), you cannot</p>
<p>move a breakpoint from its original location if multiple breakpoints occur on</p>
<p>the original source line. You must change the display mode to an assembly</p>
<p><i>MULTI: Debugging</i></p>
<p><i>132</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>modeâeither<b> View</b> â<b> Display Mode</b> â<b> Interlaced Assembly</b> or<b> View</b> â</p>
<p><b>Display Mode</b> â<b> Assembly Only</b>. Then move the individual breakpoint using</p>
<p>the same method as outlined previously.</p>
<p>â¢</p>
<p>You cannot move a breakpoint to a source line that already contains a</p>
<p>breakpoint.</p>
<p><b>Working with Hardware Breakpoints</b></p>
<p>On some targets, MULTI can set a small number of hardware breakpoints in your</p>
<p>program. MULTI denotes a hardware breakpoint in the source pane with a small</p>
<p>purple box (</p>
<p>). As with software breakpoints, you can set hardware breakpoints</p>
<p>on your program's source or assembly lines. However, unlike software breakpoints,</p>
<p>hardware breakpoints can be set in ROM because MULTI does not need to modify</p>
<p>target memory to set them. You can also set hardware breakpoints on data memory</p>
<p>locations, so that your process stops when it reads from or writes to those memory</p>
<p>locations.</p>
<p>The number of hardware breakpoints you may set varies from target to target, but</p>
<p>it is usually fewer than four. Additionally, even targets that support hardware</p>
<p>breakpoints may not support all hardware breakpoint capabilities. For information</p>
<p>about how your target handles hardware breakpoints if you are using a Green Hills</p>
<p>Probe or SuperTrace Probe, see the documentation about target-specific hardware</p>
<p>breakpoint support in the<i> Green Hills Debug Probes User's Guide</i>.</p>
<p><b>Creating and Editing Hardware Breakpoints</b></p>
<p>If you are connected to a target that supports hardware breakpoints, you can set a</p>
<p>hardware breakpoint in any of the following ways.</p>
<p>â¢</p>
<p>In the Debugger source pane, right-click a green breakdot (</p>
<p>) and choose<b> Set</b></p>
<p><b>Hardware Breakpoint</b>.</p>
<p>â¢</p>
<p>In the Debugger source pane, right-click a global or static variable and choose</p>
<p><b>Set Hardware Breakpoint</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> hardbrk</b> command. For more</p>
<p>information about this command, see Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>133</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Working with Hardware Breakpoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>On the<b> Hardware</b> tab of the<b> Breakpoints</b> window, click the<b> New HW</b></p>
<p><b>Breakpoint</b> button.</p>
<p>After you have created a hardware breakpoint, you can add conditions and command</p>
<p>lists to it using the<b> Hardware Breakpoint Editor</b>. To open a<b> Hardware Breakpoint</b></p>
<p><b>Editor</b>, do one of the following:</p>
<p>â¢</p>
<p>In the Debugger source pane, right-click the breakpoint's cube icon in the source</p>
<p>pane and choose<b> Edit Hardware Breakpoint</b> from the shortcut menu.</p>
<p>â¢</p>
<p>In the Debugger source pane, right-click a global or static variable that has a</p>
<p>hardware breakpoint set on it, and choose<b> Edit Hardware Breakpoint</b>.</p>
<p>â¢</p>
<p>Click the<b> Breakpoints</b> button (</p>
<p>), select the<b> Hardware</b> tab, and double-click</p>
<p>the breakpoint you want to edit.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> edithwbp</b> command. For information</p>
<p>about the<b> edithwbp</b> command, see Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>You can set and modify all the basic properties of a hardware breakpoint by using</p>
<p>the fields in this window, which are described in âSoftware and Hardware Breakpoint</p>
<p>Editorsâ on page 139.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>134</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>You can also set hardware breakpoints by entering breakpoint commands</p>
<p>in the Debugger command pane. For detailed information about these</p>
<p>commands, see Chapter 3, âBreakpoint Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Viewing and Managing Hardware Breakpoints</b></p>
<p>To work with hardware breakpoints, you must be connected to a debugging target</p>
<p>that supports them. If you are using a Green Hills Probe or SuperTrace Probe, see</p>
<p>the documentation about target-specific hardware breakpoint support in the<i> Green</i></p>
<p><i>Hills Debug Probes User's Guide</i>.</p>
<p>To view all hardware breakpoints and access them for editing, use the<b> Hardware</b></p>
<p>tab of the<b> Breakpoints</b> window. To open the<b> Breakpoints</b> window, click the</p>
<p><b>Breakpoints</b> button (</p>
<p>) located on the toolbar. (For other ways to open the</p>
<p><b>Breakpoints</b> window, see âViewing Breakpoint and Tracepoint Informationâ</p>
<p>on page 128.)</p>
<p>The<b> Hardware</b> tab contains a list of all the hardware breakpoints in your program.</p>
<p>For a description of the columns and buttons that appear in the<b> Breakpoints</b> window</p>
<p>and the actions and shortcuts available from the window, see âThe Breakpoints</p>
<p>Windowâ on page 146.</p>
<p><i>135</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Working with Hardware Breakpoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Working with Shared Object Breakpoints</b></p>
<p>When a shared object is loaded, breakpoints work normally. However, after the</p>
<p>shared object is unloaded, you cannot set new software breakpoints in the object's</p>
<p>code. Instead, MULTI only provides the ability to list and delete these breakpoints</p>
<p>and to toggle them on and off. When the shared object is next loaded, MULTI</p>
<p>restores the breakpoints, including any modifications you have made to them via</p>
<p>the<b> Shared Object</b> tab.</p>
<p><b>Viewing and Managing Shared Object Breakpoints</b></p>
<p>When a shared object containing breakpoints is removed from the target process at</p>
<p>run time, any breakpoints set in the shared object are shown in the<b> Shared Object</b></p>
<p>tab of the<b> Breakpoints</b> window. To open the<b> Breakpoints</b> window, click the</p>
<p><b>Breakpoints</b> button (</p>
<p>) located on the toolbar. (For alternative ways to open the</p>
<p><b>Breakpoints</b> window, see âViewing Breakpoint and Tracepoint Informationâ</p>
<p>on page 128.)</p>
<p>The<b> Shared Object</b> tab is only visible when breakpoints from an unloaded shared</p>
<p>object are available for display.</p>
<p>The<b> Shared Object</b> tab contains a list of all the shared object breakpoints in your</p>
<p>program. For a description of the columns and buttons that appear in the<b> Breakpoints</b></p>
<p>window and the actions and shortcuts available from the window, see âThe</p>
<p>Breakpoints Windowâ on page 146.</p>
<p><b>Note</b></p>
<p>To use the Debugger's command pane to list shared object breakpoints,</p>
<p>enter the<b> B</b> command. See the<b> B</b> command in Chapter 3, âBreakpoint</p>
<p><i>MULTI: Debugging</i></p>
<p><i>136</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p><b>Restoring Deleted Breakpoints</b></p>
<p>MULTI allows you to view and restore breakpoints that have been removed during</p>
<p>the current MULTI debugging session. This is especially useful if you accidentally</p>
<p>delete a breakpoint that took some time to set up (for example, if you created a</p>
<p>breakpoint that is associated with a series of commands).</p>
<p>To view deleted breakpoints that you can restore, perform one of the following</p>
<p>actions:</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> dz -list</b> command.</p>
<p>â¢</p>
<p>Open the<b> Breakpoints Restore</b> window by:</p>
<p>â</p>
<p>Entering the<b> dz -gui</b> command in the Debugger command pane, or by</p>
<p>â</p>
<p>Clicking the<b> Restore Deleted Breakpoints</b>,<b> Restore Deleted HW</b></p>
<p><b>Breakpoints</b>, or<b> Restore Deleted SO Breakpoints</b> button in the</p>
<p>bottom-left corner of the<b> Breakpoints</b> window.</p>
<p>From the<b> Breakpoints Restore</b> window, click the<b> Software</b> tab to view</p>
<p>restorable software breakpoints, the<b> Hardware</b> tab to view restorable hardware</p>
<p>breakpoints, and the<b> Shared Object</b> tab to view restorable shared object</p>
<p>breakpoints.</p>
<p>To restore deleted breakpoints, perform one of the following actions:</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> dz</b> command with appropriate</p>
<p>arguments.</p>
<p>â¢</p>
<p>Open the<b> Breakpoints Restore</b> window by using one of the methods detailed</p>
<p>earlier in this section. From the<b> Breakpoints Restore</b> window, click the<b> Restore</b></p>
<p>button to restore selected breakpoints.</p>
<p>â¢</p>
<p>In the Debugger source pane, navigate to the line where the breakpoint you</p>
<p>want to restore was set, and right-click the breakdot on that line. In the shortcut</p>
<p>menu that appears, select<b> Restore Deleted Breakpoint</b> to restore the software</p>
<p>breakpoint(s) last deleted from the line, or click<b> Restore Deleted Hardware</b></p>
<p><b>Breakpoint</b> to restore the hardware breakpoint(s) last deleted from the line.</p>
<p><i>137</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Restoring Deleted Breakpoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For complete usage information for the<b> dz</b> command, see Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book. For</p>
<p>more information about the<b> Breakpoints Restore</b> window, see âThe Breakpoints</p>
<p>Restore Windowâ on page 152.</p>
<p><b>Advanced Breakpoint Topics</b></p>
<p><b>Multiple Breakpoints and Tracepoints on a Single Line</b></p>
<p>If some combination of software breakpoints, hardware breakpoints, and tracepoints</p>
<p>are all set on the same source line and you click the marker to the left of the source</p>
<p>line,<i> all</i> software breakpoints are enabled or cleared independently of hardware</p>
<p>breakpoints and tracepoints. Similarly,<i> all</i> hardware breakpoints are enabled or</p>
<p>cleared independently of software breakpoints and tracepoints. The same principle</p>
<p>applies to tracepoints. Breakpoints and tracepoints are enabled or cleared based on</p>
<p>the following criteria:</p>
<p>â¢</p>
<p>If all software breakpoints, hardware breakpoints, or tracepoints are disabled,</p>
<p>MULTI enables all software breakpoints, hardware breakpoints, or tracepoints,</p>
<p>respectively.</p>
<p>â¢</p>
<p>If at least one software breakpoint, hardware breakpoint, or tracepoint is enabled,</p>
<p>MULTI clears all software breakpoints, hardware breakpoints, or tracepoints,</p>
<p>respectively.</p>
<p>For example, suppose a single source line contains multiple software breakpoints,</p>
<p>some of which are enabled and some disabled; one hardware breakpoint that is</p>
<p>enabled; and one tracepoint that is disabled. If you click the marker to the left of</p>
<p>the source line, MULTI clears all the software breakpoints, clears the hardware</p>
<p>breakpoint, and enables the tracepoint.</p>
<p><b>Breakpoint Limitations</b></p>
<p>â¢</p>
<p>Full source-level debugging is not possible within procedure prologues and</p>
<p>epilogues, so MULTI does not display source-level breakpoints within these</p>
<p>regions. For more information, see âThe Call Stack Window and Procedure</p>
<p>Prologues and Epiloguesâ on page 390.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>138</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>If you halt a process at an instruction where a software breakpoint is set, the</p>
<p>software breakpoint may not be hit. This means that any operation associated</p>
<p>with the breakpoint is not executed. For example, any commands set to run</p>
<p>when the breakpoint is hit will not run; if the breakpoint is a jump breakpoint,</p>
<p>it will not jump to the specified location; etc.</p>
<p>â¢</p>
<p>Setting, removing, enabling, or disabling a breakpoint requires communication</p>
<p>between the Debugger and your target. While this communication is quick, it</p>
<p>is not instantaneous. As a result, setting or enabling a breakpoint on a running</p>
<p>target may result in the breakpoint not being hit. Similarly, removing or</p>
<p>disabling a breakpoint on a running target may result in the breakpoint being</p>
<p>hit. In the second scenario, the Debugger may report</p>
<p>Stopped by unknown</p>
<p>trap/breakpoint</p>
<p>.</p>
<p>This uncommon behavior is most likely to occur if you modify a breakpoint</p>
<p>located in a tight, currently executing loop.</p>
<p><b>Software and Hardware Breakpoint Editors</b></p>
<p>The following table describes the fields and options available in the<b> Software</b></p>
<p><b>Breakpoint Editor</b> and the<b> Hardware Breakpoint Editor</b>. The options are ordered</p>
<p>alphabetically in the table below. Unless otherwise stated, all descriptions of toggle</p>
<p>options explain the behavior of the option when enabled.</p>
<p><b>Effect</b></p>
<p><b>Editor Field</b></p>
<p>Specifies a size for the<b> Value</b> and<b> Value Mask</b> fields (if available).</p>
<p>This option is available in the<b> Hardware Breakpoint Editor</b>.</p>
<p><b>Access Size</b></p>
<p>Activates the breakpoint. To disable the breakpoint, clear this box. By</p>
<p>default, breakpoints are active.</p>
<p>When a breakpoint is active, the process stops when it hits the breakpoint</p>
<p>and it meets the conditions of the breakpoint. When a breakpoint is inactive,</p>
<p>it has no effect on the process. Disabling a breakpoint does not delete the</p>
<p>breakpoint or its parameters.</p>
<p>See also the<b> tog</b> command in Chapter 3, âBreakpoint Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b> and the</p>
<p><b>Hardware Breakpoint Editor</b>.</p>
<p><b>Active</b></p>
<p><i>139</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Software and Hardware Breakpoint Editors</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Editor Field</b></p>
<p>Enables a bell that beeps each time the process hits the software breakpoint.</p>
<p>By default, the bell is disabled. To enable the bell, check this box.</p>
<p>If the breakpoint does not stop the process, MULTI does not beep when it</p>
<p>reaches the breakpoint, even if the breakpoint's bell is activated. Situations</p>
<p>when this could occur include the following:</p>
<p>â¢</p>
<p>The breakpoint is disabled.</p>
<p>â¢</p>
<p>The breakpoint is conditional, and its condition evaluated to false.</p>
<p>â¢</p>
<p>The breakpoint is associated with a command that continues execution</p>
<p>of the program.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b>.</p>
<p><b>Bell</b></p>
<p>Specifies when your process stops. Click the memory access type that</p>
<p>represents when your process should stop. The access types are:</p>
<p>â¢</p>
<p><b>Read</b> â Your process stops whenever it reads from memory at the</p>
<p>hardware breakpoint location.</p>
<p>â¢</p>
<p><b>Write</b> â Your process stops whenever it writes to memory at the</p>
<p>hardware breakpoint location.</p>
<p>â¢</p>
<p><b>Execute</b> â Your process stops whenever it fetches instructions from</p>
<p>memory at the hardware breakpoint location.</p>
<p>You should not set<b> Read</b> and/or<b> Write</b> in conjunction with<b> Execute</b>.</p>
<p>This option is available in the<b> Hardware Breakpoint Editor</b>.</p>
<p><b>Break On</b></p>
<p>Specifies one or more commands to run every time your process hits the</p>
<p>breakpoint.</p>
<p>You can enter multiple commands by inserting a semicolon between</p>
<p>commands or by entering each command on a separate line in the</p>
<p><b>Commands</b> text box.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b> and the</p>
<p><b>Hardware Breakpoint Editor</b>.</p>
<p><b>Commands</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>140</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Editor Field</b></p>
<p>Specifies the condition(s) under which the breakpoint halts your process.</p>
<p>To set conditions for a breakpoint, enter a language expression in this field.</p>
<p>While the condition remains false (or zero), the breakpoint does not stop</p>
<p>your process. If your process hits the breakpoint when the condition is true</p>
<p>(or not zero), the process stops.</p>
<p>For software breakpoints and hardware breakpoints set on executable lines</p>
<p>of code, the condition is evaluated in the context where the breakpoint</p>
<p>appears.</p>
<p>For hardware breakpoints set on data memory locations, MULTI evaluates</p>
<p>the condition in a global context, so you can only use global variables here.</p>
<p>Even when the condition is false, the breakpoint briefly interrupts the process</p>
<p>so that MULTI can evaluate the condition. Therefore, a code segment</p>
<p>containing a conditional breakpoint executes more slowly than one without</p>
<p>such a breakpoint, even when the condition is false.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b> and the</p>
<p><b>Hardware Breakpoint Editor</b>.</p>
<p><b>Condition</b></p>
<p>Specifies the breakpoint's count, which is the number of times the process</p>
<p>must hit the breakpoint before MULTI halts the process. The default</p>
<p>breakpoint count is 1.</p>
<p>If the breakpoint's count is 1, the process stops when it hits the breakpoint.</p>
<p>If the count is greater than 1, the process does not stop until it has hit the</p>
<p>breakpoint the number of times specified in this field, after which the process</p>
<p>halts every subsequent time it hits the breakpoint.</p>
<p>Each time the process hits the breakpoint, the breakpoint count is</p>
<p>decremented until it reaches 1. For more information about breakpoint</p>
<p>counts, see Chapter 3, âBreakpoint Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b> and the</p>
<p><b>Hardware Breakpoint Editor</b>.</p>
<p><b>Count</b></p>
<p>Identifies what task group must hit the software breakpoint for the</p>
<p>breakpoint to halt the process.</p>
<p>This option is only available if your target supports task groups and you</p>
<p>set the field<b> When Hit By</b> to<b> Any Task in Group</b>.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b>.</p>
<p><b>Group to Hit</b></p>
<p><i>141</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Software and Hardware Breakpoint Editors</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Editor Field</b></p>
<p>Specifies what task group halts when a process hits the software breakpoint.</p>
<p>The<b> Group to Stop</b> option is only available if you set the<b> Stop</b> field to</p>
<p><b>Task Group</b> on a target that supports task groups.</p>
<p>The<b> Group to Stop</b> option is available in the<b> Software Breakpoint Editor</b>.</p>
<p><b>Group to Stop</b></p>
<p>Specifies a string you can use to refer to the software breakpoint later.</p>
<p>Breakpoint labels are optional, but can be useful when you enter breakpoint</p>
<p>commands in the command pane. For information about breakpoint</p>
<p>commands, see Chapter 3, âBreakpoint Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>To assign a breakpoint label, type a word or name in the text field.</p>
<p>Breakpoint labels cannot contain spaces or special characters. For more</p>
<p>information about using breakpoint labels with commands, see Chapter 1,</p>
<p>âUsing Debugger Commandsâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b>.</p>
<p><b>Label</b></p>
<p>Specifies the size of memory your process accesses at the specified</p>
<p>breakpoint address. Your process hits a hardware breakpoint only if it</p>
<p>accesses<b> Length</b> number of bytes at the specified address. For example, if</p>
<p><b>Length</b> is 2 bytes, then your process hits the breakpoint when a</p>
<p>short</p>
<p>value is written to the breakpoint address, but does not hit the breakpoint</p>
<p>when a</p>
<p>char</p>
<p>or</p>
<p>int</p>
<p>value is written to the same address.</p>
<p>If<b> Length</b> is greater than the maximum hardware breakpoint access size</p>
<p>supported by your target and your target supports range hardware</p>
<p>breakpoints,<b> Length</b> specifies a range of addresses where any access will</p>
<p>hit the hardware breakpoint.</p>
<p>This option is available in the<b> Hardware Breakpoint Editor</b>.</p>
<p><b>Length</b></p>
<p>Specifies the location of a breakpoint in your program's code. This is a</p>
<p>required property of all breakpoints, so this field must contain a valid address</p>
<p>expression. For more information, see âUsing Address Expressions in</p>
<p>Debugger Commandsâ in Chapter 1, âUsing Debugger Commandsâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b> and the</p>
<p><b>Hardware Breakpoint Editor</b>.</p>
<p><b>Location</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>142</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Editor Field</b></p>
<p>Specifies the address bits that MULTI uses when comparing the current</p>
<p>address to the hardware breakpoint address. To compare addresses, MULTI</p>
<p>does the following:</p>
<p>1.</p>
<p>Performs a bitwise AND operation on the mask and the hardware</p>
<p>breakpoint address.</p>
<p>2.</p>
<p>Performs a bitwise AND operation on the mask and the current</p>
<p>address.</p>
<p>3.</p>
<p>Compares the results of these two operations. If the results are equal</p>
<p>and the<b> Value</b> and<b> Value Mask</b> fields are not set, MULTI triggers</p>
<p>the hardware breakpoint. If the<b> Value</b> and<b> Value Mask</b> fields are set,</p>
<p>MULTI verifies them before triggering the hardware breakpoint.</p>
<p>For example, suppose:</p>
<p>â¢</p>
<p>You define mask as:</p>
<p>0xFF0</p>
<p>(</p>
<p>1111 1111 0000</p>
<p>)</p>
<p>â¢</p>
<p>You define the hardware breakpoint address as:</p>
<p>0xCD6</p>
<p>(</p>
<p>1100 1101</p>
<p>0110</p>
<p>)</p>
<p>â¢</p>
<p>You do not define the<b> Value</b> or<b> Value Mask</b></p>
<p>Because the bitwise AND operations cause the last 4 bits of the current</p>
<p>address and the breakpoint address to be</p>
<p>0000</p>
<p>, MULTI triggers the hardware</p>
<p>breakpoint when your process accesses memory between addresses</p>
<p>0xCD0</p>
<p>(</p>
<p>1100 1101 0000</p>
<p>) and</p>
<p>0xCDF</p>
<p>(</p>
<p>1100 1101 1111</p>
<p>).</p>
<p>The default mask is</p>
<p>0xFFFFFFFF</p>
<p>, which specifies that the current address</p>
<p>must be identical to the specified breakpoint address.</p>
<p>This option is available in the<b> Hardware Breakpoint Editor</b>.</p>
<p><b>Mask</b></p>
<p>Allows MULTI to delete the breakpoint if MULTI needs the breakpoint's</p>
<p>resources. This option is not selected by default.</p>
<p>This option is available in the<b> Hardware Breakpoint Editor</b>.</p>
<p><b>Rolling</b></p>
<p><i>143</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Software and Hardware Breakpoint Editors</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Editor Field</b></p>
<p>Specifies what stops when a process hits the software breakpoint. The</p>
<p>available settings for this option are:</p>
<p>â¢</p>
<p>Task</p>
<p>â The breakpoint stops the task that hits that breakpoint.</p>
<p>â¢</p>
<p>System</p>
<p>â The breakpoint stops the whole system.</p>
<p>â¢</p>
<p>Task Group</p>
<p>â The breakpoint stops all the tasks in the group</p>
<p>specified by the<b> Group to Stop</b> field.</p>
<p>If your target does not support these breakpoints, this setting is disabled</p>
<p>and cannot be modified.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b>.</p>
<p><b>Stop</b></p>
<p>Specifies a type for the hardware breakpoint. The available settings for this</p>
<p>option are:</p>
<p>â¢</p>
<p><b>Global</b> â Specifies that the hardware breakpoint can be hit by any</p>
<p>task in the address space in which it is set. This setting is only</p>
<p>applicable if you are using a run-mode connection to debug</p>
<p>INTEGRITY (version 10 or later) or VxWorks.</p>
<p>â¢</p>
<p><b>Virtual Memory</b> â Instructs INTEGRITY to use a virtual memory</p>
<p>breakpoint to simulate the hardware breakpoint. This setting is only</p>
<p>applicable if you are using a run-mode connection to debug</p>
<p>INTEGRITY (version 10 or later).</p>
<p>For more information, see the<b> hardbrk</b> command's<b> global</b> and<b> vm</b> options</p>
<p>in Chapter 3, âBreakpoint Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>This option is available in the<b> Hardware Breakpoint Editor</b>.</p>
<p><b>Type</b></p>
<p>Compares the specified value with the value located at the hardware</p>
<p>breakpoint address, when the process has accessed memory at that address.</p>
<p>If the specified value, when masked with<b> Value Mask</b> is equal to the value</p>
<p>located at the hardware breakpoint address, the hardware breakpoint triggers.</p>
<p>(See the following<b> Value Mask</b> description.)</p>
<p>MULTI verifies<b> Value</b> and<b> Value Mask</b> after verifying the address and</p>
<p><b>Mask</b>.</p>
<p>This setting is only applicable on certain targets and debug servers. If you</p>
<p>set this field and it is not applicable in your current environment, MULTI</p>
<p>either returns an error or the system ignores the setting. When used for</p>
<p>reads and writes less than 32 bits in size, the behavior of this field is target</p>
<p>dependent. The behavior may also vary between big and little endian targets.</p>
<p>This option is available in the<b> Hardware Breakpoint Editor</b>.</p>
<p><b>Value</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>144</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Editor Field</b></p>
<p>Specifies the value bits that MULTI uses when comparing the current value</p>
<p>to the hardware breakpoint value. To compare values, MULTI does the</p>
<p>following:</p>
<p>1.</p>
<p>Performs a bitwise AND operation on the value mask and the hardware</p>
<p>breakpoint value.</p>
<p>2.</p>
<p>Performs a bitwise AND operation on the value mask and the current</p>
<p>value of memory at the hardware breakpoint location.</p>
<p>3.</p>
<p>Compares the results of these two operations. If the results are equal,</p>
<p>MULTI triggers the hardware breakpoint.</p>
<p>The default value mask is</p>
<p>0xFFFFFFFF</p>
<p>, which specifies that the current</p>
<p>value must be identical to the specified breakpoint value.</p>
<p>MULTI verifies<b> Value</b> and<b> Value Mask</b> after verifying the address and</p>
<p><b>Mask</b>.</p>
<p>This setting is only applicable on certain targets and debug servers. If you</p>
<p>set this field and it is not applicable in your current environment, MULTI</p>
<p>either returns an error or the system ignores the setting. When used for</p>
<p>reads and writes less than 32 bits in size, the behavior of this field is target</p>
<p>dependent. The behavior may also vary between big and little endian targets.</p>
<p>This option is available in the<b> Hardware Breakpoint Editor</b>.</p>
<p><b>Value Mask</b></p>
<p>Identifies what must hit the software breakpoint for the breakpoint to halt</p>
<p>the process. You can specify that the process stops when one of the</p>
<p>following hits the breakpoint:</p>
<p>â¢</p>
<p>This Task</p>
<p>â A specific task</p>
<p>â¢</p>
<p>Unattached Tasks</p>
<p>â Any unattached task</p>
<p>â¢</p>
<p>Attached Tasks</p>
<p>â Any attached task</p>
<p>â¢</p>
<p>Any Task</p>
<p>â Any task</p>
<p>â¢</p>
<p>Any Task in Group</p>
<p>â Any task in the group specified in the<b> Group</b></p>
<p><b>to Hit</b> field</p>
<p>If your target does not support these breakpoint conditions, this setting is</p>
<p>disabled and cannot be modified.</p>
<p>This option is available in the<b> Software Breakpoint Editor</b>.</p>
<p><b>When Hit By</b></p>
<p><i>145</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Software and Hardware Breakpoint Editors</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Breakpoints Window</b></p>
<p>The following sections describe the columns, buttons, and shortcut menus available</p>
<p>in the<b> Breakpoints</b> window, as well as the actions you can perform from this</p>
<p>window. Only the<b> Software</b>,<b> Hardware</b>, and<b> Shared Object</b> tabs are covered here.</p>
<p>For information about the<b> Tracepoints</b> tab, see âThe Tracepoints Tab of the</p>
<p>Breakpoints Windowâ on page 571.</p>
<p><b>Note</b></p>
<p>Most of the actions you can perform from the<b> Breakpoints</b> window, you</p>
<p>can also perform by entering commands in the Debugger command pane.</p>
<p>For more information, see Chapter 3, âBreakpoint Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Breakpoints Window Columns</b></p>
<p>The following table describes breakpoint properties and how they are displayed in</p>
<p>the<b> Breakpoints</b> window.</p>
<p>Columns vary according to the tab selected (<b>Software</b>,<b> Hardware</b>, or<b> Shared</b></p>
<p><b>Object</b>). The columns are ordered alphabetically in the following table.</p>
<p><b>Description</b></p>
<p><b>Column</b></p>
<p>The memory access type, which causes your process to trigger the hardware</p>
<p>breakpoint. Access types are:</p>
<p>â¢</p>
<p><b>r</b> â (read) Your process stops whenever it reads from memory at the</p>
<p>hardware breakpoint location.</p>
<p>â¢</p>
<p><b>w</b> â (write) Your process stops whenever it writes to memory at the</p>
<p>hardware breakpoint location.</p>
<p>â¢</p>
<p><b>rw</b> â (read/write) Your process stops whenever it either reads from</p>
<p>or writes to memory at the hardware breakpoint location.</p>
<p>â¢</p>
<p><b>x</b> â (execute) Your process stops whenever it fetches instructions</p>
<p>from memory at the hardware breakpoint location.</p>
<p>This column is available on the<b> Hardware</b> tab.</p>
<p><b>Access</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>146</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Column</b></p>
<p>A large blue dot (</p>
<p>) indicates the breakpoint is active. A small gray dot</p>
<p>(</p>
<p>) indicates the breakpoint is inactive. To toggle between the two states,</p>
<p>click the dot.</p>
<p>This column is available on the<b> Software</b>,<b> Hardware</b>, and<b> Shared Object</b></p>
<p>tabs.</p>
<p><b>Active</b></p>
<p>A large blue dot (</p>
<p>) indicates the bell is active. A small gray dot (</p>
<p>)</p>
<p>indicates the bell is inactive. To toggle between the two states, click the</p>
<p>dot.</p>
<p>This column is available on the<b> Software</b> tab.</p>
<p><b>Bell</b></p>
<p>On the<b> Software</b> and<b> Hardware</b> tabs: the commands that run every time</p>
<p>your process hits the breakpoint.</p>
<p>On the<b> Shared Object</b> tab: the command that restores each shared object</p>
<p>breakpoint when the shared object is loaded again.</p>
<p><b>Command</b></p>
<p>If MULTI is counting the number of times the process hits the breakpoint</p>
<p>(this is the common case): the breakpoint's current count, which indicates</p>
<p>how many more times the process must hit the breakpoint before the</p>
<p>process halts. If the count is</p>
<p>1</p>
<p>, the process halts every time the target hits</p>
<p>the breakpoint.</p>
<p>If the target is counting the number of times the process hits the breakpoint</p>
<p>(for example, if you are using INTEGRITY 10 with a run-mode</p>
<p>connection): the behavior of this column is undefined.</p>
<p>This column is available on the<b> Software</b> and<b> Hardware</b> tabs.</p>
<p><b>Count</b></p>
<p>The label (if any) of the breakpoint. Breakpoint labels cannot contain</p>
<p>spaces or special characters.</p>
<p>This column is available on the<b> Software</b> and<b> Shared Object</b> tabs.</p>
<p><b>Label</b></p>
<p>The location of the breakpoint in your program's code. For more</p>
<p>information, see âUsing Address Expressions in Debugger Commandsâ</p>
<p>in Chapter 1, âUsing Debugger Commandsâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>This column is available on the<b> Software</b> and<b> Hardware</b> tabs.</p>
<p><b>Location</b></p>
<p>If MULTI is counting (this is the common case): the number of times your</p>
<p>process has hit the breakpoint.</p>
<p>If the target is counting (for example, if you are using INTEGRITY 10</p>
<p>with a run-mode connection): the behavior of this column is undefined.</p>
<p>This column is available on the<b> Software</b> tab.</p>
<p><b>Reached</b></p>
<p><i>147</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Breakpoints Window Columns</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Column</b></p>
<p>The shared object that each breakpoint is set in.</p>
<p>This column is available on the<b> Shared Object</b> tab.</p>
<p><b>Shared Object</b></p>
<p>Identifies what must hit the breakpoint for the breakpoint to halt your</p>
<p>process, and also what tasks halt when your process hits the breakpoint.</p>
<p>This column is available on the<b> Software</b> tab.</p>
<p><b>Task</b></p>
<p><b>Breakpoints Window Buttons</b></p>
<p>In addition to displaying information about all breakpoints, the<b> Breakpoints</b> window</p>
<p>contains buttons that make it easy for you to do things such as create, modify, and</p>
<p>load breakpoints. Some operations can be performed on multiple breakpoints</p>
<p>simultaneously.</p>
<p>Buttons vary according to the tab selected (<b>Software</b>,<b> Hardware</b>, or<b> Shared</b></p>
<p><b>Object</b>). The buttons are ordered alphabetically in the following table.</p>
<p><b>Action</b></p>
<p><b>Button</b></p>
<p>Deletes the selected breakpoint(s).</p>
<p>This button is available on the<b> Software</b>,<b> Hardware</b>, and<b> Shared</b></p>
<p><b>Object</b> tabs.</p>
<p><b>Delete</b></p>
<p>Opens the<b> Software Breakpoint Editor</b> or the<b> Hardware Breakpoint</b></p>
<p><b>Editor</b>, which you can use to edit the selected software breakpoint or</p>
<p>hardware breakpoint, respectively. For more information about setting</p>
<p>software breakpoint parameters, see âCreating and Editing Software</p>
<p>Breakpointsâ on page 130. For more information about setting hardware</p>
<p>breakpoint parameters, see âCreating and Editing Hardware</p>
<p>Breakpointsâ on page 133.</p>
<p>This button is available on the<b> Software</b> and<b> Hardware</b> tabs.</p>
<p><b>Edit</b></p>
<p>Opens a<b> Load Breakpoints</b> dialog box where you can choose to load</p>
<p>the file in which you previously saved breakpoints. (See<b> Save</b></p>
<p><b>Breakpoint List</b> below.)</p>
<p><b>Note</b>: The Debugger may not be able to load group breakpoints.</p>
<p>This button is available on the<b> Software</b> tab.</p>
<p><b>Load Breakpoint</b></p>
<p><b>List</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>148</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Action</b></p>
<p><b>Button</b></p>
<p>Creates a new breakpoint at the location of the current line pointer and</p>
<p>opens a<b> Software Breakpoint Editor</b> or<b> Hardware Breakpoint Editor</b></p>
<p>on the new breakpoint.</p>
<p>This button is available on the<b> Software</b> and<b> Hardware</b> tabs.</p>
<p><b>New Breakpoint</b></p>
<p>or</p>
<p><b>New HW Breakpoint</b></p>
<p>Opens the<b> Breakpoints Restore</b> window, which allows you to view</p>
<p>and restore breakpoints that have been removed during the current</p>
<p>MULTI debugging session. For more information about this window,</p>
<p>see âThe Breakpoints Restore Windowâ on page 152.</p>
<p>This button is available on the<b> Software</b>,<b> Hardware</b>, and<b> Shared</b></p>
<p><b>Object</b> tabs.</p>
<p><b>Restore Deleted</b></p>
<p><b>Breakpoints</b></p>
<p>or</p>
<p><b>Restore Deleted HW</b></p>
<p><b>Breakpoints</b></p>
<p>or</p>
<p><b>Restore Deleted SO</b></p>
<p><b>Breakpoints</b></p>
<p>Opens a<b> Save Breakpoints</b> dialog box where you can choose a file in</p>
<p>which to save your program's currently set breakpoints. You can reload</p>
<p>the file later. Note that the Debugger may not be able to reload group</p>
<p>breakpoints. (See<b> Load Breakpoint List</b> above.)</p>
<p>This button is available on the<b> Software</b> tab.</p>
<p><b>Save Breakpoint List</b></p>
<p><b>Breakpoints Window Mouse and Keyboard Actions</b></p>
<p>The following table describes the mouse and keyboard actions you can perform on</p>
<p>items located in the<b> Breakpoints</b> window. Possible actions vary according to the</p>
<p>tab selected (<b>Software</b>,<b> Hardware</b>, or<b> Shared Object</b>). The actions are ordered</p>
<p>alphabetically in the following table.</p>
<p><b>Result</b></p>
<p><b>Action</b></p>
<p>Displays the breakpoint's location in the Debugger, if the breakpoint is</p>
<p>set in source code.</p>
<p>This action is possible on the<b> Software</b> and<b> Hardware</b> tabs.</p>
<p>Click a breakpoint</p>
<p>Opens the<b> Software Breakpoint Editor</b> or the<b> Hardware Breakpoint</b></p>
<p><b>Editor</b>, which you can use to edit the selected software breakpoint or</p>
<p>hardware breakpoint, respectively.</p>
<p>This action is possible on the<b> Software</b> and<b> Hardware</b> tabs.</p>
<p>Double-click a</p>
<p>breakpoint</p>
<p>or</p>
<p>Press<b> Enter</b></p>
<p><i>149</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Breakpoints Window Mouse and Keyboard Actions</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Result</b></p>
<p><b>Action</b></p>
<p>Toggles the state of the selected breakpoint between active and inactive.</p>
<p>See also the<b> tog</b> command in Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>This action is possible on the<b> Software</b>,<b> Hardware</b>, and<b> Shared Object</b></p>
<p>tabs.</p>
<p>Click the<b> Active</b> dot</p>
<p>Toggles the state of the bell between enabled and disabled. If enabled</p>
<p>on a specific breakpoint, the bell beeps every time the process stops at</p>
<p>that breakpoint.</p>
<p>This action is possible on the<b> Software</b> tab.</p>
<p>Click the<b> Bell</b> dot</p>
<p>Opens a shortcut menu. Available menu options are described in the</p>
<p>following table.</p>
<p>This action is possible on the<b> Software</b>,<b> Hardware</b>, and<b> Shared Object</b></p>
<p>tabs.</p>
<p>Right-click a</p>
<p>breakpoint</p>
<p>Deletes the selected breakpoint(s).</p>
<p>This action is possible on the<b> Software</b>,<b> Hardware</b>, and<b> Shared Object</b></p>
<p>tabs.</p>
<p>Press<b> Delete</b></p>
<p><b>Breakpoints Window Shortcut Menu</b></p>
<p>The following table describes the menu options that appear when you right-click a</p>
<p>breakpoint in the<b> Breakpoints</b> window. Menu options vary according to the type</p>
<p>of breakpoint clicked (software, hardware, or shared object). The menu options are</p>
<p>ordered alphabetically in the following table.</p>
<p><b>Action</b></p>
<p><b>Menu Item</b></p>
<p>Enables the breakpoint bell for the selected breakpoints. A beep sounds</p>
<p>when the process stops at these specified breakpoints.</p>
<p>This menu item is available from the<b> Software</b> tab shortcut menu.</p>
<p><b>Beep on Selected</b></p>
<p><b>Breakpoints</b></p>
<p>Deletes the selected breakpoint(s).</p>
<p>This menu item is available from the<b> Software</b>,<b> Hardware</b>, and<b> Shared</b></p>
<p><b>Object</b> tab shortcut menus.</p>
<p><b>Delete Selected</b></p>
<p><b>Breakpoints</b></p>
<p>or</p>
<p><b>Delete Selected</b></p>
<p><b>Shared Object</b></p>
<p><b>Breakpoints</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>150</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Action</b></p>
<p><b>Menu Item</b></p>
<p>Inactivates all the selected breakpoints so that the process does not stop</p>
<p>when it hits them. See also the<b> tog</b> command in Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>This menu item is available from the<b> Software</b>,<b> Hardware</b>, and<b> Shared</b></p>
<p><b>Object</b> tab shortcut menus.</p>
<p><b>Disable Selected</b></p>
<p><b>Breakpoints</b></p>
<p>or</p>
<p><b>Disable Selected</b></p>
<p><b>Shared Object</b></p>
<p><b>Breakpoints</b></p>
<p>Disables the breakpoint bell for the selected breakpoints. No sound is</p>
<p>emitted when the process stops at these specified breakpoints.</p>
<p>This menu item is available from the<b> Software</b> tab shortcut menu.</p>
<p><b>Do not Beep on</b></p>
<p><b>Selected Breakpoints</b></p>
<p>Opens the<b> Software Breakpoint Editor</b> or the<b> Hardware Breakpoint</b></p>
<p><b>Editor</b>, which you can use to edit the selected software breakpoint or</p>
<p>hardware breakpoint, respectively.</p>
<p>This menu item is available from the<b> Software</b> and<b> Hardware</b> tab</p>
<p>shortcut menus.</p>
<p><b>Edit Selected</b></p>
<p><b>Breakpoint</b></p>
<p>Activates all the selected breakpoints so that the process stops when it</p>
<p>hits them. See also the<b> tog</b> command in Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>This menu item is available from the<b> Software</b>,<b> Hardware</b>, and<b> Shared</b></p>
<p><b>Object</b> tab shortcut menus.</p>
<p><b>Enable Selected</b></p>
<p><b>Breakpoints</b></p>
<p>or</p>
<p><b>Enable Selected</b></p>
<p><b>Shared Object</b></p>
<p><b>Breakpoints</b></p>
<p>Opens the<b> Software Breakpoint Editor</b> or the<b> Hardware Breakpoint</b></p>
<p><b>Editor</b>, which you can use to create a new software or hardware</p>
<p>breakpoint with the properties that you specify.</p>
<p>This menu item is available from the<b> Software</b> and<b> Hardware</b> tab</p>
<p>shortcut menus.</p>
<p><b>New Software</b></p>
<p><b>Breakpoint</b></p>
<p>or</p>
<p><b>New Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Displays the source code where the selected breakpoint is set.</p>
<p>This menu item is available from the<b> Software</b> and<b> Hardware</b> tab</p>
<p>shortcut menus.</p>
<p><b>Show In Debugger</b></p>
<p><i>151</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Breakpoints Window Shortcut Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Breakpoints Restore Window</b></p>
<p>The following sections describe the columns, buttons, and shortcut menus available</p>
<p>in the<b> Breakpoints Restore</b> window. For general information about restoring</p>
<p>breakpoints, see âRestoring Deleted Breakpointsâ on page 137.</p>
<p><b>Note</b></p>
<p>Most of the actions you can perform from the<b> Breakpoints Restore</b></p>
<p>window, you can also perform by using the<b> dz</b> Debugger command. For</p>
<p>information about this command, see Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Breakpoints Restore Window Columns</b></p>
<p>The following table describes how properties of deleted breakpoints are displayed</p>
<p>in the<b> Breakpoints Restore</b> window.</p>
<p>Columns vary according to the tab selected (<b>Software</b>,<b> Hardware</b>, or<b> Shared</b></p>
<p><b>Object</b>). The columns are ordered alphabetically in the following table.</p>
<p><b>Description</b></p>
<p><b>Column</b></p>
<p>The command that was used to create the deleted breakpoint.</p>
<p>This column is available on the<b> Software</b>,<b> Hardware</b>, and<b> Shared Object</b></p>
<p>tabs.</p>
<p><b>Command</b></p>
<p>An identifier for use with the<b> dz</b> command (see Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p>This column is available on the<b> Shared Object</b> tab.</p>
<p><b>Label</b></p>
<p>The source location (if applicable) and address that the breakpoint existed</p>
<p>at.</p>
<p>This column is available on the<b> Software</b>,<b> Hardware</b>, and<b> Shared Object</b></p>
<p>tabs.</p>
<p><b>Location</b></p>
<p>The shared object that the deleted shared object breakpoint was set on.</p>
<p>This column is available on the<b> Shared Object</b> tab.</p>
<p><b>Shared Object</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>152</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Breakpoints Restore Window Buttons</b></p>
<p>In addition to displaying information about breakpoints that have been deleted, the</p>
<p><b>Breakpoints Restore</b> window contains buttons that make it easy for you to restore</p>
<p>or permanently remove deleted breakpoints. The buttons available in the</p>
<p><b>Breakpoints Restore</b> window are described in the following table.</p>
<p><b>Action</b></p>
<p><b>Button</b></p>
<p>Selects all breakpoints listed on the current tab.</p>
<p><b>All</b></p>
<p>Deselects all breakpoints listed on the current tab.</p>
<p><b>None</b></p>
<p>Clears all selected breakpoints from the current tab. (Once cleared, the</p>
<p>breakpoints can never be restored.)</p>
<p>This button corresponds to the<b> dz -clear</b> command. For information</p>
<p>about this command, see Chapter 3, âBreakpoint Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Clear</b></p>
<p>Restores all selected breakpoints listed on the current tab.</p>
<p>This button corresponds to the<b> dz</b> command. For information about this</p>
<p>command, see Chapter 3, âBreakpoint Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Restore</b></p>
<p><b>Breakpoints Restore Window Shortcut Menu</b></p>
<p>The following table describes the menu options that appear when you right-click a</p>
<p>deleted breakpoint entry in the<b> Breakpoints Restore</b> window. Menu options vary</p>
<p>according to the type of breakpoint clicked (software, hardware, or shared object).</p>
<p>The menu options are ordered alphabetically in the following table.</p>
<p><b>Action</b></p>
<p><b>Menu Item</b></p>
<p>Clears all selected breakpoints from the current tab. (Once cleared, the</p>
<p>breakpoints can never be restored.)</p>
<p>This menu item corresponds to the<b> dz -clear</b> command and is available</p>
<p>from the<b> Software</b>,<b> Hardware</b>, and<b> Shared Object</b> tab shortcut menus.</p>
<p><b>Clear Selected</b></p>
<p><b>Breakpoints</b></p>
<p>or</p>
<p><b>Clear Selected</b></p>
<p><b>Shared Object</b></p>
<p><b>Breakpoints</b></p>
<p><i>153</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Breakpoints Restore Window Buttons</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Action</b></p>
<p><b>Menu Item</b></p>
<p>Restores all selected breakpoints listed on the current tab.</p>
<p>This menu item corresponds to the<b> dz</b> command and is available from</p>
<p>the<b> Software</b>,<b> Hardware</b>, and<b> Shared Object</b> tab shortcut menus.</p>
<p><b>Restore Selected</b></p>
<p><b>Breakpoints</b></p>
<p>or</p>
<p><b>Restore Selected</b></p>
<p><b>Shared Object</b></p>
<p><b>Breakpoints</b></p>
<p>Jumps to the location in the Debugger source pane where the deleted</p>
<p>breakpoint was set.</p>
<p>This menu item is available from the<b> Software</b> and<b> Hardware</b> tab</p>
<p>shortcut menus.</p>
<p><b>Show Location In</b></p>
<p><b>Debugger</b></p>
<p>For complete information about the<b> dz</b> command, see Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>154</i></p>
<p><i>Chapter 8. Executing and Controlling Your Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 9</b></p>
<p><b>Navigating Windows and</b></p>
<p><b>Viewing Information</b></p>
<p><b>Contents</b></p>
<p>Navigating and Searching Basics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>156</p>
<p>Navigating, Browsing, and Searching the Source Pane . . . . . . . . . . . . . . . . . .</p>
<p>162</p>
<p>Viewing Program and Target Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>168</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes how to navigate and browse MULTI Debugger windows.</p>
<p><b>Navigating and Searching Basics</b></p>
<p>The following sections explain features and procedures common to most MULTI</p>
<p>Debugger windows.</p>
<p><b>Using the Scroll Bar</b></p>
<p>â¢</p>
<p>You can either use the scroll bar or enter the<b> scrollcommand</b> command to</p>
<p>scroll through your program. For more information about this command, see</p>
<p>Chapter 11, âNavigation Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>â¢</p>
<p>For information about navigating the source pane, see âNavigating, Browsing,</p>
<p>and Searching the Source Paneâ on page 162.</p>
<p><b>Infinite Scrolling</b></p>
<p>In two situations, normal scrolling behavior is replaced by<i> infinite scrolling</i>. In this</p>
<p>mode, the thumb in the vertical scroll bar stays fixed in the middle of the scroll bar,</p>
<p>does not reflect the relative position of the display, and cannot be dragged to new</p>
<p>locations. The scroll thumb's appearance is also different. On Windows, the</p>
<p>Debugger sets the thumb at its minimum size. On Linux/Solaris, the Debugger</p>
<p>replaces the thumb with a diamond. You can still click above or below the thumb</p>
<p>or use the arrow keys to scroll up or down. Infinite scrolling occurs in the following</p>
<p>situations:</p>
<p>â¢</p>
<p>When the Debugger displays only assembly code in the source pane. See</p>
<p>âSource Pane Display Modesâ on page 23.</p>
<p>â¢</p>
<p>In a<b> Memory View</b> window. See Chapter 15, âUsing the Memory View</p>
<p>Windowâ on page 323.</p>
<p><b>Incremental Searching</b></p>
<p>You can perform incremental text searches in most MULTI debug windows. (In</p>
<p>some windows, you must select something before you can search.) To start an</p>
<p><i>MULTI: Debugging</i></p>
<p><i>156</i></p>
<p><i>Chapter 9. Navigating Windows and Viewing Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p>incremental forward search, press<b> Ctrl</b>+<b>F</b>. To start an incremental backward search,</p>
<p>press<b> Ctrl</b>+<b>B</b>. When you start a search,</p>
<p>Srch</p>
<p>appears on the left side of the window's</p>
<p>status bar.</p>
<p>After you press<b> Ctrl</b>+<b>F</b> or<b> Ctrl</b>+<b>B</b> and start typing, MULTI begins searching the</p>
<p>active window for the string of characters and highlights the first match it finds. If</p>
<p>subsequent keystrokes do not match the first selection, MULTI continues to search</p>
<p>the active window for an exact match. The search string appears to the right of</p>
<p>Srch</p>
<p>in the status bar. In most windows, the search starts with the text that the window</p>
<p>currently displays. In the source pane, the search begins at the current line pointer.</p>
<p>To find the next or previous search match, press<b> Ctrl</b>+<b>F</b> or<b> Ctrl</b>+<b>B</b> again.</p>
<p>Incremental searches wrap around the entire text buffer of the window you are</p>
<p>searching. When the Debugger reaches the end or the beginning of the window</p>
<p>buffer, it beeps to indicate that it is about to wrap.</p>
<p>To end a search, press<b> Esc</b> or<b> Enter</b>.</p>
<p>You can switch the search mode for a single search from case-insensitive to</p>
<p>case-sensitive by typing uppercase characters in the search string. To change the</p>
<p>default case sensitivity for all incremental searches in the current session, enter the</p>
<p><b>chgcase</b> command in the Debugger command pane. For more information about</p>
<p>this command, see Chapter 16, âSearch Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>The following table summarizes the shortcuts and keystrokes available for</p>
<p>incremental searching.</p>
<p><b>Effect</b></p>
<p><b>Keyboard</b></p>
<p><b>Shortcut</b></p>
<p>Starts an incremental forward search or, if you have already started a</p>
<p>search, advances to the next matching pattern. If you have not started</p>
<p>searching and you press<b> Ctrl</b>+<b>F</b> twice, you resume the last search.</p>
<p><b>Ctrl</b>+<b>F</b></p>
<p>Starts an incremental backward search or, if you have already started a</p>
<p>search, jumps backward to the previous matching pattern. If you have</p>
<p>not started searching and you press<b> Ctrl</b>+<b>B</b> twice, you resume the last</p>
<p>search.</p>
<p><b>Ctrl</b>+<b>B</b></p>
<p>Resets the search pattern.</p>
<p><b>Ctrl</b>+<b>U</b> (while in</p>
<p>search mode)</p>
<p><i>157</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Incremental Searching</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Keyboard</b></p>
<p><b>Shortcut</b></p>
<p>Ends the search. In source pane searches, the last match remains selected.</p>
<p><b>Esc</b> or<b> Enter</b> (while</p>
<p>in search mode)</p>
<p>Adds a character to the search pattern.</p>
<p><i>any_character</i></p>
<p>(while in search</p>
<p>mode)</p>
<p>Deletes the last character in the search pattern.</p>
<p><b>Backspace</b> (while</p>
<p>in search mode)</p>
<p><b>Note</b></p>
<p>You can also enter search commands in the command pane or use the</p>
<p><b>Source Pane Search</b> dialog box to perform incremental searches in the</p>
<p>source pane. For more information, see Chapter 16, âSearch Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book and</p>
<p>âUsing the Source Pane Search Dialog Boxâ on page 167.</p>
<p><b>Example 9.1. Searching for a String</b></p>
<p>If the source pane of an active Debugger window contains the following text:</p>
<p>this is a search string.</p>
<p>and you start a search by pressing<b> Ctrl</b>+<b>F</b> and typing the letter</p>
<p>i</p>
<p>, the Debugger</p>
<p>highlights the character</p>
<p>i</p>
<p>in the word</p>
<p>this</p>
<p>.</p>
<p>If you then type</p>
<p>s</p>
<p>, the Debugger highlights the two characters</p>
<p>i</p>
<p>and</p>
<p>s</p>
<p>in the word</p>
<p>this</p>
<p>.</p>
<p>To jump to the next occurrence of the pattern</p>
<p>is</p>
<p>, press<b> Ctrl</b>+<b>F</b> again. The Debugger</p>
<p>selects the word</p>
<p>is</p>
<p>.</p>
<p>To search next for the pattern</p>
<p>in</p>
<p>, press<b> Backspace</b> to reset the search string to</p>
<p>i</p>
<p>,</p>
<p>and then type</p>
<p>n</p>
<p>. The Debugger highlights the characters</p>
<p>i</p>
<p>and</p>
<p>n</p>
<p>in</p>
<p>string</p>
<p>.</p>
<p>To stop the search, press<b> Enter</b>. The</p>
<p>in</p>
<p>in</p>
<p>string</p>
<p>remains selected.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>158</i></p>
<p><i>Chapter 9. Navigating Windows and Viewing Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Searching in Files</b></p>
<p>The MULTI Debugger supports full-text searching of open files and, if debugging</p>
<p>information is available, of all the files that make up a program. To search your</p>
<p>source files, select<b> Tools</b> â<b> Search in Files</b>. A Search in Files dialog box appears.</p>
<p>Enter your search string in the text box or use the drop-down list to select recent</p>
<p>search strings. You can also select any of the following optional search criteria.</p>
<p>â¢</p>
<p><b>Case sensitive</b> â The search only finds text that matches the case of the search</p>
<p>string exactly. If this box is cleared, the search ignores case when searching</p>
<p>for a match. By default, this box is checked.</p>
<p>â¢</p>
<p><b>Whole word</b> â The search only finds text that contains the search terms as</p>
<p>words. This means that the matching string must be preceded by a non-word</p>
<p>character and followed by a non-word character, where word characters are</p>
<p>letters, digits, and the underscore. For example, if you select this check box, a</p>
<p>search for</p>
<p>ice</p>
<p>does not match</p>
<p>slice</p>
<p>or</p>
<p>ice__</p>
<p>, but it does match</p>
<p>ice-9</p>
<p>. This</p>
<p>box is cleared by default.</p>
<p>â¢</p>
<p><b>Use Regular Expressions</b> â The search treats the text you enter as a regular</p>
<p>expression. If this box is cleared, the search treats the text you enter as a fixed</p>
<p>string. By default, this box is checked.</p>
<p>After you have entered the search string and set the search criteria, click<b> Search</b> to</p>
<p>perform the search. A<b> Search in Files Results</b> window opens to show the search</p>
<p>progress. For a description of this window, see âViewing Search in Files Resultsâ</p>
<p>in Chapter 4, âEditing Files with the MULTI Editorâ in the<i> MULTI: Managing</i></p>
<p><i>Projects and Configuring the IDE</i> book.</p>
<p><i>159</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Searching in Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>To access the same Search in Files capability without using a GUI</p>
<p>interface, use the<b> grep</b> command. For more information about this</p>
<p>command, see Chapter 16, âSearch Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>The Search in Files capability runs the BSD<b> grep</b> utility. A copy of BSD</p>
<p><b>grep</b> is installed along with the MULTI IDE. However, BSD<b> grep</b> is not</p>
<p>part of MULTI and is not distributed under the same license as MULTI.</p>
<p>For more information about the license under which BSD<b> grep</b> is</p>
<p>distributed, refer to the file<b> bsdgrep.txt</b>, which is located in the<b> copyright</b></p>
<p>subdirectory of the IDE installation directory. For information about the</p>
<p>search expression format that BSD<b> grep</b> uses, refer to the OpenBSD</p>
<p>re_format(7) man page.</p>
<p><b>Selecting, Cutting, and Pasting Text</b></p>
<p>In most MULTI windows, you can select and copy text using your mouse and</p>
<p>common keyboard shortcuts. Some windows, however, do not support text selection,</p>
<p>copying, and/or pasting. For more information about whether a specific window</p>
<p>supports text selection and modification, use the index to find the main discussion</p>
<p>of that window in this book. Conventions for selecting, copying, and pasting text</p>
<p>differ in the source and command panes of the main Debugger window. For more</p>
<p>information, see âSelecting, Copying, and Pasting Text in the Main Debugger</p>
<p>Windowâ on page 161.</p>
<p>The following table describes general conventions for selecting, cutting, and pasting</p>
<p>text in MULTI Debugger windows.</p>
<p><b>Do this</b></p>
<p><b>To</b></p>
<p>Use your mouse pointer to highlight text.</p>
<p>Select text</p>
<p>Select text, and press<b> Ctrl</b>+<b>C</b>.</p>
<p>Copy text</p>
<p>Copy text, click in the spot where you want to paste the text, and press</p>
<p><b>Ctrl</b>+<b>V</b>.</p>
<p>Paste text</p>
<p>Click in an area of the window without any text.</p>
<p>Deselect text</p>
<p><i>MULTI: Debugging</i></p>
<p><i>160</i></p>
<p><i>Chapter 9. Navigating Windows and Viewing Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>On Windows, the copy and paste functions use the Windows clipboard,</p>
<p>so you can copy and paste text among any applications that use the</p>
<p>Windows clipboard.</p>
<p>On Linux/Solaris, you can copy and paste your selection to other X</p>
<p>Window System applications that support pasting, such as xterms.</p>
<p>However, different applications may behave differently, so consult the</p>
<p>reference manual for your specific system. Generally, when you select</p>
<p>text, MULTI automatically copies it. Middle-click to paste automatically</p>
<p>copied text. Text cannot be selected in two windows at the same time.</p>
<p><b>Selecting Items from Lists</b></p>
<p>In those windows containing lists of items that you can select, the following</p>
<p>conventions usually apply:</p>
<p>â¢</p>
<p>To select an item, single-click the row containing that item. This highlights the</p>
<p>row.</p>
<p>â¢</p>
<p>To select multiple, non-adjacent items/rows, hold the<b> Ctrl</b> key while clicking</p>
<p>each item or row.</p>
<p>â¢</p>
<p>To select a range of adjacent rows, click the first row, hold the<b> Shift</b> key, and</p>
<p>then click the last row in the range.</p>
<p><b>Selecting, Copying, and Pasting Text in the Main Debugger</b></p>
<p><b>Window</b></p>
<p>Conventions for selecting, copying, and pasting text in the source and command</p>
<p>panes differ from the conventions used in other Debugger windows. In the source</p>
<p>pane, your selection automatically expands to include a whole entity, such as a word</p>
<p>or expression. For example, to select a word in the source pane, simply click</p>
<p>anywhere within the word. To select all the text occurring between a pair of</p>
<p>parentheses, including the parentheses themselves, drag your mouse over one of</p>
<p>the parenthesis markers and release.</p>
<p>When selecting text in the source pane, you may find that the Debugger performs</p>
<p>a command as soon as you release the mouse button. To prevent the Debugger from</p>
<p><i>161</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Selecting, Cutting, and Pasting Text</i></p>
<h1 style="page-break-before:always; "></h1>
<p>issuing a command, hold down the<b> Ctrl</b> key while selecting text. This also prevents</p>
<p>the Debugger from attempting to auto-complete your selection. Alternatively, you</p>
<p>can configure Debugger key bindings to prevent the Debugger from issuing</p>
<p>commands. See âCustomizing Keys and Mouse Behaviorâ in Chapter 7,</p>
<p>âConfiguring and Customizing MULTIâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book.</p>
<p>When you select text in the source pane, the Debugger automatically copies your</p>
<p>selection. To paste the selection into the command pane, middle-click in the</p>
<p>command pane. To enable this behavior on Windows, select<b> Config</b> â<b> Options</b></p>
<p>â<b> MULTI Editor</b> tab, and check<b> Allow middle click to paste</b>. In general, this</p>
<p>behavior is similar to selecting and pasting procedures on Linux/Solaris.</p>
<p><b>Note</b></p>
<p>On Windows, the automatic copy that the Debugger makes at the time</p>
<p>of selection only allows you to paste to the command pane. To copy text</p>
<p>and paste it into another window, highlight the text and press<b> Ctrl</b>+<b>C</b> to</p>
<p>copy it. Then press<b> Ctrl</b>+<b>V</b> to paste it into another window.</p>
<p><b>Navigating, Browsing, and Searching the Source Pane</b></p>
<p>You can use the following shortcuts, buttons, commands, and menu items to navigate</p>
<p>through your program code in the source pane. For information about scrolling, see</p>
<p>âUsing the Scroll Barâ on page 156.</p>
<p><b>Do (one of) the following</b></p>
<p><b>To</b></p>
<p>â¢</p>
<p>Press<b> PageUp</b>.</p>
<p>Scroll up by one screen</p>
<p>â¢</p>
<p>Press<b> PageDown</b>.</p>
<p>Scroll down by one screen</p>
<p>â¢</p>
<p>Press<b> Shift</b>+<b>UpArrow</b>.</p>
<p>Scroll up by one line</p>
<p>â¢</p>
<p>Press<b> Shift</b>+<b>DownArrow</b>.</p>
<p>Scroll down by one line</p>
<p>â¢</p>
<p>Press<b> Ctrl</b>+<b>+</b> (plus sign).</p>
<p>â¢</p>
<p>Click</p>
<p>.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Navigation</b> â<b> UpStack</b>.</p>
<p>View the code one level higher on the call</p>
<p>stack</p>
<p><i>MULTI: Debugging</i></p>
<p><i>162</i></p>
<p><i>Chapter 9. Navigating Windows and Viewing Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Do (one of) the following</b></p>
<p><b>To</b></p>
<p>â¢</p>
<p>Press<b> Ctrl</b>+<b>-</b> (minus sign).</p>
<p>â¢</p>
<p>Click</p>
<p>.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Navigation</b> â<b> DownStack</b>.</p>
<p>View the code one level lower on the call</p>
<p>stack</p>
<p>â¢</p>
<p>Click</p>
<p>.</p>
<p>â¢</p>
<p>In the command pane, enter the<b> E</b></p>
<p>command. For information about the<b> E</b></p>
<p>command, see Chapter 8, âDisplay and Print</p>
<p>Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Navigation</b> â<b> Current PC</b>.</p>
<p>View the procedure where the process is</p>
<p>stopped</p>
<p>â¢</p>
<p>In the command pane, enter the<b> uptosource</b></p>
<p>command. For information about the</p>
<p><b>uptosource</b> command, see Chapter 11,</p>
<p>âNavigation Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Navigation</b> â<b> UpStack To</b></p>
<p><b>Source</b>.</p>
<p>View the first procedure higher on the call</p>
<p>stack that has source code (for example, if</p>
<p>you are stopped inside a library function with</p>
<p>no source code and you want to return to</p>
<p>viewing your program)</p>
<p>â¢</p>
<p>In the command pane, enter the<b> e</b> command</p>
<p>followed by an address expression. For</p>
<p>information about the<b> e</b> command, see</p>
<p>Chapter 11, âNavigation Command</p>
<p>Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>â¢</p>
<p>On the navigation bar, use the File Locator</p>
<p>to navigate to a file. See âUsing the File</p>
<p>Locatorâ on page 164.</p>
<p>â¢</p>
<p>On the navigation bar, use the Procedure</p>
<p>Locator to navigate to a procedure. See</p>
<p>âUsing the Procedure Locatorâ on page 165.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Navigation</b> â<b> Goto</b></p>
<p><b>Location</b> and enter an appropriate location</p>
<p>in the dialog box.</p>
<p>Navigate to a specific file, procedure, line</p>
<p>number, breakpoint, or other location</p>
<p><i>163</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Navigating, Browsing, and Searching the Source Pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Do (one of) the following</b></p>
<p><b>To</b></p>
<p>â¢</p>
<p>In the command pane, enter the<b> indexprev</b></p>
<p>and<b> indexnext</b> commands. For information</p>
<p>about these commands, see Chapter 11,</p>
<p>âNavigation Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>â¢</p>
<p>On the navigation bar, use the<b> Back</b> (</p>
<p>)</p>
<p>and<b> Forward</b> (</p>
<p>) history buttons.</p>
<p>Return to a location you recently viewed in</p>
<p>the source pane</p>
<p><b>Using the File Locator</b></p>
<p>The File Locator (</p>
<p>) shows the name of the file currently displayed</p>
<p>in the Debugger and allows you to navigate quickly to other files in your program.</p>
<p>The following table summarizes what you can do with the File Locator.</p>
<p><b>Do this</b></p>
<p><b>To</b></p>
<p>Move the cursor over the File Locator. The file path appears in a tooltip.</p>
<p>View the full name</p>
<p>and path of the</p>
<p>displayed file</p>
<p>Type the name of the file in the File Locator and press<b> Enter</b>. If the name</p>
<p>you type is of a valid source file that was compiled into your program,</p>
<p>the Debugger navigates to the file and displays it in the source pane. If</p>
<p>the name you type does not match a filename exactly, the Debugger</p>
<p>displays a file whose name begins with the name that you typed, or if</p>
<p>there is more than one match, it displays a list of files.</p>
<p>If you do not remember the exact name of the file you are looking for,</p>
<p>use a wildcard (see âWildcardsâ on page 303). For example, if you know</p>
<p>that a file's name contains the word</p>
<p>sort</p>
<p>, enter</p>
<p>*sort*</p>
<p>in the File Locator</p>
<p>to browse a list of all the files in your program that contain the word</p>
<p>sort</p>
<p>in their names. If only one file in your program matches the pattern that</p>
<p>you type, the Debugger displays that file immediately. You can use any</p>
<p>number of wildcard characters in your search. Wildcard searching is not</p>
<p>case-sensitive.</p>
<p>Navigate to another</p>
<p>source file in your</p>
<p>program</p>
<p>Click the arrow on the right side of the File Locator to open a drop-down</p>
<p>list of recently viewed files. The File Locator sorts the files according to</p>
<p>when you last viewed them, with the currently displayed file at the top</p>
<p>of the list. To display a file in the source pane, select it in the list.</p>
<p>View a file recently</p>
<p>displayed in the</p>
<p>source pane</p>
<p><i>MULTI: Debugging</i></p>
<p><i>164</i></p>
<p><i>Chapter 9. Navigating Windows and Viewing Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Do this</b></p>
<p><b>To</b></p>
<p>Do one of the following:</p>
<p>â¢</p>
<p>In the command pane, enter the<b> browse files</b> command. For</p>
<p>information about the<b> browse</b> command, see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>Click the arrow on the right side of the File Locator and select</p>
<p><b>Browse all source files in program</b> from the list that appears.</p>
<p>â¢</p>
<p>Select<b> Browse</b> â<b> Files</b>.</p>
<p>Performing any of the above actions opens a<b> Source Files with</b></p>
<p><b>Procedures</b> window. To display a file in the source pane, click the name</p>
<p>of the file in the list.</p>
<p>Browse a list of all</p>
<p>the files in your</p>
<p>program</p>
<p>See also âBrowsing Source Filesâ on page 230.</p>
<p><b>Using the Procedure Locator</b></p>
<p>The Procedure Locator (</p>
<p>) shows the name of the procedure currently</p>
<p>displayed in the Debugger and allows you to navigate quickly to other procedures</p>
<p>in your program. The following table summarizes what you can do with the</p>
<p>Procedure Locator.</p>
<p><b>Do this</b></p>
<p><b>To</b></p>
<p>Move the mouse pointer over the Procedure Locator. The full name and</p>
<p>signature appears in a tooltip. Full signature display is only available for</p>
<p>C++ procedures. The return type of the procedure is not included in the</p>
<p>signature display.</p>
<p>View the full name</p>
<p>and signature of the</p>
<p>displayed procedure</p>
<p><i>165</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the Procedure Locator</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Do this</b></p>
<p><b>To</b></p>
<p>Type the name of the procedure in the Procedure Locator and press<b> Enter</b>.</p>
<p>If the name you type is of a valid procedure that was compiled into your</p>
<p>program, the Debugger navigates to the procedure and displays it in the</p>
<p>source pane. If the name you type does not match a procedure name</p>
<p>exactly, the Debugger displays a procedure whose name begins with the</p>
<p>name that you typed, or if there is more than one match, it displays a list</p>
<p>of procedures.</p>
<p>If you do not remember the exact name of the procedure you are looking</p>
<p>for, use a wildcard (see âWildcardsâ on page 303). For example, if you</p>
<p>know that a procedure's name contains the word</p>
<p>sort</p>
<p>, enter</p>
<p>*sort*</p>
<p>in</p>
<p>the Procedure Locator to browse a list of all the procedures in your</p>
<p>program that contain the word</p>
<p>sort</p>
<p>in their names. If only one procedure</p>
<p>in your program matches the pattern that you type, the Debugger displays</p>
<p>that procedure immediately. You can use any number of wildcard</p>
<p>characters in your search. Wildcard searching is not case-sensitive.</p>
<p>Navigate to another</p>
<p>procedure in your</p>
<p>program</p>
<p>Click the arrow on the right side of the Procedure Locator to open a</p>
<p>drop-down list of recently viewed files. The Procedure Locator sorts the</p>
<p>procedures according to when you last viewed them, with the currently</p>
<p>displayed procedure at the top of the list. If more than one procedure is</p>
<p>visible in the source pane, the name of the procedure pointed to by the</p>
<p>blue current line pointer is displayed.</p>
<p>View a procedure</p>
<p>recently displayed</p>
<p>in the source pane</p>
<p>Click the arrow on the right side of the Procedure Locator and select</p>
<p><b>Browse procedures in current file</b> from the list that appears. The</p>
<p><b>Procedures:<i> current_file</b></i> window opens. To display a procedure in the</p>
<p>source pane, click the name of the procedure in the list.</p>
<p>Browse a list of all</p>
<p>the procedures in</p>
<p>the displayed file</p>
<p>Do one of the following:</p>
<p>â¢</p>
<p>In the command pane, enter the<b> browse procs</b> command. For</p>
<p>information about the<b> browse</b> command, see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>Click the arrow on the right side of the Procedure Locator and select</p>
<p><b>Browse procedures in program</b> from the list that appears.</p>
<p>â¢</p>
<p>Select<b> Browse</b> â<b> Procedures</b>.</p>
<p>Performing any of the above actions opens a<b> Procedures</b> Browse window.</p>
<p>To display a procedure in the source pane, click the name of the procedure</p>
<p>in the list.</p>
<p>Browse a list of all</p>
<p>the procedures in</p>
<p>your program</p>
<p>For more information about browsing procedures, see âBrowsing Proceduresâ</p>
<p>on page 220.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>166</i></p>
<p><i>Chapter 9. Navigating Windows and Viewing Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Using Navigation History Buttons</b></p>
<p>The Debugger keeps a history of the source locations you have viewed. You can</p>
<p>use the<b> Back</b> (</p>
<p>) and<b> Forward</b> (</p>
<p>) buttons to display source code you have recently</p>
<p>viewed in the source pane. These buttons function similarly to the back and forward</p>
<p>buttons found in Web browsers. If you click and hold either of these buttons, you</p>
<p>can select from a short list of previously visited source locations.</p>
<p>See also the<b> indexnext</b> and<b> indexprev</b> commands in Chapter 11, âNavigation</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Using the Source Pane Search Dialog Box</b></p>
<p>The<b> Source Pane Search</b> dialog box provides a simple way for you to search your</p>
<p>code quickly and easily. To open the<b> Source Pane Search</b> dialog box, do one of</p>
<p>the following.</p>
<p>â¢</p>
<p>In the command pane, enter the<b> dialogsearch</b> command. For information about</p>
<p>the<b> dialogsearch</b> command, see Chapter 16, âSearch Command Referenceâ in</p>
<p>the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>From the main Debugger window, select<b> Tools</b> â<b> Search</b>.</p>
<p>â¢</p>
<p>Use the<b> Ctrl</b>+<b>Shift</b>+<b>F</b> keyboard shortcut.</p>
<p>To search:</p>
<p>1.</p>
<p>Enter the text you are searching for in the<b> Find</b> field.</p>
<p>2.</p>
<p>Use the radio buttons to specify the direction of the search (<b>Forward</b> or</p>
<p><b>Backward</b>), the case sensitivity of the search (<b>Exact Case</b> or<b> Ignore Case</b>),</p>
<p>and the type of search (<b>Normal</b> or<b> Regular Expression</b>). The default settings</p>
<p>are<b> Forward</b>,<b> Exact Case</b>, and<b> Normal</b>.</p>
<p><i>167</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using Navigation History Buttons</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Click<b> Find</b>.</p>
<p>MULTI highlights the first match of the search string in the source pane. To find</p>
<p>the next match, click<b> Find</b> again. The search wraps at the end of the source file.</p>
<p><b>Note</b></p>
<p>You can also search the source pane incrementally by using simple</p>
<p>keyboard shortcuts (see âIncremental Searchingâ on page 156) or by</p>
<p>entering the<b> fsearch</b> or<b> bsearch</b> commands in the command pane. For</p>
<p>information about these and about other commands that allow you to</p>
<p>search from the command pane, see Chapter 16, âSearch Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Viewing Program and Target Information</b></p>
<p>In addition to viewing information in the source pane, you can use stand-alone</p>
<p>windows to view more detailed information about your program and the state of</p>
<p>your target during program execution. The following sections provide a brief</p>
<p>introduction to the types of information you can view, and in some cases, edit.</p>
<p><b>Viewing Information in Stand-Alone Windows</b></p>
<p>The MULTI Debugger includes view windows you can use to examine aspects of</p>
<p>your source code, debugging information, and target memory information. The</p>
<p>following table briefly describes these windows and how to open them from the</p>
<p>main Debugger window. For information about the main Debugger window, see</p>
<p>Chapter 2, âThe Main Debugger Windowâ on page 11. Each window listed in the</p>
<p>following table is described in more detail later in this book.</p>
<p>For general information about navigating MULTI Debugger windows, see</p>
<p>âNavigating and Searching Basicsâ on page 156.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>168</i></p>
<p><i>Chapter 9. Navigating Windows and Viewing Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>$locals$</b> window</p>
<p>Displays information about variables local to the current function. If the current function is a</p>
<p>C++ instance method, the window also displays information about the</p>
<p>this</p>
<p>pointer.</p>
<p>The current function is the function where the program counter (PC) pointer is located. If the</p>
<p>PC pointer moves to a new function, either by running to a new function or by viewing a different</p>
<p>call stack frame, the content of the<b> $locals$</b> window changes to display local variables for that</p>
<p>function. For information about the PC pointer, see âThe Source Paneâ on page 21.</p>
<p>To open this window, click the<b> Locals</b> button (</p>
<p>).</p>
<p>The<b> $locals$</b> window is a specialized Data Explorer window. For information about the Data</p>
<p>Explorer, see Chapter 11, âViewing and Modifying Variables with the Data Explorerâ</p>
<p>on page 183.</p>
<p><b>Breakpoints</b> window</p>
<p>Displays and allows you to configure software breakpoints, hardware breakpoints, and tracepoints.</p>
<p>To open this window, click the<b> Breakpoints</b> button (</p>
<p>).</p>
<p>For more information about the contents and features of this window, see âThe Breakpoints</p>
<p>Windowâ on page 146.</p>
<p>Browse window</p>
<p>Allows you to browse information about procedures, global variables, source files, data types,</p>
<p>and cross references.</p>
<p>To open this window, select<b> Procedures</b>,<b> Globals</b>,<b> Files</b>, or<b> All Types</b> from the<b> Browse</b> menu.</p>
<p>For more information, see âThe Browse Windowâ on page 214.</p>
<p><b>Call Stack</b> window</p>
<p>Lists the functions currently on the call stack. In addition to naming each function, this window</p>
<p>provides the name and value of each argument.</p>
<p>To open the<b> Call Stack</b> window, click the<b> Call Stack</b> button (</p>
<p>).</p>
<p>For more information, see âViewing Call Stacksâ on page 388.</p>
<p>Data Explorer window</p>
<p>Displays a variable, its type, and its current value.</p>
<p>To open a Data Explorer window, double-click a variable in the source pane. The variable may</p>
<p>be of any type, whether an integer, structure, array, or class. If the Data Explorer contains a</p>
<p>pointer, double-clicking the pointer opens a new Data Explorer window and displays the variable</p>
<p>pointed to. This feature makes it easy to follow linked lists and other complex data structures.</p>
<p>For more information about the Data Explorer window, see Chapter 11, âViewing and Modifying</p>
<p>Variables with the Data Explorerâ on page 183. For more information about viewing variables,</p>
<p>see âViewing Variablesâ on page 297.</p>
<p><i>169</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Information in Stand-Alone Windows</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Graph View window</p>
<p>Displays an include file dependency graph.</p>
<p>To open the Graph View window, select<b> Browse</b> â<b> Includes</b>.</p>
<p>For more information, see âThe Graph View Windowâ on page 247.</p>
<p><b>Memory Test Wizard</b></p>
<p>Helps you perform memory test operations.</p>
<p>To open this window, select<b> Target</b> â<b> Memory Test</b>.</p>
<p>For more information, see Chapter 21, âTesting Target Memoryâ on page 511.</p>
<p><b>Memory View</b> window</p>
<p>Displays memory content information in various formats.</p>
<p>To open this window, click the<b> Memory</b> button (</p>
<p>).</p>
<p>For more information, see Chapter 15, âUsing the Memory View Windowâ on page 323.</p>
<p>MULTI Editor</p>
<p>Allows you to modify source files.</p>
<p>To use the Editor to view and edit source code for a function, double-click the function name</p>
<p>in the Debugger's source pane. The MULTI Editor opens on the function. (If you set another</p>
<p>editor as your default, that editor opens on the function.)</p>
<p>For more information about the MULTI Editor, see Chapter 4, âEditing Files with the MULTI</p>
<p>Editorâ in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>Note Browser</b> window</p>
<p>Allows you to associate Debugger Notes with any line of source or assembly code.</p>
<p>To open this window, select<b> View</b> â<b> Debugger Notes</b>.</p>
<p>For more information, see Chapter 10, âUsing Debugger Notesâ on page 173.</p>
<p><b>OSA Explorer</b></p>
<p>Displays information about a multitasking operating system.</p>
<p>To open this window, click the<b> OSA Explorer</b> button (</p>
<p>).</p>
<p>For more information, see âThe OSA Explorerâ on page 609.</p>
<p>PathAnalyzer</p>
<p><b>Trace-enabled targets only</b></p>
<p>Displays called functions graphically.</p>
<p>To open this window, select<b> TimeMachine</b> â<b> PathAnalyzer</b>.</p>
<p>For more information, see âThe PathAnalyzerâ on page 424.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>170</i></p>
<p><i>Chapter 9. Navigating Windows and Viewing Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Process Viewer</b></p>
<p><b>Linux/Solaris only</b></p>
<p>Lists processes on your target.</p>
<p>To open this window, enter the<b> top</b> command. For information about this command, see âGeneral</p>
<p>View Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Profile</b> window</p>
<p>Reports performance, function, graph, and coverage analysis profiling information.</p>
<p>To open this window, select<b> View</b> â<b> Profile</b>.</p>
<p>For more information, see âThe Profile Windowâ on page 361.</p>
<p><b>Register Information</b> window</p>
<p>Displays detailed information, including bitfields and documentation, about a specific register.</p>
<p>To open this window, enter the<b> regview</b> command followed by a register name. For information</p>
<p>about this command, see âGeneral View Commandsâ in Chapter 22, âView Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>For more information, see âThe Register Information Windowâ on page 270.</p>
<p><b>Register View</b> window</p>
<p>Displays current register values.</p>
<p>To open this window, click the<b> Registers</b> button (</p>
<p>).</p>
<p>For more information, see Chapter 13, âUsing the Register Explorerâ on page 253.</p>
<p><b>Serial Connection Chooser</b> window</p>
<p>Allows you to interact with a serial terminal.</p>
<p>To open this window, select<b> Tools</b> â<b> Serial Terminal</b> â<b> Make Serial Connection</b>.</p>
<p>For more information, see Chapter 27, âEstablishing Serial Connectionsâ on page 643.</p>
<p><b>Task Manager for<i> target</b></i> window</p>
<p><b>Debug servers that support multitasking debugging only</b></p>
<p>Displays the current status of tasks running on an operating system.</p>
<p>To open this window, select<b> View</b> â<b> Task Manager</b>.</p>
<p>For more information, see âThe Task Managerâ on page 580.</p>
<p>Tree Browser</p>
<p>Displays information about classes, static calls, and file calls in the target program.</p>
<p>To open this window, select<b> Classes</b>,<b> Static Calls</b>, or<b> File Calls</b> from the<b> Browse</b> menu.</p>
<p>For more information, see âThe Tree Browser Windowâ on page 239.</p>
<p><i>171</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Information in Stand-Alone Windows</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Information in the Command Pane</b></p>
<p>In addition to using the specialized, stand-alone windows described in the previous</p>
<p>section to view program information, you can also view some information in the</p>
<p>command pane of the main Debugger window, as described next.</p>
<p>â¢</p>
<p>To view information about a variable, pointer, or structure, click its name in</p>
<p>the source pane. When you click an item in the source pane, the resulting</p>
<p>selection is evaluated as an expression by the MULTI<b> examine</b> command,</p>
<p>which may perform macro expansion in its evaluation. For information about</p>
<p>the<b> examine</b> command, see Chapter 8, âDisplay and Print Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book. See also Chapter 14,</p>
<p>âUsing Expressions, Variables, and Procedure Callsâ on page 291.</p>
<p>For information about viewing variables, see âViewing Variablesâ on page 297.</p>
<p>When you click a pointer, the command pane also displays the value of the</p>
<p>object pointed to. When you click a structure, the command pane displays the</p>
<p>whole structure, with every structure or class element labeled.</p>
<p>â¢</p>
<p>To evaluate an expression, type it into the command pane. For more information</p>
<p>about evaluating and working with expressions, see Chapter 14, âUsing</p>
<p>Expressions, Variables, and Procedure Callsâ on page 291.</p>
<p><b>Tip</b></p>
<p>You can also use Debugger commands to print a variety of program and</p>
<p>target information to the command pane. For detailed information, see</p>
<p>Chapter 8, âDisplay and Print Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>172</i></p>
<p><i>Chapter 9. Navigating Windows and Viewing Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 10</b></p>
<p><b>Using Debugger Notes</b></p>
<p><b>Contents</b></p>
<p>Creating and Editing Debugger Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>174</p>
<p>Organizing Debugger Notes Into Groups . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>177</p>
<p>Viewing Debugger Notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>177</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes how to create, edit, and access Debugger Notes.</p>
<p>Debugger Notes allow you to associate notes with any line of source or assembly</p>
<p>code. You can quickly jump to any part of your program where you have set a Note.</p>
<p>It is also possible to use breakpoints to mark parts of your program that are of</p>
<p>particular interest. Debugger Notes, however, have the following advantages over</p>
<p>breakpoints when marking locations:</p>
<p>â¢</p>
<p>You can set Debugger Notes on source lines that do not have code associated</p>
<p>with them, such as comments.</p>
<p>â¢</p>
<p>You can simultaneously edit multiple Debugger Notes.</p>
<p>â¢</p>
<p>You can organize Debugger Notes into groups.</p>
<p>â¢</p>
<p>If you rebuild your program, Debugger Notes are not deletedâeven when they</p>
<p>are no longer in a valid location. In addition, if the line of source code where</p>
<p>you set the Debugger Note moves, the Debugger Note relocates automatically.</p>
<p>â¢</p>
<p>You can quickly display and navigate to any Debugger Note by pressing the</p>
<p><b>F12</b> key.</p>
<p><b>Creating and Editing Debugger Notes</b></p>
<p>Debugger Notes can contain any kind of text and can be associated with any line</p>
<p>of code. The line numbers of lines that contain Debugger Notes are shaded gray.</p>
<p>To set a Debugger Note:</p>
<p>â¢</p>
<p>Right-click a line in the source pane and select<b> Create Note</b>, or</p>
<p>â¢</p>
<p>Enter the<b> noteedit</b> command in the Debugger command pane. For information</p>
<p>about this command, see Chapter 7, âDebugger Note Command Referenceâ in</p>
<p>the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Editing a Single Debugger Note</b></p>
<p>You can modify a single pre-existing Debugger Note with the<b> Edit Note</b> window.</p>
<p>To open this window, do one of the following:</p>
<p>â¢</p>
<p>Double-click the shaded gray area in the line number column.</p>
<p>â¢</p>
<p>Right-click the shaded gray area and select<b> Edit Note</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>174</i></p>
<p><i>Chapter 10. Using Debugger Notes</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Enter the<b> noteedit</b> command in the Debugger command pane. For more</p>
<p>information about this command, see Chapter 7, âDebugger Note Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>The following table explains each property you can set from this window.</p>
<p>Assigns a name to the Debugger Note. The<b> Note Browser</b> and Note listings</p>
<p>display this name. If you do not specify a name when you create a new Note,</p>
<p>MULTI uses a brief version of the Note location as the default name.</p>
<p><b>Name</b></p>
<p>Specifies the name of the group where the Debugger Note is located. A Debugger</p>
<p>Note must always exist in exactly one group. To put the Note in a group that</p>
<p>already exists, select a group from the drop-down list. To create a new group,</p>
<p>type the new group name in the<b> Group</b> field.</p>
<p><b>Group</b></p>
<p>Specifies the location of the Debugger Note. This may be either an address</p>
<p>expression or a source line. For information about using an address expression</p>
<p>to specify a location, see âUsing Address Expressions in Debugger Commandsâ</p>
<p>in Chapter 1, âUsing Debugger Commandsâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Location</b></p>
<p>Assigns text to the Note.</p>
<p><b>Text</b></p>
<p>The buttons in this window allow you to perform the actions listed in the following</p>
<p>table.</p>
<p>Deletes the Note displayed in the window. A dialog box asking you to confirm</p>
<p>the deletion appears.</p>
<p><b>Delete</b></p>
<p>Navigates to the displayed Note.</p>
<p><b>Go To</b></p>
<p>Closes the window, saving any changes you made to the Note. If the Note location</p>
<p>is not valid, a warning message appears.</p>
<p><b>Close</b></p>
<p><i>175</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Editing a Single Debugger Note</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Editing Multiple Debugger Notes</b></p>
<p>You can select and modify multiple Notes with the<b> Edit Multiple Notes</b> window.</p>
<p>This window provides a quick way to simultaneously edit the group or text of</p>
<p>multiple Notes. To open this window, perform the following steps:</p>
<p>1.</p>
<p>Select<b> View</b> â<b> Debugger Notes</b> or enter the<b> noteview</b> command to open the</p>
<p><b>Note Browser</b>. For information about the<b> noteview</b> command, see Chapter 7,</p>
<p>âDebugger Note Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>2.</p>
<p>Select<b> List</b> from the<b> Style</b> drop-down box.</p>
<p>3.</p>
<p>Highlight more than one Debugger Note, right-click, and select<b> Edit</b> from the</p>
<p>menu that appears.</p>
<p>In the<b> Edit Multiple Notes</b> window, use the<b> Text</b> drop-down list to set whether</p>
<p>text should be appended or prepended to the selected Notes. Enter the desired text</p>
<p>in the field underneath the<b> Text</b> drop-down. When you click the<b> Close</b> button, the</p>
<p>text you entered is added to the text of all the Notes listed in the<b> Name</b> field.</p>
<p><b>Removing Debugger Notes</b></p>
<p>To delete a Note, do one of the following:</p>
<p>â¢</p>
<p>Enter the<b> notedel</b> command followed by an address expression or the number</p>
<p>of the Debugger Note. For information about the<b> notedel</b> command, see Chapter</p>
<p>7, âDebugger Note Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>â¢</p>
<p>Right-click the shaded area and select<b> Remove Note</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>176</i></p>
<p><i>Chapter 10. Using Debugger Notes</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Organizing Debugger Notes Into Groups</b></p>
<p>You can organize Debugger Notes into groups to make it easier to work with a large</p>
<p>number of them. A Debugger Note group is simply a named collection of Debugger</p>
<p>Notes. You can view Note groups in the<b> Note Browser</b>, and you can easily delete</p>
<p>all Notes in a group or move them to another group. For information about the<b> Note</b></p>
<p><b>Browser</b>, see âViewing Debugger Notesâ on page 177.</p>
<p>Each Debugger Note you create always exists in exactly one group. If no groups</p>
<p>exist when you create a Note, MULTI creates a new group called</p>
<p>&lt;default&gt;</p>
<p>to</p>
<p>hold the Note. This group becomes the<i> active group</i>, which indicates that any Note</p>
<p>you create is put into this group by default.</p>
<p>To add a Note to a group that is not the active group, you must either:</p>
<p>â¢</p>
<p>Change the active group by clicking</p>
<p>in the<b> Note Browser</b>, or</p>
<p>â¢</p>
<p>Enter the command<b> noteedit -group<i> group_name</b></i>. For information about the</p>
<p><b>noteedit</b> command, see Chapter 7, âDebugger Note Command Referenceâ in</p>
<p>the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Viewing Debugger Notes</b></p>
<p>To display the text stored in a Note, hover over the shaded area; the text appears in</p>
<p>a tooltip. Alternatively, single-click the shaded line number area, and the text appears</p>
<p>in the command pane.</p>
<p>To list all your program's Debugger Notes in the command pane, enter the<b> notelist</b></p>
<p>command. To list all your program's Debugger Notes in the<b> Note Browser</b>, select</p>
<p><b>View</b> â<b> Debugger Notes</b> or enter the<b> noteview</b> command. For information about</p>
<p>these commands, see Chapter 7, âDebugger Note Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>The next section contains details about the<b> Note Browser</b>.</p>
<p><i>177</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Organizing Debugger Notes Into Groups</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Note Browser</b></p>
<p>The<b> Note Browser</b> displays your Notes in a list or in full report style.</p>
<p>The list style display presents all Debugger Notes in a list format in which you can</p>
<p>expand or collapse groups.</p>
<p>To view the list style display, select<b> List</b> from the<b> Style</b> drop-down box. To edit</p>
<p>multiple Notes and to directly modify a group name, use the list style display. For</p>
<p>more information, see âEditing Multiple Debugger Notesâ on page 176.</p>
<p>In this display, MULTI highlights the active group in green to indicate that it adds</p>
<p>Notes to this group by default. Clicking a Note navigates to that Note in the</p>
<p>Debugger window.</p>
<p>The full report style display presents all Debugger Notes in report format. Full style</p>
<p>display shows the Note's name, location, and text. This display allows you to search</p>
<p>easily through Note text by using the incremental search capability (<b>Ctrl</b>+<b>F</b> and</p>
<p><b>Ctrl</b>+<b>B</b>). For more information, see âIncremental Searchingâ on page 156.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>178</i></p>
<p><i>Chapter 10. Using Debugger Notes</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To view the full style display, select<b> Full</b> from the<b> Style</b> drop-down box.</p>
<p>In this display, the<b> Edit</b> button (</p>
<p>) is always disabled. The<b> Group</b> field, located</p>
<p>in the upper-right corner of the window, determines whether the Notes from all</p>
<p>groups are displayed or only those Notes from a particular group. The<b> Group</b> field</p>
<p>also determines whether the<b> Set Active Group</b> button (</p>
<p>) is enabled. Choose from</p>
<p>the<b> Group</b> drop-down list according to your preferences.</p>
<p>The following table describes the buttons available in the<b> Note Browser</b> window.</p>
<p><b>Action</b></p>
<p><b>Button</b></p>
<p>Opens a previously saved Debugger Note list from the file you choose. For more</p>
<p>information, see the<b> notestate</b> command in Chapter 7, âDebugger Note Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Saves the current list of Debugger Notes to the file you choose. For more</p>
<p>information, see the<b> notestate</b> command in Chapter 7, âDebugger Note Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Prints the current view.</p>
<p>Creates a new Debugger Note at the line selected in the Debugger window.</p>
<p>Allows you to edit the selected Note(s) or group. This button is disabled if you</p>
<p>select both a Note and a group. It is also disabled in full style display. For more</p>
<p>information, see the<b> noteedit</b> command in Chapter 7, âDebugger Note Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Deletes the selected Notes and/or groups. For more information, see the<b> notedel</b></p>
<p>command in Chapter 7, âDebugger Note Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><i>179</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Note Browser</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Action</b></p>
<p><b>Button</b></p>
<p>Sets the active group, to which Notes are added by default if you do not specify</p>
<p>a group. This option is disabled if you select the active group.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>180</i></p>
<p><i>Chapter 10. Using Debugger Notes</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Part III</b></p>
<p><b>Viewing Debugging</b></p>
<p><b>Information and Program</b></p>
<p><b>Details</b></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 11</b></p>
<p><b>Viewing and Modifying</b></p>
<p><b>Variables with the Data</b></p>
<p><b>Explorer</b></p>
<p><b>Contents</b></p>
<p>Opening a Data Explorer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>184</p>
<p>The Data Explorer Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>185</p>
<p>Viewing Multiple Items in a Data Explorer . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>188</p>
<p>Updating Data Explorer Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>189</p>
<p>Freezing Data Explorer Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>189</p>
<p>Types of Variable Displays in a Data Explorer . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>190</p>
<p>Changing How Variables are Displayed in a Data Explorer . . . . . . . . . . . . . .</p>
<p>195</p>
<p>Modifying Variables from a Data Explorer . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>198</p>
<p>Configuring Data Explorers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>198</p>
<p>Data Explorer Messages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>200</p>
<p>Data Explorer Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>201</p>
<h1 style="page-break-before:always; "></h1>
<p>The Data Explorer is a graphical tool that displays variables of any type in a number</p>
<p>of different formats. You can modify the values of variables from a Data Explorer.</p>
<p><b>Opening a Data Explorer</b></p>
<p>To open a Data Explorer, do one of the following:</p>
<p>â¢</p>
<p>Double-click a variable in the Debugger source pane.</p>
<p>â¢</p>
<p>Double-click a variable in a preexisting Data Explorer. This opens a new Data</p>
<p>Explorer on the double-clicked variable and leaves the original Data Explorer</p>
<p>open and unchanged.</p>
<p>â¢</p>
<p>Enter the<b> view</b> command in the Debugger's command pane, where:</p>
<p>â</p>
<p><b>view<i></b> expr</i> [,<i> expr</i>]... â Opens a Data Explorer that displays the specified</p>
<p>expression(s)</p>
<p><i>expr</i></p>
<p>.</p>
<p>â</p>
<p><b>view<i></b> type</i> â Opens a Data Explorer that displays the type</p>
<p><i>type</i></p>
<p>.</p>
<p>â</p>
<p><b>view</b> *<i>address</i> â Opens a Data Explorer that displays the contents of the</p>
<p>given location in memory. You must enter an asterisk (*) before the address</p>
<p>name.</p>
<p>â</p>
<p><b>view</b> $locals$ â Opens a Data Explorer that displays all local variables.</p>
<p>If the current procedure is a C++ instance method, the</p>
<p>this</p>
<p>pointer is</p>
<p>displayed as well. This command is equivalent to the<b> localsview</b> command</p>
<p>and the<b> Locals</b> button (</p>
<p>) located in the Debugger. For information about</p>
<p>the<b> localsview</b> command, see âGeneral View Commandsâ in Chapter 22,</p>
<p>âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>â</p>
<p><b>view<i></b> number</i>:$locals$ â Opens a Data Explorer that displays local</p>
<p>variables for the procedure located</p>
<p><i>number</i></p>
<p>levels up the stack. If the</p>
<p>procedure is a C++ instance method, the</p>
<p>this</p>
<p>pointer is displayed as well.</p>
<p>For more information about the<b> view</b> command, see âGeneral View Commandsâ</p>
<p>in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>If a Data Explorer is already open when you perform any of the preceding actions,</p>
<p>the variables you specified appear in the existing Data Explorer.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>184</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To close a Data Explorer, press<b> Ctrl</b>+<b>Q</b> or select<b> Edit</b> â<b> Close</b>. Enter the<b> viewdel</b></p>
<p>command to close all Data Explorers associated with the active Debugger window.</p>
<p>This command also closes Browse,<b> Register View</b>,<b> Memory View</b>,<b> Call Stack</b>,</p>
<p>and<b> Breakpoints</b> windows. For more information about the<b> viewdel</b> command, see</p>
<p>âGeneral View Commandsâ in Chapter 22, âView Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>The Data Explorer Window</b></p>
<p>The Data Explorer window displays information about your program variables. The</p>
<p>format of this information depends on what type of variables you are viewing and</p>
<p>on a number of configuration and formatting options you can modify. For</p>
<p>information about modifying configuration options, see âChanging How Variables</p>
<p>are Displayed in a Data Explorerâ on page 195 and âData Explorer Menusâ</p>
<p>on page 201.</p>
<p>A sample Data Explorer follows:</p>
<p>By default, the Data Explorer displays two columns. The<b> Variable</b> column displays</p>
<p>the names of variables, types, members, or expressions in an expandable tree format.</p>
<p>Numbers preceding variable names indicate call stack depth. For example,<b> 2: myval</b></p>
<p>indicates that the variable<b> myval</b> is two stack levels up from the current program</p>
<p>counter. The<b> Value</b> column displays values when applicable.</p>
<p><b>Note</b></p>
<p>For a description of all menu items available from the Data Explorer, see</p>
<p>âData Explorer Menusâ on page 201.</p>
<p><i>185</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Data Explorer Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Data Explorer Toolbar</b></p>
<p>The Data Explorer toolbar contains the following buttons, from left to right:</p>
<p>â¢</p>
<p><b>Undo</b> (</p>
<p>) â Undoes your last action. Click<b> Undo</b> once for each action you</p>
<p>want to undo. The<b> Undo</b> button appears dimmed when you reach the point at</p>
<p>which no more actions can be undone.</p>
<p>This button is only available for certain operations. The most common</p>
<p>operations you can undo are deleting variables from a Data Explorer, making</p>
<p>arrays, casting variables to a different type, rerooting members, and</p>
<p>dereferencing pointers.</p>
<p>â¢</p>
<p><b>Redo</b> (</p>
<p>) â Restores the last action you undid. Click<b> Redo</b> once for each</p>
<p>action you want to restore. The<b> Redo</b> button appears dimmed when you reach</p>
<p>the point at which no more actions can be restored.</p>
<p>This button is only available after you have undone certain operations. The</p>
<p>most common operations you can redo are deleting variables from a Data</p>
<p>Explorer, making arrays, casting variables to a different type, rerooting</p>
<p>members, and dereferencing pointers.</p>
<p>â¢</p>
<p><b>Add Variable</b> (</p>
<p>) â Adds a specified variable to the Data Explorer. Specify</p>
<p>the new variable in the dialog box that appears.</p>
<p>â¢</p>
<p><b>Delete</b> (</p>
<p>) â Removes the selected variable from the Data Explorer.</p>
<p>â¢</p>
<p><b>Freeze</b> (</p>
<p>) â Toggles the selected variable between frozen and unfrozen</p>
<p>mode. When the variable is frozen, the Data Explorer does not automatically</p>
<p>update it, and you cannot change its value.</p>
<p>Click the<b> Freeze</b> button again to reactivate the variable. When the variable is</p>
<p>unfrozen, the Data Explorer updates it every time your process stops. For more</p>
<p>information, see âFreezing Data Explorer Variablesâ on page 189.</p>
<p>â¢</p>
<p><b>Dereference Pointer</b> (</p>
<p>) â Displays the actual value, rather than the address,</p>
<p>of the variable a pointer points to. This button is only available if the selected</p>
<p>variable is a pointer.</p>
<p>By default, MULTI automatically dereferences pointers if the memory they</p>
<p>point to seems safe to read (see the description of<b> Automatically Dereference</b></p>
<p><b>Pointers</b> in âThe Settings Menuâ on page 208). However, even when automatic</p>
<p>pointer dereferencing is enabled, MULTI automatically dereferences only a</p>
<p><i>MULTI: Debugging</i></p>
<p><i>186</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>single level of pointers. To manually dereference additional levels, or to</p>
<p>dereference a pointer that MULTI does not automatically dereference, click</p>
<p>this button. (You can also manually dereference pointers to structures by</p>
<p>clicking the</p>
<p>+</p>
<p>button that appears to the left of their name.)</p>
<p><b>The Edit Bar</b></p>
<p>The edit bar allows you to change the type and value of a selected variable or define</p>
<p>the bounds of a selected array. The edit bar is located at the bottom of the Data</p>
<p>Explorer. The left side of the edit bar contains a drop-down menu where you can</p>
<p>specify the action you want to perform. Descriptions of each action follow. The</p>
<p>right side of the edit bar contains a text box (or two, depending on the action you</p>
<p>select) where you can input new values.</p>
<p>â¢</p>
<p><b>Cast Type</b> â Casts the selected variable to the newly specified type. Specify</p>
<p>a new type by entering a valid type in the text field. Press<b> Enter</b> to see your</p>
<p>change take effect. If you enter an invalid type, your text appears red and no</p>
<p>change occurs.</p>
<p>The<b> Undo</b> button (</p>
<p>) becomes available after you change a variable's type.</p>
<p>Click the<b> Undo</b> button to return to the previous type.</p>
<p>The<b> Cast Type</b> entry is automatically selected when you click a variable in the</p>
<p><b>Variable</b> column.</p>
<p>â¢</p>
<p><b>Edit Value</b> â Edits the value of the selected variable. Define a new value by</p>
<p>entering a valid number, string, or enumeration in the text field. Press<b> Enter</b></p>
<p>to see your change take effect. If you enter an invalid value, your text appears</p>
<p>red and no change occurs.</p>
<p>The<b> Edit Value</b> entry is automatically selected when you click in the<b> Value</b></p>
<p>column.</p>
<p>â¢</p>
<p><b>Array Bounds</b> â Specifies the range of elements to display. In the text boxes,</p>
<p>enter the indexes with which you want to begin and end the array. Press<b> Enter</b></p>
<p>to see your changes take effect.</p>
<p>The<b> Undo</b> button (</p>
<p>) becomes available after you change array bounds. Click</p>
<p>the<b> Undo</b> button to return to the previous view.</p>
<p><i>187</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Edit Bar</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Array Bounds</b> entry is automatically selected when you click an array in</p>
<p>the<b> Variable</b> column.</p>
<p><b>Viewing Multiple Items in a Data Explorer</b></p>
<p>You can use the Data Explorer to view multiple variables or to view the same</p>
<p>variables at different points during a process.</p>
<p>When you double-click a variable in the source pane or enter the<b> view</b> command</p>
<p>followed by a variable, MULTI opens a Data Explorer displaying information about</p>
<p>that variable. Information about each additional variable you specifyâeither by</p>
<p>double-clicking in the source pane or by entering the<b> view</b> commandâis added to</p>
<p>the existing Data Explorer. For more information about the<b> view</b> command, see</p>
<p>âGeneral View Commandsâ in Chapter 22, âView Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>If you double-click a variable in the source pane more than once or if you enter the</p>
<p><b>view</b> command to specify the same variable more than once, the variable appears</p>
<p>in the same Data Explorer multiple times. You can freeze one instance of the variable</p>
<p>and leave the other unfrozen to display the same variable at different points in the</p>
<p>process. For information about freezing variables, see âFreezing Data Explorer</p>
<p>Variablesâ on page 189.</p>
<p>To open a new Data Explorer on a variable listed in an existing Data Explorer,</p>
<p>double-click the item in the Data Explorer. The original Data Explorer remains</p>
<p>open and unchanged, and a new Data Explorer opens on the double-clicked item.</p>
<p>The undo/redo history for the original Data Explorer is not transferred; the new</p>
<p>Data Explorer starts with a new history.</p>
<p>You can drag variables from the Debugger's source pane or from another Data</p>
<p>Explorer into an open Data Explorer. If you drag a variable from the source pane,</p>
<p>MULTI copies it into the Data Explorer. If you drag a variable from another Data</p>
<p>Explorer, MULTI moves the variable into the specified Data Explorer and removes</p>
<p>it from its original location.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>188</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Updating Data Explorer Variables</b></p>
<p>The Data Explorer updates the values of its non-frozen variables each time your</p>
<p>process stops. You can also force an update of non-frozen variables. In the Debugger</p>
<p>command pane, enter the<b> update</b> command with no arguments. If necessary, the</p>
<p>Data Explorer halts the process to update the data and then resumes the process.</p>
<p>You can also enter the<b> update<i> interval</b></i> command to schedule periodic updates. By</p>
<p>updating Data Explorer variables every</p>
<p><i>interval</i></p>
<p>seconds while your process is</p>
<p>running, this command allows you to monitor the value of variables continually.</p>
<p>To deactivate this update, re-enter the<b> update<i> interval</b></i> command with the interval</p>
<p>set to zero (0).</p>
<p><b>Note</b></p>
<p>The<b> update</b> command also attempts to refresh other view windows</p>
<p>including the<b> Register View</b>,<b> Memory View</b>, and<b> Call Stack</b> windows.</p>
<p>For more information about the<b> update</b> command, see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Freezing Data Explorer Variables</b></p>
<p>You can freeze Data Explorer variables to compare the values of variables at different</p>
<p>times. If you double-click a variable in the source pane more than once or if you</p>
<p>enter the<b> view</b> command to specify the same variable more than once, the variable</p>
<p>appears in the same Data Explorer multiple times (see âViewing Multiple Items in</p>
<p>a Data Explorerâ on page 188). You can freeze one instance of the variable and leave</p>
<p>the other unfrozen. If you freeze a child element (such as a member of a structure)</p>
<p>in a Data Explorer, all children under the same parent will also be frozen.</p>
<p>To freeze a variable, do one of the following:</p>
<p>â¢</p>
<p>Select the variable and click the<b> Freeze</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>Select the variable and then select<b> View</b> â<b> Freeze â<i>variable</i>â</b>.</p>
<p>While the frozen variable is selected, the<b> Freeze</b> button (</p>
<p>) appears to be pushed</p>
<p>down and a tick mark appears beside the<b> Freeze â<i>variable</i>â</b> menu item. The text</p>
<p>for frozen variables is blue. You cannot update or edit frozen variables.</p>
<p><i>189</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Updating Data Explorer Variables</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To reactivate a frozen variable, click the<b> Freeze</b> button again or select<b> View</b> â</p>
<p><b>Freeze â<i>variable</i>â</b> again. The Data Explorer updates the value of the variable to</p>
<p>reflect the current state of the process and continues to automatically update it each</p>
<p>time the process stops.</p>
<p><b>Tip</b></p>
<p>To freeze an original variable in an existing Data Explorer and open the</p>
<p>same variable in another Data Explorer, select the variable and press</p>
<p><b>Ctrl</b>+<b>D</b>.</p>
<p><b>Types of Variable Displays in a Data Explorer</b></p>
<p>The following sections describe example Data Explorers for structures, linked lists,</p>
<p>arrays, and C++ classes.</p>
<p><b>Displaying Structures</b></p>
<p>The following graphic displays a Data Explorer showing a structure named</p>
<p>my_tree</p>
<p>.</p>
<p>It was generated with the</p>
<p>view my_tree</p>
<p>command.</p>
<p>In this example, the name of the displayed variable is</p>
<p>my_tree</p>
<p>, and its type is</p>
<p>struct tree_node</p>
<p>. This structure contains five fields, which each appear on</p>
<p>separate lines:</p>
<p>language</p>
<p>,</p>
<p>word</p>
<p>,</p>
<p>id</p>
<p>,</p>
<p>left</p>
<p>, and</p>
<p>right</p>
<p>. These fields are in<b> Natural</b></p>
<p>format. The Data Explorer dereferences pointers to simple items and shows the</p>
<p>value of the item pointed to.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>190</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>In C++, the Data Explorer marks member variables stored by reference</p>
<p>with an â@â preceding the address.</p>
<p><b>Displaying Linked Lists</b></p>
<p>The Data Explorer displays linked lists in two different formats. The graphic below</p>
<p>represents a typical Data Explorer view for the following structure definition:</p>
<p>struct ListType {</p>
<p>int value;</p>
<p>struct ListType *next;</p>
<p>}</p>
<p>The second formatâformatting a linked list as a container of elementsâdisplays</p>
<p>the list as if it were an array. As the following graphic demonstrates, this format</p>
<p>greatly simplifies the display of these common structures.</p>
<p><i>191</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Displaying Linked Lists</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To format a linked list as a container of elements, select a member or variable of</p>
<p>the type you want to display, and select<b> View</b> â<b> View â<i>variable</i>â as Container</b>.</p>
<p>This menu item is only available if you select a pointer to an aggregate type.</p>
<p>The<b> Expand As Container</b> dialog box opens. This dialog box gives you the</p>
<p>following choices for how to display your data type:</p>
<p>â¢</p>
<p><b>Null-terminated list</b> â Displays the type as a C-style null-terminated list. A</p>
<p>null-terminated list is a linked list that consists of a series of structures connected</p>
<p>via<i> next</i> pointers and terminated with a NULL pointer. Choose the member</p>
<p>that is the<i> next</i> pointer in the<b> âNextâ Pointer</b> drop-down list, and click<b> OK</b>.</p>
<p>â¢</p>
<p><b>Circular list</b> â Displays the type as a C-style circular list. A C-style circular</p>
<p>list is a linked list that consists of a series of structures connected via<i> next</i></p>
<p>pointers that form a loop. For the purpose of display, MULTI terminates the</p>
<p>list when iteration returns to the initial node. Choose the member that is the</p>
<p><i>next</i> pointer in the<b> âNextâ Pointer</b> drop-down list, and click<b> OK</b>.</p>
<p>â¢</p>
<p><b>Binary tree</b> â Displays the type as a tree of objects with two children,<i> left</i></p>
<p>and<i> right</i>. Chose the<i> left</i> and<i> right</i> pointers from the appropriate drop-down</p>
<p>lists, and click<b> OK</b>. MULTI traverses the tree in order.</p>
<p>After you specify a visualization for the data type, MULTI displays all variables of</p>
<p>that type as a container of elements. To display more element rows, select<b> View</b> â</p>
<p><b>Show More Elements</b>. To display fewer rows, select<b> View</b> â<b> Show Fewer</b></p>
<p><b>Elements</b>. To display all element rows, select<b> View</b> â<b> Show All Elements</b>.</p>
<p>To stop viewing the type as a container, select a variable of that type in a Data</p>
<p>Explorer, and then select<b> View</b> â<b> Stop Viewing as Container</b>. You may also</p>
<p>temporarily disable the capability of viewing the type as a container. To do so, select</p>
<p>a variable of that type in the Data Explorer and then select<b> Format</b> â<b> Format</b></p>
<p><b>Container</b>, clearing the<b> Format Container</b> option.</p>
<p><b>Note</b></p>
<p>In addition to lists, you can also format other containers or structures as</p>
<p>containers of elements. For more information, see Appendix E, âCreating</p>
<p>Custom Data Visualizationsâ on page 741.</p>
<p>You can also use the<b> viewlist</b> command to display the elements in a linked list</p>
<p>structure. Entering this command is helpful if you are trying to view a few elements</p>
<p>in the middle of the linked list. However, the display this command creates often</p>
<p><i>MULTI: Debugging</i></p>
<p><i>192</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>takes up more space than the container display and can be redundant unless you</p>
<p>select<b> View</b> â<b> Stop Viewing as Container</b> first. In addition, you must specify</p>
<p>exactly how many elements you want to view, whereas you can simply select the</p>
<p><b>Show More Elements</b>,<b> Show Fewer Elements</b>, and<b> Show All Elements</b> menu</p>
<p>items in the container display. For more information about the<b> viewlist</b> command,</p>
<p>see âGeneral View Commandsâ in Chapter 22, âView Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Displaying Arrays</b></p>
<p>The following graphic displays an array in a Data Explorer. It was generated with</p>
<p>the</p>
<p>view bat</p>
<p>command, where</p>
<p>bat</p>
<p>is an array of 4 integers.</p>
<p>The Data Explorer shows each element of an array on a separate line. The indices</p>
<p>appear in the<b> Variable</b> column and the values of each element appear in the<b> Value</b></p>
<p>column.</p>
<p>To display a pointer or address type as an array, do one of the following:</p>
<p>â¢</p>
<p>Select a variable in the Data Explorer and then select<b> Format</b> â<b> Make Array</b>.</p>
<p>Each subsequent time you select<b> Format</b> â<b> Make Array</b>, the size of the array</p>
<p>increases by ten (10).</p>
<p>â¢</p>
<p>Select a variable in the Data Explorer and then select<b> Cast Type</b> from the edit</p>
<p>bar. (If you select the variable from the<b> Variable</b> column,<b> Cast Type</b> is</p>
<p>automatically selected.) Enter any valid type followed immediately by a number</p>
<p>enclosed in square brackets.</p>
<p><i>193</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Displaying Arrays</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For example, you might enter:</p>
<p><i>type</i>[<i>number</i>]</p>
<p>where</p>
<p><i>type</i></p>
<p>is a valid type and</p>
<p><i>number</i></p>
<p>is any integer.</p>
<p>Press<b> Enter</b> to see your change take effect.</p>
<p>To view a C or C++ character pointer as an array, select the pointer, ensure that</p>
<p><b>Settings</b> â<b> Automatically Dereference Pointers</b> is enabled (the default), and then</p>
<p>select<b> Format</b> â<b> View Alternate</b>. You may have to click the plus icon to see</p>
<p>individual elements.</p>
<p>To change the size of a selected array, select one of the following:</p>
<p>â¢</p>
<p><b>View</b> â<b> Show More Elements</b></p>
<p>â¢</p>
<p><b>View</b> â<b> Show Fewer Elements</b></p>
<p>â¢</p>
<p><b>View</b> â<b> Show All Elements</b></p>
<p>You can also change the size of a selected array by editing the number that appears</p>
<p>in square brackets when<b> Cast Type</b> is selected in the edit bar.</p>
<p>To change the bounds of a selected array, choose<b> Array Bounds</b> from the edit bar.</p>
<p>(If you selected the array from the<b> Variable</b> column,<b> Array Bounds</b> is automatically</p>
<p>selected.) Then enter the indices with which you want to begin and end the array.</p>
<p>Press<b> Enter</b> to see your change take effect.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>194</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Displaying C++ Classes</b></p>
<p>The following graphic displays a Data Explorer showing C++ classes.</p>
<p>MULTI can display C++ class types, base class types, and virtual base class types</p>
<p>in a Data Explorer. The Data Explorer displays static members of a class inside</p>
<p>square brackets. It displays members of an anonymous union in an unnamed tree.</p>
<p><b>Changing How Variables are Displayed in a Data Explorer</b></p>
<p>You can modify how Data Explorers display variables by doing one of the following:</p>
<p>â¢</p>
<p>Change the type used to display a variable. See âChanging the Type Used to</p>
<p>Display a Variableâ on page 195.</p>
<p>â¢</p>
<p>View pointers to C++ base classes. See âViewing Pointers to C++ Base Classesâ</p>
<p>on page 196.</p>
<p>â¢</p>
<p>Change the base used to display a number. See the descriptions of the<b> Hex</b>,</p>
<p><b>Natural</b>,<b> Decimal</b>,<b> Binary</b>, and<b> Octal</b> menu items in âThe Format Menuâ</p>
<p>on page 204.</p>
<p><b>Changing the Type Used to Display a Variable</b></p>
<p>To change the type used to display a variable in the Data Explorer, select the variable</p>
<p>and then select<b> Cast Type</b> from the edit bar. (If you select the variable from the</p>
<p><b>Variable</b> column,<b> Cast Type</b> is automatically selected.) Specify the new type by</p>
<p><i>195</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Displaying C++ Classes</i></p>
<h1 style="page-break-before:always; "></h1>
<p>entering a valid type in the text field. Press<b> Enter</b> to see your variable cast to the</p>
<p>newly specified type. Each change you make to the type in this way is independent</p>
<p>of previous changes. If you enter an invalid type, your text appears red and no</p>
<p>change occurs. You cannot change the type of a frozen variable.</p>
<p>To change a variable's type to an array of the current type, see âDisplaying Arraysâ</p>
<p>on page 193.</p>
<p><b>Viewing Pointers to C++ Base Classes</b></p>
<p>In C++, a Data Explorer can cast a base class pointer to its derived class type. To</p>
<p>enable this behavior, select the pointer and then select<b> Format</b> â<b> Cast To Derived</b>.</p>
<p>With this option enabled, MULTI attempts to find the actual type of an object by</p>
<p>matching the name of its virtual table to a known type.</p>
<p>An example follows.</p>
<p>#include &lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>class A {</p>
<p>public:</p>
<p>int a;</p>
<p>virtual int af() {return a;}</p>
<p>};</p>
<p>class B : public A {</p>
<p>public:</p>
<p>int b;</p>
<p>};</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>A *ap;</p>
<p>B b;</p>
<p>ap = (A*)&amp;b;</p>
<p>ap-&gt;a = 10;</p>
<p>cout &lt;&lt; &quot;ap-&gt;a: &quot; &lt;&lt; ap-&gt;a &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p>If, in the preceding example, you open a Data Explorer on the variable</p>
<p>ap</p>
<p>after the</p>
<p>statement</p>
<p>ap = (A*)&amp;b;</p>
<p>, MULTI resolves the variable to a pointer to the</p>
<p>B</p>
<p>class.</p>
<p>It does so by matching the virtual function table for</p>
<p>B</p>
<p>with the one from</p>
<p>ap</p>
<p>. To</p>
<p><i>MULTI: Debugging</i></p>
<p><i>196</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>recast the variable as a pointer to the base class (A), disable<b> Format</b> â<b> Cast To</b></p>
<p><b>Derived</b>.</p>
<p>There are limitations to this capability. The base class must have a virtual function</p>
<p>table or no comparison can be made. For example, if class</p>
<p>A</p>
<p>were defined as follows:</p>
<p>class A {</p>
<p>public:</p>
<p>int a;</p>
<p>};</p>
<p>and then you enable<b> Format</b> â<b> Cast To Derived</b>, the Data Explorer view does not</p>
<p>change because MULTI cannot resolve the derived class. This limitation also applies</p>
<p>to multiple inheritance. An example follows.</p>
<p>#include &lt;iostream&gt;</p>
<p>using namespace std;</p>
<p>class A {</p>
<p>public:</p>
<p>int a;</p>
<p>virtual int af() {return a;}</p>
<p>};</p>
<p>class Z {</p>
<p>public:</p>
<p>int z;</p>
<p>};</p>
<p>class M : public A, public Z {</p>
<p>public:</p>
<p>int m;</p>
<p>};</p>
<p>int main(int argc, char *argv[])</p>
<p>{</p>
<p>A *ap;</p>
<p>Z *zp;</p>
<p>M m;</p>
<p>m.a = 10;</p>
<p>ap = (A*)&amp;m;</p>
<p>zp = (Z*)&amp;m;</p>
<p>cout &lt;&lt; &quot;ap-&gt;a: &quot; &lt;&lt; ap-&gt;a &lt;&lt; endl;</p>
<p>cout &lt;&lt; &quot;zp-&gt;z: &quot; &lt;&lt; zp-&gt;z &lt;&lt; endl;</p>
<p>return 0;</p>
<p>}</p>
<p><i>197</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Pointers to C++ Base Classes</i></p>
<h1 style="page-break-before:always; "></h1>
<p>In the preceding example, MULTI can determine that the variable</p>
<p>ap</p>
<p>points to an</p>
<p>instance of class</p>
<p>M</p>
<p>. However, it cannot determine the actual type that the variable</p>
<p>zp</p>
<p>points to because class</p>
<p>Z</p>
<p>has no virtual function table.</p>
<p><b>Modifying Variables from a Data Explorer</b></p>
<p>To modify a variable's value, select the variable and then select<b> Edit Value</b> from</p>
<p>the edit bar. (If you select the variable's value in the<b> Value</b> column,<b> Edit Value</b> is</p>
<p>automatically selected.) Define the new value by entering a valid number, string,</p>
<p>or enumeration in the text field. Press<b> Enter</b> to see your change take effect. If you</p>
<p>enter an invalid value, your text appears red and no change occurs.</p>
<p><b>Configuring Data Explorers</b></p>
<p>You can configure settings for both individual Data Explorers and for all Data</p>
<p>Explorers. The following sections describe how to do so.</p>
<p><b>Configuring Individual Data Explorer Dimensions</b></p>
<p>When you first open a Data Explorer, MULTI auto-sizes the window to a size</p>
<p>appropriate for the displayed data, but within the minimum and maximum height</p>
<p>and width values specified in your current configuration file. MULTI also</p>
<p>automatically positions the column divider in the Data Explorer so that the<b> Variable</b></p>
<p>column fully displays the longest variable name, type name, member name, or</p>
<p>expression.</p>
<p>You can manually resize a Data Explorer and/or column by dragging the window</p>
<p>edges or the column divider. However, if you manually resize the window, the Data</p>
<p>Explorer no longer auto-sizes to adjust for new data. If you want to use a Data</p>
<p>Explorer that automatically resizes, you must close the current Data Explorer and</p>
<p>open a new one.</p>
<p>You can also specify global Data Explorer dimensions in the<b> Options</b> window. For</p>
<p>more information, see âConfiguring Global Data Explorer Dimensionsâ on page 200.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>198</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Setting Global Options for Data Explorers</b></p>
<p>In addition to formatting individual Data Explorers, you can also set a number of</p>
<p>MULTI IDE configuration options that affect the format and behavior of all variables</p>
<p>in all Data Explorers.</p>
<p><b>Limiting the Complexity of Data Displayed</b></p>
<p>Depending on your target, you may want to minimize the amount of data MULTI</p>
<p>reads from the target. MULTI provides configuration options to limit the complexity</p>
<p>of information displayed in Data Explorers and to control how much data is read.</p>
<p>After making configuration changes, issue the<b> update</b> command to see the effects</p>
<p>of your changes. For information about this command, see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>The following list provides the configuration options.</p>
<p>â¢</p>
<p>To specify a maximum length for the string representation of data in Data</p>
<p>Explorers, enter the<b> configure formatStringMaxLength<i> num</b></i> command in</p>
<p>the Debugger command pane, where</p>
<p><i>num</i></p>
<p>is the maximum number of characters.</p>
<p>When the accumulated data reaches this length, MULTI does not read any</p>
<p>further data from the target unless you select a more detailed view of that data.</p>
<p>The minimum value is 1024 bytes.</p>
<p>â¢</p>
<p>To specify the maximum number of nested structure levels that Data Explorers</p>
<p>display on one line, enter the<b> configure formatStringMaxDepth<i> num</b></i></p>
<p>command in the Debugger command pane, where</p>
<p><i>num</i></p>
<p>is the maximum depth</p>
<p>of the display. Past this maximum depth, the Data Explorer displays values of</p>
<p>nested structures as</p>
<p>...</p>
<p>. The minimum value is one level.</p>
<p>â¢</p>
<p>To set the maximum initial number of elements in a container, enter the</p>
<p><b>configure maxContainerDisplaySize<i> num</b></i> command in the Debugger</p>
<p>command pane, where</p>
<p><i>num</i></p>
<p>is the maximum number of elements. The default</p>
<p>setting is 20.</p>
<p>â¢</p>
<p>To set the number of elements added to a display when you expand a container,</p>
<p>enter the<b> configure containerSizeincrement<i> num</b></i> command in the Debugger</p>
<p>command pane, where</p>
<p><i>num</i></p>
<p>is the number of elements to be added. The default</p>
<p>setting is 10.</p>
<p><i>199</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Setting Global Options for Data Explorers</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For more information about<b> formatStringMaxLength</b> and<b> formatStringMaxDepth</b>,</p>
<p>see âOther Debugger Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ</p>
<p>in the<i> MULTI: Managing Projects and Configuring the IDE</i> book. For more</p>
<p>information about<b> maxContainerDisplaySize</b> and<b> containerSizeincrement</b>, see</p>
<p>âThe More Debugger Options Dialogâ in Chapter 8, âConfiguration Optionsâ in</p>
<p>the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>Configuring Global Data Explorer Dimensions</b></p>
<p>The global configuration options<b> Minimum initial size (WxH)</b> and<b> Maximum</b></p>
<p><b>initial size (WxH)</b> affect the default dimensions of Data Explorers, while<b> Initial</b></p>
<p><b>position (XxY)</b> affects the default positioning. To access these configuration options,</p>
<p>select<b> Config</b> â<b> Options</b> â<b> Debugger</b> tab.</p>
<p>For more information, see âThe Debugger Options Tabâ in Chapter 8, âConfiguration</p>
<p>Optionsâ in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>Data Explorer Messages</b></p>
<p>The Data Explorer may display any of the following messages.</p>
<p><b>Meaning</b></p>
<p><b>Message</b></p>
<p>There is too much data to show on this line. To expand the</p>
<p>data in the current window, click the plus sign (+) that appears</p>
<p>to the left of the variable. To show the data in a new Data</p>
<p>Explorer, double-click the line.</p>
<p>...</p>
<p>The variable no longer exists in the current lexical scope. This</p>
<p>usually happens when you have stepped past the last use of</p>
<p>the variable. If the variable is assigned to a register, the Data</p>
<p>Explorer shows the current value of the register along with</p>
<p>this message, but the value is most likely meaningless.</p>
<p>Dead</p>
<p>The container has no elements to display.</p>
<p>Empty</p>
<p>Short for ânot a number.â The value is not a legal representation</p>
<p>of any number. This message applies to floating-point variable</p>
<p>types.</p>
<p>NaN</p>
<p>No process is currently being debugged, so the Data Explorer</p>
<p>cannot display a value.</p>
<p>No process</p>
<p><i>MULTI: Debugging</i></p>
<p><i>200</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Message</b></p>
<p>Debug symbol information does not exist for the current</p>
<p>procedure. This message applies to local variables.</p>
<p>No symbols for this</p>
<p>procedure</p>
<p>The variable does not exist because a compiler optimization</p>
<p>removed it.</p>
<p>Optimized away</p>
<p>The original procedure, in which the variable was in scope, is</p>
<p>no longer on the call stack. The Data Explorer only displays</p>
<p>this message when<b> Evaluate</b> â<b> In Context</b> is enabled. For</p>
<p>information about<b> Evaluate</b> â<b> In Context</b>, see âThe Evaluate</p>
<p>Menuâ on page 206.</p>
<p>Original procedure not</p>
<p>on stack</p>
<p>The process you are debugging is running, so the current value</p>
<p>of the variable is unknown.</p>
<p>Process running</p>
<p>The variable has not been assigned an initial value and could</p>
<p>have a random value in memory. The Data Explorer shows the</p>
<p>current value of the variable, but this value is most likely</p>
<p>meaningless.</p>
<p>Not Initialized</p>
<p>MULTI does not have read access to the memory location that</p>
<p>a pointer or address type points to, or the memory location</p>
<p>does not exist.</p>
<p>Unreadable memory</p>
<p>TimeMachine was unable to reconstruct the value of the</p>
<p>variable. For more information, see âDealing with Incomplete</p>
<p>Trace Dataâ on page 411.</p>
<p>Unreadable/Unknown</p>
<p><b>Data Explorer Menus</b></p>
<p>The following sections describe all menu items available from the Data Explorer.</p>
<p>Some menu items are context sensitive and are therefore unavailable in certain</p>
<p>situations. Some of these menu items are also available via the Data Explorer's</p>
<p>right-click menu.</p>
<p>If a toggle menu item is enabled, a check mark (Windows) or a dot (Linux/Solaris)</p>
<p>appears to the left of the menu item. Unless otherwise stated, all descriptions of</p>
<p>toggle menu items explain the behavior of the item when enabled.</p>
<p><i>201</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Explorer Menus</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Edit Menu</b></p>
<p>The following table describes the menu items available from the Data Explorer's</p>
<p><b>Edit</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Adds a variable to the Data Explorer.</p>
<p><b>Add Variable</b></p>
<p>Removes the selected variable from the Data Explorer.</p>
<p><b>Remove â<i>variable</i>â</b></p>
<p><b>from Window</b></p>
<p>Moves the selected variable from its original location in an existing Data</p>
<p>Explorer to a new Data Explorer.</p>
<p><b>Move â<i>variable</i>â to</b></p>
<p><b>New Window</b></p>
<p>Copies the selected variable to a new Data Explorer.</p>
<p><b>Copy â<i>variable</i>â to</b></p>
<p><b>New Window</b></p>
<p>Closes the Data Explorer.</p>
<p>Equivalent to<b> Ctrl</b>+<b>Q</b>.</p>
<p><b>Close</b></p>
<p><b>The View Menu</b></p>
<p>The following table describes the menu items available from the Data Explorer's</p>
<p><b>View</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a submenu that lists the following menu items:</p>
<p>â¢</p>
<p><b>Address</b> (Hotkey:<b> S</b>) â Displays the<b> Address</b> column, which shows</p>
<p>the addresses of the variables you are viewing. If you are viewing</p>
<p>a structure, the field offsets also appear. By default, this item is</p>
<p>disabled.</p>
<p>â¢</p>
<p><b>Type</b> (Hotkey:<b> T</b>) â Displays the<b> Type</b> column, which shows the</p>
<p>types of the variables you are viewing. By default, this item is</p>
<p>disabled.</p>
<p>â¢</p>
<p><b>Variable</b> â Displays the<b> Variable</b> column, which shows the names</p>
<p>of the variables you are viewing. By default, this item is enabled.</p>
<p>â¢</p>
<p><b>Value</b> â Displays the<b> Value</b> column, which shows the values of</p>
<p>the variables you are viewing. By default, this item is enabled.</p>
<p><b>Show</b></p>
<p>Shows the toolbar. By default, this item is enabled.</p>
<p><b>Toolbar</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>202</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Freezes the selected variable. When the variable is frozen, the Data</p>
<p>Explorer does not automatically update it, and you cannot change its</p>
<p>display format or value. When the variable is unfrozen, the Data Explorer</p>
<p>updates it every time your process stops. By default, this item is disabled.</p>
<p>For more information, see âFreezing Data Explorer Variablesâ</p>
<p>on page 189.</p>
<p><b>Freeze â<i>variable</i>â</b></p>
<p>Displays the actual value, rather than the address, of the variable a pointer</p>
<p>points to. This option is only available if the selected variable is a pointer.</p>
<p>By default, MULTI automatically dereferences pointers if the memory</p>
<p>they point to seems safe to read (see the description of<b> Automatically</b></p>
<p><b>Dereference Pointers</b> in âThe Settings Menuâ on page 208). However,</p>
<p>even when automatic pointer dereferencing is enabled, MULTI</p>
<p>automatically dereferences only a single level of pointers. To manually</p>
<p>dereference additional levels, or to dereference a pointer that MULTI</p>
<p>does not automatically dereference, select this option. (You can also</p>
<p>manually dereference pointers to structures by clicking the</p>
<p>+</p>
<p>button that</p>
<p>appears to the left of their name.)</p>
<p>Equivalent to the hotkey<b> P</b>.</p>
<p><b>Dereference Pointer</b></p>
<p>Opens the<b> Register Information</b> window. For more information, see</p>
<p>âThe Register Information Windowâ on page 270. This option is only</p>
<p>available for local variables stored in a register.</p>
<p><b>Show Register Info</b></p>
<p><b>for â<i>variable</i>â</b></p>
<p>Displays<i> variable</i> as a register, or opens the<b> Register Setup</b> dialog box</p>
<p>if<i> variable</i> does not match an existing register definition.</p>
<p><b>View â<i>variable</i>â as</b></p>
<p><b>Register</b></p>
<p>Opens the<b> Expand As Container</b> dialog, which allows you to specify</p>
<p>how to display variables of<i> variable's</i> type as containers. This option is</p>
<p>only available for aggregate types or pointers to aggregate types.</p>
<p><b>View â<i>variable</i>â as</b></p>
<p><b>Container</b></p>
<p>Stops viewing variables of<i> variable's</i> type as containers. This option</p>
<p>only applies to containers previously displayed with<b> View â<i>variable</i>â</b></p>
<p><b>as Container</b> (preceding).</p>
<p><b>Stop Viewing as</b></p>
<p><b>Container</b></p>
<p>Displays 10 more rows of information in the Data Explorer. This menu</p>
<p>item is only available if you select the name or address of an array, list,</p>
<p>or container.</p>
<p><b>Note:</b> This option can be used to extend an array past its end. This causes</p>
<p>target memory to be read past the end of the array and changes the size</p>
<p>of the array for the purposes of the Data Explorer.</p>
<p><b>Show More</b></p>
<p><b>Elements</b></p>
<p>Displays 10 fewer rows of information in the Data Explorer. This menu</p>
<p>item is only available if you select the name or address of an array, list,</p>
<p>or container.</p>
<p><b>Show Fewer</b></p>
<p><b>Elements</b></p>
<p><i>203</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The View Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays rows of information for all elements in the Data Explorer. This</p>
<p>menu item is only available if you select the name or address of a</p>
<p>statically sized array, list, or container (but not a C pointer).</p>
<p><b>Show All Elements</b></p>
<p><b>The Format Menu</b></p>
<p>The following table describes the menu items available from the Data Explorer's</p>
<p><b>Format</b> menu.</p>
<p><b>Note</b></p>
<p>The first five menu items, which control how numbers are displayed in</p>
<p>a Data Explorer, pertain to all types except character pointer types. These</p>
<p>string types are always displayed as quoted strings unless the menu items</p>
<p><b>View Alternate</b> and<b> Settings</b> â<b> Automatically Dereference Pointers</b></p>
<p>are enabled, in which case they are displayed as an array of characters.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays the numbers and characters of the selected variable, the selected</p>
<p>variable's children, etc. in base 16. By default, this item is disabled.</p>
<p>However, you can make it the default format for numbers and characters</p>
<p>by selecting<b> Config</b> â<b> Options</b> â<b> Debugger</b> tab and checking<b> Display</b></p>
<p><b>all numbers/characters as hex</b>.</p>
<p>See also the note that precedes this table.</p>
<p>Equivalent to the hotkey<b> H</b>.</p>
<p><b>Hex</b></p>
<p>Displays addresses of the selected variable, the selected variable's</p>
<p>children, etc. in hexadecimal notation, characters in ASCII notation, and</p>
<p>all other numbers in decimal notation. By default, this item is enabled.</p>
<p>See also the note that precedes this table.</p>
<p>Equivalent to the hotkey<b> N</b>.</p>
<p><b>Natural</b></p>
<p>Displays the numbers and characters of the selected variable, the selected</p>
<p>variable's children, etc. in base 10. By default, this item is disabled.</p>
<p>See also the note that precedes this table.</p>
<p>Equivalent to the hotkey<b> D</b>.</p>
<p><b>Decimal</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>204</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays the numbers and characters of the selected variable, the selected</p>
<p>variable's children, etc. in base 2. By default, this item is disabled.</p>
<p>See also the note that precedes this table.</p>
<p>Equivalent to the hotkey<b> B</b>.</p>
<p><b>Binary</b></p>
<p>Displays the numbers and characters of the selected variable, the selected</p>
<p>variable's children, etc. in base 8. By default, this item is disabled.</p>
<p>See also the note that precedes this table.</p>
<p>Equivalent to the hotkey<b> O</b>.</p>
<p><b>Octal</b></p>
<p>Inserts zeros to the left of hexadecimal values. When you enable this</p>
<p>item, the hexadecimal value has the same bit width as the displayed data.</p>
<p>By default, this item is disabled.</p>
<p>Equivalent to the hotkey<b> X</b>.</p>
<p><b>Pad Hex Values</b></p>
<p>Displays variables as arrays. For pointer and address types, this treats</p>
<p>the pointer as an array such that the first element of the array is located</p>
<p>at the address pointed to. For non-pointer types, the Data Explorer</p>
<p>displays an array of the appropriate type starting at the variable's location.</p>
<p>Each subsequent time you select<b> Make Array</b>, the size of the array</p>
<p>increases by ten (10).</p>
<p>C and C++ character pointer types must be in<b> View Alternate</b> mode to</p>
<p>be viewed as arrays. Additionally,<b> Settings</b> â<b> Automatically</b></p>
<p><b>Dereference Pointers</b> must be enabled (the default). See<b> View Alternate</b></p>
<p>(following).</p>
<p>Equivalent to the hotkey<b> A</b>.</p>
<p><b>Make Array</b></p>
<p>Displays data in an alternate way. For most types, the value is displayed</p>
<p>in the currently selected format as well as in the alternate format. For</p>
<p>example, an integer in natural format is displayed as</p>
<p><i>decimal</i></p>
<p>(<i>hexadecimal</i>)</p>
<p>.</p>
<p>If<b> Settings</b> â<b> Automatically Dereference Pointers</b> is enabled (the</p>
<p>default), a character pointer, which is normally displayed as a string, is</p>
<p>displayed as an array. All other pointers are treated as integers, which</p>
<p>default to displaying in hexadecimal.</p>
<p>By default, this item is disabled.</p>
<p>Equivalent to the hotkey<b> V</b>.</p>
<p><b>View Alternate</b></p>
<p><i>205</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Format Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Determines the derived C++ class type of the current object and displays</p>
<p>the object cast to that type. This item only applies to the display of C++</p>
<p>classes. For more information, see âViewing Pointers to C++ Base</p>
<p>Classesâ on page 196.</p>
<p>By default, this item is enabled.</p>
<p>Equivalent to the hotkey<b> I</b>.</p>
<p><b>Cast to Derived</b></p>
<p>Displays class member functions in type view. By default, this item is</p>
<p>enabled.</p>
<p>Equivalent to the hotkey<b> F</b>.</p>
<p><b>Show Member</b></p>
<p><b>Functions</b></p>
<p>Displays the typedefs for template parameters. This option is only valid</p>
<p>when you are viewing an instance of a type with template parameters in</p>
<p>C++.</p>
<p>By default, this item is disabled.</p>
<p>Equivalent to the hotkey<b> W</b>.</p>
<p><b>Show Template</b></p>
<p><b>Parameters</b></p>
<p>Displays Standard Template Library (STL) containers as if they were</p>
<p>an array of elements. See âDisplaying Linked Listsâ on page 191. You</p>
<p>can also define data descriptions for custom data types. See Appendix E,</p>
<p>âCreating Custom Data Visualizationsâ on page 741.</p>
<p>By default, this item is enabled.</p>
<p>Equivalent to the hotkey<b> E</b>.</p>
<p><b>Format Container</b></p>
<p><b>The Evaluate Menu</b></p>
<p>The<b> Evaluate</b> menu contains four menu items that control the context that is searched</p>
<p>to locate the variables being displayed. These options are mutually exclusive; only</p>
<p>one of them can be selected at a time. By default,<b> As Global</b> is used for all</p>
<p>expressions involving only global variables,<b> By Address</b> is used if the expression</p>
<p>is a static variable, and<b> In Context</b> is used for most others. MULTI detects which</p>
<p>category the viewed variable falls under, and sets these options accordingly. You</p>
<p>can change these options at any time, causing MULTI to re-evaluate the variable</p>
<p>with the new setting.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>206</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The following table describes the menu items available from the Data Explorer's</p>
<p><b>Evaluate</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Specifies that when the Data Explorer is updated, MULTI will re-evaluate</p>
<p>the selected variable's expression in the same context in which it first</p>
<p>evaluated it. For example, if other procedures have been called since the</p>
<p>Data Explorer was created, MULTI walks up the stack until it finds a</p>
<p>stack frame with the procedure that was executing when the Data</p>
<p>Explorer was created. It then evaluates the expression there. If MULTI</p>
<p>cannot find such a stack frame, the Data Explorer displays an error. See</p>
<p>also<b> As Local</b> (following).</p>
<p>Equivalent to the hotkey<b> C</b>.</p>
<p><b>In Context</b></p>
<p>Specifies that when the Data Explorer is updated, MULTI will re-evaluate</p>
<p>the selected variable's expression within the current procedure at the top</p>
<p>of the call stack. See also<b> In Context</b> (preceding).</p>
<p>Equivalent to the hotkey<b> L</b>.</p>
<p><b>As Local</b></p>
<p>Specifies that when the Data Explorer is updated, MULTI will re-evaluate</p>
<p>the selected variable's expression, looking for variables in the global</p>
<p>scope and ignoring all procedure scopes. This option is useful when an</p>
<p>expression involves only global variables.</p>
<p>Equivalent to the hotkey<b> G</b>.</p>
<p><b>As Global</b></p>
<p>Specifies that when the Data Explorer is updated, MULTI will use the</p>
<p>last valid variable address to display data. MULTI does not re-evaluate</p>
<p>the selected variable's expression in any context. This option is useful</p>
<p>for examining the contents of local variables in memory before and after</p>
<p>they are in scope.</p>
<p>Equivalent to the hotkey<b> R</b>.</p>
<p><b>By Address</b></p>
<p><b>The Tools Menu</b></p>
<p>The following table describes the menu items available from the Data Explorer's</p>
<p><b>Tools</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays the source code, if available, for<i> variable's</i> definition in the</p>
<p>source pane.</p>
<p><b>Go to Definition of</b></p>
<p><b>â<i>variable</i>â</b></p>
<p>Displays the source code, if available, for<i> variable's</i> declaration in the</p>
<p>source pane. This is available only for global and static variables.</p>
<p><b>Go to Declaration</b></p>
<p><b>of â<i>variable</i>â</b></p>
<p><i>207</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Tools Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays<i> variable's</i> cross references, if any, in a Browse window. For</p>
<p>more information, see âBrowsing Cross Referencesâ on page 236.</p>
<p><b>Browse References</b></p>
<p><b>of â<i>variable</i>â</b></p>
<p>Sets a watchpoint on<i> variable</i>. For more information, see the<b> watchpoint</b></p>
<p>command in Chapter 3, âBreakpoint Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Set Watchpoint on</b></p>
<p><b>â<i>variable</i>â</b></p>
<p>Opens a Graph View window on<i> variable</i>. If data descriptions are</p>
<p>available for<i> variable's</i> type, MULTI traverses the data and displays a</p>
<p>graph according to the data description. See Appendix E, âCreating</p>
<p>Custom Data Visualizationsâ on page 741.</p>
<p><b>Explore â<i>variable</i>â</b></p>
<p>Opens a<b> Memory View</b> window in which you can view and modify</p>
<p>memory contents. Initially, this window displays memory at the address</p>
<p>of the selected variable. See also the<b> memview</b> command in âGeneral</p>
<p>View Commandsâ in Chapter 22, âView Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>Equivalent to the hotkey<b> M</b>.</p>
<p><b>Memory View on</b></p>
<p><b>â<i>variable</i>â</b></p>
<p>Opens a dialog box that allows you to print the contents of the Data</p>
<p>Explorer.</p>
<p><b>Print</b></p>
<p><b>The Settings Menu</b></p>
<p>The following table describes the menu items available from the Data Explorer's</p>
<p><b>Settings</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Dereferences pointers viewed in the Data Explorer if the memory they</p>
<p>point to seems safe to read. For character pointers, this option reads the</p>
<p>string pointed to and displays it in the Data Explorer.</p>
<p>Except for character pointer variables, the names of dereferenced</p>
<p>variables begin with an asterisk (</p>
<p>*</p>
<p>).</p>
<p>By default, this item is enabled.</p>
<p>Equivalent to the configuration option<b> derefPointer</b>. For information</p>
<p>about<b> derefPointer</b>, see âThe More Debugger Options Dialogâ in Chapter</p>
<p>8, âConfiguration Optionsâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book.</p>
<p><b>Automatically</b></p>
<p><b>Dereference</b></p>
<p><b>Pointers</b></p>
<p>Applies different colors to local variables, global variables, variables</p>
<p>evaluated in context, and variables evaluated by address. By default, this</p>
<p>item is enabled.</p>
<p><b>Color Text Based</b></p>
<p><b>on Evaluate</b></p>
<p><b>Context</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>208</i></p>
<p><i>Chapter 11. Viewing and Modifying Variables with the Data Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a new Data Explorer for variables that have more than five rows</p>
<p>of information. By default, this item is disabled.</p>
<p><b>Default Large</b></p>
<p><b>Variables to New</b></p>
<p><b>Window</b></p>
<p><i>209</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Settings Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 12</b></p>
<p><b>Browsing Program Elements</b></p>
<p><b>Contents</b></p>
<p>Browsing Program Elements Overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>212</p>
<p>The Browse Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>214</p>
<p>The Tree Browser Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>239</p>
<p>The Graph View Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>247</p>
<h1 style="page-break-before:always; "></h1>
<p>The MULTI Debugger provides several kinds of display windows that allow you</p>
<p>to view program elements in different graphical formats. This chapter describes</p>
<p>each of the following windows:</p>
<p>â¢</p>
<p>The Browse window â Lists information about the selected object type in a</p>
<p>single collapsible and expandable list. For general information about this</p>
<p>window, see âThe Browse Windowâ on page 214.</p>
<p>â¢</p>
<p>The Tree Browser window â Displays information about the selected object</p>
<p>type in collapsible and expandable lists. This window displays expanded</p>
<p>information in new columns, thus offering a hierarchical view of the relationship</p>
<p>among the items it displays. For general information about this window, see</p>
<p>âThe Tree Browser Windowâ on page 239.</p>
<p>â¢</p>
<p>The Graph View window â Displays an object graph that shows the</p>
<p>relationships between items. For general information about this window, see</p>
<p>âThe Graph View Windowâ on page 247.</p>
<p><b>Browsing Program Elements Overview</b></p>
<p>You can browse the following program elements in one or more of these windows:</p>
<p>â¢</p>
<p><i>Procedures</i> â Select<b> Browse</b> â<b> Procedures</b>. See âBrowsing Proceduresâ</p>
<p>on page 220.</p>
<p>â¢</p>
<p><i>Global variables</i> â Select<b> Browse</b> â<b> Globals</b>. See âBrowsing Global</p>
<p>Variablesâ on page 228.</p>
<p>â¢</p>
<p><i>Source files</i> â See âBrowsing Source Filesâ on page 230.</p>
<p>â</p>
<p><i>All</i> (all source files that contain procedures used in the program you are</p>
<p>debugging) â Select<b> Browse</b> â<b> Files</b>.</p>
<p>â</p>
<p><i>Includers</i> (all source files that directly include the current file) â</p>
<p>Right-click an empty spot in the source pane and select<b> Browse Includers</b></p>
<p><b>Of This File</b> from the menu that appears.</p>
<p>â</p>
<p><i>Included files</i> (all files that the current file directly includes) â Right-click</p>
<p>an empty spot in the source pane and select<b> Browse Files Included By</b></p>
<p><b>This File</b> from the menu that appears.</p>
<p>â</p>
<p><i>Include graph</i> (a graph of included files) â Select<b> Browse</b> â<b> Includes</b>.</p>
<p>See âBrowsing Includesâ on page 247.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>212</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><i>Data types</i> â Select<b> Browse</b> â<b> All Types</b>. See âBrowsing Data Typesâ</p>
<p>on page 233.</p>
<p>â¢</p>
<p><i>Cross references</i> (for a particular symbol in the program you are debugging)</p>
<p>â In the source pane, right-click the symbol and select<b> Browse References</b></p>
<p>from the menu that appears. See âBrowsing Cross Referencesâ on page 236.</p>
<p>Note that this menu option is only available if the program you are debugging</p>
<p>was compiled with cross reference information. For information about how to</p>
<p>do this, see the<i> MULTI: Building Applications</i> book for your target.</p>
<p>â¢</p>
<p><i>Class hierarchies</i> â Select<b> Browse</b> â<b> Classes</b>. See âBrowsing Classesâ</p>
<p>on page 243.</p>
<p>â¢</p>
<p><i>Calls</i>:</p>
<p>â</p>
<p><i>Static calls by function</i> (functions that call other functions, and functions</p>
<p>that the procedure at the current line pointer calls) â Select<b> Browse</b> â</p>
<p><b>Static Calls</b>. See âBrowsing Static Calls By Functionâ on page 244.</p>
<p>â</p>
<p><i>Dynamic calls by function</i> (functions that were actually called during run</p>
<p>time) â Select<b> Browse</b> â<b> Dynamic Calls</b>. See âBrowsing Dynamic Calls</p>
<p>by Functionâ on page 246.</p>
<p>Note that this menu option is only available if you collected profiling data</p>
<p>about function calls (that is, call count data with call graph support</p>
<p>enabled). See âOverview of Profiling Methodsâ on page 355.</p>
<p>â</p>
<p><i>Static calls by file</i> (source files whose functions are called from a particular</p>
<p>source file) â Select<b> Browse</b> â<b> File Calls</b>. See âBrowsing Static Calls</p>
<p>By Fileâ on page 245.</p>
<p><b>Note</b></p>
<p>For most of these program elements and views, there are alternative ways</p>
<p>to open the browsing tools. The following sections document each</p>
<p>browsing tool, its views, and the ways you can access it.</p>
<p><i>213</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Program Elements Overview</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Browse Window</b></p>
<p>The Browse window is a graphical tool that you can use to view information about</p>
<p>procedures, global variables, source files, data types, and cross references. The</p>
<p>columns in the main portion of the window vary depending on what type of object</p>
<p>you are viewing, but the four menus and the basic behavior of the window are</p>
<p>always the same. The following section describes the aspects of the Browse window</p>
<p>that remain constant. Later sections document how you can use the Browse window</p>
<p>to view specific types of information.</p>
<p><b>Browse Window Basics</b></p>
<p>You can open a Browse window in multiple waysâeach of which is described in</p>
<p>more detail in the following sections. For most of the elements that you can view</p>
<p>in a Browse window, you can simply select<b> Browse</b> â<i><b> program element</b></i> from the</p>
<p>Debugger. For example, to open a Browse window similar to the one shown below,</p>
<p>select<b> Browse</b> â<b> Procedures</b>.</p>
<p><b>Note</b></p>
<p>To browse cross references, files that include the current file, or files that</p>
<p>the current file includes, right-click in the source pane and select the</p>
<p>appropriate menu option from the menu that appears. For more</p>
<p>information, see âBrowsing Source Filesâ on page 230 and âBrowsing</p>
<p>Cross Referencesâ on page 236.</p>
<p>As with most MULTI windows, you can:</p>
<p>â¢</p>
<p>Reorder the columns of a Browse window by dragging and dropping column</p>
<p>headers.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>214</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Sort the displayed data by clicking the relevant column header.</p>
<p>â¢</p>
<p>Open a context-sensitive shortcut menu by right-clicking in the window.</p>
<p>Every Browse window includes one column known as the<i> primary column</i>. Unlike</p>
<p>other columns, you can never hide the primary column, but you can change the</p>
<p>content formatting via the<b> Show</b> menu. The primary column and available formatting</p>
<p>options differ based on what type of object you view.</p>
<p>Every Browse window includes the following four menus. Menu options vary</p>
<p>according to the type of information you browse.</p>
<p>â¢</p>
<p><b>Object</b> menu â Allows you to switch among viewing procedures, global</p>
<p>variables, source files, or data types. The type of program element you are</p>
<p>currently viewing has a bullet or check mark next to it. Simply select one of</p>
<p>the other choices listed at the top of the<b> Object</b> menu to change the type of</p>
<p>object being displayed. In a single Browse window, you can only view one</p>
<p>type of information at a time, but you can have multiple Browse windows open</p>
<p>simultaneously.</p>
<p>This menu also allows you to print the contents of the current Browse window,</p>
<p>access MULTI's online help information, or close the Browse window. This</p>
<p>menu is exactly the same in all Browse windows.</p>
<p>â¢</p>
<p><b>Filter</b> menu â Allows you to specify filters that limit which objects the Browse</p>
<p>window displays. You can set a user-defined filter and/or a selection of</p>
<p>predefined filters. The availability of predefined filters varies depending on</p>
<p>what type of object you are viewing. For more information about filtering, see</p>
<p>âFiltering Content in the Browse Windowâ on page 216.</p>
<p>â¢</p>
<p><b>Show</b> menu â Allows you to specify the columns displayed in the Browse</p>
<p>window and the style of the primary column. The availability of columns and</p>
<p>styles varies depending on the type of object you are viewing. Menu options</p>
<p>are described in the sections that cover each type of Browse window.</p>
<p>â¢</p>
<p><b>Tools</b> menu â Allows you to perform actions on the information in the Browse</p>
<p>window or open other tools that allow you to do so. Most of the options in this</p>
<p>menu also appear in the shortcut menu. The availability of menu items in this</p>
<p>menu and in the shortcut menu vary depending on what type of object you are</p>
<p>viewing. Menu options are described in the sections that cover each type of</p>
<p>Browse window.</p>
<p><i>215</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browse Window Basics</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Each Browse window contains a status bar, which lists the number of items displayed</p>
<p>in the format:</p>
<p>Shown:<i> visible</i>/<i>total</i></p>
<p>where:</p>
<p>â¢</p>
<p><i>visible</i></p>
<p>is the number of items that are not filtered. See âFiltering Content</p>
<p>in the Browse Windowâ on page 216.</p>
<p>â¢</p>
<p><i>total</i></p>
<p>(also known as the<i> base set</i>) is the number of total objects encapsulated</p>
<p>by the Browse window. See âUsing Filtersâ on page 219.</p>
<p>If the Browse window contains contracted headings (see âBrowse Window</p>
<p>Headingsâ on page 220), the status bar displays the following alternative format:</p>
<p>Shown:<i> visible</i>/<i>total</i> (<i>expanded</i>/<i>visible</i> Expanded)</p>
<p>where:</p>
<p>â¢</p>
<p><i>visible</i></p>
<p>and</p>
<p><i>total</i></p>
<p>are the same as above.</p>
<p>â¢</p>
<p><i>expanded</i></p>
<p>is the number of entries that are both visible (i.e., not filtered) and</p>
<p>not contracted.</p>
<p><b>Filtering Content in the Browse Window</b></p>
<p>In all Browse windows, you can select what data to display by using pre-existing</p>
<p>and/or user-defined filters. You can enable and disable filters using the<b> Filter</b> menu.</p>
<p>Some filters are enabled by default when procedures or global variables are first</p>
<p>displayed in a Browse window.</p>
<p>The<b> Filter</b> menu displays only those filters that apply to the current type of object.</p>
<p>User-defined filters are applied to the names of the objects being shown in the</p>
<p>Browse window (see âUser-Defined Filtersâ on page 218). The status box at the</p>
<p>bottom of the Browse window lists the number of displayed objects as well as the</p>
<p>total number of objects, which includes those that have been filtered out.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>216</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Predefined Filters</b></p>
<p>The predefined filters you can enable and disable from the<b> Filter</b> menu are described</p>
<p>in the following table. Only those filters appropriate to the object type you are</p>
<p>viewing are available in the menu. You can apply multiple filters.</p>
<p><b>Effect</b></p>
<p><b>Menu option</b></p>
<p>Toggles the display of virtual tables in C++ programs. This filter</p>
<p>can only be applied to global variables.</p>
<p><b>Hide C++ VTBLs</b></p>
<p>Toggles the display of type identifiers in C++ programs. This filter</p>
<p>can only be applied to global variables.</p>
<p><b>Hide C++ Type</b></p>
<p><b>Identifiers</b></p>
<p>Toggles the display of type information in C++ programs. This filter</p>
<p>can only be applied to global variables.</p>
<p><b>Hide C++ Type Info</b></p>
<p>Toggles the display of initialization names in C++ programs. This</p>
<p>filter can only be applied to global variables.</p>
<p><b>Hide C++ Initialization</b></p>
<p><b>Names</b></p>
<p>Toggles the display of objects in the</p>
<p>std</p>
<p>namespace in C++</p>
<p>programs. This filter can be applied to global variables, procedures,</p>
<p>or data types.</p>
<p><b>Hide C++ std::*</b></p>
<p>Toggles the display of objects whose names begin with a period (</p>
<p>.</p>
<p>).</p>
<p>This filter can be applied to global variables, procedures, or data</p>
<p>types.</p>
<p><b>Hide .*</b></p>
<p>Toggles the display of objects whose names begin with an underscore</p>
<p>(</p>
<p>_</p>
<p>). This filter can be applied to global variables, procedures, data</p>
<p>types, or source files.</p>
<p><b>Hide _*</b></p>
<p>Toggles the display of global variables from shared libraries that</p>
<p>were loaded into your program. This filter can only be applied to</p>
<p>global variables.</p>
<p><b>Hide Globals from</b></p>
<p><b>Shared Library</b></p>
<p>Toggles the display of source files that do not contain any procedures.</p>
<p>This filter can only be applied to files.</p>
<p><b>Hide Files without</b></p>
<p><b>Procedures</b></p>
<p>Toggles the display of procedures that do not have source code. This</p>
<p>filter can only be applied to procedures.</p>
<p><b>Hide Procedures</b></p>
<p><b>without Source</b></p>
<p>Toggles the display of procedures that are inlined. This filter can</p>
<p>only be applied to procedures.</p>
<p><b>Hide Inlined</b></p>
<p><b>Procedures</b></p>
<p>Toggles the display of objects that are defined as static. This filter</p>
<p>can be applied to either global variables or procedures.</p>
<p><b>Hide Static Names</b></p>
<p>Toggles the display of objects that are not defined as static. This</p>
<p>filter can be applied to either global variables or procedures.</p>
<p><b>Hide Non-Static Names</b></p>
<p><i>217</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Filtering Content in the Browse Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Menu option</b></p>
<p>Toggles the display of writes. This filter can only be applied to cross</p>
<p>references.</p>
<p><b>Hide Writes</b></p>
<p>Toggles the display of reads. This filter can only be applied to cross</p>
<p>references.</p>
<p><b>Hide Reads</b></p>
<p>Toggles the display of address references. This filter can only be</p>
<p>applied to cross references.</p>
<p><b>Hide Addresses</b></p>
<p>Toggles the display of declarations. This filter can only be applied</p>
<p>to cross references.</p>
<p><b>Hide Declarations</b></p>
<p><b>User-Defined Filters</b></p>
<p>To define your own filter to apply to the objects listed in the Browse window, select</p>
<p><b>Filter</b> â<b> User-defined Filter</b> from the menu bar of any Browse window. The</p>
<p>following<b> Define Filters</b> dialog box opens:</p>
<p>To specify what objects to display in the Browse window, enter text and wildcard</p>
<p>patterns in this dialog box (see âWildcardsâ on page 303). To specify multiple</p>
<p>patterns in the<b> Show</b> and<b> Hide</b> text fields, use semicolons or whitespace to separate</p>
<p>the patterns.</p>
<p>The next section explains how the Browse window processes user-defined filters</p>
<p>with selected predefined filters.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>218</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Using Filters</b></p>
<p>If you specify a user-defined filter and/or one or more predefined filters, the Browse</p>
<p>window uses the following algorithm to determine what objects to display.</p>
<p>1.</p>
<p>The Browse window determines the base set of objects in the Browse window.</p>
<p>When you first open a Browse window, the base set of objects is the set of</p>
<p>objects that were initially specified. For example, if you open the Browse</p>
<p>window with the<b> e f*</b> command (see âBrowsing Proceduresâ on page 220), the</p>
<p>base objects are all the procedures whose names begin with the letter</p>
<p>f</p>
<p>. Another</p>
<p>example: if you open the Browse window by selecting<b> Browse</b> â<b> Procedures</b>,</p>
<p>the base objects are all the procedures in your program. Each time you change</p>
<p>the object type you want to browse by using the<b> Object</b> menu, the newly loaded</p>
<p>objects become the new base set.</p>
<p>2.</p>
<p>The Browse window hides any remaining objects whose names do not match</p>
<p>the patterns listed in the<b> Show</b> field of the<b> Define Filters</b> dialog box.</p>
<p>3.</p>
<p>The Browse window hides any remaining objects whose names match the</p>
<p>patterns listed in the<b> Hide</b> field of the<b> Define Filters</b> dialog box.</p>
<p>4.</p>
<p>The Browse window hides any remaining objects that match the other filters</p>
<p>enabled in the<b> Filter</b> menu.</p>
<p>For example, if the user-defined filters are:</p>
<p>â¢</p>
<p><b>Show</b></p>
<p>fa*</p>
<p>â¢</p>
<p><b>Hide</b></p>
<p>fab*</p>
<p>only those objects from the base object set whose names start with</p>
<p>fa</p>
<p>but not</p>
<p>fab</p>
<p>are displayed.</p>
<p><b>Note</b></p>
<p>The base set (described above) does not change based on user-defined</p>
<p>filters or the selections you make in the<b> Filter</b> menu, which only affect</p>
<p>what is displayed in the Browse window. However, the base set does</p>
<p>change based on your selections in the<b> Object</b> menu.</p>
<p><i>219</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Filtering Content in the Browse Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Browse Window Headings</b></p>
<p>In procedure, user type, and source file Browse windows, displayed data has</p>
<p>additional formatting. In each of these cases, items known as<i> headings</i> appear with</p>
<p>either a plus sign (<b>+</b>) or a minus sign (<b>-</b>) next to their entry in the primary column.</p>
<p>Clicking a plus sign expands the children of that heading; clicking a minus sign</p>
<p>contracts the children. The meaning of each of the headings depends on what type</p>
<p>of objects are displayed. When you first open a Browse window, all headings appear</p>
<p>fully expanded (a minus sign is displayed next to each heading, and all children are</p>
<p>visible).</p>
<p>In filtering and sorting, the Browse window treats headings in the same fashion as</p>
<p>regular objects. Those headings colored the same as keywords, however, are of a</p>
<p>different type than the displayed base object type. If the selected heading is colored</p>
<p>like a keyword, certain<b> Tools</b> options appear dimmed and certain right-click menu</p>
<p>options do not appear.</p>
<p>For example, in the procedure Browse window all headings appear colored like</p>
<p>keywords, indicating that they are types and not procedures. As a result,<b> Tools</b> â</p>
<p><b>Browse References</b> (among others) is unavailable when such an entry is selected.</p>
<p>For more specific information about headings in procedure Browse windows, see</p>
<p>âHeadings in the Procedures Browse Windowâ on page 227.</p>
<p><b>Browsing Procedures</b></p>
<p>You can open a Browse window that displays procedures by selecting a menu</p>
<p>option, using a shortcut, or issuing a command. Depending on how you open the</p>
<p>Browse window, it displays either all the procedures in a program or some subset</p>
<p>of procedures.</p>
<p>â¢</p>
<p>To open a Browse window displaying all procedures in your program, do one</p>
<p>of the following:</p>
<p>â</p>
<p>From the Debugger, select<b> Browse</b> â<b> Procedures</b>.</p>
<p>â</p>
<p>From an existing Browse window that is not currently displaying</p>
<p>procedures, select<b> Object</b> â<b> Procedures</b>.</p>
<p>â</p>
<p>From the Procedure Locator located on the Debugger navigation bar, select</p>
<p><b>Browse procedures in program</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>220</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â</p>
<p>From the command pane, issue the<b> browse procedures</b> or<b> browse procs</b></p>
<p>command. For information about this command, see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>To open a Browse window displaying only the procedures in a specific file,</p>
<p>do one of the following:</p>
<p>â</p>
<p>While viewing the file in the Debugger, select<b> Browse procedures in</b></p>
<p><b>current file</b> from the Procedure Locator on the Debugger navigation bar.</p>
<p>â</p>
<p>Double-click the file in a Browse window displaying source files.</p>
<p>â</p>
<p>From the command pane, issue the<b> e</b> command with the arguments</p>
<p>&quot;<i><b>file</b></i>&quot;#*</p>
<p>(for example,</p>
<p>e &quot;<b>test.c</b>&quot;#*</p>
<p>). For information about the<b> e</b></p>
<p>command, see Chapter 11, âNavigation Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>To open a Browse window displaying procedures that match a specific pattern,</p>
<p>issue the<b> e</b> command with a pattern that matches more than one procedure in</p>
<p>your program. For example, issuing the<b> e f*</b> command opens a Browse window</p>
<p>on all the procedures in your program that begin with the letter</p>
<p>f</p>
<p>. For</p>
<p>information about the<b> e</b> command, see Chapter 11, âNavigation Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>To open a Browse window displaying the procedures called from a specific</p>
<p>procedure or the procedures that call a specific procedure, right-click a</p>
<p>procedure in the source pane and select<b> Browse Other</b> â<b> Browse Callees</b> or</p>
<p><b>Browse Other</b> â<b> Browse Callers</b>, respectively, from the shortcut menu.</p>
<p><b>Note</b></p>
<p>Sometimes MULTI opens a modal dialog box version of the Browse</p>
<p>window when you have not performed any of the preceding actions. This</p>
<p>usually happens when you have issued a command such as<b> b *</b> and</p>
<p>specified a pattern that matches more than one procedure or an overloaded</p>
<p>C++ procedure. You can use this version of the Browse window to specify</p>
<p>the procedures you want the issued command to operate on so that the</p>
<p>command can continue. For an illustration and instructions on how to</p>
<p>use this dialog box, see âProcedure Ambiguities and the Browse Dialog</p>
<p>Boxâ on page 227. For information about the<b> b</b> command, see Chapter 3,</p>
<p>âBreakpoint Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><i>221</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Procedures</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Browsing Procedures General Information</b></p>
<p>When the Browse window opens, it may contain all the procedures in the program</p>
<p>being debugged, or just those meeting all the starting criteria as described above.</p>
<p>For example, it may display the procedures that match the wildcard pattern of an<b> e</b></p>
<p>command, or the callers of a procedure. But whenever you switch to a different</p>
<p>object type with the<b> Object</b> menu and then select<b> Object</b> â<b> Procedures</b> again, the</p>
<p>Browse window will display all of your program's procedures.</p>
<p>Procedures are color-coded in the Browse window according to MULTI's color</p>
<p>settings. They are displayed in the following way:</p>
<p>â¢</p>
<p>Procedure headings are displayed in the color used to represent keywords (see</p>
<p>âHeadings in the Procedures Browse Windowâ on page 227).</p>
<p>â¢</p>
<p>Procedures without source code are displayed in gray.</p>
<p>â¢</p>
<p>Procedures that are inlined are displayed in the color used to represent unused</p>
<p>code.</p>
<p>â¢</p>
<p>Procedures that are static (that are not also inlined or lacking source code) are</p>
<p>displayed in the color used to represent comments.</p>
<p>â¢</p>
<p>All other procedures are displayed in the normal text color.</p>
<p><b>Browsing Procedures Show Menu</b></p>
<p>The following table describes the options available in the<b> Show</b> menu when you</p>
<p>browse procedures. It also lists which options are enabled by default.</p>
<p><b>Note</b></p>
<p>The primary column when you browse procedures is the<b> Procedure</b></p>
<p><b>Name</b> column. The formatting options listed next apply only to this</p>
<p>column, which is always displayed when you browse procedures.</p>
<p><b>Meaning</b></p>
<p><b>Default</b></p>
<p><b>Option</b></p>
<p>Formats the<b> Procedure Name</b> column (the primary</p>
<p>column) so that the use name is displayed.</p>
<p>Off</p>
<p><b>Name</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>222</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Default</b></p>
<p><b>Option</b></p>
<p>Formats the<b> Procedure Name</b> column (the primary</p>
<p>column) so that the mangled name is displayed. For some</p>
<p>languages, this may be the same as what would be</p>
<p>displayed under the<b> Name</b> option. For example, in C,</p>
<p>the mangled name may be the same as the use name.</p>
<p>Off</p>
<p><b>Mangled Name</b></p>
<p>Formats the<b> Procedure Name</b> column (the primary</p>
<p>column) so that the unscoped portion of the use name is</p>
<p>displayed. For example, in C++, a procedure with the</p>
<p>name</p>
<p>Foo::bar(int a)</p>
<p>would be displayed as</p>
<p>bar(int a)</p>
<p>. For many entries, this is the same as what</p>
<p>would be displayed under the<b> Name</b> option. For more</p>
<p>information, see âHeadings in the Procedures Browse</p>
<p>Windowâ on page 227.</p>
<p>On</p>
<p><b>Unqualified</b></p>
<p><b>Name</b></p>
<p>Shows or hides the<b> BP</b> column. This column displays</p>
<p>the first breakdot of the procedure. If a breakpoint is set</p>
<p>at the first executable line of the procedure, the icon for</p>
<p>the corresponding breakpoint type is shown; otherwise,</p>
<p>a green dot is shown. To set a breakpoint at the first</p>
<p>executable line of the procedure, click the green dot.</p>
<p>On</p>
<p><b>Breakpoint</b></p>
<p>Shows or hides the<b> Object File</b> column. This column</p>
<p>displays the object file in which the procedure is located.</p>
<p>On</p>
<p><b>Object File</b></p>
<p>Shows or hides the<b> Source File</b> column. This column</p>
<p>displays the source file in which the procedure is located.</p>
<p>Off</p>
<p><b>Source File</b></p>
<p>Shows or hides the<b> Module</b> column. This column</p>
<p>displays the name of the module in which the procedure</p>
<p>is located, if any.</p>
<p>Off</p>
<p><b>Module</b></p>
<p>Shows or hides the<b> Library</b> column. This column</p>
<p>displays the name of the library in which the procedure</p>
<p>is located, if any.</p>
<p>Off</p>
<p><b>Library</b></p>
<p>Shows or hides the<b> Address</b> column. This column</p>
<p>displays the address of the procedure.</p>
<p>Off</p>
<p><b>Address</b></p>
<p>Shows or hides the<b> Size</b> column. This column displays</p>
<p>the size of the procedure in bytes.</p>
<p>Off</p>
<p><b>Size</b></p>
<p><i>223</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Procedures</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Default</b></p>
<p><b>Option</b></p>
<p>Shows or hides the<b> Type</b> column. This column displays:</p>
<p>â¢</p>
<p>GI</p>
<p>if the procedure is an inlined, non-static</p>
<p>procedure.</p>
<p>â¢</p>
<p>SI</p>
<p>if the procedure is an inlined, static procedure.</p>
<p>â¢</p>
<p>G</p>
<p>if the procedure is a not-inlined, non-static</p>
<p>procedure.</p>
<p>â¢</p>
<p>S</p>
<p>if the procedure is a not-inlined, static procedure.</p>
<p>On</p>
<p><b>Type</b></p>
<p><b>Browsing Procedures Mouse Operations</b></p>
<p>The following table describes the results of mouse operations on procedures in the</p>
<p>Browse window.</p>
<p><b>Meaning</b></p>
<p><b>Mouse action</b></p>
<p>Displays the selected procedure in the Debugger's source pane. If you</p>
<p>click in the<b> BP</b> column, the Debugger will either insert a breakpoint at</p>
<p>the selected procedure if no breakpoint is there, or remove the breakpoint</p>
<p>there if one already exists. The breakpoint is set at the first executable</p>
<p>line of the procedure.</p>
<p>Click</p>
<p>Opens a new window displaying the cross references for the selected</p>
<p>procedure.</p>
<p>Double-click</p>
<p>Opens a shortcut menu. For more details, see âBrowsing Procedures</p>
<p>Tools Menuâ on page 224.</p>
<p>Right-click</p>
<p><b>Browsing Procedures Tools Menu</b></p>
<p>The following table describes the options available in the<b> Tools</b> menu when you</p>
<p>browse procedures. Additionally, the table describes shortcut menu options that</p>
<p>become available when you right-click content in the Browse window. The table's</p>
<p>âLocationâ column specifies whether the option appears in the<b> Tools</b> menu, the</p>
<p>shortcut menu, or both menus.</p>
<p><b>Meaning</b></p>
<p><b>Location</b></p>
<p><b>Option</b></p>
<p>Contracts every heading.</p>
<p>Both</p>
<p><b>Contract All</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>224</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Location</b></p>
<p><b>Option</b></p>
<p>Expands every heading (this is the way the Browse</p>
<p>window looks when first opened).</p>
<p>Both</p>
<p><b>Expand All</b></p>
<p>Toggles whether global scope is enabled or not. See</p>
<p>âHeadings in the Procedures Browse Windowâ</p>
<p>on page 227.</p>
<p><b>Tools</b> menu</p>
<p><b>Global Scope</b></p>
<p><b>On/Off</b></p>
<p>Displays the selected procedure's cross references (if</p>
<p>any) in another Browse window.</p>
<p>Both</p>
<p><b>Browse</b></p>
<p><b>References</b></p>
<p>Displays the selected procedure's callers in another</p>
<p>Browse window.</p>
<p>Both</p>
<p><b>Browse Callers</b></p>
<p>Displays the selected procedure's callees in another</p>
<p>Browse window.</p>
<p>Both</p>
<p><b>Browse Callees</b></p>
<p>Opens the selected procedure in MULTI's Editor.</p>
<p>Both</p>
<p><b>Show in Editor</b></p>
<p>Opens a Tree Browser window to show the selected</p>
<p>procedure's static call graph.</p>
<p>Both</p>
<p><b>Show in Tree</b></p>
<p><b>Browser</b></p>
<p>Sets a software breakpoint.</p>
<p>See also the<b> b</b> command in Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Set Breakpoint</b></p>
<p>Opens the<b> Software Breakpoint Editor</b> window,</p>
<p>which allows you to specify and set a software</p>
<p>breakpoint. See the<b> b</b> command in Chapter 3,</p>
<p>âBreakpoint Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book, and also</p>
<p>âCreating and Editing Software Breakpointsâ</p>
<p>on page 130.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Set and Edit</b></p>
<p><b>Breakpoint</b></p>
<p>Sets a software breakpoint which can be hit by any</p>
<p>task. This option is available only when connected to</p>
<p>a target which supports this type of breakpoint. See the</p>
<p><b>sb</b> command in Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Set Any Task</b></p>
<p><b>Breakpoint</b></p>
<p>Opens the<b> Software Breakpoint Editor</b>, which allows</p>
<p>you to edit the software breakpoint set on the line.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Edit Breakpoint</b></p>
<p>Removes the software breakpoint from the line.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Remove</b></p>
<p><b>Breakpoint</b></p>
<p>Enables the software breakpoint located on the line.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Enable</b></p>
<p><b>Breakpoint</b></p>
<p><i>225</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Procedures</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Location</b></p>
<p><b>Option</b></p>
<p>Disables the software breakpoint located on the line.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Disable</b></p>
<p><b>Breakpoint</b></p>
<p>Sets a hardware breakpoint on the line.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Set Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Opens the<b> Hardware Breakpoint Editor</b>, which</p>
<p>allows you to edit the hardware breakpoint set on the</p>
<p>line.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Edit Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Removes the hardware breakpoint from the line.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Remove</b></p>
<p><b>Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Enables the hardware breakpoint located on the line.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Enable</b></p>
<p><b>Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Disables the hardware breakpoint located on the line.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Disable</b></p>
<p><b>Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Opens the<b> Tracepoint Editor</b>, which allows you to</p>
<p>set a tracepoint.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Set Tracepoint</b></p>
<p>Opens the<b> Tracepoint Editor</b>, which allows you to</p>
<p>edit the tracepoint.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Edit Tracepoint</b></p>
<p>Removes the tracepoint.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Remove</b></p>
<p><b>Tracepoint</b></p>
<p>Enables the tracepoint.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Enable</b></p>
<p><b>Tracepoint</b></p>
<p>Disables the tracepoint.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Disable</b></p>
<p><b>Tracepoint</b></p>
<p>Sets breakpoints at the first executable line of all</p>
<p>displayed procedures.</p>
<p>Both</p>
<p><b>Set BPs on</b></p>
<p><b>Entries</b></p>
<p>Deletes breakpoints at the first executable line of all</p>
<p>displayed procedures.</p>
<p>Both</p>
<p><b>Delete BPs on</b></p>
<p><b>Entries</b></p>
<p>Opens the<b> Breakpoints</b> window for the program being</p>
<p>debugged.</p>
<p>Shortcut menu</p>
<p>(<b>BP</b> column only)</p>
<p><b>Breakpoint</b></p>
<p><b>Window</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>226</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Headings in the Procedures Browse Window</b></p>
<p>As noted in âBrowse Window Headingsâ on page 220, some entries may be headings</p>
<p>when you browse procedures. For procedures, these headings are the âscopesâ (or</p>
<p>enclosing types) of the procedures listed as children of the heading. For example,</p>
<p>in C++ we might have a class</p>
<p>Foo</p>
<p>with a member function</p>
<p>bar(int a)</p>
<p>. The full</p>
<p>use name of this function would then be</p>
<p>Foo::bar(int a)</p>
<p>, with</p>
<p>Foo</p>
<p>being the</p>
<p>scope and</p>
<p>bar(int a)</p>
<p>the unqualified name of the procedure.</p>
<p>To collect all unscoped types into a global scope, use<b> Tools</b> â<b> Global Scope On/Off</b></p>
<p>to enable the global scope option (see âBrowsing Procedures Tools Menuâ</p>
<p>on page 224). This will place all globally accessible functions into a fake scope, to</p>
<p>ease viewing by allowing all unscoped names to be hidden by contracting the heading</p>
<p>labeled</p>
<p>&lt;global_scope&gt;</p>
<p>.</p>
<p><b>Procedure Ambiguities and the Browse Dialog Box</b></p>
<p>Sometimes MULTI will display a modal dialog box version of the Browse window</p>
<p>for procedures. This happens if, during a command (such as<b> b *</b>), you have specified</p>
<p>a pattern that matches more than one procedure or an overloaded C++ procedure.</p>
<p>This results in a procedure name ambiguity, and the command cannot continue.</p>
<p>You can use this dialog box to specify which procedure you would like the issued</p>
<p>command to operate on, and let the command continue.</p>
<p>By selecting the rows in the Browse dialog box, you can specify which procedures</p>
<p>should be used in the action or command to resolve the procedure name ambiguity.</p>
<p>Depending on the command, you may be allowed to select several procedures, or</p>
<p><i>227</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Procedures</i></p>
<h1 style="page-break-before:always; "></h1>
<p>just one. After you have made your choice, you can click one of the buttons available</p>
<p>at the bottom of the Browse dialog box:</p>
<p><b>Meaning</b></p>
<p><b>Button</b></p>
<p>Accepts the current selections.</p>
<p><b>OK</b></p>
<p>Selects all of the procedures displayed in the Browse dialog box, if selecting</p>
<p>multiple procedures is applicable.</p>
<p><b>All</b></p>
<p>Ensures that none of the procedures displayed in the Browse dialog box</p>
<p>is selected, if making no selection is applicable.</p>
<p><b>None</b></p>
<p>Closes the Browse dialog box and cancels whatever operation caused the</p>
<p>dialog box to appear.</p>
<p><b>Cancel</b></p>
<p><b>Browsing Global Variables</b></p>
<p>To open a Browse window for global variables, do one of the following:</p>
<p>â¢</p>
<p>From the Debugger, select<b> Browse</b> â<b> Globals</b>.</p>
<p>â¢</p>
<p>From the command pane, issue the<b> browse globals</b> command. For information</p>
<p>about this command, see âGeneral View Commandsâ in Chapter 22, âView</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>From an existing Browse window, select<b> Object</b> â<b> Globals</b>.</p>
<p><b>Browse Globals General Information</b></p>
<p>Global variables are color-coded in the Browse window according to MULTI's</p>
<p>color settings. They are displayed in the following way:</p>
<p>â¢</p>
<p>Static global variables are displayed in the color for comments.</p>
<p>â¢</p>
<p>All other global variables are displayed in the normal text color.</p>
<p><b>Browsing Globals Show Menu</b></p>
<p>The following table describes the options available in the<b> Show</b> menu when you</p>
<p>browse global variables. It also lists which options are enabled by default.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>228</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>The primary column when you browse global variables is the<b> Global</b></p>
<p><b>Name</b> column. The formatting options listed next apply only to this</p>
<p>column, which is always displayed when you browse global variables.</p>
<p><b>Meaning</b></p>
<p><b>Default</b></p>
<p><b>Option</b></p>
<p>Formats the<b> Global Name</b> column (the primary column)</p>
<p>so that the use name is displayed.</p>
<p>On</p>
<p><b>Name</b></p>
<p>Formats the<b> Global Name</b> column (the primary column)</p>
<p>so that the mangled name is displayed. For some</p>
<p>languages, this may be the same as what would be</p>
<p>displayed under the<b> Name</b> option. For example, in C,</p>
<p>the mangled name may be the same as the use name.</p>
<p>Off</p>
<p><b>Mangled Name</b></p>
<p>Equivalent to the<b> Name</b> option.</p>
<p>Off</p>
<p><b>Unqualified</b></p>
<p><b>Name</b></p>
<p>Shows or hides the<b> Object File</b> column. This column</p>
<p>displays the name of the object file in which the global</p>
<p>variable is referred to or defined.</p>
<p>Off</p>
<p><b>Object File</b></p>
<p>Shows or hides the<b> Module</b> column. This column</p>
<p>displays the name of the module in which the global</p>
<p>variable is located, if any.</p>
<p>On</p>
<p><b>Module</b></p>
<p>Shows or hides the<b> Library</b> column. This column</p>
<p>displays the name of the library in which the global</p>
<p>variable is located, if any.</p>
<p>Off</p>
<p><b>Library</b></p>
<p>Shows or hides the<b> Address</b> column. This column</p>
<p>displays the address of the global variable.</p>
<p>Off</p>
<p><b>Address</b></p>
<p>Shows or hides the<b> Size</b> column. This column displays</p>
<p>the size of the global variable.</p>
<p>Off</p>
<p><b>Size</b></p>
<p>Shows or hides the<b> Type</b> column. This column displays:</p>
<p>â¢</p>
<p>G</p>
<p>if the global variable is non-static.</p>
<p>â¢</p>
<p>S</p>
<p>if the global variable is static.</p>
<p>On</p>
<p><b>Type</b></p>
<p><i>229</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Global Variables</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Browsing Globals Mouse Operations</b></p>
<p>The following table describes the results of mouse operations on global variables</p>
<p>in the Browse window.</p>
<p><b>Meaning</b></p>
<p><b>Mouse action</b></p>
<p>Displays the selected global variable's definition in the Debugger's</p>
<p>source pane, if it can be found.</p>
<p>Click</p>
<p>Opens a new window displaying the cross-references for the selected</p>
<p>variable.</p>
<p>Double-click</p>
<p>Opens a shortcut menu. For more details, see âBrowsing Globals Tools</p>
<p>Menuâ on page 230.</p>
<p>Right-click</p>
<p><b>Browsing Globals Tools Menu</b></p>
<p>The following table lists the options available in the<b> Tools</b> menu when you browse</p>
<p>global variables. The same menu is displayed when you right-click content in the</p>
<p>Browse window.</p>
<p><b>Meaning</b></p>
<p><b>Option</b></p>
<p>Prints the value of the selected global variable in the command pane.</p>
<p>This value is available only if your process is running.</p>
<p><b>Print Value</b></p>
<p>Opens a Data Explorer to show the value of the selected global variable.</p>
<p>This value is available only if your process is running.</p>
<p><b>View Value</b></p>
<p>Displays the selected global variable's definition in the Debugger's</p>
<p>source pane, if it can be found.</p>
<p><b>Go To Definition</b></p>
<p>Shows the clicked global variable's cross references in a new Browse</p>
<p>window.</p>
<p><b>Browse References</b></p>
<p><b>Browsing Source Files</b></p>
<p>â¢</p>
<p>To open a Browse window displaying all source files, do one of the following:</p>
<p>â</p>
<p>From the Debugger, select<b> Browse</b> â<b> Files</b>.</p>
<p>â</p>
<p>From the File Locator located on the Debugger navigation bar, select</p>
<p><b>Browse all source files in program</b>.</p>
<p>â</p>
<p>From an existing Browse window, select<b> Object</b> â<b> Files</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>230</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â</p>
<p>From the command pane, issue the<b> browse files</b> command. For information</p>
<p>about this command, see âGeneral View Commandsâ in Chapter 22, âView</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>â¢</p>
<p>To open a Browse window displaying a more limited selection of source files,</p>
<p>issue the<b> e</b> command with a suitable pattern (</p>
<p>e *.c</p>
<p>, for example). For</p>
<p>information about the<b> e</b> command, see Chapter 11, âNavigation Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>To open a Browse window displaying all of the files included by the current</p>
<p>file, right-click an empty spot in the Debugger's source pane and select<b> Browse</b></p>
<p><b>Includers Of This File</b>.</p>
<p>â¢</p>
<p>To open a Browse window displaying all of the files that this file includes,</p>
<p>right-click an empty spot in the Debugger's source pane and select<b> Browse</b></p>
<p><b>Files Included By This File</b>.</p>
<p><b>Browsing Source Files General Information</b></p>
<p>The name of each source file is listed in the Browse window. Source files are</p>
<p>color-coded according to MULTI's color settings. They are displayed in the following</p>
<p>way:</p>
<p>â¢</p>
<p>Source files that do not define any procedures are displayed in gray.</p>
<p>â¢</p>
<p>Source file headings are displayed in the color used for keywords (see âHeadings</p>
<p>in the Source File Browse Windowâ on page 233).</p>
<p>â¢</p>
<p>All other source files are displayed in the normal text color.</p>
<p><b>Browsing Source Files Show Menu</b></p>
<p>The following table describes the options available in the<b> Show</b> menu when you</p>
<p>browse source files. It also lists which options are enabled by default.</p>
<p><b>Note</b></p>
<p>The primary column when you browse source files is the<b> Source File</b></p>
<p><b>Name</b> column. The formatting options listed next apply only to this</p>
<p>column, which is always displayed when you browse source files.</p>
<p><i>231</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Source Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Default</b></p>
<p><b>Option</b></p>
<p>Formats the<b> Source File Name</b> column (the primary</p>
<p>column) so that the full path is displayed.</p>
<p>Off</p>
<p><b>Full Name</b></p>
<p>Formats the<b> Source File Name</b> column (the primary</p>
<p>column) so that only the actual file name is displayed.</p>
<p>On</p>
<p><b>Base Name</b></p>
<p>Shows or hides the<b> Module</b> column. This column</p>
<p>displays the name of the module in which the source file</p>
<p>is located, if any.</p>
<p>Off</p>
<p><b>Module</b></p>
<p><b>Browsing Source Files Mouse Operations</b></p>
<p>The following table describes the results of mouse operations on source files in the</p>
<p>Browse window.</p>
<p><b>Meaning</b></p>
<p><b>Mouse action</b></p>
<p>Displays the selected source file in the Debugger's source pane.</p>
<p>Click</p>
<p>Opens a Browse window of procedures defined in the selected source</p>
<p>file, if any.</p>
<p>Double-click</p>
<p>Opens a shortcut menu. For more details, see âBrowsing Source Files</p>
<p>Tools Menuâ on page 232.</p>
<p>Right-click</p>
<p><b>Browsing Source Files Tools Menu</b></p>
<p>The following table describes the options available in the<b> Tools</b> menu when you</p>
<p>browse source files. The same menu is displayed when you right-click content in</p>
<p>the Browse window.</p>
<p><b>Meaning</b></p>
<p><b>Option</b></p>
<p>Opens a Browse window of procedures defined in the selected source</p>
<p>file, if any.</p>
<p><b>Browse Procedures</b></p>
<p><b>in File</b></p>
<p>Contracts every heading.</p>
<p><b>Contract All</b></p>
<p>Expands every heading (this is the way the Browse window looks when</p>
<p>first opened).</p>
<p><b>Expand All</b></p>
<p>Opens the selected file in MULTI's Editor.</p>
<p><b>Show in Editor</b></p>
<p>Opens a Tree Browser window to show the reference relationships</p>
<p>between the selected source file and other source files.</p>
<p><b>Show in Tree</b></p>
<p><b>Browser</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>232</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Option</b></p>
<p>Opens a Graph View window that displays an include file dependency</p>
<p>graph centered on the selected source file.</p>
<p><b>Graph Includes</b></p>
<p><b>Headings in the Source File Browse Window</b></p>
<p>As noted in âBrowse Window Headingsâ on page 220, some entries may be headings</p>
<p>when you browse source files. For source files, these headings are the directory</p>
<p>path of the source files. For example, if there was a Browse window open on a</p>
<p>single file</p>
<p>file.c</p>
<p>contained within the directory</p>
<p>directory</p>
<p>, there would be a</p>
<p>single heading labeled</p>
<p>directory</p>
<p>with</p>
<p>file.c</p>
<p>as its only child.</p>
<p><b>Browsing Data Types</b></p>
<p>To open a Browse window for data types, do one of the following:</p>
<p>â¢</p>
<p>From the Debugger, select<b> Browse</b> â<b> All Types</b>.</p>
<p>â¢</p>
<p>From an existing Browse window, select<b> Object</b> â<b> Types</b>.</p>
<p>â¢</p>
<p>From the command pane, issue the<b> browse types</b> command. For information</p>
<p>about this command, see âGeneral View Commandsâ in Chapter 22, âView</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Browsing Data Types Show Menu</b></p>
<p>The following table describes the options available in the<b> Show</b> menu when you</p>
<p>browse data types. It also lists which options are enabled by default.</p>
<p><b>Note</b></p>
<p>Only one column is displayed when you browse data types. You cannot</p>
<p>hide this column.</p>
<p><b>Meaning</b></p>
<p><b>Default</b></p>
<p><b>Option</b></p>
<p>Formats the displayed names so that the use name is</p>
<p>displayed.</p>
<p>Off</p>
<p><b>Name</b></p>
<p><i>233</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Data Types</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Default</b></p>
<p><b>Option</b></p>
<p>Formats the displayed names so that the mangled name</p>
<p>is displayed. For some languages, this may be the same</p>
<p>as what would be displayed under the<b> Name</b> option. For</p>
<p>example, in C, the mangled name may be the same as</p>
<p>the use name.</p>
<p>Off</p>
<p><b>Mangled Name</b></p>
<p>Formats the displayed names so that the unscoped portion</p>
<p>of the use name is displayed. For example, in C++, a</p>
<p>data type</p>
<p>bar</p>
<p>inside the namespace</p>
<p>Foo</p>
<p>would have the</p>
<p>use name</p>
<p>Foo::bar</p>
<p>. Under this option, this name would</p>
<p>be displayed simply as</p>
<p>bar</p>
<p>, with a parent heading named</p>
<p>Foo</p>
<p>. For many entries, this is the same as what would</p>
<p>be displayed under the<b> Name</b> option. For more</p>
<p>information, see âHeadings for Data Types Browse</p>
<p>Windowâ on page 235.</p>
<p>On</p>
<p><b>Unqualified</b></p>
<p><b>Name</b></p>
<p><b>Browsing Data Types Mouse Operations</b></p>
<p>The following table describes the results of mouse operations on data types in the</p>
<p>Browse window.</p>
<p><b>Meaning</b></p>
<p><b>Mouse action</b></p>
<p>Shows the clicked data type's definition in the Debugger source pane,</p>
<p>if it can be found.</p>
<p>Click</p>
<p>Opens a new window displaying the cross references for the selected</p>
<p>type.</p>
<p>Double-click</p>
<p>Opens a shortcut menu. For more details, see âBrowsing Data Types</p>
<p>Tools Menuâ on page 234.</p>
<p>Right-click</p>
<p><b>Browsing Data Types Tools Menu</b></p>
<p>The following table lists the options available in the<b> Tools</b> menu when you browse</p>
<p>data types. Additionally, the table indicates which options appear in the shortcut</p>
<p>menu that is displayed when you right-click content in the Browse window.</p>
<p><b>Meaning</b></p>
<p><b>Location</b></p>
<p><b>Option</b></p>
<p>Opens a Data Explorer to show the selected data type's</p>
<p>structure.</p>
<p>Both</p>
<p><b>View Struct</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>234</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Location</b></p>
<p><b>Option</b></p>
<p>Contracts every heading.</p>
<p>Both</p>
<p><b>Contract All</b></p>
<p>Expands every heading (this is the way the Browse</p>
<p>window looks when first opened).</p>
<p>Both</p>
<p><b>Expand All</b></p>
<p>Toggles whether global scope is enabled or not. See</p>
<p>âHeadings for Data Types Browse Windowâ on page 235.</p>
<p><b>Tools</b> menu</p>
<p><b>Global Scope</b></p>
<p><b>On/Off</b></p>
<p>Shows the clicked data type's cross references in a new</p>
<p>Browse window.</p>
<p>Both</p>
<p><b>Browse</b></p>
<p><b>References</b></p>
<p>Shows the clicked data type's superclasses (if any) in a</p>
<p>new Browse window.</p>
<p>Both</p>
<p><b>Browse</b></p>
<p><b>Superclasses</b></p>
<p>Shows the clicked data type's subclasses (if any) in a</p>
<p>new Browse window.</p>
<p>Both</p>
<p><b>Browse</b></p>
<p><b>Subclasses</b></p>
<p>Shows the clicked data type's definition in an Editor</p>
<p>Window.</p>
<p>Both</p>
<p><b>Show in Editor</b></p>
<p>Shows the clicked data type in a Tree Browser window</p>
<p>so that you can browse its hierarchy information.</p>
<p>Both</p>
<p><b>Show in Tree</b></p>
<p><b>Browser</b></p>
<p><b>Headings for Data Types Browse Window</b></p>
<p>As noted in âBrowse Window Headingsâ on page 220, some entries may be headings</p>
<p>when you browse data types. For data types, these headings are the âscopesâ (or</p>
<p>enclosing types) of the data types listed as children of the heading. For example, in</p>
<p>C++ we might have a namespace</p>
<p>Foo</p>
<p>with a member class</p>
<p>Bar</p>
<p>. The full use name</p>
<p>of this type would then be</p>
<p>Foo::Bar</p>
<p>, with</p>
<p>Foo</p>
<p>being the scope and</p>
<p>Bar</p>
<p>the</p>
<p>unqualified name of the type.</p>
<p>You can collect all the C-style structs in your program into a global scope by using</p>
<p><b>Tools</b> â<b> Global Scope On/Off</b> to enable the global scope option (see âBrowsing</p>
<p>Data Types Tools Menuâ on page 234). This places all C-style structs into a fake</p>
<p>scope, which allows you to hide all of these types by contracting the heading labeled</p>
<p>&lt;global_scope&gt;</p>
<p>.</p>
<p><b>Note</b></p>
<p>In C++, we also treat template types as scopes over their parameter lists.</p>
<p>For example, displaying the class</p>
<p>Foo&lt;int&gt;</p>
<p>in a Browse window would</p>
<p>have</p>
<p>Foo</p>
<p>as a heading and</p>
<p>&lt;int&gt;</p>
<p>as a child beneath it. This is so that</p>
<p>multiple instantiations of the same base template type do not clutter the</p>
<p><i>235</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Data Types</i></p>
<h1 style="page-break-before:always; "></h1>
<p>display of data types, and so that they are easy to hide (by contracting</p>
<p>the children of a template type you do not want to examine).</p>
<p><b>Browsing Cross References</b></p>
<p>When the program being debugged is compiled with cross reference information,</p>
<p>you can open a Browse window for cross references by right-clicking a symbol in</p>
<p>the Debugger's source pane and selecting<b> Browse References</b> from the shortcut</p>
<p>menu that appears.</p>
<p><b>Browsing Cross References General Information</b></p>
<p>Cross references are color-coded in the Browse window according to MULTI's</p>
<p>color settings. They are displayed as follows:</p>
<p>â¢</p>
<p>Definitions are displayed in the normal text color.</p>
<p>â¢</p>
<p>Declarations and common declarations are displayed in the color for dead code.</p>
<p>â¢</p>
<p>Reads are displayed in the color for comments.</p>
<p>â¢</p>
<p>Writes are displayed in the color for strings.</p>
<p>â¢</p>
<p>Reads and writes (that is, cross references that both read and write) are displayed</p>
<p>in the color for characters.</p>
<p>â¢</p>
<p>Address references are displayed in the color for keywords.</p>
<p><b>Browsing Cross References Show Menu</b></p>
<p>The following table describes the options available in the<b> Show</b> menu when you</p>
<p>browse cross references. It also lists which options are enabled by default.</p>
<p><b>Note</b></p>
<p>The primary column when you browse cross references is the<b> File</b></p>
<p><b>Position</b> column. This column is always displayed when you browse</p>
<p>cross references.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>236</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Default</b></p>
<p><b>Option</b></p>
<p>Shows or hides the<b> BP</b> column. This column displays a</p>
<p>breakdot if the reference lies on a line with associated</p>
<p>code. If there is a breakpoint set at that line already, this</p>
<p>column displays the appropriate breakpoint icon. To set</p>
<p>or clear a breakpoint on this line, click the green dot.</p>
<p>On</p>
<p><b>Breakpoint</b></p>
<p>Shows or hides the<b> Procedure Position</b> column. This</p>
<p>column displays the procedure-relative line position of</p>
<p>the reference. If the cross reference is not located in a</p>
<p>procedure, it has no procedure-relative line position and</p>
<p>this column is empty.</p>
<p>On</p>
<p><b>Position in Proc</b></p>
<p>Shows or hides the<b> Module</b> column. This column</p>
<p>displays the name of the module in which the reference</p>
<p>is located, if any.</p>
<p>Off</p>
<p><b>Module</b></p>
<p>Shows or hides the<b> Column</b> column. This column</p>
<p>displays the column position of the reference.</p>
<p>Off</p>
<p><b>Column</b></p>
<p>Shows or hides the<b> Type</b> column. This column displays</p>
<p>one of the following values:</p>
<p>â¢</p>
<p>Def</p>
<p>if the cross reference is a definition.</p>
<p>â¢</p>
<p>Decl</p>
<p>if the cross reference is declaration.</p>
<p>â¢</p>
<p>C-Decl</p>
<p>if the cross reference is a common</p>
<p>declaration.</p>
<p>â¢</p>
<p>Write</p>
<p>if the cross reference is an assignment or</p>
<p>write to the item.</p>
<p>â¢</p>
<p>Read</p>
<p>if the cross reference is an access or read from</p>
<p>the item.</p>
<p>â¢</p>
<p>Read,Write</p>
<p>if the cross reference both reads from</p>
<p>and writes to the item. For example, in C,</p>
<p>item++</p>
<p>both adds one to</p>
<p>item</p>
<p>(a write) and returns the</p>
<p>original value (a read).</p>
<p>â¢</p>
<p>Addr</p>
<p>if the cross reference is an address reference</p>
<p>(that is, taking the address of the item).</p>
<p>On</p>
<p><b>Type</b></p>
<p><i>237</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Cross References</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Browsing Cross References Mouse Operations</b></p>
<p>The following table describes the results of mouse operations on cross references</p>
<p>in the Browse window.</p>
<p><b>Meaning</b></p>
<p><b>Mouse action</b></p>
<p>Displays the selected cross reference in the Debugger's source pane,</p>
<p>and highlights the piece of code for the cross reference. If you click in</p>
<p>the<b> BP</b> column on a green dot, the Debugger inserts a breakpoint at the</p>
<p>location. If you click in the<b> BP</b> column on a breakpoint icon, the</p>
<p>Debugger removes the breakpoint.</p>
<p>Click</p>
<p>Opens the selected cross reference in the Editor.</p>
<p>Double-click</p>
<p>Opens a shortcut menu. For more details, see âBrowsing Cross</p>
<p>References Tools Menuâ on page 238.</p>
<p>Right-click</p>
<p><b>Browsing Cross References Tools Menu</b></p>
<p>The following table describes the options available in the<b> Tools</b> menu when you</p>
<p>browse cross references. Additionally, the table describes shortcut menu options</p>
<p>that become available when you right-click content in the Browse window. The</p>
<p>table's âLocationâ column specifies whether the option appears in the<b> Tools</b> menu,</p>
<p>the shortcut menu, or both menus.</p>
<p><b>Meaning</b></p>
<p><b>Location</b></p>
<p><b>Option</b></p>
<p>Opens the selected cross reference in the Editor.</p>
<p>Both</p>
<p><b>Show in Editor</b></p>
<p>For descriptions of these menu items, see âBrowsing</p>
<p>Procedures Tools Menuâ on page 224.</p>
<p>Shortcut menu (<b>BP</b></p>
<p>column only)</p>
<p>Breakpoint and</p>
<p>tracepoint menu</p>
<p>items</p>
<p>Sets breakpoints at all lines for all displayed cross</p>
<p>references.</p>
<p>Both</p>
<p><b>Set BP on</b></p>
<p><b>Entries</b></p>
<p>Deletes breakpoints at all lines for all displayed cross</p>
<p>references.</p>
<p>Both</p>
<p><b>Delete BP on</b></p>
<p><b>Entries</b></p>
<p>Opens a<b> Breakpoints</b> window for the program being</p>
<p>debugged.</p>
<p>Shortcut menu (<b>BP</b></p>
<p>column only)</p>
<p><b>Breakpoint</b></p>
<p><b>Window</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>238</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To set breakpoints at all of the locations where the value of a variable (or a type's</p>
<p>member field) is changed:</p>
<p>1.</p>
<p>Obtain the references for the variable. (In the Debugger source pane, right-click</p>
<p>the variable, and select<b> Browse References</b>.)</p>
<p>2.</p>
<p>In the Browse window, hide the reads (select<b> Filter</b> â<b> Hide Reads</b>).</p>
<p>3.</p>
<p>Right-click anywhere in the Browse window's source pane, and select<b> Set BP</b></p>
<p><b>on Entries</b> from the shortcut menu.</p>
<p><b>The Tree Browser Window</b></p>
<p>You can use the Tree Browser to examine the structure of your program in several</p>
<p>ways.</p>
<p><b>Opening a Tree Browser</b></p>
<p>To use a Tree Browser, you must be debugging a program. You can open a Tree</p>
<p>Browser in several ways, depending on what type of information you want to view.</p>
<p>See also:</p>
<p>â¢</p>
<p>âBrowsing Classesâ on page 243</p>
<p>â¢</p>
<p>âBrowsing Static Calls By Functionâ on page 244</p>
<p>â¢</p>
<p>âBrowsing Static Calls By Fileâ on page 245</p>
<p>â¢</p>
<p>âBrowsing Dynamic Calls by Functionâ on page 246</p>
<p><b>Using a Tree Browser</b></p>
<p>Regardless of the type of information you are viewing in the Tree Browser, the</p>
<p>interface is basically the same.</p>
<p><i>239</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Tree Browser Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The main part of the Tree Browser window is a tree graph, which consists of colored</p>
<p>nodes. The meanings of the colors vary depending on the type of information you</p>
<p>are viewing. (The following sections provide further explanation of coloring.) To</p>
<p>customize the colors used to display information in a Tree Browser, see the</p>
<p>tb<i>Type</i>Fg</p>
<p>and</p>
<p>tb<i>Type</i>Bg</p>
<p>configuration options in âOther Debugger Configuration</p>
<p>Optionsâ in Chapter 8, âConfiguration Optionsâ in the<i> MULTI: Managing Projects</i></p>
<p><i>and Configuring the IDE</i> book.</p>
<p>One node of the tree graph is called the âroot node.â It is the particular function (or</p>
<p>other object) that you are examining. The name of the root node is displayed in the</p>
<p>title bar of the Tree Browser window. You can expand ancestorsâcallers, if you</p>
<p>are looking at a function, or superclasses, if you are looking at a classâof the root</p>
<p>node towards the left, and descendentsâcallees or subclassesâof the root node</p>
<p>towards the right. You may expand away from the root node for as many levels as</p>
<p>you want. However, if you want to look at an ancestor of a descendent of the root</p>
<p>node, for example, you will need to reroot your graph. See âRerootingâ on page 243.</p>
<p>To expand ancestors or descendents of a node, click the plus sign (</p>
<p>) next to the</p>
<p>node. To contract something you have expanded, click the minus sign (</p>
<p>). If there</p>
<p>is no plus or minus sign, there is nothing to expand or contract.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>240</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p>There are four ways to expand many nodes at once. They are available from the</p>
<p><b>Expand</b> menu or from the expansion buttons on the toolbar.</p>
<p>To expand the descendents of the selected node (or of the root node if no node is</p>
<p>selected) until there are no more descendents, until recursion is detected, until 50</p>
<p>levels have been expanded, or until 10,000 new nodes have been revealed by</p>
<p>expansion, do one of the following:</p>
<p>â¢</p>
<p>Select<b> Expand</b> â<b> All Descendents</b>.</p>
<p>â¢</p>
<p>Click<b> Expand All Descendents</b> (</p>
<p>).</p>
<p><b>Note</b></p>
<p>To cancel this operation, press<b> Esc</b>.</p>
<p>To perform a similar expansion on the ancestors of the selected node (or on the</p>
<p>ancestors of the root node if no node is selected), do one of the following:</p>
<p>â¢</p>
<p>Select<b> Expand</b> â<b> All Ancestors</b>.</p>
<p>â¢</p>
<p>Click<b> Expand All Ancestors</b> (</p>
<p>).</p>
<p>Sometimes you may want to expand one level instead of all the nodes. To expand</p>
<p>one level of the selected node's descendents (or of the root node's descendents if no</p>
<p>node is selected), do one of the following:</p>
<p>â¢</p>
<p>Select<b> Expand</b> â<b> One Level of Descendents</b>.</p>
<p>â¢</p>
<p>Click<b> Expand Descendents One Level</b> (</p>
<p>).</p>
<p>To obtain similar results, you can also click every node's plus sign on the descendent</p>
<p>side of the graph. The difference between doing this and performing one of the</p>
<p>preceding operations is that the menu items do not expand recursive nodes.</p>
<p>To expand one level of the selected node's ancestors (or of the root node's ancestors</p>
<p>if no node is selected), do one of the following:</p>
<p>â¢</p>
<p>Select<b> Expand</b> â<b> One Level of Ancestors</b>.</p>
<p>â¢</p>
<p>Click<b> Expand Ancestors One Level</b> (</p>
<p>).</p>
<p>To resize a column of nodes, drag the separator on the column header to the right</p>
<p>of the column that you want to resize.</p>
<p><i>241</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using a Tree Browser</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Node Operations</b></p>
<p>Each node is labeled with a short, descriptive name. In C++, the short name does</p>
<p>not include class or namespace qualifiers, which come before the final double colon</p>
<p>(</p>
<p>::</p>
<p>). To view the full name in a tooltip, hover your cursor over the node.</p>
<p>To view more information about a node, click it. Information about the node,</p>
<p>including its full name, is displayed in the status bar of the Tree Browser window.</p>
<p>Clicking certain types of nodes, such as function and file nodes, also causes the</p>
<p>source code for the node to be displayed in the Debugger source pane.</p>
<p>To open a shortcut menu for a node, right-click the node. The shortcut menu for a</p>
<p>function node resembles the following:</p>
<p>A class node shortcut menu resembles the following:</p>
<p>The first two operations,<b> Reroot</b> and<b> Reroot in New Window</b>, are described in</p>
<p>âRerootingâ on page 243. The middle portion of the menu contains various actions</p>
<p>you can perform on the node. These actions vary depending on the type of node</p>
<p>and are documented in âOpening a Tree Browserâ on page 239. The bottom portion</p>
<p>of the menu lists the types of ancestors or descendents a node may have. It also</p>
<p>allows you to expand or contract them, which is equivalent to clicking the plus/minus</p>
<p>sign on the side of the node.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>242</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Rerooting</b></p>
<p>If there is a node on the graph that you want to make the root node so that you can</p>
<p>examine both its ancestors and its descendents, you can reroot on that node.</p>
<p>To reroot on a node, do one of the following:</p>
<p>â¢</p>
<p>Click the node and select<b> Browse</b> â<b> Reroot Selected Node</b>.</p>
<p>â¢</p>
<p>Right-click the node and select<b> Reroot</b>.</p>
<p>â¢</p>
<p>Middle-click the node.</p>
<p>Once you reroot on a node, everything that was previously in the Tree Browser</p>
<p>window disappears. However, the previous content of the window is stored in a</p>
<p>history mechanism much like that in a Web browser.</p>
<p>To access the history, do one of the following:</p>
<p>â¢</p>
<p>Select<b> Browse</b> â<b> Back</b>, or click<b> Back</b> (</p>
<p>).</p>
<p>â¢</p>
<p>Select<b> Browse</b> â<b> Forward</b>, or click<b> Forward</b> (</p>
<p>).</p>
<p>To reroot a node in a new window, rather than replacing the current window contents,</p>
<p>do one of the following:</p>
<p>â¢</p>
<p>Click the node and select<b> Browse</b> â<b> Reroot Selected Node(s) in New</b></p>
<p><b>Window(s)</b>.</p>
<p>â¢</p>
<p>Right-click the node and select<b> Reroot in New Window</b>.</p>
<p>â¢</p>
<p>Double-middle-click the node.</p>
<p><b>Browsing Classes</b></p>
<p>To use a Tree Browser to browse your class hierarchy, do one of the following:</p>
<p>â¢</p>
<p>From the Debugger, select<b> Browse</b> â<b> Classes</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> browse classes</b> command. For</p>
<p>information about this command, see âGeneral View Commandsâ in Chapter</p>
<p>22, âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><i>243</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Classes</i></p>
<h1 style="page-break-before:always; "></h1>
<p>A window similar to the following appears.</p>
<p>The children of the</p>
<p>root classes</p>
<p>node are all of the classes (including structs</p>
<p>and unions) that do not inherit from another class. A class that is a subclass of</p>
<p>another class is shown as a child of its parent class. The color green is used to</p>
<p>distinguish classes and structs from unions, which are highlighted in yellow.</p>
<p>To view the members in a class, do one of the following:</p>
<p>â¢</p>
<p>Double-click the class.</p>
<p>â¢</p>
<p>Right-click the class and select<b> Browse Members in Class</b>.</p>
<p>To see the definition of the class in the Debugger window, do one of the following:</p>
<p>â¢</p>
<p>Click the class.</p>
<p>â¢</p>
<p>Right-click the class and select<b> Examine Class in Debugger</b>.</p>
<p><b>Browsing Static Calls By Function</b></p>
<p>The Tree Browser can use information from your program's symbol table to show</p>
<p>you which functions your functions call, or those they are called by. These potential,</p>
<p>or<i> static</i>, paths are solely based on the build-time symbol table of your program,</p>
<p>and not on the actual run-time paths taken by the process.</p>
<p>To browse static calls by function, do one of the following:</p>
<p>â¢</p>
<p>From the Debugger, select<b> Browse</b> â<b> Static Calls</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>244</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> browse scalls</b> command. For</p>
<p>information about this command, see âGeneral View Commandsâ in Chapter</p>
<p>22, âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>A Tree Browser opens, centered on the function you are currently looking at in the</p>
<p>Debugger source window.</p>
<p>To open a Tree Browser on a specific function (for example,</p>
<p>foo()</p>
<p>), do one of the</p>
<p>following:</p>
<p>â¢</p>
<p>In the Debugger, right-click the function and select<b> Browse Other</b> â<b> Browse</b></p>
<p><b>Static Calls</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the following:</p>
<p>browse scalls foo</p>
<p>Color provides information about the function represented by a given node. Purple</p>
<p>indicates a normal function for which MULTI has the source code. Green indicates</p>
<p>a function for which no information is availableâusually because the function is</p>
<p>in a library that MULTI does not have symbols for. Pink indicates a recursion in</p>
<p>the Tree Browser.</p>
<p>To view a function in the Debugger source pane, click the function node.</p>
<p>To edit a function, double-click the function node. This feature is also available</p>
<p>from the shortcut menu that appears when you right-click the function node.</p>
<p><b>Browsing Static Calls By File</b></p>
<p>In addition to viewing the static call graph by function, you can also view it by file.</p>
<p>The root file is connected to any file that contains a function called from within the</p>
<p>root file. This may result in the root file being connected to itself.</p>
<p>To browse static calls by file, do one of the following:</p>
<p>â¢</p>
<p>From the Debugger, select<b> Browse</b> â<b> File Calls</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> browse fcalls</b> command. For</p>
<p>information about this command, see âGeneral View Commandsâ in Chapter</p>
<p><i>245</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Static Calls By File</i></p>
<h1 style="page-break-before:always; "></h1>
<p>22, âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>A Tree Browser opens on the file you are currently viewing in the Debugger.</p>
<p>To open a Tree Browser on a specific file (for example,<b> foo.c</b>), enter the following</p>
<p>in the Debugger command pane:</p>
<p>browse fcalls foo.c</p>
<p>Color provides information about the file represented by a given node. Pink indicates</p>
<p>a file that has debug information. Gray indicates a file that does not have complete</p>
<p>debug information.</p>
<p>To view a file in the Debugger, click its node. To edit a file, double-click its node.</p>
<p>Right-click a file node to open a shortcut menu that allows you to edit the file, view</p>
<p>the file in the Debugger source pane, browse a list of functions in the file, or view</p>
<p>file properties.</p>
<p><b>Browsing Dynamic Calls by Function</b></p>
<p>Unlike the static call graph, which shows potential calls, the dynamic call graph</p>
<p>uses profiling data to display which functions a function actually called during run</p>
<p>time. This feature is only available if you have collected call count profiling data</p>
<p>with call graph support enabled. See âOverview of Profiling Methodsâ on page 355.</p>
<p>To browse the dynamic call graph, do one of the following:</p>
<p>â¢</p>
<p>From the Debugger, select<b> Browse</b> â<b> Dynamic Calls</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> browse dcalls</b> command. For</p>
<p>information about this command, see âGeneral View Commandsâ in Chapter</p>
<p>22, âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book..</p>
<p>â¢</p>
<p>To view a particular function specified by<i> function_name</i>, enter<b> browse dcalls</b></p>
<p><i><b>function_name</b></i> in the Debugger command pane. For information about this</p>
<p>command, see âGeneral View Commandsâ in Chapter 22, âView Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>246</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Pink nodes indicate functions that have debug information. Gray nodes indicate</p>
<p>functions that do not have debug information.</p>
<p><b>The Graph View Window</b></p>
<p>The Graph View window displays relationships between items as a two-dimensional</p>
<p>graph of objects. An edge between two objects in the graph indicates a relationship</p>
<p>between the two items.</p>
<p><b>Browsing Includes</b></p>
<p>To open a Graph View window displaying an include file dependency graph, do</p>
<p>one of the following:</p>
<p>â¢</p>
<p>From the Debugger, select<b> Browse</b> â<b> Includes</b>.</p>
<p>â¢</p>
<p>From the command pane, issue the<b> browse includes</b> command. For information</p>
<p>about this command, see âGeneral View Commandsâ in Chapter 22, âView</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>The resulting graph is vertically centered on the current file, and shows all files</p>
<p>included in this file as well as all files that include this file. An edge pointing from</p>
<p>a file to an included file indicates a dependency.</p>
<p><i>247</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Graph View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>When you display the include dependency graph from a root file (that is, a file that</p>
<p>is not itself included by anything), some files may be marked with a leading<b> (*)</b>.</p>
<p>These are files that appear not to contribute anything to the root file and that can</p>
<p>probably be removed from the include graph without harm.</p>
<p>Clicking a file node causes the file to be displayed in the Debugger source pane.</p>
<p><b>Controlling Layout and Navigating in Graph View</b></p>
<p>You can control the layout of a graph in the Graph View window via the<b> Layout</b></p>
<p>menu or the right-click shortcut menu. You can navigate the graph via the right-click</p>
<p>shortcut menu, the<b> Search for Objects</b> window, or the history buttons. The following</p>
<p>sections describe each in more detail.</p>
<p><b>The Layout Menu</b></p>
<p>The Graph View<b> Layout</b> menu contains the following options:</p>
<p><b>Meaning</b></p>
<p><b>Option</b></p>
<p>Recalculates the layout of the graph. This option may be used</p>
<p>to improve the layout of the graph after collapsing nodes.</p>
<p><b>Redo Layout</b></p>
<p>Formats the graph vertically (edges are directed downward).</p>
<p>When disabled, the graph is formatted horizontally (edges are</p>
<p>directed rightward).</p>
<p><b>Vertical Layout</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>248</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Graph View Shortcut Menu</b></p>
<p>Right-clicking an object in the graph gives a shortcut menu with the following</p>
<p>options:</p>
<p><b>Meaning</b></p>
<p><b>Option</b></p>
<p>Recalculates the layout of the graph. This option may be used</p>
<p>to improve the layout of the graph after collapsing nodes.</p>
<p><b>Redo Layout</b></p>
<p>Opens a submenu listing children of the selected object.</p>
<p>Choosing one of these children scrolls the graph to that object.</p>
<p>If the object has more than 10 children, an additional option</p>
<p><b>View Full List</b> appears in the submenu. Selecting this option</p>
<p>opens the<b> Search for Objects</b> window.</p>
<p><b>Go To Child</b></p>
<p>Opens a submenu listing parents of the selected object.</p>
<p>Choosing one of these parents scrolls the graph to that object.</p>
<p>If the object has more than 10 parents, an additional option</p>
<p><b>View Full List</b> appears in the submenu. Selecting this option</p>
<p>opens the<b> Search for Objects</b> window.</p>
<p><b>Go To Parent</b></p>
<p>Removes the object and all descendants that have only one</p>
<p>parent. You can display the object again by selecting<b> Expand</b></p>
<p><b>Children</b> from the object's parent or by selecting<b> Expand</b></p>
<p><b>Parent</b> from any of the children that are still visible.</p>
<p><b>Collapse Node</b></p>
<p>Removes all children of the object and then traverses the</p>
<p>subtrees of each child, removing those objects that no longer</p>
<p>show parents. In a simple tree, the net effect is to remove all</p>
<p>nodes in the subtree rooted at the object. You can display the</p>
<p>children again by choosing<b> Expand Children</b>.</p>
<p><b>Collapse Children</b></p>
<p>Redisplays the object's children, if they were previously</p>
<p>collapsed. Also redisplay the children's children, and so on,</p>
<p>since they now have a visible parent.</p>
<p><b>Expand Children</b></p>
<p>Similar to<b> Collapse Children</b>, except operating on the object's</p>
<p>parents, the parents'</p>
<p>parents, and so on.</p>
<p><b>Collapse Parents</b></p>
<p>Similar to<b> Expand Children</b>, except operating on the object's</p>
<p>parents, the parents'</p>
<p>parents, and so on.</p>
<p><b>Expand Parents</b></p>
<p>Opens the file in an editor.</p>
<p><b>Edit File</b></p>
<p>Re-centers the graph on the selected file, producing a graph</p>
<p>of files that include the selected file, and files that it includes.</p>
<p>This creates a new entry in the history.</p>
<p><b>Re-center Graph</b></p>
<p><i>249</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Controlling Layout and Navigating in Graph View</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Search for Objects Window</b></p>
<p>The<b> Search for Objects</b> window provides additional navigation tools for Graph</p>
<p>View. To open the<b> Search for Objects</b> window, do one of the following:</p>
<p>â¢</p>
<p>In the Graph View toolbar, click the<b> Search</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>Select<b> Edit</b> â<b> Search</b>.</p>
<p>The<b> Search for Objects</b> window consists of the following elements:</p>
<p>â¢</p>
<p>The<b> Find</b> text field, which allows you to specify a filter for the entries in the</p>
<p><b>All</b> list. Filters may include wildcards and are case-insensitive.</p>
<p>â¢</p>
<p>The<b> All</b> list displays a list of all objects that fit the current filter. Selecting an</p>
<p>item in the<b> All</b> list scrolls to and selects the corresponding object in Graph</p>
<p>View. Similarly, selecting an object in Graph View selects the corresponding</p>
<p>list item in the<b> All</b> list.</p>
<p>â¢</p>
<p>The<b> Parents</b> list displays a list of all parents of the selected object. Entries that</p>
<p>appear dimmed indicate objects that are currently collapsed. Selecting an item</p>
<p>in the<b> Parents</b> list causes Graph View to scroll to, but not select, the</p>
<p>corresponding object.</p>
<p>â¢</p>
<p>The<b> Children</b> list displays a list of all children of the selected object. Entries</p>
<p>that appear dimmed indicate objects that are currently collapsed. Selecting an</p>
<p>item in the<b> Children</b> list causes Graph View to scroll to, but not select, the</p>
<p>corresponding object.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>250</i></p>
<p><i>Chapter 12. Browsing Program Elements</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The History Buttons</b></p>
<p>The Graph View history buttons allow you to switch between different versions of</p>
<p>the graph. Clicking the<b> Back</b> button (</p>
<p>) moves back in the history, while clicking</p>
<p>the<b> Forward</b> button (</p>
<p>) moves forward in the history.</p>
<p><i>251</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Controlling Layout and Navigating in Graph View</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 13</b></p>
<p><b>Using the Register Explorer</b></p>
<p><b>Contents</b></p>
<p>The Register View Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>254</p>
<p>The Register Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>270</p>
<p>The Modify Register Definition Dialog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>276</p>
<p>The Register Setup Dialog . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>279</p>
<p>The Register Search Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>280</p>
<p>Using Debugger Commands to Work with Registers . . . . . . . . . . . . . . . . . . . .</p>
<p>282</p>
<p>Customizing Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>285</p>
<h1 style="page-break-before:always; "></h1>
<p>The Register Explorer allows you to configure how registers are defined, accessed,</p>
<p>and displayed within the Debugger. The Register Explorer includes the<b> Register</b></p>
<p><b>View</b> window, which allows you to view the values of registers within the Debugger</p>
<p>and the<b> Register Information</b> window, which shows you detailed information</p>
<p>about a register and allows you to add and change register definitions.</p>
<p><b>Note</b></p>
<p>Despite its name, the Register Explorer is not limited to working with</p>
<p>the physical registers on your target processor. The Register Explorer</p>
<p>can also work with objects that derive their values from other registers,</p>
<p>from locations in memory, or even from the result of a Debugger</p>
<p>expression. All of these objects are treated in the same manner as physical</p>
<p>target registers. In this chapter, the term<i> register</i> includes everything that</p>
<p>can be described in a Register Explorer definitions file.</p>
<p>Your Green Hills Compiler installation includes one or more register definition</p>
<p>files for your target architecture. For information about these files'</p>
<p>names and</p>
<p>locations, see âRegister Explorer Startupâ on page 286. For information about their</p>
<p>format, see âThe GRD Register Definition Formatâ on page 776.</p>
<p><b>The Register View Window</b></p>
<p>The Register Explorer provides a<b> Register View</b> window specifically for viewing</p>
<p>registers. You can use this window to create multiple views of a target's registers</p>
<p>and easily switch between them. Since the window can hide registers and groups,</p>
<p>you can use it to pare down dozens of registers into the ones that are most relevant</p>
<p>for debugging your application.</p>
<p>To open the<b> Register View</b> window from a Debugger, you can do one of the</p>
<p>following:</p>
<p>â¢</p>
<p>Click the<b> Registers</b> button (</p>
<p>) on the Debugger toolbar.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Registers</b>.</p>
<p>â¢</p>
<p>Run the command<b> regview</b> in the Debugger command pane. For information</p>
<p>about the<b> regview</b> command, see âRegister Commandsâ in Chapter 14, âRegister</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>254</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Register View</b> window shows all the registers for your target, your custom</p>
<p>registers, and various configuration controls. An example Power Architecture</p>
<p><b>Register View</b> window is shown below.</p>
<p>The main components of the<b> Register View</b> window include:</p>
<p>â¢</p>
<p><i>Menu Bar</i> â Contains entries for various operations that allow you to configure</p>
<p>the tabs and appearance of the<b> Register View</b> window. For a description of</p>
<p>the individual menus and options, see âThe Menu Barâ on page 256.</p>
<p>â¢</p>
<p><i>Toolbar</i> â Provides shortcuts for often-used operations. For a description of</p>
<p>the individual buttons, see âToolbarâ on page 259.</p>
<p>â¢</p>
<p><i>View tabs</i> â Show the registers of your target organized in different ways. For</p>
<p>information about the default tabs, see âTabsâ on page 260. For instructions on</p>
<p>how to create custom tabs, see âCustomizing the Register View Windowâ</p>
<p>on page 263.</p>
<p>â¢</p>
<p><i>Register tree</i> â Each tab contains a two-column register tree. You can select</p>
<p>registers and groups from this tree and perform actions on them using the</p>
<p>right-click menu. For details, see âRegister Treeâ on page 260.</p>
<p><i>255</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Register View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Menu Bar</b></p>
<p>The<b> Register View</b> window has three menus,<b> File</b>,<b> View</b>, and<b> Format</b>.</p>
<p>The<b> File</b> menu contains the menu items listed in the following table.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Saves values of all registers into a text file.</p>
<p><b>Save All Register</b></p>
<p><b>Values into File</b></p>
<p>Saves the values of all registers in the current tab into a file.</p>
<p><b>Save All Register</b></p>
<p><b>Values in Active</b></p>
<p><b>Tab into File</b></p>
<p>Saves the values of the selected registers in the current tab into a file</p>
<p><b>Save Selected</b></p>
<p><b>Register Values into</b></p>
<p><b>File</b></p>
<p>Loads register values from a file in the saved register value format. See</p>
<p>a saved register value file for an example.</p>
<p><b>Load Register</b></p>
<p><b>Values from File</b></p>
<p>Saves to a<b> .grd</b> file the register definitions modified during the current</p>
<p>debugging session, registers defined with the<b> regadd</b> command, or</p>
<p>registers defined from a Data Explorer's<b> View</b> â<b> View â<i>variable</i>â as</b></p>
<p><b>Register</b> menu item. See âThe Register Setup Dialogâ on page 279.</p>
<p><b>Save Register</b></p>
<p><b>Definitions Created</b></p>
<p><b>on the Fly</b></p>
<p>Loads register definitions from a<b> .grd</b> file and adds them to the definitions</p>
<p>already present.</p>
<p><b>Load Register</b></p>
<p><b>Definitions from</b></p>
<p><b>File</b></p>
<p>Unloads register definitions from an incrementally loaded<b> .grd</b> file.</p>
<p><b>Unload Register</b></p>
<p><b>Definitions from</b></p>
<p><b>File</b></p>
<p>Creates a memory-mapped register for a memory address.</p>
<p><b>Add</b></p>
<p><b>Memory-mapped</b></p>
<p><b>Register</b></p>
<p>Reinitialize the register information from the default register definition</p>
<p>file(s). This is a slow process for some targets.</p>
<p><b>Reinitialize</b></p>
<p><b>Register</b></p>
<p><b>Information</b></p>
<p>Toggles the option that specifies whether to reuse an existing<b> Register</b></p>
<p><b>Information</b> window or open an additional<b> Register Information</b></p>
<p>window when a new register is viewed.</p>
<p><b>Reuse Register</b></p>
<p><b>Information</b></p>
<p><b>Window</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>256</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Freezes the<b> Register View</b> window so that it does not automatically</p>
<p>refresh.</p>
<p>When the<b> Register View</b> window is not frozen, the values of the registers</p>
<p>in the window are updated each time the process stops. If the window</p>
<p>is frozen, the register values will not be updated each time the process</p>
<p>stops.</p>
<p><b>Freeze</b></p>
<p>Prints all register values.</p>
<p><b>Print</b></p>
<p>Closes the<b> Register View</b> window.</p>
<p><b>Close</b></p>
<p>The<b> View</b> menu contains the following menu items.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Launches the<b> Register Search</b> window, see âThe Register Search</p>
<p>Windowâ on page 280).</p>
<p><b>Search Register</b></p>
<p>Controls whether registers that are hidden on the active tab are displayed</p>
<p>in the register tree.</p>
<p>When a check mark appears beside this menu item, registers and groups</p>
<p>that have been hidden on the active tab will be displayed in the register</p>
<p>tree as light gray entries. When hidden items are displayed, you can edit</p>
<p>them to remove the hidden attribute.</p>
<p>When no check mark appears next to this menu item, registers and groups</p>
<p>that are hidden on the active tab are not displayed in the register tree.</p>
<p>To toggle between these settings, select the<b> Show Hidden Registers</b></p>
<p>menu item.</p>
<p><b>Show Hidden</b></p>
<p><b>Registers</b></p>
<p>Adds a new tab to the<b> Register View</b> window. See âAdding a New</p>
<p>Register View Window Tabâ on page 264.</p>
<p><b>Add New Tab</b></p>
<p>Deletes the active tab from the<b> Register View</b> window. See âRemoving</p>
<p>Unwanted Tabsâ on page 266.</p>
<p><b>Remove Active Tab</b></p>
<p>Moves the tab one to the left in the ordering of tabs at the top of the</p>
<p><b>Register View</b> window. See âModifying the Ordering of Tabsâ</p>
<p>on page 265.</p>
<p><b>Promote Active Tab</b></p>
<p>Moves the tab one to the right in the ordering of tabs at the top of the</p>
<p><b>Register View</b> window. See âModifying the Ordering of Tabsâ</p>
<p>on page 265.</p>
<p><b>Demote Active Tab</b></p>
<p>Makes the active tab display groups starting from the root of the register</p>
<p>group tree, if the tree has been re-rooted. See âChanging the Root of the</p>
<p>Register Treeâ on page 266.</p>
<p><b>Unroot Active Tab</b></p>
<p><i>257</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Menu Bar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Refreshes all of the register values displayed in the register tree if the</p>
<p><b>Register View</b> window is not frozen.</p>
<p><b>Refresh</b></p>
<p>Expands all nodes on the current tab of the<b> Register View</b> window.</p>
<p><b>Expand All</b></p>
<p>Contracts all nodes on the current tab of the<b> Register View</b> window.</p>
<p><b>Collapse All</b></p>
<p>The<b> Format</b> menu contains the menu items listed in the table below. You can use</p>
<p>this menu to configure the tabs and appearance of the<b> Register View</b> window.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>When selected, register values will be displayed in their default format.</p>
<p>This default format corresponds to how values of the register's type are</p>
<p>normally displayed in Data Explorers.</p>
<p><b>Natural</b></p>
<p>When selected, register values will be displayed in signed base 10 integer</p>
<p>notation whenever applicable.</p>
<p><b>Decimal</b></p>
<p>When selected, register values will be displayed in unsigned base 16</p>
<p>notation whenever applicable.</p>
<p><b>Hexadecimal</b></p>
<p>When selected, register values will be displayed in unsigned binary</p>
<p>notation whenever applicable.</p>
<p><b>Binary</b></p>
<p>When selected, register values will be displayed in unsigned base 8</p>
<p>notation whenever applicable.</p>
<p><b>Octal</b></p>
<p>When selected, register values will be displayed in the natural format as</p>
<p>well as in a secondary format. For example, an enumeration value is</p>
<p>displayed along with an integer value when this menu item is selected.</p>
<p><b>View Alternate</b></p>
<p>When selected, any hexadecimal values that are displayed will include</p>
<p>leading zeros to their full bit width.</p>
<p>When cleared, hexadecimal values are displayed without leading zeros.</p>
<p><b>Pad Hex Values</b></p>
<p>When selected, any registers that are pointers to values stored in memory</p>
<p>will be automatically dereferenced and the contents of memory at that</p>
<p>location will be displayed.</p>
<p>When cleared, only the pointer is shown and not the value to which it</p>
<p>points.</p>
<p><b>Expand Value</b></p>
<p>When selected, any register values that change while you are stepping</p>
<p>through your program are highlighted to make them distinct from</p>
<p>registers whose values did not change.</p>
<p>When cleared, all registers are displayed in the same way, regardless of</p>
<p>whether their values changed or not.</p>
<p><b>Show Changes</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>258</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>When selected, the bitfields contained within registers will be displayed</p>
<p>as structures (individual values separated by vertical bars).</p>
<p>When cleared, the bitfield registers are displayed as integer hexadecimal</p>
<p>or decimal constants.</p>
<p><b>Expand Register</b></p>
<p><b>Bitfields</b></p>
<p><b>Toolbar</b></p>
<p>Directly underneath the menu bar is the toolbar, which contains the following</p>
<p>buttons:</p>
<p><b>Meaning</b></p>
<p><b>Button</b></p>
<p>Saves the values of the selected registers in the current tab into a file.</p>
<p>Loads register values from a file in the saved register value format. See a</p>
<p>saved register value file for an example.</p>
<p>Creates a memory-mapped register for a memory address.</p>
<p>Expands all nodes on the current tab of the<b> Register View</b> window.</p>
<p>Contracts all nodes on the current tab of the<b> Register View</b> window.</p>
<p>Launches the Register Search window (see âThe Register Search Windowâ</p>
<p>on page 280) so that you can search a register you want.</p>
<p>Refreshes all of the register values displayed in the register tree if the</p>
<p><b>Register View</b> window is not frozen.</p>
<p>Freezes the<b> Register View</b> window so that it does not automatically refresh.</p>
<p>When the<b> Register View</b> window is not frozen, the values of the registers</p>
<p>in the window are updated each time the process stops. If the window is</p>
<p>frozen, the register values will not be updated each time the process stops.</p>
<p>Toggles the option that specifies whether to reuse an existing<b> Register</b></p>
<p><b>Information</b> window or open an additional<b> Register Information</b> window</p>
<p>when a new register is viewed.</p>
<p>Prints all register values.</p>
<p>Closes the<b> Register View</b> window.</p>
<p>Whether this button appears on your toolbar depends on the setting of the</p>
<p>option<b> Display close (x) buttons</b>. To access this option, select<b> Config</b> â</p>
<p><b>Options</b> â<b> General Tab</b>.</p>
<p><i>259</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Toolbar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Tabs</b></p>
<p>Directly underneath the toolbar is a list of tabs. Each tab of the<b> Register View</b></p>
<p>window shows the registers of your target organized in a different way. In addition</p>
<p>to tabs that you create, you may see default tabs, which are automatically created.</p>
<p>The possible default tabs are listed below:</p>
<p>â¢</p>
<p>The<b> Processor</b> tab usually contains all of the registers present on the target</p>
<p>processor.</p>
<p>â¢</p>
<p>The<b> Board</b> tab contains all memory-mapped registers and dynamic registers</p>
<p>defined in the Debugger, as well as indirect registers. These registers are usually</p>
<p>specific to the target board you are using.</p>
<p>â¢</p>
<p>The<b> Ungrouped</b> tab displays any user-defined registers that have not been</p>
<p>placed into any register group.</p>
<p>These default tabs are present only if they contain registers. For example, the</p>
<p><b>Ungrouped</b> tab will probably not appear unless you have defined your own registers</p>
<p>and these registers have not been placed in any group.</p>
<p>Each register tab except for<b> Ungrouped</b> views the same hierarchical register structure</p>
<p>as defined in the register definition files. Different tabs can be configured to display</p>
<p>different subsets of the available registers. You can alter the visibility of registers</p>
<p>and groups on a single tab without affecting other tabs. See âSelectively Displaying</p>
<p>Registers and Groupsâ on page 264.</p>
<p>To switch between tabs, click the name of the tab you want to view in the tab list.</p>
<p>For information about adding a new tab or performing other operations on tabs, see</p>
<p>âCustomizing the Register View Windowâ on page 263.</p>
<p><b>Register Tree</b></p>
<p>Underneath the tab list is a tree of the registers and groups that are visible for the</p>
<p>active tab. The column on the left displays the names of register groups and the</p>
<p>names of registers. The column on the right shows the current value for registers.</p>
<p>If the list of registers and groups is larger than the visible area of the register tree,</p>
<p>scroll to view parts of the tree that are not visible.</p>
<p>Each group in the left column has a plus or minus icon next to it. To expand or</p>
<p>contract the group, click this icon. When the group is expanded, the minus sign icon</p>
<p><i>MULTI: Debugging</i></p>
<p><i>260</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>will be shown and all of the items contained in that register group will be visible</p>
<p>in the register tree. When the group is contracted, the plus sign icon will be shown</p>
<p>and the items contained in that register group will not be visible in the register tree.</p>
<p>Registers containing a pointer also display plus/minus icons.</p>
<p>To select a single row of the register tree, click the row. To select a contiguous</p>
<p>range of rows of the register tree, use<b> Shift</b>+click. To make a noncontiguous selection</p>
<p>of rows, use<b> Ctrl</b>+click.</p>
<p>To operate on an entry in the register tree, right-click the entry. A shortcut menu</p>
<p>will appear. For more information, see âPerforming Actions on Registers Using the</p>
<p>Shortcut Menusâ on page 262.</p>
<p>To open a Data Explorer (see also âThe Data Explorer Windowâ on page 185) or a</p>
<p><b>Register Information</b> window (if the register has bitfields definition) on a register</p>
<p>that is in a row of the register tree, double-click the row.</p>
<p>In the<b> Name</b> column, a tooltip may be available:</p>
<p>â¢</p>
<p>For registers or groups that have names that extend beyond the width of the</p>
<p><b>Name</b> column;</p>
<p>â¢</p>
<p>For registers or groups that have an alternate name specified in the GRD file</p>
<p>with the</p>
<p>long_name</p>
<p>or</p>
<p>ln</p>
<p>option;</p>
<p>â¢</p>
<p>For registers that have certain special values, such as a pointer to code.</p>
<p>Colors are used to distinguish different objects:</p>
<p>â¢</p>
<p>Groups are displayed in the color MULTI uses for string constants;</p>
<p>â¢</p>
<p>Registers are displayed in the standard text color;</p>
<p>â¢</p>
<p>Register bitfields are displayed in the color MULTI uses for customized items;</p>
<p>â¢</p>
<p>Dereferences of pointer registers are displayed in the color MULTI uses for</p>
<p>keywords.</p>
<p>For more information, see the description of âSyntax Color Settingsâ in âColors</p>
<p>Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ in the<i> MULTI:</i></p>
<p><i>Managing Projects and Configuring the IDE</i> book.</p>
<p><i>261</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Register Tree</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Performing Actions on Registers Using the Shortcut Menus</b></p>
<p>When you right-click a row or selection in the register tree, a shortcut menu appears.</p>
<p>You can use this menu to change properties of the selected items, as well as the</p>
<p>active tab of the<b> Register View</b> window. Three types of objects can be right-clicked</p>
<p>in the<b> Register View</b> window: a single register, a single group, or a selection that</p>
<p>contains multiple items of the register tree. A shortcut menu appears that contains</p>
<p>some of the items from the following table.</p>
<p><b>Shown For</b></p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Single register</p>
<p>Single group</p>
<p>Multiple items</p>
<p>If the selection was visible in the register</p>
<p>tree of the active tab, this choice will make</p>
<p>it invisible (unless<b> Show Hidden Items</b> is</p>
<p>selected).</p>
<p>When you hide a group, all of its children</p>
<p>are implicitly hidden as well.</p>
<p>See âSelectively Displaying Registers and</p>
<p>Groupsâ on page 264.</p>
<p><b>Hide<i> Item</b></i> or</p>
<p><b>Hide Selected</b></p>
<p><b>Registers</b></p>
<p>Single register</p>
<p>Single group</p>
<p>Multiple items</p>
<p>If the selection was hidden in the register</p>
<p>tree of the active tab, this choice will make</p>
<p>the selection visible again. See âSelectively</p>
<p>Displaying Registers and Groupsâ</p>
<p>on page 264.</p>
<p><b>Show<i> Item</b></i> or</p>
<p><b>Show Selected</b></p>
<p><b>Registers</b></p>
<p>Single register</p>
<p>Opens a dialog box that allows the value of</p>
<p>the register to be modified. Editing values</p>
<p>through this dialog is only possible for</p>
<p>registers that do not contain structures or</p>
<p>bitfields. Complex structures must be edited</p>
<p>from the command line or a Data Explorer.</p>
<p>See âEditing Register Contentsâ</p>
<p>on page 267.</p>
<p><b>Edit Contents</b></p>
<p><b>of<i> Register</b></i></p>
<p>Single register</p>
<p>Opens a Data Explorer displaying the value</p>
<p>of the selected register or its field. See âThe</p>
<p>Data Explorer Windowâ on page 185.</p>
<p><b>Open a Data</b></p>
<p><b>Explorer on</b></p>
<p><i><b>Register</b></i></p>
<p>Single register</p>
<p>Opens a<b> Register Information</b> window</p>
<p>displaying the selected register's detail</p>
<p>information. See âThe Register Information</p>
<p>Windowâ on page 270.</p>
<p><b>Open an Info</b></p>
<p><b>View on</b></p>
<p><i><b>Register</b></i></p>
<p><i>MULTI: Debugging</i></p>
<p><i>262</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Shown For</b></p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Single register</p>
<p>Opens a Memory View window displaying</p>
<p>the memory at the address represented by</p>
<p>the selected register. See Chapter 15, âUsing</p>
<p>the Memory View Windowâ on page 323.</p>
<p><b>View Memory</b></p>
<p><b>at Address in</b></p>
<p><i><b>Register</b></i></p>
<p>Single group</p>
<p>Makes the tab display only the children of</p>
<p>the selected group. This is useful when</p>
<p>configuring new tabs. See âChanging the</p>
<p>Root of the Register Treeâ on page 266.</p>
<p><b>Reroot Tab at</b></p>
<p><i><b>Group</b></i></p>
<p>Single register</p>
<p>Single group</p>
<p>Multiple items</p>
<p>Reverts the effect of any rerooting</p>
<p>commands applied to the tab. This is useful</p>
<p>when configuring new tabs. See âChanging</p>
<p>the Root of the Register Treeâ on page 266.</p>
<p><b>Unroot Active</b></p>
<p><b>Tab</b></p>
<p>Single register</p>
<p>Single group</p>
<p>Multiple items</p>
<p>Copies the contents of the value column for</p>
<p>the selected item or items to the clipboard.</p>
<p>See âCopying Register Valuesâ on page 267.</p>
<p><b>Copy Values</b></p>
<p>Single register</p>
<p>Single group</p>
<p>Multiple items</p>
<p>Saves the values of the selected registers in</p>
<p>the current tab into a file.</p>
<p><b>Save Selected</b></p>
<p><b>Register Values</b></p>
<p><b>into File</b></p>
<p>Single register</p>
<p>Single group</p>
<p>Multiple items</p>
<p>Loads register values from a file in the</p>
<p>saved register value format. See a saved</p>
<p>register value file for an example.</p>
<p><b>Load Register</b></p>
<p><b>Values from</b></p>
<p><b>File</b></p>
<p><b>Customizing the Register View Window</b></p>
<p>In addition to configuring the basic display of the<b> Register View</b> window, you can</p>
<p>also create and store multiple display configurations that will appear as customized</p>
<p>tabs in the<b> Register View</b> window.</p>
<p>Each tab in the<b> Register View</b> window contains a distinct view of the hierarchical</p>
<p>organization of groups and registers. You can choose to display only certain registers</p>
<p>and groups on each tab independently of other tabs. This means that you can create</p>
<p>new tabs that only display the registers you are interested in at particular points in</p>
<p>your process, and flip between these displays by clicking the appropriate tabs.</p>
<p><i>263</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Customizing the Register View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>You cannot modify the way registers are hierarchically grouped or ordered</p>
<p>without modifying the register definition files.</p>
<p>The<b> Register View</b> window remembers how it was configured between debugging</p>
<p>sessions. Settings are saved and restored based upon which register definition file</p>
<p>is loaded when the Debugger is opened. This usually means that configurations of</p>
<p>the registers for different target processor families are saved and restored</p>
<p>independently of each other.</p>
<p><b>Adding a New Register View Window Tab</b></p>
<p>The first step in creating a new configuration of the<b> Register View</b> window is to</p>
<p>add a new tab. To do this, choose<b> View</b> â<b> Add New Tab</b> in the<b> Register View</b></p>
<p>window. Use the dialog box to enter the name you want to give the new tab. The</p>
<p>tab name must contain only alphanumeric characters and underscores. Although</p>
<p>not required, this name should be short to keep the tab list narrower than the width</p>
<p>of your<b> Register View</b> window, making it easier to switch tabs without scrolling</p>
<p>through a long tab list. After you click<b> OK</b>, a new tab will appear in the list at the</p>
<p>top of the<b> Register View</b> window and will be made the active tab.</p>
<p>When you create a new tab, it displays the full structure of the register tree by</p>
<p>default. You can now show or hide registers and groups to pare this tree down to</p>
<p>the information that is most important to you.</p>
<p><b>Selectively Displaying Registers and Groups</b></p>
<p>Some target processors may have dozens of registers that are displayed in the default</p>
<p>register tree. You may not care about the values of many of these registers, and the</p>
<p>ones that are important to you may be scattered throughout the register tree. By</p>
<p>changing which items of the register tree are shown or hidden, you can display only</p>
<p>the information that is most relevant to you. Registers and groups are hidden on a</p>
<p>per-tab basis; hiding or showing a group on one tab does not affect its display on</p>
<p>the other tabs.</p>
<p>To hide a register, right-click the register you want to hide and choose<b> Hide<i> Register</b></i></p>
<p>from the shortcut menu.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>264</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To hide groups of registers, right-click the group and choose<b> Hide<i> Group</b></i> from the</p>
<p>shortcut menu. The group, and anything the group contained, will no longer be</p>
<p>displayed on that tab.</p>
<p>To hide multiple objects, use<b> Shift</b>+click or<b> Ctrl</b>+click in the register tree to select</p>
<p>multiple items. When you have selected everything you want to hide, right-click</p>
<p>one of the selected items and choose<b> Hide Selected Items</b> from the shortcut menu.</p>
<p>To display a hidden register or group, choose<b> View</b> â<b> Show Hidden Registers</b>.</p>
<p>All of the hidden registers and groups are now displayed as light gray items in the</p>
<p>register tree. Right-click the item you want to display and choose<b> Show<i> Item</b></i> from</p>
<p>the menu. The name of the item now appears in black, indicating that it is no longer</p>
<p>hidden. To show multiple items simultaneously, right-click a member of a multiple</p>
<p>selection, similarly to how multiple items are hidden at once. To remove the dimmed</p>
<p>items from the list, again choose the<b> View</b> â<b> Show Hidden Registers</b> option.</p>
<p>You can also show and hide items on a tab by using the<b> regtab</b> command. For more</p>
<p>information about this command, see âRegister Commandsâ in Chapter 14, âRegister</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Modifying the Ordering of Tabs</b></p>
<p>You can modify the left to right tab order that appears at the top of the<b> Register</b></p>
<p><b>View</b> window. The order of the tabs is maintained across Debugger sessions.</p>
<p>Whenever you open a new<b> Register View</b> window, the leftmost tab in the ordering</p>
<p>is the first one that is displayed.</p>
<p>To move a tab one position to the left, first click its label to make it the active tab.</p>
<p>Then choose<b> View</b> â<b> Promote Active Tab</b> in the<b> Register View</b> window.</p>
<p>To move a tab one position to the right, first click its label to make it the active tab.</p>
<p>Then choose<b> View</b> â<b> Demote Active Tab</b> in the<b> Register View</b> window.</p>
<p>You can also modify the ordering of tabs in the<b> Register View</b> window by using</p>
<p>the<b> regtab</b> command. For more information about this command, see âRegister</p>
<p>Commandsâ in Chapter 14, âRegister Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><i>265</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Customizing the Register View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Removing Unwanted Tabs</b></p>
<p>Each open<b> Register View</b> window must contain at least one tab. If the window</p>
<p>contains more than one tab, you can perform one of the following actions to remove</p>
<p>an unwanted tab:</p>
<p>â¢</p>
<p>Click the tab's label to make it the active tab, and then select<b> View</b> â<b> Remove</b></p>
<p><b>Active Tab</b>.</p>
<p>â¢</p>
<p>Use the<b> regtab</b> command. For information about this command, see âRegister</p>
<p>Commandsâ in Chapter 14, âRegister Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>Removal is permanent for customized tabs (see âAdding a New Register View</p>
<p>Window Tabâ on page 264). However, the automatically created<b> Processor</b>,<b> Board</b>,</p>
<p>and<b> Ungrouped</b> tabs can be restored. To restore these tabs:</p>
<p>1.</p>
<p>Exit MULTI.</p>
<p>2.</p>
<p>Remove the relevant<b> .ini</b> configuration file from:</p>
<p>â¢</p>
<p>Windows 7/Vista â<i><b> user_dir</i>\AppData\Roaming\GHS\regview\</b></p>
<p>â¢</p>
<p>Windows XP â<i><b> user_dir</i>\Application Data\GHS\regview\</b></p>
<p>â¢</p>
<p>Linux/Solaris â<i><b> user_dir</i>/.ghs/regview/</b></p>
<p>Note that removing this configuration file also permanently deletes all</p>
<p>customized tabs.</p>
<p><b>Changing the Root of the Register Tree</b></p>
<p>Newly created tabs always display the full register tree. You may only be interested</p>
<p>in the registers in a certain group that is nested within other groups of the register</p>
<p>tree. By showing and hiding groups, you can make all the other groups invisible,</p>
<p>leaving only the registers you are interested in visible, along with the groups that</p>
<p>contain them.</p>
<p>To hide the parents of a visible register or group, change the root of the register tree</p>
<p>for a tab. When you change the root of the register tree on a tab, only the children</p>
<p>of the group chosen to be the new root are displayed. To specify that a group should</p>
<p>be the new root, right-click the group and choose<b> Reroot Tab at<i> Group</b></i> from the</p>
<p><i>MULTI: Debugging</i></p>
<p><i>266</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>shortcut menu. Afterwards, the register tree on that tab now displays only the children</p>
<p>of the group you specified to be the root.</p>
<p>You can display all of the groups in the default register tree and undo a rerooting</p>
<p>operation by unrooting the register tree on a tab. First click the desired label to make</p>
<p>it the active tab. Choose<b> View</b> â<b> Unroot Active Tab</b> in the<b> Register View</b> window.</p>
<p>The tab will now display all of the default register tree's visible groups.</p>
<p>You can also reroot and unroot tabs by using the<b> regtab</b> command. For information</p>
<p>about this command, see âRegister Commandsâ in Chapter 14, âRegister Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Copying Register Values</b></p>
<p>You can place a copy of any information in the register tree onto the clipboard. To</p>
<p>make a copy, select the items you want to copy and press<b> Ctrl</b>+<b>C</b>. All of the rows</p>
<p>that are selected in the register tree will be copied to the clipboard. Since only full</p>
<p>rows can be selected, the copy will take names of groups and registers as well as</p>
<p>their values.</p>
<p>Sometimes you may want to copy just the value of a particular register or set of</p>
<p>registers and omit the register names. To do this, first select the registers whose</p>
<p>values you want to copy. Then right-click the selection and choose<b> Copy Values</b></p>
<p>from the shortcut menu that appears. If you only want to copy the value of a single</p>
<p>register, right-click the register and it will be selected automatically.</p>
<p><b>Editing Register Contents</b></p>
<p>Many registers contain values that are not interpreted as bitfields or structures, but</p>
<p>as simple unsigned bits, floating-point values, or integers. For registers that lack</p>
<p>complicated structures, their contents can be edited directly from the<b> Register View</b></p>
<p>window.</p>
<p>To edit the contents of a register, right-click the register you want to modify and</p>
<p>choose<b> Edit Contents of<i> Register</b></i> from the shortcut menu that appears. A dialog</p>
<p>box will appear that shows the current value of the register. Type in the new value</p>
<p>or a Debugger command line expression that evaluates to the new value you want</p>
<p>the register to have. When you click<b> OK</b>, the register will be assigned either the</p>
<p><i>267</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Copying Register Values</i></p>
<h1 style="page-break-before:always; "></h1>
<p>value you typed in or the result of evaluating your expression in the current Debugger</p>
<p>environment.</p>
<p>To modify the values of registers that have complicated structures, you must do</p>
<p>your editing from a<b> Register Information</b> window or a Data Explorer. To modify</p>
<p>register value with the<b> Register Information</b> window:</p>
<p>1.</p>
<p>Open a<b> Register Information</b> window on the register (right-click the register</p>
<p>you want to modify and choose<b> Open an Info View on<i> Register</b></i> from the</p>
<p>shortcut menu). A<b> Register Information</b> window will appear showing the</p>
<p>details of the register's structure.</p>
<p>2.</p>
<p>Edit the register's contents as described in âChanging a Register Valueâ</p>
<p>on page 275.</p>
<p>To modify register value with the Data Explorer:</p>
<p>1.</p>
<p>Open a Data Explorer on the register (right-click the register you want to</p>
<p>modify and choose<b> Open a Data Explorer on<i> Register</b></i> from the shortcut</p>
<p>menu). A Data Explorer will appear showing the details of the register's</p>
<p>structure.</p>
<p>2.</p>
<p>Edit the register's contents as you would edit the values of any other structure</p>
<p>in a Data Explorer.</p>
<p>See Chapter 11, âViewing and Modifying Variables with the Data Explorerâ</p>
<p>on page 183.</p>
<p><b>Controlling Refresh of Register Values</b></p>
<p>By default, the<b> Register View</b> window tries to update the values of all the registers</p>
<p>it displays whenever your process is halted. There may be cases where you do not</p>
<p>want the values to be automatically updated, such as when you want to keep a copy</p>
<p>of the current values of a processor's registers to compare with the values at a future</p>
<p>time. You may also want to suppress automatic updating if you are using a slow</p>
<p>target connection.</p>
<p>To suppress the automatic updating of register values, click the</p>
<p>button in the</p>
<p><b>Register View</b> window. The button will appear to be pushed down to indicate that</p>
<p>the window is frozen. While the window is frozen, the register values will not be</p>
<p>automatically updated from your target. In the frozen state you may still scroll</p>
<p><i>MULTI: Debugging</i></p>
<p><i>268</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>through the register tree to view all of the register values that were present when</p>
<p>the window was frozen. You are not allowed to switch between tabs when the</p>
<p><b>Register View</b> window is frozen. To unfreeze the window and allow the register</p>
<p>values to be automatically refreshed again, click the</p>
<p>button again.</p>
<p>By default, when the value of a particular register changes, that register's entry will</p>
<p>be highlighted in the register tree. To toggle this highlighting on and off, choose</p>
<p><b>Format</b> â<b> Show Changes</b>.</p>
<p>If you want to manually refresh register values in the<b> Register View</b> window while</p>
<p>your process is halted, choose<b> View</b> â<b> Refresh</b>. Usually the values will be</p>
<p>automatically refreshed each time the process is halted, but you will need to manually</p>
<p>refresh to see any changes to volatile registers that occur while your process is</p>
<p>halted.</p>
<p><b>Printing the Window Contents</b></p>
<p>To print the list of registers and register values in a<b> Register View</b> window, click</p>
<p>the</p>
<p>button or select<b> File</b> â<b> Print</b> and specify the appropriate settings in the</p>
<p><b>Print Options</b> dialog that appears.</p>
<p><b>Register View Window Configuration Files</b></p>
<p>The<b> Register View</b> window tab configurations are stored in configuration files to</p>
<p>maintain settings across Debugger sessions. These files, whose names end in<b> .ini</b>,</p>
<p>are stored in the<b> regview</b> subdirectory of your personal configuration directory (see</p>
<p>âRemoving Unwanted Tabsâ on page 266). Usually you will not need to modify</p>
<p>these configuration files directly. If you are customizing MULTI for internal</p>
<p>distributions, however, you may want to add tabs for your users in addition to the</p>
<p><b>Processor</b>,<b> Board</b>, and<b> Ungrouped</b> tabs. To do so, use the</p>
<p>gui_tab</p>
<p>clause in the</p>
<p>register definition file. For details, see âThe GRD Register Definition Formatâ</p>
<p>on page 776.</p>
<p><i>269</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Printing the Window Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Register Information Window</b></p>
<p>The<b> Register Information</b> window shows detailed information about a register,</p>
<p>including bitfields and documentation, and provides convenient approaches to</p>
<p>change the register's value.</p>
<p>Here is an example for the Power Architecture</p>
<p>msr</p>
<p>register:</p>
<p><i>MULTI: Debugging</i></p>
<p><i>270</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>You can open a<b> Register Information</b> window in the following ways:</p>
<p>â¢</p>
<p>In the<b> Register View</b> window's shortcut menu, choose<b> Open an Info View on</b></p>
<p><i><b>register_name</b></i>.</p>
<p>â¢</p>
<p>In the<b> Register View</b> window, double-click a register with a bitfield definition.</p>
<p>â¢</p>
<p>Issue the<b> regview</b> command followed by a register name. For information about</p>
<p>the<b> regview</b> command, see âRegister Commandsâ in Chapter 14, âRegister</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>The<b> Register Information</b> window contains the following parts:</p>
<p>â¢</p>
<p><b>Location</b> â Displays the register's type (register, memory-mapped, etc.) and</p>
<p>address information, if any.</p>
<p>â¢</p>
<p><b>Hex value</b> â Displays the register's value, in hexadecimal.</p>
<p>The currently selected hexadecimal digits in the bitfield panes (see below for</p>
<p>more information) are displayed in the color used for selections, and any digits</p>
<p>changed in this display but not yet written to the target by clicking<b> Apply</b> are</p>
<p>displayed in red.</p>
<p>â¢</p>
<p><b>Binary value</b> â Displays the register's binary value.</p>
<p>The bits are displayed in groups of 4 or 8 bits. To toggle between 4 and 8 bit</p>
<p>groups, select<b> Show Binary in Nibbles</b> from the shortcut menu accessible in</p>
<p>the bitfield panes. Bit groups are separated by an underline. As in the<b> Hex</b></p>
<p><b>value</b> display, the currently selected binary digits in the bitfield panes (see</p>
<p>below for more information) are displayed in the color used for selections, and</p>
<p>any bits changed in this display but not yet written to the target by clicking</p>
<p><b>Apply</b> are displayed in red.</p>
<p>â¢</p>
<p>Concise display pane â Displays the register's bitfield names as column</p>
<p>headings and values in the corresponding cells. Any bits changed in this display</p>
<p>but not yet written to the target by clicking<b> Apply</b> are displayed in red. For</p>
<p>more information, see âConcise Display Paneâ on page 272.</p>
<p>â¢</p>
<p>Detailed display pane â Displays the register's detailed bitfield information.</p>
<p>Any bits changed in this display but not yet written to the target by clicking</p>
<p><b>Apply</b> are displayed in red. For more information, see âDetailed Display Paneâ</p>
<p>on page 273.</p>
<p><i>271</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Register Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Help pane â Displays the register's documentation. For details, see âHelp</p>
<p>Paneâ on page 274.</p>
<p>Whenever you select a bitfield in the bitfield panes, its description (if defined</p>
<p>in the register definition file) will be shown in the help pane in a special</p>
<p>background color.</p>
<p>â¢</p>
<p>Button set â Allows you to write any changes made in this window to the</p>
<p>target, revert any changes, or close the<b> Register Information</b> window. For</p>
<p>more information, see âButton Setâ on page 275.</p>
<p><b>Concise Display Pane</b></p>
<p>In the concise display pane, the register's field names are shown in column headers,</p>
<p>and the corresponding field values are shown below the field names. The fields are</p>
<p>displayed in order from the most significant bit to the least significant bit.</p>
<p>When you right-click a value cell, a shortcut menu appears with the following items:</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Sets the value to the bitfield.</p>
<p>This menu item is displayed for a writable register's enumeration</p>
<p>bitfields or 1 or 2 bit bitfields. The current value is dimmed.</p>
<p><b>Set Value:<i>value</b></i></p>
<p>Allows you to provide a new value for the bitfields.</p>
<p>This menu item is displayed for a writable register's bitfields that are</p>
<p>not enumeration types and that are wider than 2 bits.</p>
<p><b>Change Value</b></p>
<p>Launches a<b> Modify Register Definition</b> dialog (see âThe Modify</p>
<p>Register Definition Dialogâ on page 276) to modify the register's bitfield</p>
<p>definitions.</p>
<p>You can save the modified register bitfield definition into a file by</p>
<p>choosing<b> File</b> â<b> Save Register Definitions Created on the Fly</b> from</p>
<p>the<b> Register View</b> window.</p>
<p><b>Modify Register</b></p>
<p><b>Definition</b></p>
<p>Toggles whether to show numeric or literal values for bitfields in the</p>
<p>concise display pane.</p>
<p><b>Show Numeric</b></p>
<p><b>Values</b></p>
<p>Toggles whether to display undefined bitfields.</p>
<p><b>Pad Undefined</b></p>
<p><b>Bitfields</b></p>
<p>Toggles whether to display binary values grouped by nibbles (4 bits)</p>
<p>or bytes (8 bits).</p>
<p><b>Show Binary in</b></p>
<p><b>Nibbles</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>272</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Reverses the numbering for bits.</p>
<p>This option only changes the displayed bit indices; it does not change</p>
<p>the register's value.</p>
<p><b>Reverse Bit</b></p>
<p><b>Numbering</b></p>
<p>Swaps the bytes in the register value displayed in the<b> Register</b></p>
<p><b>Information</b> window.</p>
<p>This option changes the register value in the<b> Register Information</b></p>
<p>window. Click the<b> Apply</b> button to write the modification to the target.</p>
<p><b>Reverse Byte Order</b></p>
<p><b>Detailed Display Pane</b></p>
<p>In the detailed display pane, displayed just below the concise display pane, more</p>
<p>comprehensive information about each bitfield is present. The bitfields are listed</p>
<p>in the order they are defined in the corresponding register definition file.</p>
<p>The register's bitfields and their possible values (for enumeration bitfields) are</p>
<p>displayed in rows in the detailed display pane. The following columns are present</p>
<p>in the display:</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Bit number or bit number range for a bitfield.</p>
<p>The column's value can be changed by toggling the<b> Reverse Bit</b></p>
<p><b>Numbering</b> option in the shortcut menu.</p>
<p><b>Bit #</b></p>
<p>Bitfield name.</p>
<p><b>Name</b></p>
<p>Bitfield's numeric value.</p>
<p><b>Value</b></p>
<p>Bitfield's description.</p>
<p>If a bitfield has a single-line description, it will be fully displayed in</p>
<p>the column; if a bitfield has a multiple-line description, the first line</p>
<p>will be displayed in the column followed by</p>
<p>...</p>
<p>; if a bitfield has no</p>
<p>description but has a long name, the long name will be displayed in the</p>
<p>column.</p>
<p><b>Description</b></p>
<p><i>273</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Detailed Display Pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p>When you right-click a cell, a shortcut menu appears with the following items:</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Toggles whether to display the possible values for each bitfield of the</p>
<p>register.</p>
<p>When the flag is on, an enumeration bitfield's possible values are shown</p>
<p>below the bitfield. In the row showing a possible bitfield value, the</p>
<p>other columns are blank. Double-click one of these bitfield value choices</p>
<p>to change the bitfield to that value.</p>
<p><b>Show Possible Field</b></p>
<p><b>Values</b></p>
<p>Other items in the shortcut menu have the same functions as the</p>
<p>corresponding items in the shortcut menu of the concise display pane.</p>
<p><i><b>Other items</b></i></p>
<p><b>Help Pane</b></p>
<p>The help pane is below the detailed display pane.</p>
<p>At the top, it displays the register's general description in the following order:</p>
<p>â¢</p>
<p>The register's name, aliases etc</p>
<p>â¢</p>
<p>The register's long name (if any)</p>
<p>â¢</p>
<p>The register's description (if any)</p>
<p>Then, for each bitfield, the help pane displays information in the following order:</p>
<p>â¢</p>
<p>The bitfield's name</p>
<p>â¢</p>
<p>The bitfield's long name (if any)</p>
<p>â¢</p>
<p>The bitfield's description (if any)</p>
<p>â¢</p>
<p>The bitfield's possible values (for enumeration types)</p>
<p>The bitfields are shown in the order they are defined in the corresponding register</p>
<p>definition file.</p>
<p>Whenever you click a cell in the concise display pane or the detailed display pane,</p>
<p>the help pane will automatically scroll to and highlight the corresponding bitfield's</p>
<p>documentation.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>274</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Button Set</b></p>
<p>The button set is at the bottom of the<b> Register Information</b> window. It contains</p>
<p>the following buttons:</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Writes the register value displayed in the<b> Register Information</b> window</p>
<p>to the target.</p>
<p><b>Apply</b></p>
<p>Discards any changes made to the register value and reloads the current</p>
<p>register value.</p>
<p><b>Revert</b></p>
<p>Closes the<b> Register Information</b> window.</p>
<p>If any unwritten changes have been made, those changes will be</p>
<p>discarded.</p>
<p><b>Close</b></p>
<p><b>Changing a Register Value</b></p>
<p>The<b> Register Information</b> window provides various ways to change a register's</p>
<p>value, provided the register is not read-only:</p>
<p>â¢</p>
<p>In the<b> Hex value</b>,<b> Binary value</b>, the concise display pane's numeric cells and</p>
<p>the detailed display pane's<b> Value</b> column, you can directly modify the register</p>
<p>value:</p>
<p>1.</p>
<p>Select the text you want to change (the hex prefix in<b> Hex value</b> cannot</p>
<p>be changed);</p>
<p>2.</p>
<p>Type in the new value.</p>
<p>If an invalid character is typed, you may hear a beep.</p>
<p>â¢</p>
<p>In the shortcut menus of the concise display pane and the detailed display pane,</p>
<p>you can select the value entries to set the corresponding bitfield's value for</p>
<p>enumeration bitfields, or select<b> Change Value</b> to type in values for</p>
<p>non-enumeration bitfields wider than 2 bits.</p>
<p>â¢</p>
<p>In the detailed display pane, you can double-click a listed enumeration value</p>
<p>to set the corresponding bitfield to that value.</p>
<p>â¢</p>
<p>In the concise display pane and the detailed display pane, you can double-click</p>
<p>a bitfield with only one bit to toggle its value.</p>
<p><i>275</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Button Set</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Modify Register Definition Dialog</b></p>
<p>You can use the<b> Modify Register Definition</b> dialog (an example is shown below)</p>
<p>to change a register's bitfield definition for the current debugging session.</p>
<p>The<b> Modify Register Definition</b> dialog can be launched by choosing<b> Modify</b></p>
<p><b>Register Definition</b> from the shortcut menu of the<b> Register Information</b> window's</p>
<p>concise display pane or detailed display pane.</p>
<p>If you modify an existing register's definition or create a new register, you will be</p>
<p>asked to save these definitions into a</p>
<p>GRD</p>
<p>file when you quit MULTI. To save any</p>
<p>new or modified register definitions to a</p>
<p>GRD</p>
<p>file, choose<b> File</b> â<b> Save Register</b></p>
<p><b>Definitions Created on the Fly</b> from the<b> Register View</b> window. You can merge</p>
<p>the changes into your default register definition system later or dynamically load</p>
<p>the</p>
<p>GRD</p>
<p>file in future debugging session by choosing<b> File</b> â<b> Load Register</b></p>
<p><b>Definitions from File</b> from the<b> Register View</b> window.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>276</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Modify Register Definition</b> dialog contains three parts:</p>
<p>â¢</p>
<p>The bitfield editor pane, which contains fields for a bitfield's attributes and a</p>
<p>set of buttons to manipulate the changes. For more information, see âBitfield</p>
<p>Editor Paneâ on page 277.</p>
<p>â¢</p>
<p>The bitfield list pane, which lists the information for all bitfields. For more</p>
<p>information, see âBitfield List Paneâ on page 278.</p>
<p>â¢</p>
<p>The button set, which allows you to commit (<b>OK</b>) or discard (<b>Cancel</b>) the</p>
<p>changes made in the dialog.</p>
<p><b>Bitfield Editor Pane</b></p>
<p>The bitfield editor pane has the following attributes. Whenever you select an entry</p>
<p>in the bitfield list pane, the settings for the selected bitfield will be displayed in the</p>
<p>editor pane. If you click the<b> New</b> button, a template for a new bitfield will be</p>
<p>displayed in the editor pane.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>The name of the bitfield.</p>
<p>Bitfields within a register must have distinct names. For a new bitfield,</p>
<p>MULTI will generate a unique name; you can change it to a more</p>
<p>meaningful name.</p>
<p><b>Name</b></p>
<p>The description of the bitfield, which will be shown in the<b> Register</b></p>
<p><b>Information</b> window.</p>
<p><b>Description</b></p>
<p>The starting bit position (inclusive) of the bitfield.</p>
<p>The bits are numbered starting with 0.</p>
<p><b>From</b></p>
<p>The ending bit position (inclusive) of the bitfield.</p>
<p><b>To</b></p>
<p>The type of the bitfield:</p>
<p>hex</p>
<p>,</p>
<p>binary</p>
<p>,</p>
<p>signed</p>
<p>,</p>
<p>unsigned</p>
<p>, or an</p>
<p>enumeration type defined in one of the</p>
<p>GRD</p>
<p>files that have been loaded.</p>
<p><b>Type</b></p>
<p><i>277</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Bitfield Editor Pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The functions of the buttons in the bitfield editor pane are listed below:</p>
<p><b>Meaning</b></p>
<p><b>Button</b></p>
<p>Creates a new bitfield in the bitfield editor pane.</p>
<p><b>New</b></p>
<p>Propagates the changes shown in the bitfield editor pane to the bitfield</p>
<p>list pane.</p>
<p>If the bitfield shown in the bitfield editor pane is an existing bitfield in</p>
<p>the bitfield list, the corresponding entry in the bitfield list will be</p>
<p>changed; otherwise, the new bitfield will be added to the end of the</p>
<p>bitfield list.</p>
<p>In order to accept any changes made, you still have to click the<b> OK</b></p>
<p>button in the lower button set.</p>
<p><b>Submit</b></p>
<p><b>Bitfield List Pane</b></p>
<p>The bitfield list pane appears below the bitfield editor pane. Its columns correspond</p>
<p>to the attributes of a bitfield, as described in âBitfield Editor Paneâ on page 277.</p>
<p>To display or change a bitfield's attributes, click a list entry to select it. The bitfield's</p>
<p>attributes will be displayed in the bitfield editor pane, where they can be examined</p>
<p>or changed.</p>
<p>The following choices appear in the right-click menu of the bitfield list:</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Creates a new bitfield in the bitfield editor pane.</p>
<p><b>Add</b></p>
<p>Deletes the selected bitfields.</p>
<p><b>Delete</b></p>
<p>Displays the most recently selected bitfield in the bitfield editor pane</p>
<p>where it can be examined or changed.</p>
<p><b>Modify</b></p>
<p>Moves the selected bitfield or bitfields up one row.</p>
<p><b>Move Up</b></p>
<p>Moves the selected bitfield or bitfields down one row.</p>
<p><b>Move Down</b></p>
<p>Sorts the bitfields by their bit position in ascending order.</p>
<p><b>Sort by Bit Position</b></p>
<p><b>in Ascending Order</b></p>
<p>Sorts the bitfields by their bit position in descending order.</p>
<p><b>Sort by Bit Position</b></p>
<p><b>in Descending Order</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>278</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The following keyboard shortcuts can be used to manipulate the bitfield list:</p>
<p><b>Meaning</b></p>
<p><b>Key Action</b></p>
<p>Moves the selected bitfields up one row.</p>
<p><b>Ctrl</b>+<b>UpArrow</b></p>
<p>Moves the selected bitfields down one row.</p>
<p><b>Ctrl</b>+<b>DownArrow</b></p>
<p>Deletes the selected bitfields.</p>
<p><b>Ctrl</b>+<b>D</b></p>
<p>Deletes the selected bitfields.</p>
<p><b>Delete</b></p>
<p><b>The Register Setup Dialog</b></p>
<p>You can create a new register in one of these ways:</p>
<p>â¢</p>
<p>Choose<b> View</b> â<b> View â<i>variable</i>â as Register</b> from a Data Explorer.</p>
<p>â¢</p>
<p>Run the<b> regadd</b> command in the Debugger command pane. For information</p>
<p>about the<b> regadd</b> command, see âRegister Commandsâ in Chapter 14, âRegister</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>The<b> Register Setup</b> dialog opens so that you can specify the basic information for</p>
<p>the newly created register.</p>
<p>The<b> Register Setup</b> dialog contains the fields listed in the table below.</p>
<p><b>Meaning</b></p>
<p><b>Field</b></p>
<p>Name of the register. This name must not already be used for an existing</p>
<p>register.</p>
<p><b>Name</b></p>
<p>Access type of the register.</p>
<p>The only available choice is</p>
<p>Memory-mapped</p>
<p>.</p>
<p><b>Access Type</b></p>
<p>The address at which the register value can be read.</p>
<p><b>Address</b></p>
<p><i>279</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Register Setup Dialog</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Field</b></p>
<p>Access size used to read the register value.</p>
<p><b>Width</b></p>
<p><b>Register View</b> window tab on which the register will be displayed.</p>
<p>Choose one of the tab names from the list.</p>
<p><b>Tab</b></p>
<p>Group to which the register is to be associated. Choose one of the group</p>
<p>names from the list.</p>
<p><b>Group</b></p>
<p>Specifies the byte order of the register:</p>
<p>â¢</p>
<p><b>Default</b>â Always the same as the target</p>
<p>â¢</p>
<p><b>Big Endian</b> â Always big endian</p>
<p>â¢</p>
<p><b>Little Endian</b> â Always little endian</p>
<p><b>Byte Order</b></p>
<p>Chooses whether bits will be numbered with bit 0 referring to the least</p>
<p>significant bit, as on most CPU architectures, or with bit 0 referring to</p>
<p>the most significant bit, as on Power Architecture.</p>
<p><b>Bit Order</b></p>
<p>When a new register is created, a new<b> Register View</b> window will be launched to</p>
<p>show the register in the proper tab, and a<b> Register Information</b> window will be</p>
<p>launched to show the register's detailed information.</p>
<p><b>The Register Search Window</b></p>
<p>To locate a register on a target with many registers, use the<b> Register Search</b> window</p>
<p>(see an example below).</p>
<p>You can launch the<b> Register Search</b> window by either:</p>
<p>â¢</p>
<p>Clicking the</p>
<p>button in the toolbar of the<b> Register View</b> window</p>
<p><i>MULTI: Debugging</i></p>
<p><i>280</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Choosing<b> View</b> â<b> Search Register</b> from the<b> Register View</b> window</p>
<p>The<b> Register Search</b> window contains three parts:</p>
<p>â¢</p>
<p><b>Text</b> field â Enter a string to be matched against the register's various</p>
<p>attributes. After each typed character, MULTI searches the register database</p>
<p>loaded from</p>
<p>GRD</p>
<p>files, and displays matching registers in the Register List. The</p>
<p>register attributes searched include:</p>
<p>â</p>
<p>Register names, including</p>
<p>name</p>
<p>,</p>
<p>short name</p>
<p>,</p>
<p>long name</p>
<p>and</p>
<p>alias</p>
<p>â</p>
<p>Register description</p>
<p>â</p>
<p>Register bitfield descriptions</p>
<p>â¢</p>
<p><b>Close</b> button â Closes the<b> Register Search</b> window.</p>
<p>â¢</p>
<p>Register list â Displays registers matching the text in the<b> Text</b> field.</p>
<p>The register list's columns display the information in the following table.</p>
<p><b>Meaning</b></p>
<p><b>Field</b></p>
<p>Register name.</p>
<p><b>Name</b></p>
<p>Tab in which the register is displayed in the<b> Register View</b> window.</p>
<p><b>Tab</b></p>
<p>The path of the register in the hierarchy shown in the<b> Register View</b></p>
<p>window.</p>
<p>The tab name is at the beginning of the path.</p>
<p><b>Path</b></p>
<p>The register attribute that matches the text entered in the<b> Text</b> field.</p>
<p><b>Matched Item</b></p>
<p>To locate a register in the<b> Register View</b> window, single-click the entry in the</p>
<p>register list; to display a register in the<b> Register Information</b> window (if the register</p>
<p>has bitfields defined) or in the Data Explorer (otherwise), double-click the</p>
<p>corresponding entry in the Register List.</p>
<p>The following items appear in the right-click menu of the register list:</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Displays the register in the<b> Register View</b> window. The tab to which</p>
<p>the register belongs is displayed and all group nodes in the register's</p>
<p>path are expanded, if necessary.</p>
<p><b>Show â<i>register</i>â in</b></p>
<p><b>Register Explorer</b></p>
<p><i>281</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Register Search Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Shows the register in the<b> Register Information</b> window.</p>
<p><b>Show Register</b></p>
<p><b>Information for</b></p>
<p><b>â<i>register</i>â</b></p>
<p>Shows the register in the Data Explorer.</p>
<p><b>Show â<i>register</i>â in</b></p>
<p><b>Data Explorer</b></p>
<p><b>Using Debugger Commands to Work with Registers</b></p>
<p>Registers that are defined by Register Explorer can be accessed directly from the</p>
<p>command line or used in command line expressions. To use the value in the register</p>
<p>named</p>
<p><i>reg</i></p>
<p>on the command line, enter a dollar sign followed by its name (</p>
<p>$<i>reg</i></p>
<p>).</p>
<p>Assume that a 32-bit memory-mapped register</p>
<p>b</p>
<p>is defined and currently contains</p>
<p>the value</p>
<p>5</p>
<p>. You can display the register value as follows:</p>
<p>&gt; $b</p>
<p>$b = 0x00000005</p>
<p>You can assign a new value to the register:</p>
<p>&gt; $b=3+3</p>
<p>$b = 0x00000006</p>
<p>Bitfield registers and structured registers are accessed from the command line in</p>
<p>the same way as C-style structs. Assuming that a bitfield register</p>
<p>y</p>
<p>with the following</p>
<p>bitfield description in the</p>
<p>GRD</p>
<p>format is defined as follows:</p>
<p># Bitfields of register y</p>
<p>bitfield {</p>
<p>y_bitfield {</p>
<p>&quot;cache_state&quot; {loc=&quot;0..1&quot;}</p>
<p>&quot;reserved&quot; {loc=&quot;2..31&quot;}</p>
<p>}</p>
<p>}</p>
<p><i>MULTI: Debugging</i></p>
<p><i>282</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>This register definition indicates that</p>
<p>y</p>
<p>has two bitfields,</p>
<p>cache_state</p>
<p>in the low</p>
<p>two bits and</p>
<p>reserved</p>
<p>in the high 30 bits. Assume the initial value of</p>
<p>y</p>
<p>is</p>
<p>0x13</p>
<p>.</p>
<p>If you print out the register in the command pane, it will be displayed as a C-style</p>
<p>struct:</p>
<p>&gt; $y</p>
<p>y = struct y {</p>
<p>reserved = 0x00000001;</p>
<p>cache_state = 0x00000003;</p>
<p>} y</p>
<p>You can display an individual field of a bitfield register. For example:</p>
<p>&gt; $y.cache_state</p>
<p>cache_state = 0x00000003</p>
<p>You can assign to a field of a bitfield register. For example:</p>
<p>&gt; $y.cache_state=2</p>
<p>cache_state = 0x00000002</p>
<p>In the above example, the</p>
<p>cache_state</p>
<p>bitfield will be modified without affecting</p>
<p>the</p>
<p>reserved</p>
<p>bitfield:</p>
<p>&gt; $y</p>
<p>struct y {</p>
<p>reserved = 0x00000001;</p>
<p>cache_state = 0x00000002;</p>
<p>} y</p>
<p>Registers that are pointers to structures are accessed like C-style pointers on the</p>
<p>command line. Assume that a structure</p>
<p>frame</p>
<p>and a register</p>
<p>fp</p>
<p>are described in</p>
<p>the register definition files, as follows:</p>
<p># Structure frame definition</p>
<p>struct {</p>
<p>frame {</p>
<p>hi_word {type=&quot;short&quot;}</p>
<p>lo_word {type=&quot;short&quot;}</p>
<p>}</p>
<p>}</p>
<p><i>283</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using Debugger Commands to Work with Registers</i></p>
<h1 style="page-break-before:always; "></h1>
<p># some characteristics of register fp</p>
<p>register {</p>
<p>fp {address=0; type=&quot;frame *&quot;}</p>
<p>}</p>
<p>Assume that</p>
<p>fp</p>
<p>is currently pointing to a the memory address</p>
<p>0xbbb</p>
<p>that contains</p>
<p>0x000a0007</p>
<p>. The following illustrates what you would see in the command pane</p>
<p>when printing out the contents of</p>
<p>fp</p>
<p>.</p>
<p>&gt; $fp</p>
<p>$fp :</p>
<p>*fp *0xbbb: struct frame {</p>
<p>hi_word = 10;</p>
<p>lo_word = 7;</p>
<p>}</p>
<p>The pointer was automatically dereferenced when the register contents were printed.</p>
<p>To print out a single field, dereference the field:</p>
<p>&gt; $fp-&gt;lo_word</p>
<p>lo_word = 7</p>
<p>To assign to one of the fields, dereference the field:</p>
<p>&gt; $fp-&gt;hi_word=1 &lt;&lt; 3</p>
<p>hi_word = 8</p>
<p>Registers that are pointers to raw types are accessed the same way as variables that</p>
<p>are pointers to the corresponding type. When using a register's value as an argument</p>
<p>to a MULTI command or a command line procedure call, use the same syntax as</p>
<p>you would for printing out register values or assigning to registers from the command</p>
<p>line.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>284</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Customizing Registers</b></p>
<p><b>Customizing Registers from the Command Line</b></p>
<p>You can modify existing register definitions and define new registers from the</p>
<p>command line while you are debugging a program. For descriptions of the syntax</p>
<p>and function of these commands, see âRegister Commandsâ in Chapter 14, âRegister</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>Any modifications to the register definitions made from the command</p>
<p>line are active only until you reload the program or connect to a different</p>
<p>target. For persistent modifications, you must use<b> .rc</b> files or customize</p>
<p>the default register definition files, as described below.</p>
<p><b>Customizing Registers in Default .rc Files</b></p>
<p>Any register modifications that are present in a program's default<b> .rc</b> file are</p>
<p>persistent across reloads and establishing target connections. Default<b> .rc</b> files are</p>
<p>the best place to insert definitions of registers you want to consistently use while</p>
<p>debugging a specific program. For more information about default<b> .rc</b> files, see</p>
<p>Chapter 7, âConfiguring and Customizing MULTIâ in the<i> MULTI: Managing</i></p>
<p><i>Projects and Configuring the IDE</i> book.</p>
<p>The<b> regappend</b> and<b> regload</b> commands can appear in default<b> .rc</b> files and will be</p>
<p>applied whenever the program is reloaded or a connection to a new target is</p>
<p>established. For information about the<b> regappend</b> and<b> regload</b> commands, see</p>
<p>âRegister Commandsâ in Chapter 14, âRegister Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Customizing Default Register Definition Files</b></p>
<p>When you install the Green Hills Compiler, some default register definition files</p>
<p>are installed. These files define a set of registers and register groups for popular</p>
<p>target processors and boards. You should not need to modify these files. You can</p>
<p>customize the default set of files, however, to add new registers or register groups</p>
<p><i>285</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Customizing Registers</i></p>
<h1 style="page-break-before:always; "></h1>
<p>that are relevant to your target environment. This section describes how the default</p>
<p>files are located and when they are loaded.</p>
<p><b>Tip</b></p>
<p>If you are customizing registers for a single program only, you should</p>
<p>probably use the default<b> .rc</b> file approach. See also âCustomizing</p>
<p>Registers in Default .rc Filesâ on page 285. The default register definition</p>
<p>files should only be modified if you want definitions to be applied to all</p>
<p>of the programs you debug.</p>
<p><b>Register Explorer Startup</b></p>
<p>When you open a Debugger, MULTI searches for the root</p>
<p>GRD</p>
<p>file, which is used</p>
<p>to display the registers of the target hardware. If MULTI cannot find or successfully</p>
<p>load the root</p>
<p>GRD</p>
<p>file, most debugging functionality will not be available.</p>
<p>The root</p>
<p>GRD</p>
<p>file is the first of the following four register files that MULTI locates.</p>
<p>MULTI searches for the register files in the order listed. For information about the</p>
<p>directories MULTI searches when trying to locate the register files, see âFile</p>
<p>Locationsâ on page 287.</p>
<p>1.</p>
<p><i><b>prog</i>.grd</b> â</p>
<p><i>prog</i></p>
<p>is the name of the program you are debugging.<i><b> prog</i>.grd</b>,</p>
<p>if it exists, is a user-defined file.</p>
<p>2.</p>
<p><i><b>dbserv</i>-<i>dbtarget</i>.grd</b> â</p>
<p><i>dbserv</i></p>
<p>is the debug server you are connected to, and</p>
<p><i>dbtarget</i></p>
<p>is your debug server target.<i><b> dbserv</i>-<i>dbtarget</i>.grd</b>, if it exists, is a</p>
<p>user-defined file.</p>
<p>3.</p>
<p><i><b>cpu</i>.grd</b> â</p>
<p><i>cpu</i></p>
<p>is the acronym for your processor family. (For a list of possible</p>
<p><i>cpu</i></p>
<p>values, see the following table.)<i><b> cpu</i>.grd</b> is included in your Green Hills</p>
<p>Compiler installation. If you have not defined the register files listed above,</p>
<p><i><b>cpu</i>.grd</b> is used as the root</p>
<p>GRD</p>
<p>file.</p>
<p>4.</p>
<p><i><b>dbserv</i>.grd</b> â</p>
<p><i>dbserv</i></p>
<p>is the debug server you are connected to.<i><b> dbserv</i>.grd</b>,</p>
<p>if it exists, is a user-defined file.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>286</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Appropriate values for</p>
<p><i>cpu</i></p>
<p>(in<i><b> cpu</i>.grd</b>) are listed in the following table.</p>
<p><b>Value of</b></p>
<p><i><b>cpu</b></i></p>
<p><b>(in<i> cpu</i>.grd)</b></p>
<p><b>Processor Family</b></p>
<p>68</p>
<p>680x0/683xx/ColdFire</p>
<p>arc</p>
<p>ARC</p>
<p>arm</p>
<p>ARM/Thumb</p>
<p>bf</p>
<p>Blackfin</p>
<p>fp</p>
<p>FirePath</p>
<p>fr20</p>
<p>FR</p>
<p>lexra</p>
<p>Lexra</p>
<p>mc</p>
<p>M-CORE</p>
<p>mips</p>
<p>MIPS/MIPS 16</p>
<p>ncp</p>
<p>nCPU</p>
<p>ndr</p>
<p>NDR</p>
<p>ppc</p>
<p>Power Architecture</p>
<p>sc</p>
<p>StarCore</p>
<p>sh</p>
<p>SH</p>
<p>sparc</p>
<p>Sparc</p>
<p>tri</p>
<p>TriCore</p>
<p>810</p>
<p>V81x/V83x</p>
<p>850</p>
<p>V85x</p>
<p>386</p>
<p>x86/Pentium</p>
<p><b>File Locations</b></p>
<p>MULTI searches for the register files listed in âRegister Explorer Startupâ</p>
<p>on page 286, one at a time, in the following five standard directory locations unless</p>
<p>otherwise noted. When MULTI finds one of the register files, it discontinues the</p>
<p>search and uses the located file as the root</p>
<p>GRD</p>
<p>file (see âRegister Explorer Startupâ</p>
<p>on page 286). MULTI searches the directories in the order listed.</p>
<p>1.</p>
<p>The directory containing the program being debugged.</p>
<p>2.</p>
<p>The directory containing the MULTI executable (</p>
<p>multi.exe)</p>
<p>.</p>
<p><i>287</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Customizing Default Register Definition Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>The<b> registers</b> directory located in your personal configuration directory.</p>
<p>4.</p>
<p>The<b> registers</b> directory located in the site-wide configuration directory.</p>
<p>5.</p>
<p>The<b> registers</b> directory located in the Green Hills Compiler<b> defaults</b> directory.</p>
<p>For information about configuration directories, see Chapter 7, âConfiguring and</p>
<p>Customizing MULTIâ in the<i> MULTI: Managing Projects and Configuring the IDE</i></p>
<p>book.</p>
<p><b>Note</b></p>
<p>MULTI does not search for<i><b> prog</i>.grd</b> in the<b> registers</b> directories.</p>
<p><b>Tip</b></p>
<p>If the root</p>
<p>GRD</p>
<p>file contains non-absolute include directives, MULTI</p>
<p>attempts to resolve the locations of the directives by searching the</p>
<p>directory where the root</p>
<p>GRD</p>
<p>file is located. If you defined the root</p>
<p>GRD</p>
<p>file and you want to include the Compiler installation's<i><b> cpu</i>.grd</b> file in</p>
<p>it, you can use the variable</p>
<p>${__TOOLS_DEFAULTS_DIR__}</p>
<p>when</p>
<p>specifying the path to<i><b> cpu</i>.grd</b>. For example, for a Power Architecture</p>
<p>target, you could specify:</p>
<p>%include &quot;${__TOOLS_DEFAULTS_DIR__}/registers/ppc.grd&quot;</p>
<p><b>Overloading Default Register Descriptions</b></p>
<p>You should usually keep your customized register definitions in the default<b> .rc</b> file</p>
<p>for your program. If you overload one of the default files, be careful. If you do not</p>
<p>include the appropriate default register definition file for your target, you may not</p>
<p>be able to access any standard registers.</p>
<p>Setting Defaults for an Individual Program</p>
<p>You can add custom register definitions for an individual program by using a register</p>
<p>definition file named after your program. Suppose you have a program</p>
<p><i>prog</i></p>
<p>that</p>
<p>is compiled for a Power Architecture target. You should add custom register</p>
<p>definitions into a<i><b> prog</i>.grd</b> register definition file in your configuration directory.</p>
<p>This file's contents should be of the following form in</p>
<p>GRD</p>
<p>format.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>288</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p># foo.grd</p>
<p>#</p>
<p># ... description of this file ...</p>
<p># Include standard Power Architecture register definitions</p>
<p>%include &quot;${__TOOLS_DEFAULTS_DIR__}/registers/ppc.grd&quot;</p>
<p>#</p>
<p># add custom register descriptions here</p>
<p>#</p>
<p>Whenever you debug a program</p>
<p><i>prog</i></p>
<p>, MULTI will find<i><b> prog</i>.grd</b> first and load it,</p>
<p>applying the standard Power Architecture register definitions from<b> ppc.grd</b> and</p>
<p>then the custom register definitions.</p>
<p><b>Note</b></p>
<p>Be sure you insert an appropriate</p>
<p>%include</p>
<p>for the target on which your</p>
<p>process is running. Otherwise you may be unable to view the standard</p>
<p>registers on your target.</p>
<p>Setting Defaults for Multiple Programs</p>
<p>You can provide custom register definitions that are applied whenever you debug</p>
<p>any program compiled for a specific target. These universal modifications are useful</p>
<p>for defining things like custom register groups that you always use. Changes that</p>
<p>you put in one of the default register definition files for a particular target are applied</p>
<p>when you debug any program compiled for that target.</p>
<p>To apply custom register definitions to all programs compiled for a specific target,</p>
<p>follow these steps:</p>
<p>1.</p>
<p>In your local configuration directory, create a directory named<b> registers</b> if it</p>
<p>does not already exist. Your local configuration directory is:</p>
<p>â¢</p>
<p>Windows 7/Vista â<i><b> user_dir</i>\AppData\Roaming\GHS\</b></p>
<p>â¢</p>
<p>Windows XP â<i><b> user_dir</i>\Application Data\GHS\</b></p>
<p>â¢</p>
<p>Linux/Solaris â<i><b> user_dir</i>/.ghs/</b></p>
<p><i>289</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Customizing Default Register Definition Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>2.</p>
<p>In the<b> registers</b> directory, create a file with the name<i><b> cpu</i>.grd</b>, where</p>
<p><i>cpu</i></p>
<p>is</p>
<p>the acronym for your processor family (for example,<b> ppc.grd</b>). For a list of</p>
<p>possible</p>
<p><i>cpu</i></p>
<p>values, see the table in âRegister Explorer Startupâ on page 286.</p>
<p>3.</p>
<p>Use a text editor (such as the MULTI Editor) to edit the new<i><b> cpu</i>.grd</b> file:</p>
<p>a.</p>
<p>To include MULTI's default register definition file, add:</p>
<p>%include &quot;${__TOOLS_DEFAULTS_DIR__}/registers/<i>cpu</i>.grd&quot;</p>
<p>to the top of the file.</p>
<p><i>cpu</i></p>
<p>is the acronym for your processor family. If</p>
<p>you do not insert this</p>
<p>%include</p>
<p>directive, you may be unable to view</p>
<p>the standard registers on your target.</p>
<p>b.</p>
<p>Add your custom register definitions to the end of the file. For example:</p>
<p># include my custom defintions</p>
<p>%include &quot;my_regs.grd&quot;</p>
<p><i>MULTI: Debugging</i></p>
<p><i>290</i></p>
<p><i>Chapter 13. Using the Register Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 14</b></p>
<p><b>Using Expressions,</b></p>
<p><b>Variables, and Procedure</b></p>
<p><b>Calls</b></p>
<p><b>Contents</b></p>
<p>Evaluating Expressions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>292</p>
<p>Viewing Variables . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>297</p>
<p>Variable Lifetimes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>299</p>
<p>Examining Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>300</p>
<p>Wildcards . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>303</p>
<p>Procedure Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>304</p>
<p>Macros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>307</p>
<p>MULTI Special Variables and Operators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>309</p>
<p>Syntax Checking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>320</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes how you can type expressions into the Debugger command</p>
<p>pane to examine and perform calculations with the values of variables in your</p>
<p>program. It also describes how you can use MULTI variables to examine and modify</p>
<p>the behavior of the Debugger.</p>
<p><b>Evaluating Expressions</b></p>
<p>To evaluate an expression, enter it into the Debugger's command pane. Expressions</p>
<p>may contain:</p>
<p>â¢</p>
<p>Symbols (for example, you can refer to variables in your program)</p>
<p>â¢</p>
<p>Numerical constants</p>
<p>â¢</p>
<p>String constants, which can contain the standard C language character escapes</p>
<p>â¢</p>
<p>Math and assignment (for example, you can add values together and assign</p>
<p>values to variables in your program)</p>
<p>â¢</p>
<p>Procedure calls</p>
<p>â¢</p>
<p>Macros</p>
<p>The Debugger calculates the value of the expression and displays it. If you want to</p>
<p>watch the value of an expression and have it reevaluated as you step through your</p>
<p>program, you should use a Data Explorer. See âThe Data Explorer Windowâ</p>
<p>on page 185.</p>
<p><b>Expression Scope</b></p>
<p>Expressions are evaluated in a specific context, which affects what variables can</p>
<p>be meaningfully used in an expression. MULTI determines the scope of an</p>
<p>expression based on the position of the blue current line pointer (</p>
<p>) and the scope</p>
<p>rules of the language in use.</p>
<p>For example, suppose you are stopped inside the function</p>
<p>main()</p>
<p>:</p>
<p>int main() {</p>
<p>int foo = 3;</p>
<p>printf(&quot;Hello World! foo = %d&quot;, foo);</p>
<p>return foo;</p>
<p>}</p>
<p><i>MULTI: Debugging</i></p>
<p><i>292</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If the current line pointer is located on a line above the function</p>
<p>main()</p>
<p>(that is,</p>
<p>out of its scope), and you enter the following expression in the command pane:</p>
<p>&gt; print foo</p>
<p>MULTI prints the output:</p>
<p>Unknown name &quot;foo&quot; in expression.</p>
<p>However, if the current line pointer is located inside the function</p>
<p>main()</p>
<p>, the same</p>
<p>input:</p>
<p>&gt; print foo</p>
<p>outputs:</p>
<p>foo = 3</p>
<p>For information about variable lifetimes, see âVariable Lifetimesâ on page 299.</p>
<p><b>Expressing Source Addresses</b></p>
<p>In any expression, you may want to include the address associated with a particular</p>
<p>source location. MULTI accepts any of the following methods of expressing source</p>
<p>addresses:</p>
<p>#<i>line</i></p>
<p>Address of the code at line number</p>
<p><i>line</i></p>
<p>in the current file.</p>
<p>(&quot;<b>foo.c</b>&quot; #<i> proc</i> #<i> line</i>)</p>
<p>Address of line</p>
<p><i>line</i></p>
<p>for procedure</p>
<p><i>proc</i></p>
<p>in file<b> foo.c</b>.</p>
<p><i>proc</i> #<i> line</i></p>
<p>Address of line</p>
<p><i>line</i></p>
<p>for procedure</p>
<p><i>proc</i></p>
<p>.</p>
<p>(</p>
<p>&quot;<b>foo.c</b>&quot; #<i> proc</i> ##<i> label</i>)</p>
<p>Address of label</p>
<p><i>label</i></p>
<p>for procedure</p>
<p><i>proc</i></p>
<p>in file<b> foo.c</b>.</p>
<p><i>proc</i> ##<i> label</i></p>
<p>Address of label</p>
<p><i>label</i></p>
<p>for procedure</p>
<p><i>proc</i></p>
<p>.</p>
<p><i>293</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Expressing Source Addresses</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Language-Independent Expressions</b></p>
<p>The Debugger always follows the operator definitions for the current language. For</p>
<p>example, in C, the assignment operator is one equal sign (</p>
<p>=</p>
<p>) and the equality</p>
<p>comparison is two equal signs (</p>
<p>==</p>
<p>). On the other hand, in some languages, (Ada,</p>
<p>for example) colon equal (</p>
<p>:=</p>
<p>) is the assignment operator, and one equal sign (</p>
<p>=</p>
<p>) is</p>
<p>the equality comparison. This can make definition of language-independent</p>
<p>expressions difficult. To overcome this problem, the Debugger always recognizes</p>
<p>colon equal (</p>
<p>:=</p>
<p>) as the assignment operator (in addition to the correct operator in</p>
<p>the current language) and two equal signs (</p>
<p>==</p>
<p>) as the comparison operator. To</p>
<p>ensure that expressions are language-independent, these operators should be used</p>
<p>to implement features or capabilities (such as button definitions) that may remain</p>
<p>in operation over several source languages.</p>
<p>If you are debugging multiple-language applications, use syntax appropriate to the</p>
<p>language of the source file currently displayed in the Debugger.</p>
<p><b>Language Keywords</b></p>
<p>When the Debugger evaluates expressions, it understands the following keywords</p>
<p>for the current source language.</p>
<p><b>Keywords</b></p>
<p><b>Language</b></p>
<p>char</p>
<p>,</p>
<p>const</p>
<p>,</p>
<p>double</p>
<p>,</p>
<p>enum</p>
<p>,</p>
<p>float</p>
<p>,</p>
<p>int</p>
<p>,</p>
<p>long</p>
<p>,</p>
<p>long long</p>
<p>,</p>
<p>q15</p>
<p>,</p>
<p>q31</p>
<p>,</p>
<p>short</p>
<p>,</p>
<p>signed</p>
<p>,</p>
<p>sizeof</p>
<p>,</p>
<p>struct</p>
<p>,</p>
<p>union</p>
<p>,</p>
<p>unsigned</p>
<p>,</p>
<p>void</p>
<p>,</p>
<p>volatile</p>
<p>,</p>
<p>__accum</p>
<p>,</p>
<p>__bigendian</p>
<p>,</p>
<p>__bytereversed</p>
<p>,</p>
<p>__fixed</p>
<p>,</p>
<p>__littleendian</p>
<p>C</p>
<p>(All C Keywords),</p>
<p>class</p>
<p>,</p>
<p>namespace</p>
<p>,</p>
<p>bool</p>
<p>C++</p>
<p><b>Caveats for Expressions</b></p>
<p>Consider the following when constructing expressions:</p>
<p>â¢</p>
<p>If the expression begins the same way as a Debugger command or begins with</p>
<p>a number, put the expression in parentheses<b> ()</b> or explicitly use the<b> print</b> or</p>
<p><b>call</b> command to distinguish it from the Debugger command. For example, to</p>
<p>look at the value of the variable</p>
<p>c</p>
<p>, enter</p>
<p>(c)</p>
<p>or</p>
<p>print c</p>
<p>. To call a procedure</p>
<p>named</p>
<p>c()</p>
<p>, enter</p>
<p>call c()</p>
<p>. If you just enter</p>
<p>c</p>
<p>, the Debugger will execute</p>
<p>the<b> c</b> (continue) command. For information about the<b> print</b> command, see</p>
<p><i>MULTI: Debugging</i></p>
<p><i>294</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Chapter 8, âDisplay and Print Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book. For information about the<b> call</b> command, see</p>
<p>Chapter 2, âGeneral Debugger Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>â¢</p>
<p>If a filename such as<b> class.cc</b> or<b> namespace.cc</b> is the same as a language</p>
<p>keyword and is used in an expression or command, you must enclose the</p>
<p>filename in quotation marks. For example, the<b> e foo.cc#2</b> command executes</p>
<p>successfully but the<b> e class.cc#2</b> command does not. The second command</p>
<p>must be<b> e &quot;class.cc&quot;#2</b>.</p>
<p>â¢</p>
<p>Use</p>
<p>\</p>
<p>followed by<b> Enter</b> to span multiple lines.</p>
<p>â¢</p>
<p>Comments begin with</p>
<p>/*</p>
<p>(forward slash + asterisk) and end with either a new</p>
<p>line or</p>
<p>*/</p>
<p>(asterisk + forward slash).</p>
<p>â¢</p>
<p>C++ style (</p>
<p>//</p>
<p>) end-of-line comments are also supported.</p>
<p>â¢</p>
<p>If the process has not been started, the expression may only contain constants</p>
<p>(global addresses may be considered constants, depending on your system).</p>
<p>After the process has started, the expression may also contain in-scope variables</p>
<p>and procedure calls.</p>
<p>â¢</p>
<p>If the process is running, the expression may only contain constants and, if the</p>
<p>system allows, global and static variables and their addresses.</p>
<p>â¢</p>
<p>If the process has not been started and was linked against shared objects,</p>
<p>expressions referring to procedures and variables located within these shared</p>
<p>objects may not be allowed.</p>
<p>â¢</p>
<p>There are restrictions on procedure calls and overloaded operator calls. For</p>
<p>more information, see âProcedure Callsâ on page 304.</p>
<p>â¢</p>
<p>The MULTI Debugger allows you to run, halt, step and set breakpoints in C99</p>
<p>programs just as in regular C programs. However, the MULTI expression</p>
<p>evaluator generally follows C89 rules, not C99 rules. Specifically, expressions</p>
<p>whose meaning depends on any of the following are not guaranteed to be</p>
<p>evaluated correctly by MULTI:</p>
<p>â</p>
<p>C99 complex types</p>
<p>â</p>
<p>C99 imaginary types</p>
<p>â</p>
<p>C99</p>
<p>NAN</p>
<p>and</p>
<p>INFINITY</p>
<p>constants</p>
<p>â</p>
<p>Differences in the types of integer literals in C99</p>
<p><i>295</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Caveats for Expressions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>MULTI may not be able to parse C++ expressions (such as casts) involving</p>
<p>types that contain non-type template parameters.</p>
<p>â¢</p>
<p>In C++, template types with multiple adjacent right angle brackets (</p>
<p>&gt;</p>
<p>) may</p>
<p>appear without intervening spaces, contrary to the C++ standard.</p>
<p>â¢</p>
<p>C++ templated functions are not supported.</p>
<p>â¢</p>
<p>In C++, the</p>
<p>.*</p>
<p>and</p>
<p>-&gt;*</p>
<p>pointer-to-member operators and values of</p>
<p>pointer-to-member types are not supported.</p>
<p>â¢</p>
<p>In C++, casts to reference types are not supported.</p>
<p>â¢</p>
<p>In C++, the Debugger never calls destructors while evaluating an expression.</p>
<p>â¢</p>
<p>In C++, you must include the</p>
<p>enum</p>
<p>,</p>
<p>struct</p>
<p>, or</p>
<p>union</p>
<p>keyword when referring</p>
<p>to an enumeration, structure, or union.</p>
<p>â¢</p>
<p>In C++, expressions containing fully qualified function names are treated as</p>
<p>command line procedure calls (with one exception*). To work around this</p>
<p>behavior, leave off the types when specifying function names. If more than</p>
<p>one function with the given name existsâfor example,</p>
<p>foo(int)</p>
<p>and</p>
<p>foo(char)</p>
<p>âa Browse window prompts you to pick one.</p>
<p>*Expressions containing fully qualified names are treated as expressions when</p>
<p>used in conjunction with MULTI's<b> e</b> or<b> examine</b> command. For information</p>
<p>about the<b> e</b> command, see Chapter 11, âNavigation Command Referenceâ in</p>
<p>the<i> MULTI: Debugging Command Reference</i> book. For information about the</p>
<p><b>examine</b> command, see Chapter 8, âDisplay and Print Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>In C++, referring directly to the name of an overloaded operator function is</p>
<p>legal only within address expressions. See âUsing Address Expressions in</p>
<p>Debugger Commandsâ in Chapter 1, âUsing Debugger Commandsâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>In C++, an expression involving an overloaded operator may not call the correct</p>
<p>operator function if the operator function is a virtual method overridden by a</p>
<p>derived class.</p>
<p>â¢</p>
<p>In C++, methods overridden via virtual inheritance may be resolved incorrectly</p>
<p>when called from the command line. This usually results in your being offered</p>
<p>the choice to call either a base-class method or a derived-class method, when</p>
<p>only the derived-class method is actually applicable.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>296</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Support for AltiVec vector data types is limited:</p>
<p>â</p>
<p>You cannot perform math operations on them.</p>
<p>â</p>
<p>You cannot cast them to or from non-vector types. You can, however,</p>
<p>convert pointers to them. For example, you can convert</p>
<p>void *</p>
<p>to</p>
<p>vector</p>
<p>float *</p>
<p>.</p>
<p>â</p>
<p>Vector assignment is supported, but direct numerical assignment is not.</p>
<p>For example:</p>
<p>vector unsigned int vector1;</p>
<p>vector unsigned int vector2;</p>
<p>vector1 = vector2; /* This will work in an expression. */</p>
<p>vector1 = {1,2,3,4}; /* This will not work. */</p>
<p>â¢</p>
<p>Expressions involving values of function pointer type are not supported on</p>
<p>targets such as 64-bit Power Architecture where the ABI requires the use of</p>
<p>function descriptors. The Debugger will attempt to detect and reject attempts</p>
<p>to write a value of function pointer type to a target variable on these targets.</p>
<p>â¢</p>
<p>Compiler intrinsics are not supported.</p>
<p>â¢</p>
<p>Expressions involving the</p>
<p>long double</p>
<p>floating-point type may lose precision</p>
<p>or otherwise yield incorrect values.</p>
<p>â¢</p>
<p>Classes defined inside functions cannot be referenced in expressions.</p>
<p>â¢</p>
<p>GNU built-in functions are not supported.</p>
<p>â¢</p>
<p>Input of integer constants wider than 64 bits is not supported. Most mathematical</p>
<p>and logical operators are not supported on values wider than 64 bits.</p>
<p><b>Viewing Variables</b></p>
<p>There are several different methods for viewing the value of a variable, including</p>
<p>the following:</p>
<p>â¢</p>
<p>Click the variable in the source pane to see information about the variable in</p>
<p>the command pane. For more information, see âViewing Information in the</p>
<p>Command Paneâ on page 172.</p>
<p>â¢</p>
<p>Double-click the variable in the source pane.</p>
<p><i>297</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Variables</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Use the<b> print</b> command or the<b> examine</b> command. For information about these</p>
<p>commands, see Chapter 8, âDisplay and Print Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>Enter the variable name in the command pane.</p>
<p>â¢</p>
<p>Right-click the variable and select<b> View Value</b>.</p>
<p>You can use any of the formats listed in the following table to unambiguously refer</p>
<p>to a specific variable. Note that an arbitrary variable called</p>
<p>fly</p>
<p>is used in these</p>
<p>examples. Spaces before and after the</p>
<p>#</p>
<p>symbol are optional, but the pair of straight</p>
<p>double quotes (</p>
<p>&quot;&quot;</p>
<p>) around a filename is required. Local variables need to be either</p>
<p>static or within a procedure on the stack.</p>
<p>fly</p>
<p>Performs a scope search for the variable</p>
<p>fly</p>
<p>, starting at the blue arrow and proceeding outward.</p>
<p>Local variables, local static variables, and parameters are checked first, then file static variables,</p>
<p>global variables, and special variables.</p>
<p>$fly</p>
<p>Searches the list of special variables for</p>
<p>fly</p>
<p>. See âMULTI Special Variables and Operatorsâ</p>
<p>on page 309.</p>
<p>:fly</p>
<p>::fly</p>
<p>Searches for a global variable named</p>
<p>fly</p>
<p>.</p>
<p>(<i>stack_depth</i> # fly)</p>
<p>(<i>stack_depth</i> ## fly)</p>
<p>Uses the</p>
<p><i>stack_depth</i></p>
<p>procedure on the call stack for the scope search. This is useful if you</p>
<p>are debugging a recursive procedure and multiple instances are on the stack. You can then pick</p>
<p>the instance and display the value of the variable for that instance. The procedure currently</p>
<p>containing the program counter is at stack depth 0 (zero). See the<b> e</b> command in Chapter 11,</p>
<p>âNavigation Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Parentheses are required for these cases.</p>
<p>(<i>stack_depth</i> ##<i> label</i> # fly)</p>
<p>Local variable</p>
<p>fly</p>
<p>in the lexical block at label</p>
<p><i>label</i></p>
<p>in procedure at stack depth</p>
<p><i>stack_depth</i></p>
<p>.</p>
<p>Parentheses are required for this case.</p>
<p>(&quot;<i><b>foo.c</b></i>&quot; #<i> proc</i> ##<i> label</i> # fly)</p>
<p>Local variable</p>
<p>fly</p>
<p>in the lexical block at label</p>
<p><i>label</i></p>
<p>in procedure</p>
<p><i>proc</i></p>
<p>in file</p>
<p><i>foo.c</i></p>
<p>.</p>
<p>Parentheses are required for this case.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>298</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p><i>proc</i> ##<i> label</i> # fly</p>
<p>Local variable</p>
<p>fly</p>
<p>for block at label</p>
<p><i>label</i></p>
<p>in procedure</p>
<p><i>proc</i></p>
<p>.</p>
<p>(&quot;<i><b>foo.c</b></i>&quot; #<i> proc</i> # fly)</p>
<p>Local variable</p>
<p>fly</p>
<p>for procedure</p>
<p><i>proc</i></p>
<p>in file</p>
<p><i>foo.c</i></p>
<p>. Parentheses are required for this case.</p>
<p><i>proc</i> # fly</p>
<p>Local variable</p>
<p>fly</p>
<p>for procedure</p>
<p><i>proc</i></p>
<p>.</p>
<p>(&quot;<i><b>foo.c</b></i>&quot; # fly)</p>
<p>Static variable</p>
<p>fly</p>
<p>in file</p>
<p><i>foo.c</i></p>
<p>. Parentheses are required for this case.</p>
<p>.</p>
<p>(This designator is a period.)</p>
<p>Represents the result of the latest expression.</p>
<p><b>Variable Lifetimes</b></p>
<p>The Green Hills compilers augment the location description (such as register number,</p>
<p>stack offset, memory location) for user variables with lifetime information, which</p>
<p>indicates when the value at the given location is valid.</p>
<p>When you use Debugger commands (for example,<b> print</b> or<b> view</b>) or Data Explorers</p>
<p>to evaluate expressions, the messages listed in the following table may appear next</p>
<p>to the value of the expression.</p>
<p>Dead</p>
<p>The value displayed may be invalid because the location used to store the value of this variable</p>
<p>may have been reused by the compiler to store the value of a temporary (or another) variable.</p>
<p>Not Initialized</p>
<p>The value displayed may represent an uninitialized value.</p>
<p>Optimized Away</p>
<p>The variable was optimized away by the compiler and does not have any storage. No value will</p>
<p>be displayed in conjunction with this message.</p>
<p>Part of Expression Dead</p>
<p>One or more of the values used in the displayed expression may be invalid. See above for more</p>
<p>on what this means.</p>
<p>Part of Expression Not Initialized</p>
<p>One or more of the values used in the displayed expression may be uninitialized. See above for</p>
<p>more on what this means.</p>
<p><i>299</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Variable Lifetimes</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For information about expression scope, see âExpression Scopeâ on page 292.</p>
<p><b>Examining Data</b></p>
<p>The following sections describe commands and shortcuts for examining data. In</p>
<p>the Debugger source pane, you can examine most items by double-clicking them.</p>
<p>See âThe Data Explorer Windowâ on page 185.</p>
<p><b>Variables</b></p>
<p>Variable names are represented exactly the same way they are named in the program.</p>
<p>The case sensitivity of the current source language is used.</p>
<p>To display the value of a variable in the Debugger command pane, do one of the</p>
<p>following:</p>
<p>â¢</p>
<p>Click the variable name in the source pane.</p>
<p>â¢</p>
<p>Enter the variable name in the Debugger command pane. If the variable has</p>
<p>the same name as a MULTI command, preface the variable with the<b> print</b></p>
<p>command (for example,</p>
<p>print e</p>
<p>) or enclose the variable in a pair of</p>
<p>parentheses (for example,</p>
<p>(e)</p>
<p>). For information about the<b> print</b> command,</p>
<p>see Chapter 8, âDisplay and Print Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Expression Formats</b></p>
<p>You can use an expression format to specify the output format of some commands.</p>
<p>An example expression format follows:</p>
<p><b>print</b> [/<i>format</i>]<i> expr</i></p>
<p>An expression format is of the form:</p>
<p>[<i>count</i>][<i>style</i>[<i>size</i>]]</p>
<p>where</p>
<p><i>count</i></p>
<p>is the number of times to apply the format style</p>
<p><i>style</i></p>
<p>, and</p>
<p><i>size</i></p>
<p>is</p>
<p>the number of bytes to format. For example,</p>
<p>print /4d2 fly</p>
<p>prints, starting at</p>
<p><i>MULTI: Debugging</i></p>
<p><i>300</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>fly</p>
<p>, four 2-byte numbers in decimal. If not specified,</p>
<p><i>count</i></p>
<p>defaults to one, and</p>
<p><i>size</i></p>
<p>defaults to the size of the type printed.</p>
<p>In addition to a number,</p>
<p><i>size</i></p>
<p>can be specified as one of the following values:</p>
<p>â¢</p>
<p>b</p>
<p>â One byte (usually a character)</p>
<p>â¢</p>
<p>s</p>
<p>â Two bytes (usually a short)</p>
<p>â¢</p>
<p>l</p>
<p>(lowercase</p>
<p>L</p>
<p>) â Four bytes (usually an int)</p>
<p>These are appended to</p>
<p><i>style</i></p>
<p>. For example,</p>
<p>print /xb fly</p>
<p>prints a single</p>
<p>character-sized hex value. Whenever a format contains a preset size (that is,</p>
<p>character-sized in the case of</p>
<p>/b</p>
<p>, or int-sized in the case of</p>
<p>/O</p>
<p>), the size is dictated</p>
<p>by the target (for example, a target-sized character).</p>
<p><b>Note</b></p>
<p>Size specifiers override any preset size from a format. For example,</p>
<p>print /Ob fly</p>
<p>prints a byte-sized octal, not an int-sized octal.</p>
<p>The following table lists the options for</p>
<p><i>style</i></p>
<p>.</p>
<p><b>Effect</b></p>
<p><b>Value</b></p>
<p>Prints the string</p>
<p><i>expr</i></p>
<p>as a string. By default, this prints to the first null character,</p>
<p>but you can use the</p>
<p><i>size</i></p>
<p>value to force the printing of a given number of bytes,</p>
<p>regardless of the occurrence of null characters. Note that</p>
<p><i>expr</i></p>
<p>should actually</p>
<p>be a string; if it is a pointer to a string, you should use the</p>
<p>s</p>
<p>format style (see</p>
<p>below).</p>
<p>Same as</p>
<p>print /s &amp;expr</p>
<p>.</p>
<p>a</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>as an address, using the size of an address as its preset size.</p>
<p>A</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>in decimal as the target's default character size.</p>
<p>b</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>in binary.</p>
<p>B</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>as an ASCII character.</p>
<p>c</p>
<p>C</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>in decimal. If capitalized,</p>
<p><i>expr</i></p>
<p>is printed as an int-sized value.</p>
<p>d</p>
<p>D</p>
<p>Converts</p>
<p><i>expr</i></p>
<p>to the style</p>
<p>[-]<i>d.ddd</i>e+<i>dd</i></p>
<p>, where there is one digit before the</p>
<p>radix character and the number of digits after it is equal to the precision</p>
<p>specification given for</p>
<p><i>size</i></p>
<p>. If</p>
<p><i>size</i></p>
<p>is not present, then the size of a double on</p>
<p>the current target is used.</p>
<p>e</p>
<p>E</p>
<p><i>301</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Expression Formats</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Value</b></p>
<p>Converts</p>
<p><i>expr</i></p>
<p>to the decimal notation in the style</p>
<p>[-]<i>ddd</i>.<i>ddd</i></p>
<p>, where the</p>
<p>number of digits after the radix character is equal to the precision specification</p>
<p>given for</p>
<p><i>size</i></p>
<p>. If</p>
<p><i>size</i></p>
<p>is not present, then the size of a double on the current</p>
<p>target is used. If</p>
<p><i>size</i></p>
<p>is explicitly zero, then no digits or radix characters are</p>
<p>printed.</p>
<p>f</p>
<p>F</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>in style</p>
<p>f</p>
<p>or</p>
<p>e</p>
<p>. The style chosen depends on the converted value.</p>
<p>Style</p>
<p>e</p>
<p>is used only if the exponent resulting from the conversion is less than -4</p>
<p>or greater than the precision given by</p>
<p><i>size</i></p>
<p>. Trailing zeros are removed from the</p>
<p>result. A radix character appears only if followed by a digit. This is the default</p>
<p>for floats and doubles. If</p>
<p><i>size</i></p>
<p>is not present, then the size of a double on the</p>
<p>current target is used.</p>
<p>g</p>
<p>G</p>
<p>Using the</p>
<p><i>expr</i></p>
<p>as an address, disassembles a machine instruction.</p>
<p>i</p>
<p>(Uppercase</p>
<p>i</p>
<p>) Using the</p>
<p><i>expr</i></p>
<p>as an address, disassembles a machine instruction.</p>
<p>If the address maps evenly to a line number in the source, it prints the source line</p>
<p>first. This allows you to see what the compiler generated for a line of source.</p>
<p>Using the mixed source/assembly mode in the source pane is an easier way to</p>
<p>view the same information.</p>
<p>I</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>using the ânormalâ format based on its type. If no format is specified,</p>
<p>this is the default. If capitalized,</p>
<p><i>expr</i></p>
<p>is not dereferenced; otherwise, structures</p>
<p>and pointers are dereferenced.</p>
<p>n</p>
<p>N</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>in octal. If capitalized,</p>
<p><i>expr</i></p>
<p>is printed as an int-sized value.</p>
<p>o</p>
<p>O</p>
<p>(Lowercase</p>
<p>p</p>
<p>) Prints the name of the procedure containing address</p>
<p><i>expr</i></p>
<p>, along</p>
<p>with the filename and the source line or instruction that addresses maps. If</p>
<p><i>size</i></p>
<p>is</p>
<p>1</p>
<p>or</p>
<p>b</p>
<p>, only the procedure name will be printed. If</p>
<p><i>size</i></p>
<p>is</p>
<p>2</p>
<p>or</p>
<p>s</p>
<p>, only the</p>
<p>filename and procedure name will be printed.</p>
<p>p</p>
<p>(Uppercase</p>
<p>p</p>
<p>) Prints the name and signature of the procedure containing address</p>
<p><i>expr</i></p>
<p>.</p>
<p>P</p>
<p>Prints the floating point number that has the same bit representation as the binary</p>
<p>number given by</p>
<p><i>expr</i></p>
<p>. For example:</p>
<p>&gt; print /q 0x3ff199999999999a</p>
<p>1.100000</p>
<p>If</p>
<p><i>expr</i></p>
<p>is larger than 4 bytes in size, a double is printed instead.</p>
<p>See also</p>
<p>x</p>
<p>below.</p>
<p>q</p>
<p>Prints the bounds of a ranged type or variable of a ranged type, such as a C bitfield.</p>
<p>r</p>
<p>Prints a string using</p>
<p><i>expr</i></p>
<p>as a pointer to the beginning of the string. Same as</p>
<p>print /a *<i>expr</i></p>
<p>.</p>
<p>s</p>
<p><i>MULTI: Debugging</i></p>
<p><i>302</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Value</b></p>
<p>Prints a formatted dump of a structure. This is the default for items of type struct.</p>
<p>S</p>
<p>Prints the type of variable or procedure.</p>
<p>t</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>in unsigned decimal. If capitalized,</p>
<p><i>expr</i></p>
<p>is printed as an int-sized</p>
<p>value.</p>
<p>u</p>
<p>U</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>using the ânormalâ format based on its type. This is identical to</p>
<p>n</p>
<p>.</p>
<p>v</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>in hexadecimal. If capitalized,</p>
<p><i>expr</i></p>
<p>is printed as an int-sized value.</p>
<p>If</p>
<p><i>expr</i></p>
<p>is a floating point number, prints the binary number that has the same</p>
<p>bit representation as the floating point number given by</p>
<p><i>expr</i></p>
<p>. For example:</p>
<p>&gt; print /x 1.1</p>
<p>0x3ff19999_9999999a</p>
<p>See also</p>
<p>q</p>
<p>above.</p>
<p>x</p>
<p>X</p>
<p>Prints</p>
<p><i>expr</i></p>
<p>as a set.</p>
<p>z</p>
<p><b>Note</b></p>
<p>For more information about expression formats and the various commands</p>
<p>that use them to display data or expressions, see the commands<b> print</b>,</p>
<p><b>examine</b>, and<b> eval</b> in Chapter 8, âDisplay and Print Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Language Dependencies</b></p>
<p>In C++, when the Debugger displays a class, it also displays the fields of all the</p>
<p>parents of that class, including virtual parents, if that information is available. Static</p>
<p>fields associated with a class are also displayed. Additionally, fields of the class or</p>
<p>its parents that are stored by reference will be displayed as an address preceded by</p>
<p>an at sign (</p>
<p>@</p>
<p>).</p>
<p><b>Wildcards</b></p>
<p>In some contexts, the Debugger supports the use of wildcards in procedure and file</p>
<p>names (for example, with the<b> e</b> command and in the File Locator and Procedure</p>
<p>Locator). A question mark (</p>
<p>?</p>
<p>) matches any single letter, while an asterisk (</p>
<p>*</p>
<p>) or an</p>
<p>at sign (</p>
<p>@</p>
<p>) matches any number of letters. For example, the sequence</p>
<p>??*</p>
<p>matches</p>
<p>all names that are at least two characters long.</p>
<p><i>303</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Language Dependencies</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The following table lists several different formats for referring to procedures in</p>
<p>C++. Text you substitute for the replaceable words (italicized) may contain</p>
<p>wildcards.</p>
<p><i>class</i>::<i>func</i></p>
<p>Matches all members whose names match</p>
<p><i>func</i></p>
<p>of all classes whose names match</p>
<p><i>class</i></p>
<p>,</p>
<p>regardless of their arguments.</p>
<p>::<i>func</i></p>
<p>Matches all global or static functions whose names match</p>
<p><i>func</i></p>
<p>. Argument types may be supplied</p>
<p>to restrict the match.</p>
<p><i>func</i></p>
<p>Matches all functions, whether class members or not, whose names match</p>
<p><i>func</i></p>
<p>.</p>
<p><b>Procedure Calls</b></p>
<p>Making procedure calls from the Debugger command pane requires your program</p>
<p>to be linked with<b> libmulti.a</b>, a library supplied by Green Hills. For more information,</p>
<p>see the documentation about enabling command line procedure calls in the<i> MULTI:</i></p>
<p><i>Building Applications</i> book.</p>
<p>Expressions may contain procedure calls. For example:</p>
<p>fly = AddArgs(1, 2) * 3;</p>
<p>In C++, overloaded operators may be called provided that they are not inlined and</p>
<p>that the left side of the expression is not contained completely within a register.</p>
<p>Thus, the following expression:</p>
<p>complex(1,2) + complex(2,3)</p>
<p>is converted into the appropriate procedure calls. Constructors are called when</p>
<p>appropriate, again provided that they are not inlined.</p>
<p>However, if</p>
<p>fly</p>
<p>were a small struct contained entirely within a register, the</p>
<p>following expression:</p>
<p>fly += bee;</p>
<p>would fail.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>304</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>You can make a command line procedure call to any non-inlined procedure in the</p>
<p>program being debugged. For example, assume that the procedure</p>
<p>printf()</p>
<p>is</p>
<p>referenced in the program, and thus the code for it is on the target. In this case you</p>
<p>may enter:</p>
<p>printf(&quot;Hello, %s!\n&quot;, &quot;world&quot;)</p>
<p>If the name of the procedure you are trying to call is the same as that of a MULTI</p>
<p>command, the MULTI command is executed instead of the procedure. To specify</p>
<p>that MULTI commands are ignored when you call a procedure from the command</p>
<p>pane, enter the<b> call</b> command before the procedure. For example, suppose you want</p>
<p>to make a command line procedure call to a procedure named</p>
<p>e</p>
<p>that takes an integer.</p>
<p>Enter:</p>
<p>call e(1)</p>
<p>in the command pane. If you enter:</p>
<p>e (1)</p>
<p>MULTI executes the<b> e</b> command instead. For information about the<b> call</b> command,</p>
<p>see Chapter 2, âGeneral Debugger Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>To find out what procedures are available to be called, use one of the following</p>
<p>commands to list the procedures in the program being debugged:</p>
<p>â¢</p>
<p><b>browse procs</b> (see the<b> browse</b> command in âGeneral View Commandsâ in</p>
<p>Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book)</p>
<p>â¢</p>
<p><b>l p *</b> (lowercase</p>
<p>L</p>
<p>, lowercase</p>
<p>p</p>
<p>, asterisk; see the<b> l</b> command in Chapter 8,</p>
<p>âDisplay and Print Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book)</p>
<p><b>Tip</b></p>
<p>To gain access to library routines that are not referenced anywhere in the</p>
<p>program code, and thus are not linked into the program image, add a</p>
<p>dummy reference to the program and recompile.</p>
<p><i>305</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Caveats for Command Line Procedure Calls</b></p>
<p>â¢</p>
<p>Any breakpoints encountered during command line procedure calls are handled</p>
<p>as usual.</p>
<p>â¢</p>
<p>In some cases, interrupts may need to be disabled before command line</p>
<p>procedure calls will work.</p>
<p>â¢</p>
<p>If MULTI detects an executing task, it prevents you from making command</p>
<p>line procedure calls via a freeze-mode connection to an operating system kernel.</p>
<p>You can bypass this restriction if you know it is safe to do so by issuing the</p>
<p>command<b> configure AllowProcCallInOsaTask on</b> (see âOther Debugger</p>
<p>Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ in the<i> MULTI:</i></p>
<p><i>Managing Projects and Configuring the IDE</i> book).</p>
<p>â¢</p>
<p>If function prototype information is available, the Debugger checks the function</p>
<p>prototype and converts each argument expression to the type of the</p>
<p>corresponding argument. If it is not available, automatic promotion of arguments</p>
<p>and detection of invalid arguments are not supported. In this case, you should</p>
<p>ensure that function arguments specified are compatible with the function being</p>
<p>called.</p>
<p>â¢</p>
<p>For calls to procedures written in assembly language, the Debugger cannot</p>
<p>perform argument conversions, check that the types of arguments are correct,</p>
<p>or check that the number of arguments is correct.</p>
<p>â¢</p>
<p>When evaluating an expression, the Debugger may call any compiled function,</p>
<p>with or without arguments, including both application and operating system</p>
<p>functions. However, an OS function on the target system is only called if it is</p>
<p>already linked into your program. You are responsible for linking any system</p>
<p>calls that are called from the command line into the program.</p>
<p>â¢</p>
<p>C++ templated functions are not supported.</p>
<p>â¢</p>
<p>In C++ or any language with inlined procedures, a procedure that is always</p>
<p>inlined (so there is no stand-alone version of the procedure) may not be called.</p>
<p>â¢</p>
<p>In C++, when the expression evaluator is unable to disambiguate overloaded</p>
<p>procedure names, a dialog box prompts you to identify what function to use.</p>
<p>â¢</p>
<p>In C++, default arguments are not inserted.</p>
<p>â¢</p>
<p>In C++, the class member</p>
<p>operator()</p>
<p>, the function call operator, and the</p>
<p>new()</p>
<p>and</p>
<p>delete()</p>
<p>operators are not supported.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>306</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In C++, any procedure or method whose return type has a copy constructor</p>
<p>cannot be called from the command line.</p>
<p>â¢</p>
<p>In C++, any procedure or method that takes a parameter having a type with a</p>
<p>copy constructor cannot be called from the command line.</p>
<p>â¢</p>
<p>If you are using a run-mode debug server such as<b> rtserv</b> or<b> rtserv2</b>, you may</p>
<p>only make command line procedure calls on halted tasks that are actually</p>
<p>runnable (as opposed to halted tasks that were pended before being halted).</p>
<p>MULTI attempts to detect and prevent procedure calls to tasks that appear to</p>
<p>have been halted while performing a system call (tasks are not runnable in this</p>
<p>context). However, MULTI is not always able to detect situations in which it</p>
<p>is unsafe to make command line procedure calls on a given run-mode task that</p>
<p>is halted. If you are debugging an INTEGRITY run-mode target, see âRun-Mode</p>
<p>Debuggingâ in the<i> INTEGRITY Development Guide</i> for more information.</p>
<p>â¢</p>
<p>Command line procedure calls to functions that use the host I/O facilities of</p>
<p>the Debugger to make blocking calls (for example, reading input from the user</p>
<p>via the I/O pane) can cause the Debugger to appear unresponsive. In these</p>
<p>cases, you can hit the<b> Esc</b> key to halt the blocked thread.</p>
<p>â¢</p>
<p>You cannot step or run back into TimeMachine mode while a command line</p>
<p>procedure call is in progress.</p>
<p>â¢</p>
<p>Arguments of function pointer type are not supported on targets such as 64-bit</p>
<p>Power Architecture where the ABI requires the use of function descriptors.</p>
<p>The Debugger will attempt to detect and reject attempts to pass a value of</p>
<p>function pointer type as an argument to a command line procedure call on these</p>
<p>targets.</p>
<p><b>Macros</b></p>
<p>From the command pane, you can evaluate C/C++ macros defined in the program</p>
<p>you are debugging if the macro is used somewhere in the program and if the program</p>
<p>has been compiled with generation of debugging information enabled. See the</p>
<p><i>MULTI: Building Applications</i> book for information about generating debugging</p>
<p>information.</p>
<p>The Debugger treats object-like macros differently than function-like macros.</p>
<p>Examples of both types of macros follow.</p>
<p><i>307</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Macros</i></p>
<h1 style="page-break-before:always; "></h1>
<p>#define OBJ_MACRO 0</p>
<p>is an object-like macro, whereas</p>
<p>#define FUNC_MACRO(x) (x*2)</p>
<p>is a function-like macro.</p>
<p>If an object-like macro and another symbol in your program share the same name,</p>
<p>the symbol takes precedence over the macro if the symbol is local to the current</p>
<p>function or file. If, however, a function-like macro and another symbol in your</p>
<p>program share the same name, the macro always takes precedence over the symbol.</p>
<p>When you evaluate a macro, MULTI expands it regardless of your location in the</p>
<p>program (even if you are currently viewing a file that is out of the scope of the</p>
<p>macro definition). If multiple definitions of a macro exist across the program, the</p>
<p>Debugger uses the definition local to the current file. If the current file does not</p>
<p>contain a definition, MULTI uses a specific definition designated by the debug</p>
<p>information.</p>
<p>The following table lists the most common methods of interaction with macros.</p>
<p><b>Meaning</b></p>
<p><b>Action</b></p>
<p>â¢</p>
<p>Object-like macros: displays the evaluated value of the macro,</p>
<p>whatever that may be. In some instances, this may result in an error</p>
<p>message similar to</p>
<p>Unknown name &quot;<i>foo</i>&quot; in expression</p>
<p>. This</p>
<p>is because the Debugger is evaluating the macro in the current context,</p>
<p>and a variable necessary to completely evaluate it is not defined within</p>
<p>the current scope.</p>
<p>â¢</p>
<p>Function-like macros: displays the definition of the macro.</p>
<p>Click</p>
<p>â¢</p>
<p>Object-like macros: equivalent to a click.</p>
<p>â¢</p>
<p>Function-like macros: displays the evaluated value of the macro, if</p>
<p>the arguments are selected as well. If they are not, this is equivalent</p>
<p>to a click. The caveats that apply to clicking an object-like macro (see</p>
<p>above) apply to clicking and selecting a function-like macro and its</p>
<p>arguments.</p>
<p>Click and Select</p>
<p>Opens a shortcut menu. See âThe C/C++ Macro Shortcut Menuâ</p>
<p>on page 711.</p>
<p>Right-click</p>
<p><i>MULTI: Debugging</i></p>
<p><i>308</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Action</b></p>
<p>Expands the macro with its evaluation in the current scope, as click above</p>
<p>(or click and select for function-like macros) does. Expression evaluation</p>
<p>is aborted entirely if any of the variables used by the macro are not defined</p>
<p>in the current scope.</p>
<p>In a standard</p>
<p>expression (that is,</p>
<p><i>not</i> an address</p>
<p>expression)</p>
<p><b>MULTI Special Variables and Operators</b></p>
<p>The Debugger maintains a list of special variables and operators that are not a part</p>
<p>of your program, but can be used in the Debugger as if they were. For example,</p>
<p>you can use a special variable or operator in an expression that you evaluate in the</p>
<p>Debugger.</p>
<p>The MULTI special variables and operators include user-defined variables (such</p>
<p>as</p>
<p>$foo</p>
<p>), pre-defined system variables (such as</p>
<p>_DATA</p>
<p>), processor registers (such</p>
<p>as</p>
<p>$r1</p>
<p>), and special operators (such as</p>
<p>$bp_adr(%<i>bp_label</i>)</p>
<p>).</p>
<p>When the Debugger is evaluating an expression and it finds a variable name such</p>
<p>as</p>
<p>foo</p>
<p>, it first performs a scope search in the program to see if the variable exists.</p>
<p>If the variable does not exist, then the list of special variables and operators is</p>
<p>searched. Variable names beginning with a dollar sign (</p>
<p>$</p>
<p>), such as</p>
<p>$foo</p>
<p>, are assumed</p>
<p>to be special variables or operators.</p>
<p><b>User-Defined Variables</b></p>
<p>You can define a new variable by entering an appropriate statement into the</p>
<p>Debugger command pane. The statement must adhere to the following format:</p>
<p><b>$<i>variable_name</b></i> [=<i>expression</i>]</p>
<p>where:</p>
<p>â¢</p>
<p><i>variable_name</i></p>
<p>should not be a reserved keyword. Reserved keywords include</p>
<p>commands and system variables.</p>
<p>â¢</p>
<p>The value of the optional argument</p>
<p><i>expression</i></p>
<p>initializes the variable. If</p>
<p>you do not specify</p>
<p><i>expression</i></p>
<p>, the initial value of the variable is zero (0).</p>
<p><i>309</i></p>
<p><i>Green Hills Software</i></p>
<p><i>MULTI Special Variables and Operators</i></p>
<h1 style="page-break-before:always; "></h1>
<p>User-defined variables are of the same type as the last expression assigned. For</p>
<p>example, entering:</p>
<p>â¢</p>
<p>$foo=1</p>
<p>creates the special variable</p>
<p>$foo</p>
<p>, assigns it the value 1, and makes its type int.</p>
<p>â¢</p>
<p>$bar=3*4</p>
<p>creates the special variable</p>
<p>$bar</p>
<p>, assigns it the value 12, and makes its type</p>
<p>int.</p>
<p>â¢</p>
<p>$baz=myInstance.a</p>
<p>creates the special variable</p>
<p>$baz</p>
<p>, assigns it the value of</p>
<p>myInstance.a</p>
<p>, and</p>
<p>makes it the same type as</p>
<p>myInstance.a</p>
<p>.</p>
<p>User-defined variables are just like any other, except that it is meaningless to evaluate</p>
<p>their addresses.</p>
<p><b>System Variables</b></p>
<p>The following table lists the currently defined system variables. Modifying the</p>
<p>values of these variables changes the way the Debugger operates. To display the</p>
<p>value of a system variable, enter it in the Debugger command pane with a dollar</p>
<p>sign prepended to it (for example,</p>
<p>$ANSICMODE</p>
<p>).</p>
<p>ANSICMODE</p>
<p>When set to</p>
<p>0</p>
<p>(zero), expressions are evaluated as they are in K+R C. When set to</p>
<p>1</p>
<p>, which is</p>
<p>the default value, expressions are evaluated as in ANSI C. Generally, this affects how</p>
<p>unsigned</p>
<p>shorts</p>
<p>,</p>
<p>unsigned chars</p>
<p>, and</p>
<p>unsigned</p>
<p>bitfields are coerced. By default in K+R, they are</p>
<p>coerced to</p>
<p>unsigned int</p>
<p>, whereas in ANSI they are coerced to</p>
<p>int</p>
<p>. Thus</p>
<p>((unsigned</p>
<p>short) 3)/ -3</p>
<p>yields different results in ANSI and K+R. The type of</p>
<p>sizeof</p>
<p>is different,</p>
<p>as is the interpretation of the</p>
<p>op=</p>
<p>operators in certain obscure cases.</p>
<p>CONTINUECOUNT</p>
<p>If this is</p>
<p>0</p>
<p>(zero) or</p>
<p>1</p>
<p>, the Debugger will stop at the next breakpoint. If it is 2, the Debugger</p>
<p>will stop at the second breakpoint reached by the process, and so on. Use the<b> c</b> command to set</p>
<p>its value. For example, to set it to 3, enter:</p>
<p>c @3</p>
<p>. For information about the<b> c</b> command, see</p>
<p>âContinue Commandsâ in Chapter 13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>310</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>DEBUGSHARED</p>
<p>Enables/disables debugging of shared objects. This system variable is only relevant with targets</p>
<p>that support shared libraries, such as certain native Linux/Solaris platforms or advanced embedded</p>
<p>real-time operating systems.</p>
<p>DEREFPOINTER</p>
<p>Controls whether or not pointers are automatically dereferenced when displayed by the<b> print</b>,</p>
<p><b>examine</b>, and<b> view</b> commands. For information about the<b> print</b> and<b> examine</b> commands, see</p>
<p>Chapter 8, âDisplay and Print Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book. For information about the<b> view</b> command, see âGeneral View Commandsâ in</p>
<p>Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>DISNAMELEN</p>
<p>Controls the length of the label printed when labels appear in certain cases in disassembly. For</p>
<p>example, the disassembly of a call or branch may include the target label;</p>
<p>DISNAMELEN</p>
<p>controls</p>
<p>how many characters of that constant to print.</p>
<p>FASTSTEP</p>
<p>When set to non-zero (the default), the Debugger attempts to speed up source code stepping.</p>
<p>On each source step, the Debugger analyzes the code, sets temporary breakpoints on all possible</p>
<p>step destinations, and allows the process to run until one of the breakpoints is hit. This allows</p>
<p>the process to run at nearly full speed during the source step. When set to</p>
<p>0</p>
<p>(zero), the Debugger</p>
<p>usually steps one machine instruction at a time until it reaches the next source line. However,</p>
<p>it still sets temporary breakpoints and runs to step over function calls. This method is generally</p>
<p>much slower.</p>
<p>This system variable corresponds to<b> Debug</b> â<b> Debug Settings</b> â<b> Fast Source Step</b>.</p>
<p>SERVERTIMEOUT</p>
<p>How long (in seconds) MULTI will wait for a debug server to respond before concluding that</p>
<p>the server has failed. MULTI will prompt the user to close the connection or keep waiting.</p>
<p>TASKWIND</p>
<p>If this is</p>
<p>0</p>
<p>(zero), the Task Manager (for multitasking targets) will be disabled.</p>
<p>VERIFYHALT</p>
<p>Verifies halting a process before setting a breakpoint by bringing up a confirmation dialog.</p>
<p><i>311</i></p>
<p><i>Green Hills Software</i></p>
<p><i>System Variables</i></p>
<h1 style="page-break-before:always; "></h1>
<p>System variables beginning with an underscore (</p>
<p>_</p>
<p>), such as those shown in the</p>
<p>following table, represent the internal state of the Debugger and are not normally</p>
<p>listed. To see them, use the command<b> l s _</b> (lowercase</p>
<p>L</p>
<p>, lowercase</p>
<p>s</p>
<p>, underscore).</p>
<p>For information about the<b> l</b> command, see Chapter 8, âDisplay and Print Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>_ASMCACHE</p>
<p>When set to</p>
<p>1</p>
<p>, which is the default value, the disassembly of program code in the Debugger</p>
<p>window is done by reading data from the executable file, not from the program being debugged.</p>
<p>This allows a faster disassembly display to the screen. Setting</p>
<p>_ASMCACHE</p>
<p>to</p>
<p>0</p>
<p>(zero) forces</p>
<p>the Debugger to read the text to be disassembled from the program being debugged, instead of</p>
<p>from the buffer or executable file. If instruction memory is modified or destroyed and</p>
<p>_ASMCACHE</p>
<p>is</p>
<p>1</p>
<p>, then displays of disassembled instructions will continue to show the original, unmodified</p>
<p>instructions in the executable file. This is confusing because the instructions actually executed</p>
<p>are not those shown by the disassembly display.</p>
<p>Sometimes, when a peculiar behavior occurs on the target system, such as when the process</p>
<p>stops on an apparently valid instruction or when it refuses to single-step or continue past a valid</p>
<p>instruction, then the instruction memory on the target system has been corrupted. Try setting</p>
<p>_ASMCACHE</p>
<p>to</p>
<p>0</p>
<p>(zero) and redisplaying the assembly code. You may find invalid instructions</p>
<p>at the point of failure. (You may need to turn off</p>
<p>_INTERLACE</p>
<p>(assembly) mode and examine</p>
<p>another part of the program, turn</p>
<p>_INTERLACE</p>
<p>mode back on, and then return to the point of</p>
<p>the entry to clear out the Debugger's internal disassembly cache.)</p>
<p>_AUTO_CHECK_COHERENCY</p>
<p>If nonzero, automatic coherency checking is enabled. If zero, automatic coherency checking is</p>
<p>disabled. For more information, see âDetecting Coherency Errorsâ on page 536.</p>
<p>See also the</p>
<p>_AUTO_CHECK_NUM_ADDRS</p>
<p>variable below.</p>
<p>_AUTO_CHECK_NUM_ADDRS</p>
<p>Sets the number of addresses to check for coherency. Because extra memory is read on every</p>
<p>stop, use care when setting the number of addresses to be read. Setting a large number of</p>
<p>addresses may slow normal run control. By default, MULTI checks either 16 addresses or the</p>
<p>number of addresses lasting the length of 4 instructions (whichever is fewer).</p>
<p>The value of this variable is only meaningful if automatic coherency checking is enabled. See</p>
<p>the</p>
<p>_AUTO_CHECK_COHERENCY</p>
<p>variable above.</p>
<p>For more information, see âDetecting Coherency Errorsâ on page 536.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>312</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>_CACHE</p>
<p>If non-zero, the Debugger uses a cache for reading memory from the target. The cache is</p>
<p>invalidated every time the process state changes. This speeds up embedded debugging. Because</p>
<p>certain devices such as hardware registers and control ports must be accessed using a specific</p>
<p>memory access size, you must disable the</p>
<p>_CACHE</p>
<p>variable before viewing memory that</p>
<p>corresponds to these devices.</p>
<p>For related commands, see the<b> memread</b> and<b> memwrite</b> commands in Chapter 10, âMemory</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>_DATA</p>
<p>Used only for position-independent data (PID) systems where the executable is linked as if it</p>
<p>were at one address, while it runs at another. This variable is set to the offset between the location</p>
<p>at which the data segment resides and at which it is linked. It should not be set to</p>
<p>-1</p>
<p>. This is</p>
<p>set on the command line with the<b> -data</b> option.</p>
<p>_DISPMODE</p>
<p>Determines whether assembly code is interlaced with source code in the source pane. See âThe</p>
<p>Command Pane Shortcut Menuâ on page 712. This variable has no effect in<b> Assem</b> source pane</p>
<p>display mode.</p>
<p>_INIT_SP</p>
<p>Tells the Debugger the value of the stack pointer at program start up, in certain target</p>
<p>environments where this information is not available.</p>
<p>_LANGUAGE</p>
<p>Shows which language-specific rules for the expression evaluator are in use.</p>
<p>0</p>
<p>(zero) means C,</p>
<p>3</p>
<p>means C++,</p>
<p>7</p>
<p>means Assembly, and</p>
<p>31</p>
<p>[default] means auto-select based on the type of</p>
<p>current file. You should not usually need to change this system variable from its default value.</p>
<p>_LINES</p>
<p>This controls the number of lines displayed by the<b> printwindow</b> command, and in non-GUI</p>
<p>mode, also controls the number of lines shown between</p>
<p>More?</p>
<p>prompts. For information about</p>
<p>the<b> printwindow</b> command, see Chapter 8, âDisplay and Print Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>_OPCODE</p>
<p>If non-zero, then disassembly mode displays the hexadecimal value of the instruction.</p>
<p>_TEXT</p>
<p>Used only for position-independent code (PIC) systems where the executable is linked as if it</p>
<p>were at one address, while it runs at another. This variable is set to the offset between the location</p>
<p>at which the text segment resides and links. It should not be set to</p>
<p>-1</p>
<p>. This variable is set on</p>
<p>the command line with the<b> -text</b> option.</p>
<p><i>313</i></p>
<p><i>Green Hills Software</i></p>
<p><i>System Variables</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The following system variables are read-only.</p>
<p><b>Note</b></p>
<p>Supported values for the system variables whose names begin with</p>
<p>_TARGET</p>
<p>are defined in the<b> os_constants_internal.grd</b> file located at</p>
<p><i><b>compiler_install_dir</i>/defaults/registers</b>.</p>
<p>_BREAK</p>
<p>The current breakpoint number.</p>
<p>_CURRENT_TASKID</p>
<p>The task ID of the currently executing OSA task.</p>
<p>_ENTRYPOINT</p>
<p>The address of the entry point (for example,</p>
<p>_start</p>
<p>) for the current thread, if any. Note that</p>
<p>this may differ from the entry point of user code (for example,</p>
<p>main</p>
<p>).</p>
<p>_ENTRYPOINT</p>
<p>is not</p>
<p>adjusted for the PIC base address of PIC programs.</p>
<p>_EXEC_NAME</p>
<p>The name and path of the program currently loaded in the Debugger.</p>
<p>_FILE</p>
<p>The name of the current file.</p>
<p>_INTERLACE</p>
<p>Indicates whether assembly code is displayed in the source window. If there is assembly code</p>
<p>currently displayed in the source window, then this is</p>
<p>1</p>
<p>; otherwise it is</p>
<p>0</p>
<p>(zero).</p>
<p>_LAST_COMMAND_STATUS</p>
<p>The status of the last MULTI command execution (</p>
<p>0</p>
<p>means failure,</p>
<p>1</p>
<p>means success).</p>
<p>_LAST_CONNECT_CMD_LINE</p>
<p>The argument(s) last run with the MULTI<b> connect</b> command. For information about the<b> connect</b></p>
<p>command, see âGeneral Target Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>_LINE</p>
<p>The current line number.</p>
<p>_MULTI_DIR</p>
<p>The name of the directory that contains the MULTI executable.</p>
<p>_MULTI_MAJOR_VERSION</p>
<p>MULTI's major version (for example,</p>
<p>1</p>
<p>in MULTI 1.2.3).</p>
<p><i>MULTI: Debugging</i></p>
<p><i>314</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>_MULTI_MICRO_VERSION</p>
<p>MULTI's micro version (for example,</p>
<p>3</p>
<p>in MULTI 1.2.3).</p>
<p>_MULTI_MINOR_VERSION</p>
<p>MULTI's minor version (for example,</p>
<p>2</p>
<p>in MULTI 1.2.3).</p>
<p>_NONGUIMODE</p>
<p>This indicates whether or not MULTI was started in non-GUI (<b>-nodisplay</b>) mode.</p>
<p>_OS_DIR</p>
<p>The full path to the directory containing the Green Hills RTOS installation used to build the</p>
<p>program currently loaded in the Debugger.</p>
<p>_OS_DIR</p>
<p>contains an empty string if the RTOS</p>
<p>installation directory cannot be determined.</p>
<p>_PID</p>
<p>The identification number (ID) of the process, as reported by the debug server.</p>
<p>_PROCEDURE</p>
<p>The name of the current procedure.</p>
<p>_PROCESS</p>
<p>MULTI's internal slot number for the current process.</p>
<p>_REMOTE_CONNECTED</p>
<p>This is</p>
<p>1</p>
<p>if a remote target connection has been established,</p>
<p>0</p>
<p>(zero) otherwise.</p>
<p>_RTSERV_VER</p>
<p>The version number of<b> rtserv</b> (</p>
<p>2</p>
<p>indicates<b> rtserv2</b>,</p>
<p>1</p>
<p>indicates<b> rtserv</b>, and</p>
<p>0</p>
<p>indicates a</p>
<p>non-<b>rtserv</b> connection).</p>
<p>_SELECTION</p>
<p>A string variable representing the current selection from the source pane.</p>
<p>_SETUP_SCRIPT</p>
<p>The full path to the file containing the setup script for the current connection. If the current</p>
<p>process is not connected or the current connection does not have a setup script,</p>
<p>_SETUP_SCRIPT</p>
<p>contains an empty string.</p>
<p>_SETUP_SCRIPT_DIR</p>
<p>The full path to the directory containing the setup script for the current connection. If the current</p>
<p>process is not connected or the current connection does not have a setup script,</p>
<p>_SETUP_SCRIPT_DIR</p>
<p>contains an empty string.</p>
<p><i>315</i></p>
<p><i>Green Hills Software</i></p>
<p><i>System Variables</i></p>
<h1 style="page-break-before:always; "></h1>
<p>_STATE</p>
<p>The process state, where:</p>
<p>â¢</p>
<p>1 = No child</p>
<p>â¢</p>
<p>2 = Stopped</p>
<p>â¢</p>
<p>3 = Running</p>
<p>â¢</p>
<p>4 = Dying</p>
<p>â¢</p>
<p>5 = Just forked</p>
<p>â¢</p>
<p>6 = Just exec'ed</p>
<p>â¢</p>
<p>7 = About to resume</p>
<p>â¢</p>
<p>8 = Zombied</p>
<p>_TARGET</p>
<p>Contains a unique identifier indicating the target processor's family and variant.</p>
<p>_TARGET_COPROCESSOR</p>
<p>Contains a unique identifier indicating the target coprocessor's variant.</p>
<p>_TARGET_FAMILY</p>
<p>The family of the target on which the program being debugged is running.</p>
<p>_TARGET_IS_BIGENDIAN</p>
<p>Indicates whether the target is big endian (</p>
<p>1</p>
<p>) or little endian (</p>
<p>0</p>
<p>).</p>
<p>_TARGET_OS</p>
<p>Displays an identifier indicating which OS is running on the target, if such information is</p>
<p>available.</p>
<p>_TARGET_MINOR_OS</p>
<p>Displays an identifier indicating which minor type of OS is running on the target, if such</p>
<p>information is available.</p>
<p>_TARGET_SERIES</p>
<p>This may contain information about whether the target processor is a member of a certain series</p>
<p>of processors (for example, the PowerPC 400 series). This does not work for all processor</p>
<p>families.</p>
<p>_TASK_EXIT_CODE</p>
<p>The exit code of the current task.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>316</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>_TOP_PROJECT</p>
<p>The full path to the Top Project used to build the program currently loaded in the Debugger.</p>
<p>The setting of this variable reflects the path that was correct at the time the program was built;</p>
<p>if you move the project, you must rebuild it and reload the program to update this variable. This</p>
<p>variable contains an empty string if the name of the project file cannot be determined.</p>
<p>_TOP_PROJECT_DIR</p>
<p>The full path to the directory containing the Top Project used to build the program currently</p>
<p>loaded in the Debugger. The setting of this variable reflects the path that was correct at the time</p>
<p>the program was built; if you move the project, you must rebuild it and reload the program to</p>
<p>update this variable. This variable contains an empty string if the name of the project file cannot</p>
<p>be determined.</p>
<p><b>Processor-Specific Variables</b></p>
<p>Processor registers are included as predefined variables. To find out what register</p>
<p>names are available on your system, use the command<b> l r</b> (lowercase</p>
<p>L</p>
<p>, lowercase</p>
<p>R</p>
<p>) to list the registers. For information about the<b> l</b> command, see Chapter 8, âDisplay</p>
<p>and Print Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>All registers can be treated as integers of the correct size for the register. Be careful</p>
<p>when you modify the contents of registers when you are debugging high-level code;</p>
<p>the results of these modifications can often produce unpredictable effects.</p>
<p>The following predefined Debugger internal variable is also included.</p>
<p>$result</p>
<p>Holds the return value of the most recently completed procedure. This variable is an alias for</p>
<p>the register on the processor architecture used for returning integers. On most systems, this is</p>
<p>also the register to return pointers. It may be written to as well as read from.</p>
<p>This value is not guaranteed to be correct; it depends on the return type of the function and the</p>
<p>processor architecture. The actual return variable may be located elsewhere. As with any register,</p>
<p>you must be careful when you change its value.</p>
<p><b>Special Operators</b></p>
<p>The Debugger maintains a list of special operators that are not a part of your program,</p>
<p>but can be used in the Debugger as if they were. For example, you can use special</p>
<p>operators in expressions that you evaluate in the Debugger.</p>
<p><i>317</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Processor-Specific Variables</i></p>
<h1 style="page-break-before:always; "></h1>
<p>$bp_adr(%<i>bp_label</i>)</p>
<p>Returns the address of the breakpoint with label</p>
<p><i>bp_label</i></p>
<p>.</p>
<p>$entadr(<i>procedure</i>)</p>
<p>Returns the address of the first instruction after the given procedure</p>
<p><i>procedure</i></p>
<p>'s prologue</p>
<p>code. (The procedure prologue code is also known as the stack frame setup code or the entry</p>
<p>code.)</p>
<p>If</p>
<p><i>procedure</i></p>
<p>is not given, the current procedure is used.</p>
<p>$exists(&quot;<i>symbol</i>&quot;)</p>
<p>$M_sym_exists(&quot;<i>symbol</i>&quot;)</p>
<p>Returns a Boolean indicating whether the symbol</p>
<p><i>symbol</i></p>
<p>exists within the program currently</p>
<p>being debugged.</p>
<p>$in(<i>procedure</i>)</p>
<p>Returns true if the current process is stopped and the current program counter (PC) is in the</p>
<p>given procedure</p>
<p><i>procedure</i></p>
<p>.</p>
<p>$M_called_from(<i>level</i>, &quot;<i>string</i>&quot;)</p>
<p>Returns a Boolean indicating true if the</p>
<p><i>level</i></p>
<p>is 0, and</p>
<p>&quot;<i>string</i>&quot;</p>
<p>is the name of a function</p>
<p>on the current call stack. Otherwise, it returns true if</p>
<p>&quot;<i>string</i>&quot;</p>
<p>is the name of the function at</p>
<p>the call stack depth indicated by</p>
<p><i>level</i></p>
<p>.</p>
<p>$M_can_read_address(<i>num</i>)</p>
<p>Returns true if the address indicated by</p>
<p><i>num</i></p>
<p>is readable; returns false otherwise.</p>
<p>$M_file_exists(&quot;<i>file</i>&quot;)</p>
<p>Returns a Boolean indicating whether the file</p>
<p><i>file</i></p>
<p>exists within the program currently being</p>
<p>debugged.</p>
<p>$M_get_temp_memory(<i>size</i>)</p>
<p>Returns an address that points at a chunk of memory of</p>
<p><i>size</i></p>
<p>address units. If</p>
<p><i>size</i></p>
<p>is too large,</p>
<p>an error message is printed and</p>
<p>-1</p>
<p>is returned as the address. This chunk of memory is guaranteed</p>
<p>to be valid only until MULTI needs more temporary memory on the target. In practice, it should</p>
<p>remain valid until the next time the user stores a string or other data structure to the target (by</p>
<p>calling a constructor at the command pane, for example).</p>
<p>Using this special operator requires that your program be linked with<b> libmulti.a</b>, a library</p>
<p>supplied by Green Hills. For more information, see the documentation about enabling command</p>
<p>line procedure calls in the<i> MULTI: Building Applications</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>318</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>$M_offsetof(<i>type</i>,<i> field</i>)</p>
<p>offsetof(<i>type</i>,<i> field</i>)</p>
<p>Returns the offset in bytes of the member field</p>
<p><i>field</i></p>
<p>within the aggregate type</p>
<p><i>type</i></p>
<p>. The first</p>
<p>parameter must be either an aggregate (struct, union, or class) type name or an instance of an</p>
<p>aggregate type. The second parameter must be the name of a field within that type.</p>
<p>Note that entering</p>
<p>offsetof(<i>type, field</i>)</p>
<p>in the command pane may execute a macro or</p>
<p>procedure call if the current program has a macro or procedure call with the name</p>
<p>offsetof</p>
<p>.</p>
<p>To guarantee the use of the Debugger's built-in operator, use</p>
<p>$M_offsetof()</p>
<p>.</p>
<p>$M_sec_begin(&quot;<i>section</i>&quot;)</p>
<p>Returns the address of the beginning of the section</p>
<p><i>section</i></p>
<p>. It returns -1 if the section does</p>
<p>not exist within the program currently being debugged.</p>
<p>$M_sec_end(&quot;<i>section</i>&quot;)</p>
<p>Returns the address of the end of the section</p>
<p><i>section</i></p>
<p>. It returns -1 if the section does not exist</p>
<p>within the program currently being debugged.</p>
<p>$M_sec_exists(&quot;<i>section</i>&quot;)</p>
<p>Returns a Boolean indicating if the section</p>
<p><i>section</i></p>
<p>exists within the program currently being</p>
<p>debugged.</p>
<p>$M_sec_size(&quot;<i>section</i>&quot;)</p>
<p>Returns the size of the section</p>
<p><i>section</i></p>
<p>. It returns</p>
<p>-1</p>
<p>if the section does not exist within the</p>
<p>program currently being debugged.</p>
<p>$M_strcmp(<i>expr</i>, &quot;<i>string</i>&quot;)</p>
<p>Returns an integer greater than, equal to, or less than zero if the string pointed to by the first</p>
<p>parameter is lexicographically greater than, equal to, or less than the string pointed to by the</p>
<p>second parameter. The first parameter must be an expression which evaluates to a string and</p>
<p>the second parameter must be a string constant.</p>
<p>$M_strcpy(<i>expr</i>, &quot;<i>string</i>&quot;)</p>
<p>Returns the number of bytes written. The first parameter must be an expression which evaluates</p>
<p>to a string and the second parameter must be a string constant.</p>
<p>$M_strprefix(<i>expr</i>, &quot;<i>string</i>&quot;)</p>
<p>$M_strcaseprefix(<i>expr</i>, &quot;<i>string</i>&quot;)</p>
<p>Returns a Boolean indicating whether the first parameter is prefixed by the second</p>
<p>(</p>
<p>$M_strcaseprefix</p>
<p>is case-insensitive). The first parameter must be an expression that</p>
<p>evaluates to a string and the second parameter must be a string constant.</p>
<p>$M_strstr(<i>expr</i>, &quot;<i>string</i>&quot;)</p>
<p>Returns a pointer to the first occurrence of the second parameter string within the first parameter</p>
<p>string, or a null pointer if it is not found. The first parameter must be an expression which</p>
<p>evaluates to a string and the second parameter must be a string constant.</p>
<p><i>319</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Special Operators</i></p>
<h1 style="page-break-before:always; "></h1>
<p>$M_typeof(<i>var</i>)</p>
<p>Returns the type of</p>
<p><i>var</i></p>
<p>, suitable for use in casting. For example:</p>
<p>$foo = (($M_typeof(my_var)) 0x10000)</p>
<p>would give the value of</p>
<p>0x10000</p>
<p>to the MULTI local variable</p>
<p>$foo</p>
<p>and give it the same type</p>
<p>as</p>
<p>my_var</p>
<p>.</p>
<p>$M_var_is_valid(<i>var</i>)</p>
<p>Returns true if and only if the indicated variable exists in the current scope, is initialized, and</p>
<p>is not yet out of scope (that is, dead). Returns false otherwise.</p>
<p>$retadr(<i>procedure</i>)</p>
<p>Returns the address of the first instruction of the given procedure</p>
<p><i>procedure</i></p>
<p>'s epilogue code.</p>
<p>(The procedure epilogue code is also known as the stack frame release code or the return code.)</p>
<p>If</p>
<p><i>procedure</i></p>
<p>is not given, the current procedure is used.</p>
<p>sizeof(<i>variable</i>)</p>
<p>sizeof(<i>type</i>)</p>
<p>sizeof(â<i>string</i>â)</p>
<p>sizeof((<i>expression</i>))</p>
<p>Behaves similarly to the C</p>
<p>sizeof</p>
<p>operator and returns the size in bytes of the type of</p>
<p><i>variable</i></p>
<p>,</p>
<p>of</p>
<p><i>type</i></p>
<p>, or of the type resulting from</p>
<p><i>expression</i></p>
<p>. If</p>
<p>â<i>string</i>â</p>
<p>is specified, this operator</p>
<p>returns</p>
<p>strlen(&quot;<i>string</i>&quot;) + 1</p>
<p>. Unlike the C</p>
<p>sizeof</p>
<p>operator, this operator actually evaluates</p>
<p>any argument provided, such that if an expression with side effects is specified, the side effects</p>
<p>occur.</p>
<p><b>Syntax Checking</b></p>
<p>The syntax checking mechanism checks the validity of a command without actually</p>
<p>executing it, and thus without requiring target interactions and without changing</p>
<p>the system settings.</p>
<p>The Debugger command<b> sc</b> performs syntax checking. It can be used in two different</p>
<p>ways.</p>
<p>To check the syntax of a single command, enter:</p>
<p>sc &quot;<i>command</i>&quot;</p>
<p><i>MULTI: Debugging</i></p>
<p><i>320</i></p>
<p><i>Chapter 14. Using Expressions, Variables, and Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To check the syntax of an entire script file and all nested files, enter:</p>
<p>sc &lt;<i> script_file_name</i></p>
<p>For more information, see the<b> sc</b> command in âRecord and Playback Commandsâ</p>
<p>in Chapter 15, âScripting Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>Syntax checking is also automatically invoked whenever a breakpoint with an</p>
<p>associated command or condition is created. The validity of the commands associated</p>
<p>with the breakpoint is checked in the context that would exist if the breakpoint were</p>
<p>hit. If a syntax error is found in the breakpoint command, an error message is issued</p>
<p>and the breakpoint is not created.</p>
<p><b>Note</b></p>
<p>You can use the<b> bpSyntaxChecking</b> configuration option to disable this</p>
<p>automatic syntax checking. For more information, see the</p>
<p><b>bpSyntaxChecking</b> option in âThe More Debugger Options Dialogâ in</p>
<p>Chapter 8, âConfiguration Optionsâ in the<i> MULTI: Managing Projects</i></p>
<p><i>and Configuring the IDE</i> book.</p>
<p>For example, entering the command:</p>
<p>sc &quot;print abcdef&quot;</p>
<p>will echo the error message:</p>
<p>Syntax Checking: Unknown name &quot;abcdef&quot; in expression.</p>
<p>and entering the command:</p>
<p>b main { print abcdef; }</p>
<p>will echo the error messages:</p>
<p>Syntax Checking: Unknown name &quot;abcdef&quot; in expression.</p>
<p>Failed to set software breakpoint owing to syntax error.</p>
<p><i>321</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Syntax Checking</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 15</b></p>
<p><b>Using the Memory View</b></p>
<p><b>Window</b></p>
<p><b>Contents</b></p>
<p>Setting the Active Location . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>325</p>
<p>The Memory Pane . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>326</p>
<p>Controlling Memory Access . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>328</p>
<p>Editing Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>329</p>
<p>The Memory View Toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>330</p>
<p>Memory View Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>332</p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Memory View</b> window is useful for examining large buffers, strings, and other</p>
<p>contiguous blocks of memory. The window can be configured to display memory</p>
<p>in a variety of formats. Memory may also be modified from this window.</p>
<p>To open the<b> Memory View</b> window, perform one of the following actions:</p>
<p>â¢</p>
<p>Click the<b> Memory</b> button (</p>
<p>) located on the toolbar.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Memory</b>.</p>
<p>â¢</p>
<p>In a Data Explorer, select<b> Tools</b> â<b> Memory View on â<i>variable</i>â</b> to open a</p>
<p><b>Memory View</b> window examining the same memory location as the Data</p>
<p>Explorer.</p>
<p>â¢</p>
<p>In the command pane, enter the<b> memview</b> command. For information about</p>
<p>this command, see Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>324</i></p>
<p><i>Chapter 15. Using the Memory View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Setting the Active Location</b></p>
<p>The active location for the<b> Memory View</b> window is displayed in the title bar and</p>
<p>in the<b> Location</b> bar at the top of the window, and the row containing this location</p>
<p>is highlighted in the memory pane.</p>
<p>When you specify a new active location, target memory is read and the displayed</p>
<p>memory begins with the address of the active location. To change the active location,</p>
<p>do one of the following:</p>
<p>â¢</p>
<p>Enter an address expression, a section name, or a section name and offset</p>
<p>(</p>
<p>.text+0x400</p>
<p>, for example) in the location bar, and press<b> Enter</b>.</p>
<p>â¢</p>
<p>Select a previously entered location from the location bar's drop-down list.</p>
<p><b>Note</b></p>
<p>Scrolling the window does not change the highlighted location or the</p>
<p>contents of the<b> Location</b> bar. To return to the active location, press<b> Enter</b>.</p>
<p><b>Locking the Current Symbol's Location</b></p>
<p>By default, if you enter a symbol as the active location, MULTI sets the memory</p>
<p>pane location to the address for the symbol at the time you entered it. If the address</p>
<p>for the symbol changes, the text in the location bar turns red, but the address</p>
<p>highlighted in the memory pane does not change. To display and change the active</p>
<p>location to the new address, press<b> Enter</b>.</p>
<p>If you would like the<b> Memory View</b> window to track the location of the symbol</p>
<p>each time it changes, click the<b> Lock Address</b> button (</p>
<p>) so that it no longer appears</p>
<p>pushed down. In this mode, the active location is updated every time the address</p>
<p>for the symbol changes.</p>
<p><i>325</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Setting the Active Location</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Memory Pane</b></p>
<p>The memory pane is composed of rows of memory displayed in an address column</p>
<p>and multiple view columns. To change the number of bytes displayed in each row,</p>
<p>use the following buttons:</p>
<p>â¢</p>
<p><b>Contract</b> (</p>
<p>) and<b> Expand</b> (</p>
<p>) â Change the byte-width of the rows by a</p>
<p>factor of two each time they are pressed.</p>
<p>â¢</p>
<p><b>Set Row Width</b> (</p>
<p>) â Opens a window in which you can specify the width</p>
<p>of the rows.</p>
<p>The<b> Address</b> column displays the location of the first byte of each row and can</p>
<p>never be removed from the pane. You can view the rows of memory in ascending</p>
<p>or descending order. To change the order, click the header of the<b> Address</b> column.</p>
<p>Each view column displays the formatted contents of memory at that location.</p>
<p><b>Formatting View Columns</b></p>
<p>You can independently format each view column in the memory pane. To format</p>
<p>a view column, do one of the following:</p>
<p>â¢</p>
<p>Right-click the header of a column and select a formatting option from the</p>
<p>shortcut menu.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Column<i> number name</b></i> and select a formatting option from</p>
<p>the submenu.</p>
<p>The primary formatting options are<b> Hex</b>,<b> Decimal</b>,<b> Binary</b>,<b> Floating Point</b>,<b> Fixed</b></p>
<p><b>Point</b>,<b> Ascii</b>,<b> Symbols</b>,<b> Disassembly</b>, and<b> Offset</b>. You may see additional view</p>
<p>column formats if your CPU supports them.</p>
<p>In addition to primary formatting options, secondary formatting options may appear</p>
<p>if the selected primary format supports them. For the comprehensive list of options,</p>
<p>see the âThe Column Submenuâ on page 334.</p>
<p>The following information is specific to select formats.</p>
<p>â¢</p>
<p>Numerical formats â Any memory that cannot be read is displayed as a series</p>
<p>of dashes.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>326</i></p>
<p><i>Chapter 15. Using the Memory View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><b>Ascii</b> format â Any memory that cannot be represented by an ASCII character</p>
<p>is displayed as a dot (</p>
<p>.</p>
<p>).</p>
<p>â¢</p>
<p><b>Symbols</b> format â Symbols that continue from previous addresses are</p>
<p>represented with the string â</p>
<p>...</p>
<p>â.</p>
<p>â¢</p>
<p><b>Disassembly</b> format â In regions of memory without symbol information,</p>
<p>inaccurate instructions may be displayed if the beginning of the window is not</p>
<p>aligned with the start of an instruction.</p>
<p>â¢</p>
<p><b>Big Endian</b> and<b> Little Endian</b> format â If the selected byte order is not the</p>
<p>default order for your target, it is displayed in the column header.</p>
<p><b>Managing View Columns</b></p>
<p>The following table summarizes the actions you can perform on view columns:</p>
<p><b>Procedure</b></p>
<p><b>Action</b></p>
<p>One of:</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Add New Column</b> â<i><b> format</b></i>.</p>
<p>â¢</p>
<p>Right-click the header beyond the right edge of the last column</p>
<p>and select a format from the shortcut menu.</p>
<p>â¢</p>
<p>Right-click the header of a column and select<b> Add New Column</b></p>
<p>from the shortcut menu.</p>
<p>Add Column</p>
<p>One of:</p>
<p>â¢</p>
<p>Right-click the header of a column and select<b> Remove</b> from the</p>
<p>shortcut menu.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Column<i> number name</b></i> â<b> Remove</b>.</p>
<p>Remove Column</p>
<p>One of:</p>
<p>â¢</p>
<p>Right-click the header of a column and select<b> Hide</b> from the</p>
<p>shortcut menu.</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Column<i> number name</b></i> â<b> Hide</b>.</p>
<p>Hide Column</p>
<p>Select<b> View</b> â<b> Column<i> number name</b></i> â<b> Show</b>.</p>
<p>Show Column</p>
<p><i>327</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Managing View Columns</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Procedure</b></p>
<p><b>Action</b></p>
<p>One of:</p>
<p>â¢</p>
<p>Right-click the header of a column and enable<b> Size to Fit</b> from</p>
<p>the shortcut menu.</p>
<p>â¢</p>
<p>Enable<b> View</b> â<b> Column<i> number name</b></i> â<b> Size to Fit</b>.</p>
<p>Resize Column</p>
<p>Automatically</p>
<p>Drag the header of a column to its new location.</p>
<p>Reorder Columns</p>
<p><b>Controlling Memory Access</b></p>
<p>You can control how the<b> Memory View</b> window accesses memory by freezing the</p>
<p>window, setting access sizes, or disabling block reads. The following sections</p>
<p>describe each of these actions.</p>
<p><b>Freezing the Memory View Window</b></p>
<p>The contents of the memory pane are automatically updated each time the target</p>
<p>halts or steps. To prevent this update, click the<b> Freeze</b> button (</p>
<p>). Location changes</p>
<p>and automatic updates are disabled until the window is unfrozen. To unfreeze the</p>
<p>window, click the<b> Freeze</b> button again, and the contents of the window are updated.</p>
<p>To force the window to update its contents, even if frozen, by immediately re-reading</p>
<p>target memory, do one of the following:</p>
<p>â¢</p>
<p>Click the<b> Reload</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>Right-click the memory pane and select<b> Reload from Target</b>.</p>
<p>â¢</p>
<p>Select<b> Memory</b> â<b> Reload from Target</b>.</p>
<p><b>Setting Access Sizes</b></p>
<p>The preferred read and write access sizes are shown in the<i> access size display area</i>,</p>
<p>located in the right side of the status bar. The<b> Memory View</b> window defaults to</p>
<p>these sizes when accessing target memory. To change the access sizes, do one of</p>
<p>the following:</p>
<p>â¢</p>
<p>Double-click the access size display area. In the<b> Access Sizes</b> dialog box that</p>
<p>appears, select the new access sizes from the drop-down lists.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>328</i></p>
<p><i>Chapter 15. Using the Memory View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Right-click the access size display area, select<b> Read Access Size</b> or<b> Write</b></p>
<p><b>Access Size</b>, and select the new access size from the submenu.</p>
<p>â¢</p>
<p>Select<b> Memory</b> â<b> Set Access Sizes</b>. In the<b> Access Sizes</b> dialog box that</p>
<p>appears, select the new access sizes from the drop-down lists.</p>
<p>The contents of the memory pane are automatically refreshed to reflect your changes.</p>
<p><b>Note</b></p>
<p>Access sizes do not affect how memory is displayed in the view columns.</p>
<p><b>Disabling Block Reads</b></p>
<p>To increase performance, the<b> Memory View</b> window performs all target memory</p>
<p>reads as block memory accesses. If you would like to set an access size because of</p>
<p>target or memory requirements, but your debug server prevents you from doing so,</p>
<p>disable the<b> Use Block Reads</b> option. The<b> Memory View</b> window then performs</p>
<p>all reads as individual memory accesses of the preferred read size. To disable the</p>
<p><b>Use Block Reads</b> option, do one of the following:</p>
<p>â¢</p>
<p>Clear<b> Memory</b> â<b> Use Block Reads</b>.</p>
<p>â¢</p>
<p>Right-click the access size display area, and clear<b> Use Block Reads</b>.</p>
<p><b>Editing Memory</b></p>
<p>You can edit the contents of memory in the<b> Hex</b>,<b> Decimal</b>,<b> Binary</b>, and<b> ASCII</b></p>
<p>columns. To edit the contents of memory, perform the following steps:</p>
<p>1.</p>
<p>Click the character you want to edit.</p>
<p>2.</p>
<p>Type a new value. All columns update to reflect your change, which is</p>
<p>displayed in red lettering to indicate that it has not yet been written to the</p>
<p>target.</p>
<p><i>329</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Disabling Block Reads</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Repeat steps 1 and 2 for all of the characters you would like to modify.</p>
<p>4.</p>
<p>Do one of the following:</p>
<p>â¢</p>
<p>Click</p>
<p>.</p>
<p>â¢</p>
<p>Right-click the memory pane and select<b> Write Changes to Target</b>.</p>
<p>â¢</p>
<p>Select<b> Memory</b> â<b> Write Changes to Target</b>.</p>
<p>Until you perform this step, your changes will not be written to target memory.</p>
<p><b>The Memory View Toolbar</b></p>
<p>The<b> Memory View</b> toolbar contains buttons that allow you to control the<b> Memory</b></p>
<p><b>View</b> window and perform memory-specific operations. The following table</p>
<p>describes the buttons in the<b> Memory View</b> window.</p>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Contracts the byte-width of the rows by a factor of two each</p>
<p>time it is pressed.</p>
<p><b>Contract</b></p>
<p>Expands the byte-width of the rows by a factor of two each</p>
<p>time it is pressed.</p>
<p><b>Expand</b></p>
<p>Opens a window in which you can specify the width of the</p>
<p>rows.</p>
<p><b>Set Row Width</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>330</i></p>
<p><i>Chapter 15. Using the Memory View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Forces the window to update its contents, even if frozen, by</p>
<p>immediately re-reading target memory.</p>
<p>Clicking this button is equivalent to selecting<b> Reload from</b></p>
<p><b>Target</b> from the<b> Memory</b> menu or the shortcut menu.</p>
<p><b>Reload</b></p>
<p>Writes memory modifications made in the<b> Memory View</b></p>
<p>window to the target.</p>
<p>Clicking this button is equivalent to selecting<b> Write Changes</b></p>
<p><b>to Target</b> from the<b> Memory</b> menu or the shortcut menu.</p>
<p><b>Write Changes to Target</b></p>
<p>Locks the address of the symbol in the location bar. This is</p>
<p>the default behavior. To unlock the address and track the</p>
<p>location of the symbol each time it changes, click this button</p>
<p>so that it no longer appears pushed down. For more</p>
<p>information, see âLocking the Current Symbol's Locationâ</p>
<p>on page 325.</p>
<p><b>Lock Address</b></p>
<p>Prevents location changes and automatic updates. To re-enable</p>
<p>these window updates, click the<b> Freeze</b> button again.</p>
<p><b>Freeze</b></p>
<p>Opens the<b> Cache View</b> window. See âThe Cache View</p>
<p>Windowâ on page 392.</p>
<p>This button is not available for all targets.</p>
<p><b>Open Cache View</b></p>
<p>Opens the<b> Cache Find</b> window on the active location. See</p>
<p>âThe Cache Find Windowâ on page 396.</p>
<p>This button is not available for all targets.</p>
<p><b>Find in Caches</b></p>
<p>Saves the contents of the<b> Memory View</b> window to a text</p>
<p>file. The information contained in the text file is formatted</p>
<p>exactly as it appears in the columns of the<b> Memory View</b></p>
<p>window.</p>
<p><b>Save Current View to File</b></p>
<p>Prints the memory pane contents. All view column data is</p>
<p>printed for each address currently in view.</p>
<p><b>Print</b></p>
<p>Closes the<b> Memory View</b> window.</p>
<p>Clicking this button is equivalent to selecting<b> Memory</b> â</p>
<p><b>Close</b>.</p>
<p>Whether this button appears on your toolbar depends on the</p>
<p>setting of the option<b> Display close (x) buttons</b>. To access this</p>
<p>option from the Debugger, select<b> Config</b> â<b> Options</b> â</p>
<p><b>General Tab</b>.</p>
<p><b>Close</b></p>
<p><i>331</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Memory View Toolbar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Memory View Menus</b></p>
<p>The following sections describe the menu items available from the<b> Memory View</b></p>
<p>window.</p>
<p><b>The Memory Menu</b></p>
<p>The following table lists the options available in the<b> Memory</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Opens a window that allows you to copy one region of</p>
<p>memory to another.</p>
<p>This is equivalent to the<b> copy -gui</b> command.</p>
<p><b>Copy</b></p>
<p>Opens a window that allows you to fill a specified region of</p>
<p>memory with the given value.</p>
<p>This is equivalent to the<b> fill -gui</b> command.</p>
<p><b>Fill</b></p>
<p>Opens a window that allows you to search memory for a</p>
<p>specified value.</p>
<p>This is equivalent to the<b> find -gui</b> command.</p>
<p><b>Find</b></p>
<p>Opens a window that allows you to compare two regions of</p>
<p>memory.</p>
<p>This is equivalent to the<b> compare -gui</b> command.</p>
<p><b>Compare</b></p>
<p>Opens a window that allows you to load the contents of a file</p>
<p>on the host machine into a portion of memory on the target.</p>
<p>This is equivalent to the<b> memload -gui</b> command.</p>
<p><b>Load</b></p>
<p>Opens a window that allows you to save a region of memory</p>
<p>on the target to a file on the host.</p>
<p>This is equivalent to the<b> memdump -gui</b> command.</p>
<p><b>Dump</b></p>
<p>Writes memory modifications made in the<b> Memory View</b></p>
<p>window to the target.</p>
<p>Selecting this menu item is equivalent to clicking the<b> Write</b></p>
<p><b>Changes to Target</b> button (</p>
<p>) or selecting<b> Write Changes</b></p>
<p><b>to Target</b> from the shortcut menu.</p>
<p><b>Write Changes to Target</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>332</i></p>
<p><i>Chapter 15. Using the Memory View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Forces the window to update its contents, even if frozen, by</p>
<p>immediately re-reading target memory.</p>
<p>Selecting this menu item is equivalent to clicking the<b> Reload</b></p>
<p>button (</p>
<p>) or selecting<b> Reload from Target</b> from the shortcut</p>
<p>menu.</p>
<p><b>Reload from Target</b></p>
<p>Opens a window that allows you to specify preferred read</p>
<p>and write access sizes.</p>
<p>Selecting this menu item is equivalent to double-clicking the</p>
<p>access size display area.</p>
<p><b>Set Access Sizes</b></p>
<p>Toggles whether or not the<b> Memory View</b> window performs</p>
<p>all target memory reads as block memory accesses. By default,</p>
<p>this option is enabled. For more information, see âDisabling</p>
<p>Block Readsâ on page 329.</p>
<p>Selecting this menu item is equivalent to right-clicking the</p>
<p>access size display area and selecting<b> Use Block Reads</b>.</p>
<p><b>Use Block Reads</b></p>
<p>Opens the<b> Cache View</b> window. See âThe Cache View</p>
<p>Windowâ on page 392.</p>
<p>Selecting this menu item is equivalent to clicking the<b> Open</b></p>
<p><b>Cache View</b> button (</p>
<p>).</p>
<p>This menu item is not available for all targets.</p>
<p><b>Open Cache View</b></p>
<p>Opens the<b> Cache Find</b> window on the active location. See</p>
<p>âThe Cache Find Windowâ on page 396.</p>
<p>Selecting this menu item is equivalent to clicking the<b> Find</b></p>
<p><b>in Caches</b> button (</p>
<p>).</p>
<p>This menu item is not available for all targets.</p>
<p><b>Find in Caches</b></p>
<p>Saves the contents of the<b> Memory View</b> window to a text</p>
<p>file. The information contained in the text file is formatted</p>
<p>exactly as it appears in the columns of the<b> Memory View</b></p>
<p>window.</p>
<p>Selecting this menu item is equivalent to clicking the<b> Save</b></p>
<p><b>Current View to File</b> button (</p>
<p>).</p>
<p><b>Save View to File</b></p>
<p>Prints the memory pane contents. All view column data is</p>
<p>printed for each address currently in view.</p>
<p>Selecting this menu item is equivalent to clicking the<b> Print</b></p>
<p>button (</p>
<p>).</p>
<p><b>Print</b></p>
<p>Saves the memory pane settings as the default<b> Memory View</b></p>
<p>window configuration.</p>
<p><b>Save Settings as Default</b></p>
<p><i>333</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Memory Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Closes the<b> Memory View</b> window.</p>
<p>Selecting this menu item is equivalent to clicking the<b> Close</b></p>
<p>button (</p>
<p>).</p>
<p><b>Close</b></p>
<p>For information about the commands referenced in the preceding table, see Chapter</p>
<p>10, âMemory Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p><b>The View Menu</b></p>
<p>The following table lists the options available in the<b> View</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Opens a submenu providing a number of view column</p>
<p>formats. Selecting a format adds a view column of the</p>
<p>specified type to the memory pane. New columns are added</p>
<p>to the right of the last column in the window. For more</p>
<p>information about view formats, see the âThe Column</p>
<p>Submenuâ on page 334.</p>
<p><b>Add New Column</b></p>
<p>Opens a submenu with a number of options affecting the</p>
<p>specified column. See the âThe Column Submenuâ</p>
<p>on page 334.</p>
<p>This menu item is repeated for each column.</p>
<p>Selecting this menu item is equivalent to right-clicking a</p>
<p>column's header.</p>
<p><b>Column<i> number name</b></i></p>
<p><b>The Column Submenu</b></p>
<p>The following table lists the options available from the<b> View</b> â<b> Column<i> number</b></i></p>
<p><i><b>name</b></i> submenu. You can also access these same menu items by right-clicking a</p>
<p>column's header. You may see additional view column formats if your CPU supports</p>
<p>them.</p>
<p>Unless otherwise stated, all descriptions of toggle options explain the behavior of</p>
<p>the option when enabled.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>334</i></p>
<p><i>Chapter 15. Using the Memory View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Hides or shows the column. This option toggles between<b> Hide</b></p>
<p>and<b> Show</b>.</p>
<p><b>Hide</b>/<b>Show</b></p>
<p>Deletes the column.</p>
<p><b>Remove</b></p>
<p>Sets the column to automatically adjust its width to contain</p>
<p>displayed data.</p>
<p><b>Size to Fit</b></p>
<p>Displays the column's memory contents as hexadecimal</p>
<p>numbers.*</p>
<p><b>Hex</b></p>
<p>Displays the column's memory contents as decimal numbers.*</p>
<p><b>Decimal</b></p>
<p>Displays the column's memory contents as binary numbers.*</p>
<p><b>Binary</b></p>
<p>Displays the column's memory contents as floating-point</p>
<p>numbers.*</p>
<p><b>Floating Point</b></p>
<p>Displays the column's memory contents as fixed point</p>
<p>numbers.*</p>
<p><b>Fixed Point</b></p>
<p>Displays the column's memory contents as ASCII characters.</p>
<p>Any memory that cannot be represented by an ASCII character</p>
<p>is displayed as a dot (</p>
<p>.</p>
<p>).</p>
<p><b>Ascii</b></p>
<p>Displays the column's memory contents as a comma-separated</p>
<p>list of global symbols. Symbols that continue from previous</p>
<p>addresses are represented with the string â</p>
<p>...</p>
<p>â.</p>
<p><b>Symbols</b></p>
<p>Displays the column's memory contents as a</p>
<p>semicolon-separated list of assembly instructions. In regions</p>
<p>of memory without symbol information, inaccurate</p>
<p>instructions may be displayed if the beginning of the window</p>
<p>is not aligned with the start of an instruction.</p>
<p><b>Disassembly</b></p>
<p>Displays the offset between the active location and the start</p>
<p>of the row.</p>
<p><b>Offset</b></p>
<p>Sets the column's unit size. Available<i> numbers</i> are 1, 2, 4, and</p>
<p>8.</p>
<p>These menu items are only available for the<b> Hex</b>,<b> Decimal</b>,</p>
<p>and<b> Binary</b> columns.</p>
<p><i><b>number</i> byte(s)</b></p>
<p>Interprets memory data as signed decimal integers.</p>
<p>This menu item is only available for the<b> Decimal</b> column.</p>
<p><b>Signed</b></p>
<p>Interprets memory data as unsigned decimal integers.</p>
<p>This menu item is only available for the<b> Decimal</b> column.</p>
<p><b>Unsigned</b></p>
<p><i>335</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The View Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Interprets memory data as single precision floating point</p>
<p>numbers.</p>
<p>This menu item is only available for the<b> Floating Point</b></p>
<p>column.</p>
<p><b>Single Precision</b></p>
<p>Interprets memory data as double precision floating point</p>
<p>numbers.</p>
<p>This menu item is only available for the<b> Floating Point</b></p>
<p>column.</p>
<p><b>Double Precision</b></p>
<p>Interprets memory data as q15 fixed point numbers.</p>
<p>This menu item is only available for the<b> Fixed Point</b> column.</p>
<p><b>q15</b></p>
<p>Interprets memory data as q31 fixed point numbers.</p>
<p>This menu item is only available for the<b> Fixed Point</b> column.</p>
<p><b>q31</b></p>
<p>Sets the column byte order to big endian. If this is not the</p>
<p>default byte order for your target, the setting is displayed in</p>
<p>the column header.</p>
<p>This menu item is only available for the<b> Hex</b>,<b> Decimal</b>,</p>
<p><b>Binary</b>,<b> Floating Point</b>, and<b> Fixed Point</b> columns.</p>
<p><b>Big Endian</b></p>
<p>Sets the column byte order to little endian. If this is not the</p>
<p>default byte order for your target, the setting is displayed in</p>
<p>the column header.</p>
<p>This menu item is only available for the<b> Hex</b>,<b> Decimal</b>,</p>
<p><b>Binary</b>,<b> Floating Point</b>, and<b> Fixed Point</b> columns.</p>
<p><b>Little Endian</b></p>
<p>*Numerical formats display unreadable memory as a series of dashes.</p>
<p><b>The Shortcut Menu</b></p>
<p>The following table lists the options available in the shortcut menu that appears</p>
<p>when you right-click the memory pane.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Opens a submenu that allows you to set a hardware breakpoint</p>
<p>on the memory address you right-clicked. For a description</p>
<p>of the items available in this submenu, see âThe Set Hardware</p>
<p>Breakpoint Submenuâ on page 337.</p>
<p>This menu item is only available for the<b> Address</b> column.</p>
<p><b>Set Hardware Breakpoint</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>336</i></p>
<p><i>Chapter 15. Using the Memory View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Writes memory modifications made in the<b> Memory View</b></p>
<p>window to the target.</p>
<p>Selecting this menu item is equivalent to clicking the<b> Write</b></p>
<p><b>Changes to Target</b> button (</p>
<p>) or selecting<b> Memory</b> â</p>
<p><b>Write Changes to Target</b>.</p>
<p><b>Write Changes to Target</b></p>
<p>Forces the window to update its contents, even if frozen, by</p>
<p>immediately re-reading target memory.</p>
<p>Selecting this menu item is equivalent to clicking the<b> Reload</b></p>
<p>button (</p>
<p>) or selecting<b> Memory</b> â<b> Reload from Target</b>.</p>
<p><b>Reload from Target</b></p>
<p><b>The Set Hardware Breakpoint Submenu</b></p>
<p>The following table lists the options available from the shortcut menu's<b> Set</b></p>
<p><b>Hardware Breakpoint</b> submenu. This submenu is only available for the<b> Address</b></p>
<p>column.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Sets a new hardware breakpoint that is hit when your program</p>
<p>writes to the memory address you right-clicked.</p>
<p><b>Set Write Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Opens the<b> Hardware Breakpoint Editor</b> with the memory</p>
<p>address that you right-clicked already filled in. This allows</p>
<p>you to configure the properties of the hardware breakpoint</p>
<p>before it is set.</p>
<p><b>Set and Edit</b></p>
<p><i>337</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Shortcut Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 16</b></p>
<p><b>Viewing Memory Allocation</b></p>
<p><b>Information</b></p>
<p><b>Contents</b></p>
<p>Using the Memory Allocations Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>340</p>
<h1 style="page-break-before:always; "></h1>
<p><b>Using the Memory Allocations Window</b></p>
<p>If you built or linked your program using the MULTI Builder, you can use the</p>
<p><b>Memory Allocations</b> window to examine your program's heap allocations. The</p>
<p><b>Memory Allocations</b> window is most useful for tracking down memory leaks,</p>
<p>displaying overall heap usage, visualizing heap fragmentation, and detecting run-time</p>
<p>memory errors.</p>
<p>To get the most out of the<b> Memory Allocations</b> window when you are developing</p>
<p>for an embedded target, enable run-time memory checking by setting Builder or</p>
<p>driver options prior to compiling your program. For Solaris and x86-based Linux</p>
<p>targets, you may be able to access run-time memory checking information without</p>
<p>setting build options. Unless you have enabled call count profiling, simply open</p>
<p>the<b> Memory Allocations</b> window before starting program execution. If you have</p>
<p>enabled call count profiling, you must explicitly enable run-time memory checking</p>
<p>via Builder or driver options. See the<i> MULTI: Building Applications</i> book for</p>
<p>information about enabling run-time memory checks.</p>
<p>You can open the<b> Memory Allocations</b> window at any time by doing one of the</p>
<p>following:</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Memory Allocations</b>.</p>
<p>â¢</p>
<p>Enter the<b> heapview</b> command in the command pane. For more information</p>
<p>about this command, see âGeneral View Commandsâ in Chapter 22, âView</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>The<b> Memory Allocations</b> window is designed for use during run-mode</p>
<p>debugging. However, the window may also display helpful information</p>
<p>if launched on the master process during a freeze-mode debugging session</p>
<p>(that is, if the master process is selected in the target list when you open</p>
<p>the window). The<b> Memory Allocations</b> window is not accessible if you</p>
<p>attempt to open it when an OSA task is selected in the target list. For</p>
<p>information about freeze-mode debugging, the master process, and OSA</p>
<p>tasks, see Chapter 26, âFreeze-Mode Debugging and OS-Awarenessâ</p>
<p>on page 605.</p>
<p>Before you can perform any of the operations available through the<b> Memory</b></p>
<p><b>Allocations</b> window, your process must be halted, and, if you are debugging in run</p>
<p><i>MULTI: Debugging</i></p>
<p><i>340</i></p>
<p><i>Chapter 16. Viewing Memory Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p>mode, you must be able to run the program; it cannot be blocked or pending. A</p>
<p>convenient way to halt the process is to set a breakpoint on the last line of your</p>
<p>program's source code and then open the window when the process hits the</p>
<p>breakpoint. For information about run-mode debugging, see Chapter 25, âRun-Mode</p>
<p>Debuggingâ on page 577.</p>
<p><b>Note</b></p>
<p>When you use the<b> Memory Allocations</b> window to view allocations,</p>
<p>leaks, and run-time errors, code that may allow interrupts to be serviced</p>
<p>is executed on the target. If any interrupt servicing results in calls to</p>
<p>memory allocation routines, the memory checking code may crash or</p>
<p>give inaccurate results. You may need to disable interrupts before using</p>
<p>these memory analysis operations. Use of the visualization should be</p>
<p>safe, however, as it only reads the target memory and does not execute</p>
<p>any code on the target.</p>
<p>The<b> Memory Allocations</b> window contains the following three tabs:</p>
<p>â¢</p>
<p><b>Visualization</b> â Displays an interactive visualization of the program's heap</p>
<p>and information about the application's overall memory usage. For more</p>
<p>information, see âViewing the Memory Allocation Visualizationâ on page 343.</p>
<p>â¢</p>
<p><b>Leaks</b> â Displays unreachable blocks of memory. For more information, see</p>
<p>âViewing Memory Leaks and Allocation Informationâ on page 347.</p>
<p>â¢</p>
<p><b>Allocations</b> â Displays all allocated blocks of memory, including the</p>
<p>unreachable blocks displayed on the<b> Leaks</b> tab. For more information, see</p>
<p>âViewing Memory Leaks and Allocation Informationâ on page 347.</p>
<p>By default, the<b> Visualization</b> tab is displayed when the<b> Memory Allocations</b></p>
<p>window is first opened (unless you have used the<b> showleaks</b> or<b> showallocations</b></p>
<p>argument with the<b> heapview</b> command). For information about the<b> heapview</b></p>
<p>command, see âGeneral View Commandsâ in Chapter 22, âView Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>The deprecated<b> findleaks</b> command provided in previous versions of</p>
<p>MULTI is equivalent to<b> heapview showleaks</b>.</p>
<p><i>341</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the Memory Allocations Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Memory Allocations</b> window contains four menus:<b> File</b>,<b> Checking</b>,<b> View</b>,</p>
<p>and<b> Help</b>. Menu items are described in the table below. Unless otherwise stated,</p>
<p>all descriptions of toggle menu items explain the behavior of the menu item when</p>
<p>enabled.</p>
<p>Opens a<b> Save Report</b> dialog that allows you to</p>
<p>specify a file to save the contents of the active</p>
<p>tab (<i>information</i> will appear on the menu as</p>
<p><b>Visualization</b>,<b> Leaks</b>, or<b> Allocations</b>, depending</p>
<p>on which tab is active).</p>
<p><b>File</b> â<b> Save<i> information</b></i></p>
<p>Prints the contents of the active tab (<i>information</i></p>
<p>will appear on the menu as<b> Visualization</b>,<b> Leaks</b>,</p>
<p>or<b> Allocations</b>, depending on which tab is</p>
<p>active).</p>
<p><b>File</b> â<b> Print<i> information</b></i></p>
<p>Closes the<b> Memory Allocations</b> window.</p>
<p><b>File</b> â<b> Close</b></p>
<p>Specifies the amount and frequency of run-time</p>
<p>error checking. For more information, see the</p>
<p>documentation about performing selective</p>
<p>run-time memory checking in the<i> MULTI:</i></p>
<p><i>Building Applications</i> book.</p>
<p><b>Note</b>: The current state of the<b> Checking</b> menu</p>
<p>items is stored on the target. Selecting an item</p>
<p>from the<b> Checking</b> menu causes a procedure call</p>
<p>to be executed on the target, so be sure the</p>
<p>process is halted in a safe location first (see</p>
<p>âBefore Performing Operations that Execute</p>
<p>Procedure Callsâ on page 349). If the target</p>
<p>cannot be accessed, the menu items in the</p>
<p><b>Checking</b> menu appear dimmed.</p>
<p><b>Checking</b> â<b> Disable Checking</b></p>
<p><b>Checking</b> â<b> Minimal Checking</b></p>
<p><b>Checking</b> â<b> Occasionally Maximal</b></p>
<p><b>Checking</b></p>
<p><b>Checking</b> â<b> Frequently Maximal</b></p>
<p><b>Checking</b></p>
<p><b>Checking</b> â<b> Maximal Checking</b></p>
<p>Displays rounded numbers in the<b> Memory</b></p>
<p><b>Allocations</b> window.</p>
<p><b>View</b> â<b> Human Readable Numbers</b></p>
<p>Displays the hexadecimal equivalent for memory</p>
<p>sizes in the<b> Memory Allocations</b> window.</p>
<p><b>View</b> â<b> Show Hexadecimal Values</b></p>
<p>Displays unused sections of the heap as memory</p>
<p>blocks. Otherwise, discontinuities are collapsed</p>
<p>into a single bar.</p>
<p><b>View</b> â<b> Display Heap Discontinuities as</b></p>
<p><b>Blocks</b></p>
<p>Clears the run-time errors displayed in the lower</p>
<p>pane of the<b> Memory Allocations</b> window.</p>
<p><b>View</b> â<b> Clear Runtime Errors</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>342</i></p>
<p><i>Chapter 16. Viewing Memory Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Opens the MULTI Help Viewer on</p>
<p>documentation for the<b> Memory Allocations</b></p>
<p>window.</p>
<p><b>Help</b> â<b> Memory Allocations Help</b></p>
<p><b>Viewing the Memory Allocation Visualization</b></p>
<p>To view a visualization of an application's memory usage, click the<b> Visualization</b></p>
<p>tab of the<b> Memory Allocations</b> window (if it is not already the active tab) and click</p>
<p>the<b> Refresh Visualization</b> button (</p>
<p>). An example<b> Visualization</b> tab view is</p>
<p>shown next.</p>
<p>The<b> Visualization</b> tab of the<b> Memory Allocations</b> window is divided into several</p>
<p>panes.</p>
<p>The upper-left pane displays general statistics about the memory usage of your</p>
<p>application. The information that is available varies depending upon whether your</p>
<p>application was built with run-time memory checking enabled. The following list</p>
<p>describes the information that may be available in this pane.</p>
<p><i>343</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing the Memory Allocation Visualization</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><b>Heap Size (bytes)</b>:</p>
<p>â</p>
<p><b>reserved size</b> â Amount of memory initially reserved for the heap in</p>
<p>bytes.</p>
<p>â</p>
<p><b>current</b> â Current size of the heap given to the application by the</p>
<p>operating system.</p>
<p><b>Note</b></p>
<p>The current heap size may exceed the reserved size if the</p>
<p>malloc()</p>
<p>library extends the heap beyond the region initially</p>
<p>reserved for it. For more information, see your target operating</p>
<p>system's documentation for</p>
<p>malloc()</p>
<p>. If you are using</p>
<p>INTEGRITY, see the documentation about heap configuration</p>
<p>in the<i> INTEGRITY Development Guide</i>.</p>
<p>â</p>
<p><b>allocated</b> â Aggregate amount of heap memory currently used by your</p>
<p>application in allocated blocks. This is further broken down into:</p>
<p>â </p>
<p><b>user</b> â Amount of heap memory allocated by the user. This</p>
<p>information is only present when run-time memory checking is</p>
<p>enabled.</p>
<p>â </p>
<p><b>overhead</b> â Amount of memory used internally by the</p>
<p>malloc()</p>
<p>library for memory error checking. This information is only present</p>
<p>when run-time memory checking is enabled.</p>
<p>â</p>
<p><b>free</b> â Aggregate amount of heap memory available to your application</p>
<p>in free heap blocks.</p>
<p>â</p>
<p><b>left to grow</b> â Amount of reserved memory that is left for the heap to</p>
<p>grow. This information is not present if the heap size exceeds the reserved</p>
<p>size and extends into unreserved memory.</p>
<p>â¢</p>
<p><b>Blocks</b>:</p>
<p>â</p>
<p><b>total</b> â Total number of blocks in the heap visualization.</p>
<p>â</p>
<p><b>allocated</b> â Number of blocks in the heap allocated by the application.</p>
<p>â</p>
<p><b>free</b> â Number of free blocks in the heap.</p>
<p>â</p>
<p><b>discontinuities</b> â Number of discontinuities in the heap section.</p>
<p>Discontinuities can appear when the heap extends into unreserved memory.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>344</i></p>
<p><i>Chapter 16. Viewing Memory Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><b>Calls</b> â Number of calls to the memory management functions<b> sbrk()</b>,</p>
<p><b>malloc()</b>,<b> calloc()</b>,<b> realloc()</b>, and<b> free()</b>. The<b> sbrk()</b> function is typically called</p>
<p>internally by the<b> malloc()</b> library to request memory from the operating system.</p>
<p>These functions are only present when run-time memory checking is enabled.</p>
<p>â¢</p>
<p><b>Other Statistics</b>:</p>
<p>â</p>
<p><b>block alignment</b> â All heap blocks are a multiple of the alignment for</p>
<p>the architecture currently being debugged.</p>
<p>â</p>
<p><b>cumulative allocated</b> â Total number of bytes the application has</p>
<p>allocated up to the current point in its execution. Because this statistic</p>
<p>counts only allocations, it never decreases during the course of execution.</p>
<p>This information is only present when run-time memory checking is</p>
<p>enabled.</p>
<p>â</p>
<p><b>peak user allocated</b> â Maximum aggregate amount of memory the</p>
<p>application has allocated at any one time. This information is only present</p>
<p>when run-time memory checking is enabled.</p>
<p>â</p>
<p><b>largest allocated block size</b> â Size of the largest block of memory</p>
<p>currently allocated. This information is only present when run-time memory</p>
<p>checking is enabled.</p>
<p>â</p>
<p><b>largest free block size</b> â Size of the current largest free block of memory.</p>
<p>This information is only present when run-time memory checking is</p>
<p>enabled.</p>
<p>The upper-right pane of the<b> Visualization</b> tab displays a visualization of the heap.</p>
<p>In this visualization, sequences of red squares indicate allocated blocks of memory,</p>
<p>while sequences of green squares indicate free blocks of memory. Adjacent allocated</p>
<p>or free blocks alternate shades for clarity. Blocks that are recognized as</p>
<p>malloc()</p>
<p>overhead are marked in purple. Discontinuities in the heap are shown as long gray</p>
<p>bars unless you have enabled<b> View</b> â<b> Display Heap Discontinuities as Blocks</b>,</p>
<p>in which case, discontinuities are displayed as gray blocks.</p>
<p>When<b> Autosize Heap Visualization</b> is selected (the default), the visualization is</p>
<p>sized to fit best in the window. The zoom level is chosen automatically based on</p>
<p>the visible size of the visualization pane and the amount of allocated and free space</p>
<p>in the heap. You can use the zoom buttons (</p>
<p>and</p>
<p>) to look at specific sections</p>
<p>in more or less detail. Clicking one of these buttons automatically deselects<b> Autosize</b></p>
<p><b>Heap Visualization</b>. Note that each heap block (no matter how small) is always</p>
<p><i>345</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing the Memory Allocation Visualization</i></p>
<h1 style="page-break-before:always; "></h1>
<p>depicted using at least one square, so the amount of heap represented by each square</p>
<p>may vary widely when you have zoomed out all the way.</p>
<p>Click any of the squares in the heap visualization to get more details about a specific</p>
<p>heap block. These details appear in the bottom pane, described next. You can</p>
<p>navigate among heap blocks by clicking them in the visualization or by using the</p>
<p>arrows located in the middle-right side of window.</p>
<p>The bottom pane of the<b> Visualization</b> tab displays specific details about the heap</p>
<p>block you have chosen in the heap visualization pane. In addition, the check boxes</p>
<p>located above the bottom pane allow you to search several locations in memory for</p>
<p>references to a particular heap block. The following list describes the memory</p>
<p>locations you can search.</p>
<p>â¢</p>
<p><b>Registers</b> â Search the general purpose registers for references to this heap</p>
<p>block.</p>
<p>â¢</p>
<p><b>Stack</b> â Search the program stack for references to this heap block.</p>
<p>â¢</p>
<p><b>Globals</b> â Search the program globals (such as those defined in</p>
<p>.data</p>
<p>or</p>
<p>.bss</p>
<p>sections) for references to this heap block.</p>
<p>â¢</p>
<p><b>Heap</b> â Search the other allocated blocks of the heap for references to this</p>
<p>heap block.</p>
<p>If run-time errors are detected while the<b> Memory Allocations</b> window is open,</p>
<p>they are displayed below the block references. To clear run-time errors, select<b> View</b></p>
<p>â<b> Clear Runtime Errors</b>.</p>
<p><b>Updating the Visualization</b></p>
<p>Because gathering heap visualization information can take a long time, the</p>
<p><b>Visualization</b> tab is not automatically refreshed when your program's state changes.</p>
<p>A warning message appears, however, and you can click the<b> Refresh Visualization</b></p>
<p>button (</p>
<p>) to refresh the visualization and the statistics. Switching among the tabs</p>
<p>does not refresh the visualization.</p>
<p><b>Note</b></p>
<p>Updating the<b> Visualization</b> tab while the program is halted inside</p>
<p>malloc()</p>
<p>library code may cause incorrect heap data to be displayed.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>346</i></p>
<p><i>Chapter 16. Viewing Memory Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Memory Leaks and Allocation Information</b></p>
<p>The<b> Leaks</b> tab of the<b> Memory Allocations</b> window displays unreachable blocks</p>
<p>of memory, while the<b> Allocations</b> tab displays all allocated blocks of memory,</p>
<p>including unreachable blocks. An example<b> Leaks</b> tab view is shown next.</p>
<p>The columns of the<b> Leaks</b> and<b> Allocations</b> tabs display the following information</p>
<p>for each block of memory:</p>
<p>â¢</p>
<p><b>Root</b> â Any memory block that is referenced by another block in the heap is</p>
<p>marked with a dot in this column. If a memory block is not referenced by</p>
<p>anything else on the heap, it is considered a root and is marked with a red</p>
<p>asterisk. In cases where a memory block contains pointers to memory that</p>
<p>becomes unreachable when the block itself becomes unreachable, this marking</p>
<p>makes it easier to find the origin of memory leaks. For example, suppose a</p>
<p>linked list is leaked. The memory block that contains the head of the linked list</p>
<p>is marked with a red asterisk, and everything following the head of the list is</p>
<p>marked with a gray dot.</p>
<p>This information is only present when run-time memory checking is enabled.</p>
<p>â¢</p>
<p><b>Length</b> â The size of the allocated block in bytes.</p>
<p><i>347</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Memory Leaks and Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><b>Caller 0</b>,<b> Caller 1</b>, etc. â The procedure and line number (or address) of the</p>
<p>first five levels of the call stack of the allocation. (On some native targets</p>
<p>(Solaris and x86-based Linux), there may be more than five levels.)</p>
<p>â¢</p>
<p><b>Address</b> â The address of the block of memory.</p>
<p>â¢</p>
<p><b>PID</b> or<b> TID</b> â The process or task ID of the process that called</p>
<p>malloc()</p>
<p>, if</p>
<p>applicable. This column is only shown when run-time memory checking is</p>
<p>enabled and the target supports reporting of process or task IDs on a</p>
<p>per-allocation basis.</p>
<p>If the<b> Leaks</b> or<b> Allocations</b> tab is up to date with respect to the<b> Visualization</b> tab,</p>
<p>block information for the selected leak or allocation (including the references selected</p>
<p>in the<b> Visualization</b> tab) is shown in the bottom pane.</p>
<p><b>Note</b></p>
<p>Viewing memory leaks and allocation information requires that a small</p>
<p>amount of target memory be available. If the heap has been exhausted,</p>
<p>checking for leaks and allocations is not supported.</p>
<p><b>Manipulating Procedures and Memory Blocks</b></p>
<p>You can perform the following actions on the information that is displayed on the</p>
<p><b>Leaks</b> and<b> Allocations</b> tabs of the<b> Memory Allocations</b> window:</p>
<p><b>Do this</b></p>
<p><b>To</b></p>
<p>Double-click the address of the memory block.</p>
<p>View a memory block in a<b> Memory View</b></p>
<p>window</p>
<p>Click the procedure.</p>
<p>Display a procedure in the Debugger's source</p>
<p>pane</p>
<p>Double-click the procedure.</p>
<p>Edit a procedure in the Editor</p>
<p>Select the desired leaks and click the<b> Reclaim</b></p>
<p><b>Leaks</b> button on the<b> Leaks</b> tab.</p>
<p><b>Note:</b> This causes a procedure call to be</p>
<p>executed on the target, so be sure the process</p>
<p>is halted in a safe location. For more</p>
<p>information, see âBefore Performing</p>
<p>Operations that Execute Procedure Callsâ</p>
<p>on page 349.</p>
<p>Reclaim some leaks by calling</p>
<p>free()</p>
<p>on</p>
<p>them</p>
<p><i>MULTI: Debugging</i></p>
<p><i>348</i></p>
<p><i>Chapter 16. Viewing Memory Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Before Performing Operations that Execute Procedure Calls</b></p>
<p>Some of the operations available from the<b> Leaks</b> and<b> Allocations</b> tabs of the</p>
<p><b>Memory Allocations</b> window cause a procedure call to be executed on the target.</p>
<p>As a result, you should be sure that the process is halted in a safe location before</p>
<p>performing one of these operations, which are identified in the following list:</p>
<p>â¢</p>
<p>Displaying the<b> Checking</b> menu or selecting any of its items.</p>
<p>â¢</p>
<p>Refreshing leaks or allocations (see âRefreshing Leaks and Allocations</p>
<p>Informationâ on page 349)</p>
<p>â¢</p>
<p>Reclaiming leaks (see âManipulating Procedures and Memory Blocksâ</p>
<p>on page 348)</p>
<p>â¢</p>
<p>Tracking leaks or allocations (see âTracking Leaks and Allocationsâ</p>
<p>on page 350)</p>
<p>A convenient way to halt your process in a safe location is to set a breakpoint in</p>
<p>the program and wait for the breakpoint to be hit.</p>
<p>The following information describes locations where it is unsafe to be halted when</p>
<p>performing one of the preceding operations.</p>
<p>â¢</p>
<p>On INTEGRITY, the program should not be halted inside a Task that you have</p>
<p>not created, such as the kernel's Idle Task. For more information, see the</p>
<p>documentation about run-mode debugging limitations in the<i> INTEGRITY</i></p>
<p><i>Development Guide</i>.</p>
<p>â¢</p>
<p>The program should not be halted inside a task that holds the lock from</p>
<p>__ghsLock()</p>
<p>. Additionally, no task in the address space should be halted in</p>
<p>a location where it holds the lock from</p>
<p>__ghsLock()</p>
<p>. The preceding</p>
<p>operations, which rely on being able to obtain this lock, become pended if you</p>
<p>try to complete them while the lock from</p>
<p>__ghsLock()</p>
<p>is held.</p>
<p>â¢</p>
<p>When run-time memory checking is enabled, the program should not be halted</p>
<p>inside</p>
<p>malloc()</p>
<p>library code.</p>
<p><b>Refreshing Leaks and Allocations Information</b></p>
<p>Because the operation of finding leaks and allocations can be slow and invasive,</p>
<p>the<b> Leaks</b> and<b> Allocations</b> tabs do not automatically refresh every time the process</p>
<p><i>349</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Memory Leaks and Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p>is stopped. To refresh the leaks and allocations information, click the<b> Refresh Leaks</b></p>
<p>or<b> Refresh Allocations</b> button (</p>
<p>). Note that refreshing leaks or allocations causes</p>
<p>a procedure call to be executed on the target, so be sure that the process is halted</p>
<p>in a safe location. For more information, see âBefore Performing Operations that</p>
<p>Execute Procedure Callsâ on page 349.</p>
<p><b>Note</b></p>
<p>Refreshing leaks or allocations requires a small amount of dynamic</p>
<p>memory. To guarantee heap integrity, ensure that the target will not</p>
<p>exhaust its heap.</p>
<p><b>Note</b></p>
<p>Because tasks running in the same address space share memory, refreshing</p>
<p>leaks or allocations information for one task while other tasks in the same</p>
<p>address space are still running can lead to inconsistent results. If MULTI</p>
<p>detects that other tasks in an INTEGRITY AddressSpace are still running,</p>
<p>a dialog box appears to inform you of this and to give you the opportunity</p>
<p>to cancel the refresh operation. In this situation, we recommend that you</p>
<p>do the following:</p>
<p>1.</p>
<p>Click<b> No</b> to cancel the refresh operation.</p>
<p>2.</p>
<p>Set breakpoints in your code to stop each of the other tasks. Note</p>
<p>that it is important to stop each of the tasks in your code, and not in</p>
<p>kernel code or in other shared library code. Failing to stop the tasks</p>
<p>in your code can cause the refresh operation to become pended,</p>
<p>waiting for system resources to be released.</p>
<p>3.</p>
<p>Wait until all your tasks have halted at the breakpoints you set.</p>
<p>4.</p>
<p>Refresh leaks or allocations information for the original task.</p>
<p><b>Tracking Leaks and Allocations</b></p>
<p>You can track memory leaks and allocations while your process executes by using</p>
<p>the<b> Mark All</b> button, which marks all blocks of memory currently allocated in the</p>
<p>heap, and the<b> Show Leaks since last Mark</b> or<b> Show Allocations since last Mark</b></p>
<p>check box, which toggles whether only unmarked (or new) leaks or allocations are</p>
<p><i>MULTI: Debugging</i></p>
<p><i>350</i></p>
<p><i>Chapter 16. Viewing Memory Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p>shown. Marked leaks are shaded gray in the<b> Leaks</b> and<b> Allocations</b> tabs. To monitor</p>
<p>memory leaks and allocations:</p>
<p>1.</p>
<p>Halt the application at a safe and useful checkpoint. For information about</p>
<p>safe locations, see âBefore Performing Operations that Execute Procedure</p>
<p>Callsâ on page 349.</p>
<p>2.</p>
<p>Click the<b> Refresh Leaks</b> or<b> Refresh Allocations</b> button (</p>
<p>) to update the</p>
<p><b>Leaks</b> or<b> Allocations</b> information.</p>
<p>3.</p>
<p>While still halted in a safe location, click the<b> Mark All</b> button on the<b> Leaks</b></p>
<p>or<b> Allocations</b> tab of the<b> Memory Allocations</b> window. This marks the current</p>
<p>set of allocations.</p>
<p>4.</p>
<p>Resume execution of the application.</p>
<p>5.</p>
<p>Halt the application in a safe location again.</p>
<p>6.</p>
<p>Click the<b> Refresh Leaks</b> or<b> Refresh Allocations</b> button (</p>
<p>) to update the</p>
<p><b>Leaks</b> or<b> Allocations</b> information.</p>
<p>7.</p>
<p>Select the<b> Show Leaks since last Mark</b> or<b> Show Allocations since last Mark</b></p>
<p>check box so that the tabs display only those leaks and allocations that occurred</p>
<p>since the last time you marked the allocations.</p>
<p>8.</p>
<p>Repeat this process as necessary as you run through the entire application.</p>
<p><b>Note</b></p>
<p>The<b> Mark All</b> button and the<b> Show Leaks since last Mark</b> and<b> Show</b></p>
<p><b>Allocations since last Mark</b> check boxes are only available when</p>
<p>run-time memory checking is enabled.</p>
<p><b>Tip</b></p>
<p>You can achieve the same results by using Debugger commands in the</p>
<p>command pane. The command<b> heapview setmark</b> marks the current set</p>
<p>of allocations, and the command<b> heapview showleaks -new</b> or<b> heapview</b></p>
<p><b>showallocations -new</b> displays the new leaks or allocations. For more</p>
<p>information about the<b> heapview</b> command, see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><i>351</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Memory Leaks and Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Caveats for Leak Information</b></p>
<p>â¢</p>
<p>The<b> Leaks</b> tab of the<b> Memory Allocations</b> window may not display all of the</p>
<p>leaks in the program being debugged at any given moment. If dead variables</p>
<p>are still on the stack or in registers, MULTI assumes they are alive and does</p>
<p>not report anything they reference as a leak. Once the process has run further</p>
<p>(for example, returned out of the current routine, which should clear out the</p>
<p>stack), some or all of these false negatives vanish and additional leaks may</p>
<p>show up.</p>
<p>â¢</p>
<p>In some target implementations, a register may be a base register, a general</p>
<p>purpose register, or both. It is possible that the value of the base register may</p>
<p>point into the heap (for example, on some targets, when the register is the SDA</p>
<p>base pointer, and there is no data). This can prevent a memory leak from being</p>
<p>reported for a dead object at the same location as the base register.</p>
<p>â¢</p>
<p>Blocks referenced only via pointer arithmetic may be falsely marked as leaks.</p>
<p>Additionally, false positives may occur in INTEGRITY applications. For more</p>
<p>information, see the documentation about memory leaks in the<i> INTEGRITY</i></p>
<p><i>Development Guide</i>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>352</i></p>
<p><i>Chapter 16. Viewing Memory Allocation Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 17</b></p>
<p><b>Collecting and Viewing</b></p>
<p><b>Profiling Data</b></p>
<p><b>Contents</b></p>
<p>Types of Profiling Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>354</p>
<p>Overview of Profiling Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>355</p>
<p>Collecting Profiling Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>356</p>
<p>Caveats for Profiling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>360</p>
<p>Disabling the Collection of Profiling Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>360</p>
<p>Viewing Profiling Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>361</p>
<p>The Profile Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>361</p>
<p>Viewing Profiling Information in the Debugger . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>377</p>
<p>Performing Range Analyses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>379</p>
<p>Managing Profiling Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>380</p>
<h1 style="page-break-before:always; "></h1>
<p>MULTI's powerful profiling capabilities allow you to gather and view information</p>
<p>about the performance and coverage of your programs. You can use this information</p>
<p>to analyze and optimize the efficiency of your code.</p>
<p><b>Types of Profiling Data</b></p>
<p>MULTI supports three basic types of profiling data:<i> program counter (PC) samples</i>,</p>
<p><i>call count data</i> (with and without call graph support), and<i> coverage analysis data</i>.</p>
<p>Each are described below:</p>
<p>â¢</p>
<p>PC samples â Contain data about where the process spends its time. You can</p>
<p>view how much time is spent in each function, each basic block, each source</p>
<p>line, each machine instruction, and the entire program. You may be able to</p>
<p>make execution faster by using this information to improve code that accounts</p>
<p>for an unnecessarily large percentage of the total execution time.</p>
<p>â¢</p>
<p>Call count data</p>
<p>â</p>
<p>With call graph support â Contains a record of how many times each</p>
<p>function is called, as well as which child functions are called by each parent</p>
<p>function and how many times each child is called.</p>
<p>â</p>
<p>Without call graph support â Contains a record of how many times each</p>
<p>function is called.</p>
<p>â¢</p>
<p>Coverage analysis data â Contains a record of how many times each basic</p>
<p>block executed. If a given basic block is never executed, the group of</p>
<p>instructions making up the block is considered dead code for the given sample</p>
<p>input. Since the application never reaches the dead code, you can either remove</p>
<p>the code from the application or try to discover if any functionality is missing</p>
<p>from the application as a result of it.</p>
<p>Coverage data can be useful for performance analysis, especially if PC samples</p>
<p>or trace data is not available. The Debugger can use coverage data to determine</p>
<p>the number of times each instruction was executed and then to show how many</p>
<p>instructions were executed in each function and source line, giving you a rough</p>
<p>idea of how much time was spent where.</p>
<p>For a general description of the methods used to collect profiling data, see the next</p>
<p>section.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>354</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Overview of Profiling Methods</b></p>
<p>Both the method that MULTI uses to collect profiling data and the types of data</p>
<p>that MULTI collects is determined by what you choose to profile. You can profile</p>
<p>all tasks in your system (if you are using INTEGRITY version 10 or later), a</p>
<p>trace-enabled target, a run-mode task or AddressSpace on an INTEGRITY target,</p>
<p>or a stand-alone program. Profiling a target running an operating system that does</p>
<p>not support multiple address spaces (such as u-velOSity) is equivalent to profiling</p>
<p>a stand-alone program. The following list states what types of data MULTI outputs</p>
<p>for each of these (see âTypes of Profiling Dataâ on page 354).</p>
<p>â¢</p>
<p>If you profile all tasks in your system (requires INTEGRITY version 10 or</p>
<p>later) â INTEGRITY periodically samples the PC of running tasks, and the</p>
<p>run-mode debug server delivers the following profiling data to MULTI:</p>
<p>â</p>
<p>PC samples</p>
<p>MULTI uses the samples to display information for all tasks in your system.</p>
<p>For more information, see âProfiling All Tasks in Your Systemâ on page 603.</p>
<p>â¢</p>
<p>If you profile a trace-enabled target â MULTI converts trace data into profiling</p>
<p>data that is much more complete, in terms of which instructions are represented,</p>
<p>than profiling data generated by sampling methods. (Sampling methods are</p>
<p>usually timer-driven and can miss important hot spots in a process.)</p>
<p>MULTI is able to convert collected trace data into all the following types of</p>
<p>profiling data:</p>
<p>â</p>
<p>Program counter (PC) samples</p>
<p>â</p>
<p>Call count with call graph data</p>
<p>â</p>
<p>Coverage analysis data</p>
<p>â¢</p>
<p>If you profile a run-mode task or AddressSpace on an INTEGRITY target, or</p>
<p>if you profile a stand-alone program â MULTI collects one or more of the</p>
<p>following types of data:</p>
<p>â</p>
<p>PC samples</p>
<p>â</p>
<p>Call count data with or without call graph support</p>
<p>â</p>
<p>Coverage analysis data</p>
<p><i>355</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Overview of Profiling Methods</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>Only PC samples provide task-specific profiling data. You cannot</p>
<p>collect call count or coverage analysis profiling data for a specific</p>
<p>taskâonly for the encompassing AddressSpace.</p>
<p><b>Generating Profiling Data for a Task, AddressSpace, or Stand-Alone</b></p>
<p><b>Program</b></p>
<p>Green Hills simulators, run-mode debug servers, and some native debug servers</p>
<p>can sample the PC without instrumenting your code. If you are using a debug server</p>
<p>that does not support PC sampling, or if you want to be able to analyze additional</p>
<p>types of profiling data, you must compile your program with the appropriate Builder</p>
<p>or driver options set. See the<i> MULTI: Building Applications</i> book for information</p>
<p>about obtaining profiling information.</p>
<p><b>Collecting Profiling Data</b></p>
<p>This section contains detailed instructions for collecting profiling data for all tasks</p>
<p>in your system, for a trace-enabled target, a single run-mode task or AddressSpace</p>
<p>on an INTEGRITY target, or a stand-alone program. For a general overview of the</p>
<p>methods used to collect profiling data, see âOverview of Profiling Methodsâ</p>
<p>on page 355.</p>
<p>The scope of profiling is limited to what you select in the target list<i> prior</i> to enabling</p>
<p>the collection of profiling data. If you select a run-mode connection and then enable</p>
<p>profiling, profiling data is collected for all tasks in your system. If you select a</p>
<p>trace-enabled target, profiling data is collected for everything on the target. If you</p>
<p>select a run-mode task or AddressSpace on an INTEGRITY target, or if you select</p>
<p>a stand-alone program, profiling data is collected for the task (PC samples only),</p>
<p>AddressSpace, or stand-alone program. If you collect profiling data for one of these</p>
<p>items and then want to profile another, you must disable profiling collection and</p>
<p>clear existing profiling data before selecting and collecting data for the second item.</p>
<p><b>Note</b></p>
<p>If you enable profiling from the Trace List or PathAnalyzer, or with the</p>
<p><b>tracepro</b> command or the<b> TimeMachine</b> â<b> Profile</b> menu selection,</p>
<p>profiling data is generated for all traced tasks or AddressSpaces, regardless</p>
<p><i>MULTI: Debugging</i></p>
<p><i>356</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>of the selection in the target list. (For information about the<b> tracepro</b></p>
<p>command, see Chapter 20, âTrace Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.)</p>
<p><b>Collecting Profiling Data for All Tasks in Your System</b></p>
<p>To collect profiling data for all tasks in your system (requires INTEGRITY version</p>
<p>10 or later), perform the following steps:</p>
<p>1.</p>
<p>In the Debugger's target list, select the run-mode connection.</p>
<p>2.</p>
<p>Enable the collection of profiling data and open the<b> Profile</b> window by doing</p>
<p>one of the following:</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Profile</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> profile</b> command. For</p>
<p>information about the<b> profile</b> command, see Chapter 12, âProfiling</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>By default, profiling is enabled when you open the<b> Profile</b> window. Do not</p>
<p>close the<b> Profile</b> window until you are finished viewing profiling information.</p>
<p>(Closing this window halts the collection of profiling data and clears existing</p>
<p>profiling data.) For information about the<b> Profile</b> window, see âThe Profile</p>
<p>Windowâ on page 361.</p>
<p>3.</p>
<p>In the target list, select a task to view profiling data for that task in the<b> Profile</b></p>
<p>window.</p>
<p>For information about the type of data that appears in the<b> Profile</b> window, see</p>
<p>âOverview of Profiling Methodsâ on page 355.</p>
<p>In addition to the profiling information that appears in the<b> Profile</b> window, the</p>
<p>Debugger's target list displays processor usage for all tasks in your system. For</p>
<p>more information, see âProfiling All Tasks in Your Systemâ on page 603. For</p>
<p>information about other ways to view collected profiling data, see âViewing Profiling</p>
<p>Informationâ on page 361.</p>
<p><i>357</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Collecting Profiling Data for All Tasks in Your System</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Collecting Profiling Data for a Trace-Enabled Target</b></p>
<p>To collect profiling data for a trace-enabled target, perform the following steps:</p>
<p>1.</p>
<p>Trace the code that you want to profile, and retrieve the trace data as described</p>
<p>in âManaging Trace Dataâ on page 405.</p>
<p>2.</p>
<p>Generate profiling data from the collected trace data and open the<b> Profile</b></p>
<p>window on that data by doing one of the following:</p>
<p>â¢</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> Profile</b>.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, click the<b> Profile</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> tracepro</b> command. For</p>
<p>information about the<b> tracepro</b> command, see Chapter 20, âTrace</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>3.</p>
<p>If you are profiling an INTEGRITY, velOSity, or u-velOSity system â Select</p>
<p>a traced task or AddressSpace in the target list to view profiling information</p>
<p>(if available) for the selected item in the<b> Profile</b> window.</p>
<p><b>Note</b></p>
<p>If INTEGRITY trace data includes task switch information, no</p>
<p>profiling data is displayed when you select an AddressSpace in the</p>
<p>target list. If the trace data does not include task switch information,</p>
<p>profiling data for all tasks in the same AddressSpace is displayed</p>
<p>regardless of which task is selected. If you select the OSA master</p>
<p>process, the<b> Profile</b> window only shows profiling data for code that</p>
<p>is not associated with a specific task, such as exception handlers</p>
<p>and the scheduler.</p>
<p><b>Note</b></p>
<p>Depending on what kind of trace hardware you are using, the trace data</p>
<p>may contain cycle counts, instructions, or timestamps. The unit used to</p>
<p>represent time will be displayed in the status bar of the<b> Profile</b> window</p>
<p>(for example, you may see<b> Time is in cycles.</b>).</p>
<p>For information about the types of data that appear in the<b> Profile</b> window, see</p>
<p>âOverview of Profiling Methodsâ on page 355.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>358</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>You can view collected profiling data in a variety of ways. For more information,</p>
<p>see âViewing Profiling Informationâ on page 361.</p>
<p><b>Collecting Profiling Data for a Task, AddressSpace, or Stand-Alone Program</b></p>
<p>To collect profiling data for a run-mode task or AddressSpace on an INTEGRITY</p>
<p>target, or to collect profiling data for a stand-alone program, perform the following</p>
<p>steps:</p>
<p>1.</p>
<p>Before compiling your program, determine whether it is necessary to set Builder</p>
<p>options (or corresponding compiler driver options) to enable profiling. For</p>
<p>information, see âGenerating Profiling Data for a Task, AddressSpace, or</p>
<p>Stand-Alone Programâ on page 356.</p>
<p>2.</p>
<p>If necessary, compile your program with the appropriate profiling options set.</p>
<p>3.</p>
<p>Connect to your target.</p>
<p>4.</p>
<p>In the Debugger's target list, select the run-mode task, run-mode AddressSpace,</p>
<p>or stand-alone program that you want to profile.</p>
<p>5.</p>
<p>Enable the collection of profiling data and open the<b> Profile</b> window by doing</p>
<p>one of the following:</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Profile</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> profile</b> command. For</p>
<p>information about the<b> profile</b> command, see Chapter 12, âProfiling</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>By default, profiling is enabled when you open the<b> Profile</b> window. Do not</p>
<p>close the<b> Profile</b> window until you are finished viewing profiling information.</p>
<p>(Closing this window halts the collection of profiling data and clears existing</p>
<p>profiling data.) For information about the<b> Profile</b> window, see âThe Profile</p>
<p>Windowâ on page 361.</p>
<p>6.</p>
<p>Step or run the program.</p>
<p>7.</p>
<p>Usually, you should let your program run at least once before expecting to see</p>
<p>any information in the open<b> Profile</b> window. (By default, MULTI processes</p>
<p>collected profiling data automatically each time your program exits. After the</p>
<p>data has been processed, profiling information appears in the<b> Profile</b> window.)</p>
<p>In some situations, however, you may prefer to halt the process early and</p>
<p><i>359</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Collecting Profiling Data for a Task, AddressSpace, or Stand-Alone Program</i></p>
<h1 style="page-break-before:always; "></h1>
<p>manually dump and process collected profiling data. For more information,</p>
<p>see âManually Dumping Profiling Dataâ on page 381 and âManually Processing</p>
<p>Profiling Dataâ on page 383.</p>
<p>For information about the types of data that appear in the<b> Profile</b> window, see</p>
<p>âOverview of Profiling Methodsâ on page 355.</p>
<p>For information about the different ways you can view collected profiling data, see</p>
<p>âViewing Profiling Informationâ on page 361.</p>
<p><b>Caveats for Profiling</b></p>
<p>â¢</p>
<p>If you are profiling a run-mode task on an INTEGRITY target, only PC samples</p>
<p>provide task-specific profiling data. You cannot collect call count or coverage</p>
<p>analysis profiling data for a specific taskâonly for the encompassing</p>
<p>AddressSpace.</p>
<p>â¢</p>
<p>If you profile a stand-alone program, you can only collect PC samples if you</p>
<p>open the<b> Profile</b> window prior to downloading, stepping, or running the</p>
<p>program.</p>
<p><b>Disabling the Collection of Profiling Data</b></p>
<p><b>Note</b></p>
<p>This information is only relevant if you are profiling all tasks in your</p>
<p>system, a run-mode task or AddressSpace on an INTEGRITY target, or</p>
<p>a stand-alone program.</p>
<p>To disable the collection of profiling data:</p>
<p>â¢</p>
<p>If you are profiling all tasks in your system â Halt the target. Alternatively,</p>
<p>click the<b> Close</b> button (</p>
<p>) to close the<b> Profile</b> window, disable the collection</p>
<p>of profiling data, and clear existing profiling data. (Whether this button appears</p>
<p>on your toolbar depends on your MULTI configuration.)</p>
<p>â¢</p>
<p>If you are profiling a run-mode task or AddressSpace, or if you are profiling</p>
<p>a stand-alone program â In the<b> Profile</b> window, click the<b> Stop collecting</b></p>
<p><b>profile information</b> button (</p>
<p>). Alternatively, click the<b> Close</b> button (</p>
<p>) to</p>
<p>close the<b> Profile</b> window, disable the collection of profiling data, and clear</p>
<p><i>MULTI: Debugging</i></p>
<p><i>360</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>existing profiling data. (Whether this last button appears on your toolbar depends</p>
<p>on your MULTI configuration.)</p>
<p><b>Viewing Profiling Information</b></p>
<p>After you have collected profiling data (see âCollecting Profiling Dataâ on page 356),</p>
<p>you can view the information in a variety of ways:</p>
<p>â¢</p>
<p><i>In profiling reports</i> â The tabs in the<b> Profile</b> window display profiling</p>
<p>information in different report formats. For more information, see âProfiling</p>
<p>Reportsâ on page 363.</p>
<p>â¢</p>
<p><i>In the Debugger window</i> â The Debugger can indicate the percentage of time</p>
<p>spent in each source line (or each instruction, if in assembly-only mode or</p>
<p>interlaced assembly mode), which lines of code were never executed, the</p>
<p>number of times each source line was executed, or the number of times each</p>
<p>function was called. For more information, see âViewing Profiling Information</p>
<p>in the Debuggerâ on page 377.</p>
<p>â¢</p>
<p><i>In a Range Analysis window</i> â This window allows you to specify a range of</p>
<p>hexadecimal addresses to examine. For more information, see âPerforming</p>
<p>Range Analysesâ on page 379.</p>
<p>â¢</p>
<p><i>In a dynamic call graph Browse window</i> â This window displays a call graph</p>
<p>generated at run time. For more information, see âBrowsing Dynamic Calls by</p>
<p>Functionâ on page 246.</p>
<p><b>Note</b></p>
<p>Support for these display capabilities depends on what you profile and/or</p>
<p>on the type of profiling data available. For more information, see the</p>
<p>referenced sections.</p>
<p><b>The Profile Window</b></p>
<p>The<b> Profile</b> window allows you to view collected profiling data in various report</p>
<p>formats. For information about how to enable profiling and open the<b> Profile</b> window,</p>
<p>see âCollecting Profiling Data for All Tasks in Your Systemâ on page 357,</p>
<p>âCollecting Profiling Data for a Trace-Enabled Targetâ on page 358, or âCollecting</p>
<p>Profiling Data for a Task, AddressSpace, or Stand-Alone Programâ on page 359.</p>
<p><i>361</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Profiling Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If you profile all tasks in your system or if you profile a trace-enabled target, the</p>
<p><b>Profile</b> window looks similar to the following graphic.</p>
<p>If you profile a run-mode task or AddressSpace on an INTEGRITY target, or if you</p>
<p>profile a stand-alone program, the buttons on the toolbar and the availability of</p>
<p>reports and of menu items differ. In this situation, the<b> Profile</b> window looks similar</p>
<p>to the following graphic.</p>
<p><b>Note</b></p>
<p>The information available in the<b> Profile</b> window may vary slightly</p>
<p>according to your target type. For example, profiling with a cycle-accurate</p>
<p>simulator may yield additional columns in the reports containing cycle</p>
<p>information. For additional notes about profiling for your specific target,</p>
<p><i>MULTI: Debugging</i></p>
<p><i>362</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>see the<i> MULTI: Configuring Connections</i> and the<i> MULTI: Building</i></p>
<p><i>Applications</i> books for your target type.</p>
<p>The following sections explain the various features of the<b> Profile</b> window. For a</p>
<p>detailed description of all the menu items and buttons, see âThe Profile Window</p>
<p>Referenceâ on page 372.</p>
<p><b>Continual Updates in the Profile Window</b></p>
<p><b>Note</b></p>
<p>This information is only relevant if you profile all tasks in your system,</p>
<p>or if you profile a trace-enabled target.</p>
<p>When the following conditions are met, the<b> Profile</b> window continually updates</p>
<p>select information:</p>
<p>â¢</p>
<p>If you are profiling all tasks in your system â The window continually updates</p>
<p>processor usage per function (that is, the standard calls report).</p>
<p>â¢</p>
<p>If you are profiling a trace-enabled target and<b> Retrieve trace when buffer fills</b></p>
<p>is enabled â The window continually updates processor usage per function,</p>
<p>and it updates call count and call graph information (the standard calls and call</p>
<p>graph reports). For information about the<b> Retrieve trace when buffer fills</b></p>
<p>option, see âThe Trace Options Windowâ on page 480.</p>
<p>To pause the continual updating of information, click the<b> Pause updating of profile</b></p>
<p><b>display</b> button (</p>
<p>) in the<b> Profile</b> window.</p>
<p><b>Profiling Reports</b></p>
<p>Each of the tabs in the<b> Profile</b> window represents a profiling report. Depending on</p>
<p>what profiling data is available, there can be up to six profiling report tabs in the</p>
<p><b>Profile</b> window:<b> Status</b>,<b> Standard Calls</b>,<b> Call Graph</b>,<b> Coverage</b>,<b> Block Detailed</b>,</p>
<p>and<b> Source</b>. To view any one of these reports in the<b> Profile</b> window, simply click</p>
<p>the corresponding tab. (If the data required for a particular report was not collected,</p>
<p>no tab appears for that report.) You can also view each profiling report by entering</p>
<p>the following command in the Debugger command pane:</p>
<p>profilereport<i> report</i></p>
<p><i>363</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Continual Updates in the Profile Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>where</p>
<p><i>report</i></p>
<p>specifies one of the report types and can be:</p>
<p>â¢</p>
<p>status</p>
<p>â See âStatus Reportâ on page 365.</p>
<p>â¢</p>
<p>calls</p>
<p>â See âStandard Calls Reportâ on page 365.</p>
<p>â¢</p>
<p>graph</p>
<p>â See âCall Graph Reportâ on page 367.</p>
<p>â¢</p>
<p>coveragesummary</p>
<p>â See âCoverage Reportâ on page 369.</p>
<p>â¢</p>
<p>coveragedetailed</p>
<p>â See âBlock Detailed Reportâ on page 370.</p>
<p>â¢</p>
<p>sourcelines</p>
<p>â See âSource Reportâ on page 371.</p>
<p>Each profiling report generally consists of several columns of information and a</p>
<p>status bar at the bottom of the report. You can sort most of the columns by clicking</p>
<p>the column header. To sort in the opposite direction, click the same header again.</p>
<p>To resize a column, drag the separator to the left or right.</p>
<p>By default, reports omit C++ qualifiers when displaying function names. You can</p>
<p>view fully qualified function names by hovering your mouse pointer over a function,</p>
<p>or you can display fully qualified function names in the reports by selecting<b> Function</b></p>
<p><b>Names</b> â<b> Long</b> from the<b> Config</b> menu. To change back to the default behavior,</p>
<p>select<b> Function Names</b> â<b> Short</b>.</p>
<p>Within each of the reports, single-clicking a function or other component causes</p>
<p>the Debugger to jump to that function or component in the source pane.</p>
<p>Double-clicking opens a MULTI Editor window on the function or component (if</p>
<p>appropriate). Right-clicking opens a shortcut menu. For a description of the shortcut</p>
<p>menu items, see âThe Procedure Shortcut Menuâ on page 708.</p>
<p>You can save, append, or print any profiling report by selecting a menu item or by</p>
<p>using the<b> profilereport</b> Debugger command:</p>
<p>â¢</p>
<p>To save the text of the report that is currently displayed in the<b> Profile</b> window,</p>
<p>select<b> File</b> â<b> Save Report</b> or use the<b> profilereport save</b> command. The default</p>
<p>file extension given to the saved text file is<b> .rep</b>.</p>
<p>â¢</p>
<p>To append the text of the currently displayed report to a previously created</p>
<p>file, select<b> File</b> â<b> Append Report</b> or use the<b> profilereport append</b> command.</p>
<p>â¢</p>
<p>To print the text of the report that is currently displayed, select<b> File</b> â<b> Print</b></p>
<p><b>Report</b> or use the<b> profilereport print</b> command.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>364</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For more information about the<b> profilereport</b> command, see Chapter 12, âProfiling</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Each of the profiling reports is described in greater detail in the following sections.</p>
<p><b>Status Report</b></p>
<p>The status report is the report that appears by default when you open the<b> Profile</b></p>
<p>window.</p>
<p>This report is available if you are profiling a run-mode task or AddressSpace on an</p>
<p>INTEGRITY target, or if you are profiling a stand-alone program. It gives general</p>
<p>information about profiling, such as what type of data has been collected. A message</p>
<p>in the status bar indicates whether or not profiling data is being collected.</p>
<p><b>Standard Calls Report</b></p>
<p>The standard calls report gives a summary of processing time per function. It is</p>
<p>available if PC samples, call count data, or coverage analysis data is available. For</p>
<p>information about the availability of these data types, see âOverview of Profiling</p>
<p>Methodsâ on page 355.</p>
<p><i>365</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Profiling Reports</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The columns of the standard calls report are described in the following table. Some</p>
<p>columns do not contain information unless you used trace data or compiled your</p>
<p>program with Builder or driver options that generate call count data. For more</p>
<p>information, see âGenerating Profiling Data for a Task, AddressSpace, or</p>
<p>Stand-Alone Programâ on page 356.</p>
<p><b>Meaning</b></p>
<p><b>Header</b></p>
<p>The percentage of the total process time spent in each function. (The total</p>
<p>of the percentages in this column may not be exactly 100 percent, due to</p>
<p>roundoff error.)</p>
<p><b>% Time</b></p>
<p>Graphs the value of the<b> % Time</b> column.</p>
<p><b>Bar Graph</b></p>
<p>The amount of time in milliseconds (<b>ms</b>), seconds (<b>s</b>), instructions (<b>inst</b>),</p>
<p>or cycles (<b>cyc</b>) spent in each function.</p>
<p><b>Time (<i>unit</i>)</b></p>
<p>The number of times that the function was called. This column only</p>
<p>contains information if call count data is available. For information about</p>
<p>the availability of call count data, see âOverview of Profiling Methodsâ</p>
<p>on page 355.</p>
<p>If you are profiling a trace-enabled target, call counts are not available</p>
<p>for some internal helper functions used by the compiler. Usually these</p>
<p>functions have names that begin with one or two underscore characters,</p>
<p>and they are called at the beginning and end of many functions to save</p>
<p>and restore registers.</p>
<p><b># Calls</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>366</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Header</b></p>
<p>The amount of time (in milliseconds, seconds, instructions, or cycles)</p>
<p>spent on each call to the function. This column only contains information</p>
<p>if call count data is available. For information about the availability of</p>
<p>call count data, see âOverview of Profiling Methodsâ on page 355.</p>
<p><i><b>Unit</i>/call</b></p>
<p>The location of the function.</p>
<p><b>Filename</b></p>
<p>The name of the function.</p>
<p><b>Function</b></p>
<p><b>Call Graph Report</b></p>
<p>The call graph report gives a summary of processing time spent per function,</p>
<p>including time spent in each function's descendants. (Descendants of a function are</p>
<p>all routines directly or indirectly called by that function.) This report is available if</p>
<p>call count with call graph profiling data is available. For information about the</p>
<p>availability of call count with call graph profiling data, see âOverview of Profiling</p>
<p>Methodsâ on page 355.</p>
<p>The columns of the call graph report are described in the following table.</p>
<p><b>Meaning</b></p>
<p><b>Header</b></p>
<p>The name of the function.</p>
<p><b>Function</b></p>
<p>The number of function calls made by the function, followed by the actual</p>
<p>function(s) called.</p>
<p><b>Calls by Function</b></p>
<p><i>367</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Profiling Reports</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Header</b></p>
<p>The percent of the total calls made by the function to each of the listed</p>
<p>functions.</p>
<p><b>% Calls To</b></p>
<p>The number of times that the function was called, followed by the</p>
<p>function(s) that called it.</p>
<p><b>Calls to Function</b></p>
<p>The percent of the total calls made to the function by each of the listed</p>
<p>functions.</p>
<p><b>% Calls From</b></p>
<p>The actual time spent in each function.</p>
<p><b>Self Time</b>*</p>
<p>The percentage of total time spent in each function.</p>
<p><b>Self %</b></p>
<p>The actual time spent in all of the children of each function. Child times</p>
<p>are calculated by multiplying the amount of time attributed to each child</p>
<p>function by the percentage of times the parent called that child.</p>
<p><b>Child Time</b>*â¡</p>
<p>The percentage of total time spent in the children of each function.</p>
<p><b>Child %</b>â¡</p>
<p>The total processing time spent in each function and its children.</p>
<p><b>Self+Child Time</b>*â¡</p>
<p>The percentage of total time spent in each function and its children.</p>
<p><b>Self+Child %</b>â¡</p>
<p>Graphs the value of the<b> Self+Child %</b> column.</p>
<p><b>Bar Graph</b>â¡</p>
<p>*: The message in the status bar indicates whether the times are listed in milliseconds,</p>
<p>seconds, instructions, or cycles.</p>
<p>â¡: The method used to calculate the<b> Child Time</b> (and everything derived from the</p>
<p><b>Child Time</b>) is a rough approximation. The average amount of time spent in each</p>
<p>call to the child function is multiplied by the number of calls made by each parent</p>
<p>to determine the<b> Child Time</b> assigned to that parent. This is a good approximation</p>
<p>of the<b> Child Time</b> if the amount of time spent in each call to the child function does</p>
<p>not vary significantly, but it can be a poor approximation if it does. For example,</p>
<p>consider the case where functions</p>
<p>A</p>
<p>and</p>
<p>B</p>
<p>are the only callers of function</p>
<p>C</p>
<p>. Function</p>
<p>A</p>
<p>calls function</p>
<p>C</p>
<p>1000 times, and each call takes 1 millisecond. Function</p>
<p>B</p>
<p>only</p>
<p>calls function</p>
<p>C</p>
<p>1 time, but the call takes 1 second. Since the profile data does not</p>
<p>capture execution times for each individual call to function</p>
<p>C</p>
<p>, the Debugger would</p>
<p>assume that each call to function</p>
<p>C</p>
<p>took approximately 2 milliseconds. That</p>
<p>assumption would result in<b> Child Time</b> values of 2 seconds and 2 milliseconds</p>
<p>when in reality the<b> Child Times</b> should both be 1 second.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>368</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Coverage Report</b></p>
<p>The coverage report provides the percentage of bytes covered. Examining this report</p>
<p>is an easy way to find code that is not being executed. This can be useful for</p>
<p>discovering dead code and for verifying that a test suite is testing everything it is</p>
<p>intended to test.</p>
<p>Each line in the report provides the percentage of bytes of code that were executed</p>
<p>in a function. If profiling data has been generated from trace data, the coverage</p>
<p>report includes every function in the AddressSpace or stand-alone program. If</p>
<p>coverage analysis data has been generated via compiler instrumentation, the coverage</p>
<p>report includes every instrumented function in the AddressSpace or stand-alone</p>
<p>program. Typically, standard library functions are not instrumented. The status bar</p>
<p>message gives a summary of coverage for the entire AddressSpace or stand-alone</p>
<p>program.</p>
<p>This report is available if coverage analysis data is available. For information about</p>
<p>the availability of coverage analysis data, see âOverview of Profiling Methodsâ</p>
<p>on page 355.</p>
<p><i>369</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Profiling Reports</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The columns of the coverage report are described in the following table.</p>
<p><b>Meaning</b></p>
<p><b>Header</b></p>
<p>The location of the function.</p>
<p><b>Filename</b></p>
<p>The function name.</p>
<p><b>Function</b></p>
<p>The percentage of bytes executed.</p>
<p><b>% Covered</b></p>
<p>Graphs the value of the<b> % Covered</b> column.</p>
<p><b>Bar Graph</b></p>
<p><b>Block Detailed Report</b></p>
<p>The block detailed report gives the program code coverage per basic block. It is</p>
<p>available if coverage analysis data is available and if you did not use trace data. For</p>
<p>information about the availability of coverage analysis data, see âOverview of</p>
<p>Profiling Methodsâ on page 355.</p>
<p>The columns of the block detailed report are described in the following table.</p>
<p><b>Meaning</b></p>
<p><b>Header</b></p>
<p>The location of the function.</p>
<p><b>Filename</b></p>
<p>The name of the function.</p>
<p><b>Function</b></p>
<p>The starting address of the block.</p>
<p><b>Address</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>370</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Header</b></p>
<p>The file-relative source line corresponding to the block.</p>
<p><b>Line</b></p>
<p>The number of times the block was entered or a<b> NOT REACHED</b></p>
<p>message if zero.</p>
<p><b>Executions</b></p>
<p>The total time in milliseconds (<b>ms</b>), seconds (<b>s</b>), or instructions (<b>inst</b>)</p>
<p>spent in the block.</p>
<p><b>Time (<i>unit</i>)</b></p>
<p>The percentage of total time spent in the block.</p>
<p><b>% Runtime</b></p>
<p><b>Source Report</b></p>
<p>The source report is a list of all the source lines, along with how long each took to</p>
<p>execute. A source line is uniquely determined by filename and file-relative line</p>
<p>number. Only lines with positive times are displayed. This report is available if PC</p>
<p>samples are available. For information about the availability of PC samples, see</p>
<p>âOverview of Profiling Methodsâ on page 355.</p>
<p><b>Note</b></p>
<p>The time it takes to process this report is proportional to the size of what</p>
<p>you are profiling. For example, it takes longer to generate this report for</p>
<p>very large programs than for small ones.</p>
<p><i>371</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Profiling Reports</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The columns of the source report are described in the following table.</p>
<p><b>Meaning</b></p>
<p><b>Header</b></p>
<p>The location of the source line.</p>
<p><b>Filename</b></p>
<p>The file-relative line number of the source line.</p>
<p><b>Line</b></p>
<p>The function in which the source line appears.</p>
<p><b>Function</b></p>
<p>The time in milliseconds (<b>ms</b>), seconds (<b>s</b>), instructions (<b>inst</b>), or cycles</p>
<p>(<b>cyc</b>) spent on the given line.</p>
<p><b>Time (<i>unit</i>)</b></p>
<p>The percentage of the total time spent on the line.</p>
<p><b>% Time</b></p>
<p>Graphs the value of the<b> % Time</b> column.</p>
<p><b>Bar Graph</b></p>
<p><b>The Profile Window Reference</b></p>
<p>The following sections provide a comprehensive description of the menu items and</p>
<p>buttons that appear in the<b> Profile</b> window. For information about the tab views</p>
<p>within the<b> Profile</b> window, see âProfiling Reportsâ on page 363.</p>
<p><b>The File Menu</b></p>
<p>The following table describes the<b> File</b> menu items and lists their command</p>
<p>equivalents.</p>
<p>For information about the<b> profilereport</b> and<b> profilemode</b> commands, see Chapter</p>
<p>12, âProfiling Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p><b>Equivalent Command</b></p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p><b>profilereport save<i> filename</b></i></p>
<p>Saves the text of the report that is</p>
<p>currently displayed in the<b> Profile</b></p>
<p>window. The default file extension given</p>
<p>to the saved text file is<b> .rep</b>.</p>
<p><b>Save Report</b></p>
<p><b>profilereport append</b></p>
<p><i><b>filename</b></i></p>
<p>Appends the text of the report currently</p>
<p>displayed in the<b> Profile</b> window to a</p>
<p>specified, pre-existing file.</p>
<p><b>Append Report</b></p>
<p><b>profilereport print</b></p>
<p>Prints the text of the report currently</p>
<p>displayed in the<b> Profile</b> window.</p>
<p><b>Print Report</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>372</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Equivalent Command</b></p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p><b>profilemode close</b></p>
<p>Closes the<b> Profile</b> window, which halts</p>
<p>the collection of profiling data and clears</p>
<p>existing profiling data.</p>
<p><b>Close</b></p>
<p><b>The Config Menu</b></p>
<p>The following table describes the<b> Config</b> menu items and lists their command</p>
<p>equivalents, if any. These menu items are context sensitive; they may not all be</p>
<p>available every time you open this menu. Unless otherwise stated, all descriptions</p>
<p>of toggle options explain the behavior of the option when enabled.</p>
<p>For information about the<b> profilemode</b> command, see Chapter 12, âProfiling</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Equivalent Command</b></p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p><b>profilemode add</b></p>
<p>Appends new data to old data when a</p>
<p>new set of profiling data is processed</p>
<p>(such as data from a new run of the</p>
<p>program). For more information, see</p>
<p>âAdding to or Overwriting Existing</p>
<p>Profiling Dataâ on page 380.</p>
<p><b>Config</b> â<b> New</b></p>
<p><b>Data</b> â<b> Added to</b></p>
<p><b>Old</b></p>
<p><b>profilemode replace</b></p>
<p>Replaces old data with new data when a</p>
<p>new set of profiling data is processed</p>
<p>(such as data from a new run of the</p>
<p>program). For more information, see</p>
<p>âAdding to or Overwriting Existing</p>
<p>Profiling Dataâ on page 380.</p>
<p><b>Config</b> â<b> New</b></p>
<p><b>Data</b> â<b> Replaces</b></p>
<p><b>Old</b></p>
<p><b>profilemode automatic</b></p>
<p>Processes and stores profiling data</p>
<p>automatically when it is dumped. This is</p>
<p>the default unless you are using</p>
<p>INTEGRITY. For more information, see</p>
<p>âManually Processing Profiling Dataâ</p>
<p>on page 383.</p>
<p><b>Config</b> â<b> Data</b></p>
<p><b>Processing</b> â</p>
<p><b>Automatic</b></p>
<p><b>profilemode manual</b></p>
<p>Does not process profiling data</p>
<p>automatically when it is dumped. This is</p>
<p>the default if you are using INTEGRITY.</p>
<p>For more information, see âManually</p>
<p>Processing Profiling Dataâ on page 383.</p>
<p><b>Config</b> â<b> Data</b></p>
<p><b>Processing</b> â</p>
<p><b>Manual</b></p>
<p><i>373</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Profile Window Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Equivalent Command</b></p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p><b>profilemode short</b></p>
<p>Omits C++ qualifiers from the function</p>
<p>names displayed in profiling reports.</p>
<p>(You can view fully qualified function</p>
<p>names in the tooltips.)</p>
<p>This option has no effect on the display</p>
<p>of C functions.</p>
<p><b>Config</b> â<b> Function</b></p>
<p><b>Names</b> â<b> Short</b></p>
<p><b>profilemode long</b></p>
<p>Displays fully qualified function names</p>
<p>in profiling reports. Fully qualified</p>
<p>function names include all C++</p>
<p>qualifiers, such as namespace and class</p>
<p>names, function arguments, and template</p>
<p>information.</p>
<p>This option has no effect on the display</p>
<p>of C functions.</p>
<p><b>Config</b> â</p>
<p><b>Function Names</b></p>
<p>â<b> Long</b></p>
<p><b>profilemode time</b></p>
<p><b>milliseconds</b></p>
<p>Displays all times in milliseconds.</p>
<p><b>Config</b> â<b> Time</b></p>
<p><b>Units</b> â</p>
<p><b>Milliseconds</b></p>
<p><b>profilemode time seconds</b></p>
<p>Displays all times in seconds.</p>
<p><b>Config</b> â<b> Time</b></p>
<p><b>Units</b> â<b> Seconds</b></p>
<p><b>profilemode time</b></p>
<p><b>instructions</b></p>
<p>Displays all times in instructions.</p>
<p><b>Config</b> â<b> Time</b></p>
<p><b>Units</b> â</p>
<p><b>Instructions</b></p>
<p><b>profilemode time cycles</b></p>
<p>Displays all times in cycles.</p>
<p><b>Config</b> â<b> Time</b></p>
<p><b>Units</b> â<b> Cycles</b></p>
<p>(no equivalent command)</p>
<p>Draws all<b> Bar Graph</b> columns in</p>
<p>profiling reports as linear graphs.</p>
<p><b>Config</b> â<b> Bar</b></p>
<p><b>Graphs</b> â<b> Linear</b></p>
<p>(no equivalent command)</p>
<p>Draws<b> Bar Graph</b> columns in the</p>
<p><b>Standard Calls</b>,<b> Call Graph</b>, and</p>
<p><b>Source</b> reports as logarithmic graphs.</p>
<p>The<b> Bar Graph</b> column in the<b> Coverage</b></p>
<p>report is always drawn as a linear graph</p>
<p>regardless of the setting for this option.</p>
<p>This is the default.</p>
<p><b>Config</b> â<b> Bar</b></p>
<p><b>Graphs</b> â</p>
<p><b>Logarithmic</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>374</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Toolbar</b></p>
<p>The following table describes the buttons available in the<b> Profile</b> window and lists</p>
<p>their command equivalents, if any. These buttons are context sensitive; different</p>
<p>buttons are available in different contexts.</p>
<p>For information about the<b> profilemode</b> and<b> profdump</b> commands, see Chapter 12,</p>
<p>âProfiling Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book. For information about the<b> browse</b> command, see âGeneral View Commandsâ</p>
<p>in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Equivalent Command</b></p>
<p><b>Meaning</b></p>
<p><b>Button</b></p>
<p>Indicates whether profiling data is being</p>
<p>collected and, when clicked, toggles profiling</p>
<p>to the opposite state (on or off).</p>
<p><b>Stop</b></p>
<p><b>collecting</b></p>
<p><b>profile</b></p>
<p><b>information</b></p>
<p><b>Start</b></p>
<p><b>collecting</b></p>
<p><b>profile</b></p>
<p><b>information</b></p>
<p><b>profilemode stop</b></p>
<p>When this button is in the</p>
<p>position, profiling</p>
<p>data is being collected. Clicking the button when</p>
<p>it is in this position disables profiling collection</p>
<p>and clears any current profiling data (but does</p>
<p>not close the<b> Profile</b> window).</p>
<p><b>profilemode start</b></p>
<p>When this button is in the</p>
<p>position, profiling</p>
<p>data is not being collected. Clicking the button</p>
<p>when it is in this position enables profiling.</p>
<p>no equivalent command</p>
<p>Pauses the continual updating of information in</p>
<p>the<b> Profile</b> window. For more information, see</p>
<p>âContinual Updates in the Profile Windowâ</p>
<p>on page 363.</p>
<p><b>Pause</b></p>
<p><b>updating of</b></p>
<p><b>profile</b></p>
<p><b>display</b></p>
<p><b>profilemode clear</b></p>
<p>Deletes any existing profiling data. You can use</p>
<p>this button in conjunction with the<b> Dump</b></p>
<p><b>Profiling Info</b> button (</p>
<p>) to examine profiling</p>
<p>data gathered between two points of execution.</p>
<p>For more information, see âManually Dumping</p>
<p>Profiling Dataâ on page 381.</p>
<p><b>Clear</b></p>
<p><b>current</b></p>
<p><b>profile</b></p>
<p><b>information</b></p>
<p><i>375</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Profile Window Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Equivalent Command</b></p>
<p><b>Meaning</b></p>
<p><b>Button</b></p>
<p><b>profilemode add</b></p>
<p>and</p>
<p><b>profilemode replace</b></p>
<p>Toggles whether new data is added to old data</p>
<p>or whether new data replaces old data. When</p>
<p>this button appears to be pushed down and when</p>
<p>a new set of profiling data is processed (such as</p>
<p>data from a new run of the program), new data</p>
<p>is added to old data. This is the default. When</p>
<p>this button does<i> not</i> appear to be pushed down</p>
<p>and when a new set of profiling data is</p>
<p>processed, the new data replaces the old data.</p>
<p>For more information, see âAdding to or</p>
<p>Overwriting Existing Profiling Dataâ</p>
<p>on page 380.</p>
<p><b>Merge</b></p>
<p><b>new data</b></p>
<p><b>profilemode percent</b></p>
<p>Displays, to the left of each source code line in</p>
<p>the Debugger, the percentage of time spent in</p>
<p>each source line. (In assembly display mode,</p>
<p>displays the percentage of time spent on each</p>
<p>instruction.) This is the default view in the</p>
<p>Debugger.</p>
<p><b>Percentage</b></p>
<p><b>View</b></p>
<p><b>profilemode coverage</b></p>
<p>Highlights dead code (lines that were never</p>
<p>executed during the profiling run) in the</p>
<p>Debugger.</p>
<p><b>Coverage</b></p>
<p><b>View</b></p>
<p><b>profilemode count</b></p>
<p>If coverage analysis profiling data is available,</p>
<p>clicking this button displays in the Debugger</p>
<p>the total number of times each line (or</p>
<p>instruction) was executed.</p>
<p>If coverage analysis profiling data is</p>
<p>unavailable, but call count profiling data is</p>
<p>available, clicking this button displays the</p>
<p>number of times each function was called. This</p>
<p>information is displayed at the beginning of each</p>
<p>function in the Debugger.</p>
<p>For information about the availability of these</p>
<p>data types, see âOverview of Profiling Methodsâ</p>
<p>on page 355.</p>
<p><b>Count</b></p>
<p><b>View</b></p>
<p><b>profilemode range</b></p>
<p><i><b>start_addr end_addr</b></i></p>
<p>Opens a<b> Range Analysis</b> window. See</p>
<p>âPerforming Range Analysesâ on page 379.</p>
<p><b>Range</b></p>
<p><b>Analysis</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>376</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Equivalent Command</b></p>
<p><b>Meaning</b></p>
<p><b>Button</b></p>
<p><b>browse dcalls</b></p>
<p>Opens a dynamic call graph<b> Browse</b> window</p>
<p>centered on the function currently selected in</p>
<p>the Profile window. If nothing is selected in the</p>
<p>Profile window the graph is centered on the</p>
<p>function being examined in the Debugger. For</p>
<p>more information, see âBrowsing Dynamic Calls</p>
<p>by Functionâ on page 246.</p>
<p><b>Dynamic</b></p>
<p><b>Call Graph</b></p>
<p>no equivalent command</p>
<p>Updates the report with new data.</p>
<p><b>Refresh</b></p>
<p><b>Report</b></p>
<p><b>profilemode process</b></p>
<p>Processes profiling data. For more information,</p>
<p>see âManually Processing Profiling Dataâ</p>
<p>on page 383.</p>
<p><b>Process</b></p>
<p><b>Data</b></p>
<p><b>profdump</b></p>
<p>Retrieves any currently available profiling data</p>
<p>from the target. You can use this button in</p>
<p>conjunction with the<b> Clear current profile</b></p>
<p><b>information</b> button (</p>
<p>) to examine profiling</p>
<p>data gathered between two points of execution.</p>
<p>For more information, see âManually Dumping</p>
<p>Profiling Dataâ on page 381.</p>
<p><b>Dump</b></p>
<p><b>Profiling</b></p>
<p><b>Info</b></p>
<p><b>profilemode close</b></p>
<p>Closes the<b> Profile</b> window, which halts the</p>
<p>collection of profiling data and clears existing</p>
<p>profiling data. (Whether this button appears on</p>
<p>your toolbar depends on your MULTI</p>
<p>configuration.)</p>
<p><b>Close</b></p>
<p><b>Viewing Profiling Information in the Debugger</b></p>
<p>Once you have collected profiling data, you can use<b> Profile</b> window buttons or the</p>
<p><b>profilemode</b> command to view some basic profiling information directly in the</p>
<p>source pane of the Debugger, as described below. If you profile all tasks in your</p>
<p>system, or if you profile a trace-enabled target, the information is continually</p>
<p>updated.</p>
<p><b>Note</b></p>
<p>The following display modes are mutually exclusive (only one type of</p>
<p>information can be shown in the Debugger at a time). By default, the</p>
<p>Debugger displays time percentage information, if it is available.</p>
<p><i>377</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Profiling Information in the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><i>Time percentage information</i> â To view the percentage of time spent in each</p>
<p>source line, click the<b> Percentage View</b> button (</p>
<p>) in the<b> Profile</b> window or</p>
<p>run the<b> profilemode percent</b> command in the Debugger command pane. The</p>
<p>percentage is shown to the left of each source line. (If you are in assembly</p>
<p>display mode, the percentage of time spent on each instruction is displayed.)</p>
<p>This feature is only available if PC samples or coverage analysis profiling data</p>
<p>is available. For information about the availability of these data types, see</p>
<p>âOverview of Profiling Methodsâ on page 355.</p>
<p>â¢</p>
<p><i>Coverage information</i> â To highlight lines of dead code (lines that were never</p>
<p>executed) in the Debugger, click the<b> Coverage View</b> button (</p>
<p>) in the<b> Profile</b></p>
<p>window, or run the<b> profilemode coverage</b> command in the Debugger command</p>
<p>pane. Coverage highlighting is reversed for functions with the</p>
<p>ghs_noprofile</p>
<p>attribute (that is, lines that were executed are highlighted). This feature is only</p>
<p>available if coverage analysis profiling data is available. For information about</p>
<p>the availability of coverage analysis profiling data, see âOverview of Profiling</p>
<p>Methodsâ on page 355.</p>
<p>â¢</p>
<p><i>Count information (line executions)</i> â To view the total number of times each</p>
<p>line (or instruction) was executed, click the<b> Count View</b> button (</p>
<p>) in the</p>
<p><b>Profile</b> window or run the<b> profilemode count</b> command in the Debugger</p>
<p>command pane. The number of executions is shown to the left of each source</p>
<p>line. This feature is only available if coverage analysis profiling data is available.</p>
<p>For information about the availability of coverage analysis profiling data, see</p>
<p>âOverview of Profiling Methodsâ on page 355.</p>
<p>â¢</p>
<p><i>Count information (function calls)</i> â To view the total number of times each</p>
<p>function was called, click the<b> Count View</b> button (</p>
<p>) in the<b> Profile</b> window</p>
<p>or run the<b> profilemode count</b> command in the Debugger command pane. The</p>
<p>call count for each function is shown to the left of the beginning of each</p>
<p>function. This feature is only supported if coverage analysis profiling data is</p>
<p>not available and call count profiling data is available. For information about</p>
<p>the availability of these data types, see âOverview of Profiling Methodsâ</p>
<p>on page 355.</p>
<p><b>Note</b></p>
<p>If there is no profiling data for a particular line, a question mark appears</p>
<p>to the left of the line instead of actual count or time percentage</p>
<p>information.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>378</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For more information about the<b> profilemode</b> command, see Chapter 12, âProfiling</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>If you profile all tasks in your system, profiling information is also displayed in the</p>
<p>Debugger's target list in a column labeled<b> CPU %</b>. This column displays the</p>
<p>percentage of the CPU that each task and AddressSpace is currently using. For more</p>
<p>information, see âProfiling All Tasks in Your Systemâ on page 603.</p>
<p><b>Performing Range Analyses</b></p>
<p><b>Note</b></p>
<p>This information is only relevant if you are profiling a run-mode task or</p>
<p>AddressSpace on an INTEGRITY target, or if you are profiling a</p>
<p>stand-alone program,<i> and</i> if PC samples are available. For information</p>
<p>about the availability of PC samples, see âGenerating Profiling Data for</p>
<p>a Task, AddressSpace, or Stand-Alone Programâ on page 356.</p>
<p>Improving the performance of an application often requires isolating small portions</p>
<p>of large functions that account for the majority of the function's execution time,</p>
<p>such as computationally intensive nested loops. MULTI allows you to perform</p>
<p>range analyses to collect profiling information for particular sections of code.</p>
<p>You can perform a range analysis from the<b> Range Analysis</b> window or from the</p>
<p>Debugger command pane. To open a<b> Range Analysis</b> window, click the<b> Range</b></p>
<p><b>Analysis</b> button (</p>
<p>) in the<b> Profile</b> window. To specify the range you want to</p>
<p>analyze, enter a hexadecimal<b> Start</b> and<b> End</b> address in the fields of the<b> Range</b></p>
<p><b>Analysis</b> window.</p>
<p><b>Tip</b></p>
<p>In assembly display mode (see âSource Pane Display Modesâ</p>
<p>on page 23), hexadecimal addresses are displayed to the left of the</p>
<p>corresponding instructions in the Debugger source pane.</p>
<p>After you have specified the range of hexadecimal addresses, click the<b> Calculate</b></p>
<p><b>Range</b> button to display the amount of time that elapsed during execution of the</p>
<p>specified range, as well as the percentage of the total execution time required to</p>
<p>execute the range. The time is displayed in milliseconds, seconds, instructions, or</p>
<p><i>379</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Performing Range Analyses</i></p>
<h1 style="page-break-before:always; "></h1>
<p>cycles depending on the current configuration (see<b> Config</b> â<b> Time Units</b> in the</p>
<p><b>Profile</b> window).</p>
<p>If no range or an inappropriate range is specified when you click the<b> Calculate</b></p>
<p><b>Range</b> button, the<b> Range Analysis</b> window displays an error message.</p>
<p>To perform a range analysis from the Debugger command pane, issue the following</p>
<p>command:</p>
<p>profilemode range<i> start_addr end_addr</i></p>
<p>where</p>
<p><i>start_addr</i></p>
<p>and</p>
<p><i>end_addr</i></p>
<p>are the beginning and end of your range,</p>
<p>respectively. The result of the analysis appears in the Debugger command pane.</p>
<p><b>Managing Profiling Data</b></p>
<p>You can manage collected profiling data in a number of ways: by choosing whether</p>
<p>or not to overwrite existing profiling data with new data, by manually dumping and</p>
<p>processing your profiling data, and by clearing existing data. Support for some of</p>
<p>these capabilities depends on what you are profiling and on the method of profiling.</p>
<p>The following sections provide more information.</p>
<p><b>Adding to or Overwriting Existing Profiling Data</b></p>
<p>When new profiling data is collected and processed, it can be added to profiling</p>
<p>data that already exists, or it can replace old profiling data.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>380</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Accumulating data across multiple executions may be useful for getting a more</p>
<p>accurate understanding of application performance. This is the default behavior</p>
<p>(with one exception*). To append new profiling data to existing profiling data:</p>
<p>â¢</p>
<p>If you are profiling all tasks in your system or if you are profiling a</p>
<p>trace-enabled target â In the<b> Profile</b> window, click the<b> Merge new data</b> button</p>
<p>(</p>
<p>) so that it appears to be pushed down, or enter<b> profilemode add</b> in the</p>
<p>Debugger command pane.</p>
<p>â¢</p>
<p>If you are profiling a task, AddressSpace, or stand-alone program â Select</p>
<p><b>Config</b> â<b> New Data</b> â<b> Added to Old</b> in the<b> Profile</b> window, or enter</p>
<p><b>profilemode add</b> in the Debugger command pane. (*Note that you cannot add</p>
<p>new data to existing data if you are profiling a task or AddressSpace, are using</p>
<p>INTEGRITY version 10 or later, and have established a run-mode connection.)</p>
<p>To replace existing profiling data with new profiling data:</p>
<p>â¢</p>
<p>If you are profiling all tasks in your system or if you are profiling a</p>
<p>trace-enabled target â In the<b> Profile</b> window, click the<b> Merge new data</b> button</p>
<p>(</p>
<p>) so that it does<i> not</i> appear to be pushed down, or enter<b> profilemode replace</b></p>
<p>in the Debugger command pane.</p>
<p>â¢</p>
<p>If you are profiling a task, AddressSpace, or stand-alone program â Select</p>
<p><b>Config</b> â<b> New Data</b> â<b> Replaces Old</b> in the<b> Profile</b> window, or enter</p>
<p><b>profilemode replace</b> in the Debugger command pane.</p>
<p>For information about the<b> profilemode</b> command, see Chapter 12, âProfiling</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Manually Dumping Profiling Data</b></p>
<p><b>Note</b></p>
<p>This information is only relevant if one of the following is true:</p>
<p>â¢</p>
<p>You are profiling a run-mode task or AddressSpace on an</p>
<p>INTEGRITY target, or you are profiling a stand-alone program,<i> and</i></p>
<p>you instrumented your code to generate profiling data (that is, you</p>
<p>compiled your program with Builder or driver profiling options).</p>
<p>For more information, see âGenerating Profiling Data for a Task,</p>
<p>AddressSpace, or Stand-Alone Programâ on page 356.</p>
<p><i>381</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Manually Dumping Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>You collected PC samples over a freeze-mode connection.</p>
<p>By default, MULTI processes collected profiling data automatically each time your</p>
<p>program exits. In some situations, however, you may want to halt your process and</p>
<p>dump the collected profiling data at some other point. The most common scenarios</p>
<p>for manually dumping profiling data are:</p>
<p>â¢</p>
<p>When you are debugging a process, such as an operating system, that does not</p>
<p>terminate.</p>
<p>â¢</p>
<p>When you want to dump profiling data gathered between two points of execution</p>
<p>so that you can profile specific areas of execution.</p>
<p><b>Note</b></p>
<p>MULTI's ability to dump profiling data depends on command line</p>
<p>procedure calls. If you are not using INTEGRITY, interrupts may need</p>
<p>to be disabled before command line procedure calls and, consequently,</p>
<p>dumps will work. If you need to disable interrupts on your target, first</p>
<p>halt your target, and then disable interrupts. After dumping profiling data</p>
<p>(explained next), turn interrupts back on and run the program.</p>
<p>To dump all available forms of profiling data (PC samples, call count data, and</p>
<p>coverage analysis data), halt your process and then do one of the following:</p>
<p>â¢</p>
<p>Click the<b> Dump Profiling Info</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> profdump</b> command. For information</p>
<p>about the<b> profdump</b> command, see Chapter 12, âProfiling Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>To dump profiling data gathered between two specific points of execution:</p>
<p>1.</p>
<p>Run the program to the first point of execution and then clear any profiling</p>
<p>data gathered prior to reaching that point. To clear profiling data, do one of</p>
<p>the following:</p>
<p>â¢</p>
<p>Click the<b> Clear current profile information</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> profilemode clear</b> command.</p>
<p>For information about the<b> profilemode</b> command, see Chapter 12,</p>
<p>âProfiling Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>382</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>2.</p>
<p>Run the program to the second point of execution and then dump the profiling</p>
<p>data gathered between the two points.</p>
<p>If automatic data processing is disabled, you must manually process dumped</p>
<p>profiling data. For more information, see âManually Processing Profiling Dataâ</p>
<p>on page 383.</p>
<p>For information about the limitations associated with dumping profiling data, see</p>
<p>âCaveats for Dumping and Clearing Profiling Dataâ on page 385.</p>
<p><b>Manually Processing Profiling Data</b></p>
<p><b>Note</b></p>
<p>This information is only relevant if you are profiling a run-mode task or</p>
<p>AddressSpace on an INTEGRITY target, or if you are profiling a</p>
<p>stand-alone program.</p>
<p>Unless you are using INTEGRITY, MULTI is set by default to automatically process</p>
<p>and store profiling data when it is dumped. If you want more control over when</p>
<p>profiling data is processed, you can disable automatic processing and process your</p>
<p>profiling data manually.</p>
<p>To disable the automatic processing of profiling data, do one of the following:</p>
<p>â¢</p>
<p>In the<b> Profile</b> window, select<b> Config</b> â<b> Data Processing</b> â<b> Manual</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> profilemode manual</b> command.</p>
<p>After you have disabled automatic processing, you will have to process your profiling</p>
<p>data manually. To successfully process profiling data (automatically or manually),</p>
<p>you should be connected to your target with the program loaded.</p>
<p><b>Note</b></p>
<p>To avoid inadvertently merging old data into a profiling report, MULTI</p>
<p>deletes profiling data files after processing them. To save these files,</p>
<p>copy the<b> *.out</b> files to a separate directory before manually processing</p>
<p>profiling data.</p>
<p><i>383</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Manually Processing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To start the manual processing of data, do one of the following:</p>
<p>â¢</p>
<p>Click the<b> Process Data</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> profilemode process</b> command.</p>
<p>To load a<b> .pro</b> file output by<b> protrans</b> (see the documentation about the protrans</p>
<p>utility in the<i> MULTI: Building Applications</i> book), perform the following steps:</p>
<p>1.</p>
<p>Make sure you are connected to your target and the program is loaded.</p>
<p>2.</p>
<p>Copy saved profiling data files to your run directory.</p>
<p>3.</p>
<p>Rename<b> *.pro</b> files in the format</p>
<p><i>program</i>.pro</p>
<p>, where</p>
<p><i>program</i></p>
<p>is the name</p>
<p>of your program.</p>
<p>4.</p>
<p>Open the<b> Profile</b> window (for instructions, see âCollecting Profiling Data for</p>
<p>a Task, AddressSpace, or Stand-Alone Programâ on page 359).</p>
<p>5.</p>
<p>Enter the<b> profilemode import</b> command in the Debugger command pane.</p>
<p>6.</p>
<p>Follow the preceding instructions for processing data manually.</p>
<p>To re-enable automatic processing of profiling data, do one of the following:</p>
<p>â¢</p>
<p>Choose<b> Config</b> â<b> Data Processing</b> â<b> Automatic</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> profilemode automatic</b> command.</p>
<p>For information about the<b> profilemode</b> command, see Chapter 12, âProfiling</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Clearing Profiling Data</b></p>
<p>To clear existing profiling data, do one of the following:</p>
<p>â¢</p>
<p>In the<b> Profile</b> window, click the<b> Clear current profile information</b> button</p>
<p>(</p>
<p>).</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> profilemode clear</b> command. For</p>
<p>information about the<b> profilemode</b> command, see Chapter 12, âProfiling</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>384</i></p>
<p><i>Chapter 17. Collecting and Viewing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the<b> Profile</b> window, click the<b> Close</b> button (</p>
<p>) to close the<b> Profile</b> window,</p>
<p>halt the collection of profiling data, and clear existing profiling data. (Whether</p>
<p>this button appears on your toolbar depends on your MULTI configuration.)</p>
<p>For information about the limitations associated with clearing profiling data, see</p>
<p>âCaveats for Dumping and Clearing Profiling Dataâ on page 385.</p>
<p><b>Caveats for Dumping and Clearing Profiling Data</b></p>
<p>â¢</p>
<p>MULTI uses command line procedure calls to dump and clear profiling data.</p>
<p>In some cases command line procedure calls may not be possible or may have</p>
<p>adverse effects. If you are using INTEGRITY, command line procedure calls</p>
<p>are unsafe for tasks that have been halted while performing a system call.</p>
<p>MULTI attempts to detect this situation and prevent command line procedure</p>
<p>calls in this context, but it is not always able to do so, nor is it able to detect</p>
<p>every situation in which it is unsafe to make command line procedure calls.</p>
<p>To guarantee correct operation, you must ensure that the task you are profiling</p>
<p>is halted in a safe location prior to dumping or clearing profiling data. For more</p>
<p>information about the limitations of command line procedure calls, see âCaveats</p>
<p>for Command Line Procedure Callsâ on page 306.</p>
<p>â¢</p>
<p>If you are not using INTEGRITY, interrupts may need to be disabled before</p>
<p>command line procedure calls and, consequently, dump or clear operations</p>
<p>will work. If you need to disable interrupts on your target, first halt your target,</p>
<p>and then disable interrupts. After dumping or clearing profiling data, turn</p>
<p>interrupts back on and run the program.</p>
<p>â¢</p>
<p>If you profile a run-mode task or AddressSpace on an INTEGRITY target, or</p>
<p>if you profile a stand-alone program,<i> and</i> if you instrumented your code to</p>
<p>generate profiling data, dumping or clearing the profiling data may cause the</p>
<p>program, task, or tasks inside the AddressSpace to run for the duration of the</p>
<p>dump or clear operation. This brief run may cause MULTI to generate PC</p>
<p>samples.</p>
<p><i>385</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Caveats for Dumping and Clearing Profiling Data</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 18</b></p>
<p><b>Using Other View Windows</b></p>
<p><b>Contents</b></p>
<p>Viewing Call Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>388</p>
<p>Viewing Native Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>390</p>
<p>Viewing Caches . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>392</p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Call Stacks</b></p>
<p>The<b> Call Stack</b> window displays call stacks (also known as<i> call stack traces</i> or</p>
<p>simply<i> stack traces</i>), which consist of stack frames that are currently active in your</p>
<p>program. Each stack frame typically represents a function call. Stack frames are</p>
<p>shown in order from most to least recently created.</p>
<p>To open the<b> Call Stack</b> window, do one of the following:</p>
<p>â¢</p>
<p>Click the<b> Call Stack</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>Choose<b> View</b> â<b> Call Stack</b>.</p>
<p>â¢</p>
<p>In the command pane, enter<b> callsview</b>. For information about the<b> callsview</b></p>
<p>command, see Chapter 5, âCall Stack Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>The following table describes the buttons available from the toolbar of the<b> Call</b></p>
<p><b>Stack</b> window.</p>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Toggles the display of parameters in function calls.</p>
<p><b>Hide</b></p>
<p><b>Parameters</b></p>
<p>Toggles the display of the filename and line number of the function call.</p>
<p><b>Hide Positions</b></p>
<p>Toggles whether to display stack frames before</p>
<p>main()</p>
<p>.</p>
<p><b>Display stack</b></p>
<p><b>frames before</b></p>
<p><b>main()</b></p>
<p>Copies the contents of the window to the clipboard.</p>
<p><b>Copy Window</b></p>
<p><b>Contents</b></p>
<p>Toggles whether the window is refreshed.</p>
<p><b>Freeze</b></p>
<p><b>Window</b></p>
<p>Opens an Editor on the selected function, if it has source code.</p>
<p><b>Edit Function</b></p>
<p>Opens a Data Explorer showing all the local variables of the selected</p>
<p>function. If the selected function is a C++ instance method, the Data</p>
<p>Explorer also shows information about the</p>
<p>this</p>
<p>pointer.</p>
<p><b>View Locals</b></p>
<p>Prints the text contents of the<b> Call Stack</b> window to your printer.</p>
<p>To print call stack information to the command pane, enter the<b> calls</b></p>
<p>command. For information about the<b> calls</b> command, see Chapter 5, âCall</p>
<p>Stack Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Print</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>388</i></p>
<p><i>Chapter 18. Using Other View Windows</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Closes the<b> Call Stack</b> window. Whether or not this button appears on your</p>
<p>toolbar depends on the setting of the option<b> Display close (x) buttons</b>.</p>
<p><b>Close</b></p>
<p>At the far right of the toolbar is the<b> Max Depth</b> field, which controls the maximum</p>
<p>number of stack levels which the window will display. You can change it according</p>
<p>to your preference. For example, if you are debugging a program on a very slow</p>
<p>target and you only want information about the first few levels of the call stack,</p>
<p>you can decrease the number so that the window is refreshed more quickly.</p>
<p>Below the toolbar is the call stack pane, where the call stack is displayed. The</p>
<p>following table lists the mouse and keyboard operations you can perform in the call</p>
<p>stack pane.</p>
<p><b>Do this</b></p>
<p><b>To</b></p>
<p>Click the function</p>
<p>Display a function in the source pane</p>
<p>Double-click the function</p>
<p>Open an Editor on a function</p>
<p>Press<b> Ctrl</b>+<b>Shift</b>+<b>C</b></p>
<p>Copy the entire call stack pane to the clipboard</p>
<p>Press<b> Ctrl</b>+<b>F</b></p>
<p>Search forward in the call stack pane</p>
<p>Press<b> Ctrl</b>+<b>B</b></p>
<p>Search backward in the call stack pane</p>
<p>During a debugging session, if you change the attributes of a<b> Call Stack</b> window,</p>
<p>the changes will affect subsequently created<b> Call Stack</b> windows. You can also</p>
<p>change these attributes with the<b> cvconfig</b> command. For information about this</p>
<p>command, see Chapter 5, âCall Stack Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>The Call Stack Window and Command Line Procedure Calls</b></p>
<p>If a breakpoint is hit during the execution of a command line procedure call, the</p>
<p>call stack pane of the<b> Call Stack</b> window displays a separator line corresponding</p>
<p>to the location where the target was stopped when you made the procedure call.</p>
<p>The lower portion is the call stack from before the function call; the upper portion</p>
<p>is the call stack starting from the command line procedure call.</p>
<p><i>389</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Call Stack Window and Command Line Procedure Calls</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Call Stack Window and Procedure Prologues and Epilogues</b></p>
<p>At the beginning and end of every procedure are special code sequences called the</p>
<p>prologue and epilogue, respectively. These special code sequences save and restore</p>
<p>registers and modify the stack pointer. Full source-level debugging is not possible</p>
<p>within these regions, so MULTI does not display source-level breakpoints for these</p>
<p>lines. You can single-step through this code at the machine level, but many other</p>
<p>tasks such as tracing the stack and examining variables are not supported until you</p>
<p>are outside this region. The<b> Call Stack</b> window may display incorrect information</p>
<p>when a process is stopped inside a prologue, an epilogue, or a function called by a</p>
<p>prologue or epilogue.</p>
<p><b>The Call Stack Window and Interrupt/Exception Handlers</b></p>
<p>Interrupt and exception handlers typically employ nonstandard stack frames.</p>
<p>Attempting to generate a stack trace when you are stopped in an interrupt or</p>
<p>exception handler may result in the<b> Call Stack</b> window displaying incorrect or</p>
<p>incomplete information, as well as attempts to access invalid memory addresses on</p>
<p>your target.</p>
<p><b>Viewing Native Processes</b></p>
<p>The<b> Process Viewer</b> displays a snapshot of the processes on your native Linux or</p>
<p>Solaris target, much like the Linux/Solaris</p>
<p>top</p>
<p>and</p>
<p>ps</p>
<p>utilities. The primary purpose</p>
<p>of this window is to allow you to attach to native processes. The<b> Process Viewer</b></p>
<p>also provides an easy way to identify PIDs for use with certain Debugger commands</p>
<p>or dialog boxes.</p>
<p>To open a<b> Process Viewer</b>, do one of the following from your native debugging</p>
<p>environment:</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Task Manager</b> from the Debugger menu bar. (If you are in a</p>
<p>non-native environment and in run mode, this menu selection will open a Task</p>
<p>Manager instead of a<b> Process Viewer</b>.)</p>
<p>â¢</p>
<p>Issue the<b> top</b> command from the Debugger command pane. For information</p>
<p>about this command, see âGeneral View Commandsâ in Chapter 22, âView</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>390</i></p>
<p><i>Chapter 18. Using Other View Windows</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Issue the command<b> multi -top</b> from your shell (see Appendix C, âCommand</p>
<p>Line Referenceâ on page 721).</p>
<p>A sample<b> Process Viewer</b> for Linux is displayed below:</p>
<p>The<b> Process Viewer</b> displays all of the processes that you own, color-coded</p>
<p>depending on their type, where:</p>
<p>â¢</p>
<p>Red â Indicates a process that carries debugging information and contains</p>
<p>source code that can be debugged.</p>
<p>â¢</p>
<p>Gray â Indicates a process or child process of the MULTI Debugger. Attaching</p>
<p>to this process will cause MULTI to stop functioning correctly.</p>
<p>â¢</p>
<p>Black â Indicates a process that does not have available debugging information.</p>
<p>To attach to a process and debug it, either select the process and click<b> Attach</b>, or</p>
<p>simply double-click the process. If the Debugger cannot locate the executable image</p>
<p>associated with the process, you will be prompted to choose it from the disk.</p>
<p>If the<b> Process Viewer</b>'s contents become out of date and you want to see the current</p>
<p>list of processes available on your native target, simply click<b> Update</b> to refresh the</p>
<p>list. You can also enable automatic periodic refreshing by selecting the<b> Auto Update</b></p>
<p>check box and entering an integer in the<b> Interval</b> text box, which specifies how</p>
<p>often (in seconds) updates should occur. The default interval is 5 seconds.</p>
<p><i>391</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Native Processes</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Caches</b></p>
<p>MULTI includes two display windows that allow you to view the contents of the</p>
<p>caches on your processor. You can use the<b> Cache View</b> and<b> Cache Find</b> windows</p>
<p>to browse cache contents and search all of the caches at a specific address.</p>
<p><b>Note</b></p>
<p>Support for cache viewing and searching varies according to processor</p>
<p>type. Not all processors support these features, and availability also</p>
<p>depends on your debug server connection.</p>
<p><b>The Cache View Window</b></p>
<p>The<b> Cache View</b> window displays all of the entries from a single cache. You can</p>
<p>use this window to browse through the cache data to see what addresses and data</p>
<p>are in the cache, what addresses are in the cache but have been invalidated, and</p>
<p>other information.</p>
<p>To open a<b> Cache View</b> window, do one of the following:</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Caches</b>.</p>
<p>â¢</p>
<p>Enter the<b> cacheview</b> command in the Debugger command pane. For more</p>
<p>information about this command, see âCache View Commandsâ in Chapter</p>
<p>22, âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>The<b> Cache View</b> window is shown next.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>392</i></p>
<p><i>Chapter 18. Using Other View Windows</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The drop-down box on the toolbar allows you to select which cache to view.</p>
<p>By default, the<b> Cache View</b> window hides invalid cache entries. You can change</p>
<p>this default behavior by clicking the</p>
<p>button.</p>
<p>The columns in the<b> Cache View</b> window also vary depending on your processor</p>
<p>and cache type. The following table describes all possible columns, which are</p>
<p>ordered alphabetically below. See your processor's manual for more information</p>
<p>about the data in the caches.</p>
<p><b>Description</b></p>
<p><b>Column</b></p>
<p>Displays the allocate bit for the first/second cache block of this cache entry.</p>
<p><b>A0</b>,<b> A1</b></p>
<p>Displays the address of the cache line. This address may be a virtual or</p>
<p>physical address, depending on your processor, cache and whether the</p>
<p>memory management unit is enabled.</p>
<p><b>Address</b></p>
<p>Indicates whether the first/second half of the cache line is dirty. Each dirty</p>
<p>bit corresponds to 32 bytes of cache data.</p>
<p><b>D0</b>,<b> D1</b></p>
<p>Displays the data associated with this cache line. The number of bytes</p>
<p>displayed depends on your processor and cache type.</p>
<p><b>Data</b></p>
<p>Indicates whether the cache line has been locked for data.</p>
<p><b>Data Locked</b></p>
<p>Indicates whether the cache line is dirty.</p>
<p>On ARM920/922, ARM946, and ARM1136, each dirty bit corresponds to</p>
<p>16 bytes of cache data.</p>
<p>On PowerPC 440, each of the 4 bits corresponds to a double word of data</p>
<p>in the cache line.</p>
<p><b>Dirty</b>*â¡</p>
<p>Indicates whether the cache line has been locked for instructions.</p>
<p><b>Instruction</b></p>
<p><b>Locked</b></p>
<p>Indicates whether the cache line has been locked.</p>
<p><b>Lock</b>,<b> Locked</b></p>
<p>On Intel XScale IXP2350, indicates which way of the cache line is next in</p>
<p>line for replacement on a line eviction. The following list provides the</p>
<p>mapping of<b> LRU</b> bit values to cache ways:</p>
<p>â¢</p>
<p><b>01x</b> â Way 0</p>
<p>â¢</p>
<p><b>11x</b> â Way 1</p>
<p>â¢</p>
<p><b>x00</b> â Way 2</p>
<p>â¢</p>
<p><b>x01</b> â Way 3</p>
<p>On PowerPC 405, indicates whether the way will be the next out of 2</p>
<p>available ways to be replaced at line eviction.</p>
<p><b>LRU</b></p>
<p><i>393</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Cache View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Column</b></p>
<p>Displays the</p>
<p>MESI</p>
<p>bits for the first/second cache block of this cache entry.</p>
<p><b>MESI0</b>,<b> MESI1</b></p>
<p>Indicates whether the cache line has been loaded incoherently. If set, only</p>
<p>instructions hit in this line (data accesses will miss).</p>
<p><b>N</b></p>
<p>Displays the set of the cache line. Each address maps to a single set in the</p>
<p>cache.</p>
<p><b>Set</b></p>
<p>Indicates whether the cache line is shared in a multiprocessor system.</p>
<p><b>Shared</b>â¡</p>
<p>Indicates whether the cache line is stale (that is, whether the data is invalid).</p>
<p><b>Stale</b></p>
<p>Displays the MOESI state for the cache line. Available states are:</p>
<p>â¢</p>
<p><b>0</b> â Invalid</p>
<p>â¢</p>
<p><b>1</b> â Shared</p>
<p>â¢</p>
<p><b>3</b> â Owned</p>
<p>â¢</p>
<p><b>5</b> â Exclusive</p>
<p>â¢</p>
<p><b>7</b> â Modified</p>
<p><b>State</b></p>
<p>Displays the allocate bit for cache block</p>
<p>X</p>
<p>.</p>
<p><b>S[X]:Alloc</b></p>
<p>Displays the</p>
<p>MESI</p>
<p>bits for cache block</p>
<p>X</p>
<p>of this cache entry.</p>
<p><b>S[X]:MESI</b></p>
<p>Displays the parity bit for cache block</p>
<p>X</p>
<p>.</p>
<p><b>SX:Parity</b></p>
<p>Displays the symbol associated with the address at the start of the cache</p>
<p>line.</p>
<p><b>Symbol</b></p>
<p>Displays the TID disable field for the memory page associated with this</p>
<p>cache entry.</p>
<p><b>TD</b></p>
<p>Displays the tag extended real address (TERA) of this cache entry. This is</p>
<p>the top 4 bits of the physical address associated with this cache entry.</p>
<p><b>TERA</b></p>
<p>Displays the translation ID field for the memory page associated with this</p>
<p>cache entry.</p>
<p><b>TID</b></p>
<p>Displays the translation space for the memory page associated with this</p>
<p>cache line.</p>
<p><b>TS</b></p>
<p>Indicates whether the cache line has been recently used.</p>
<p><b>Used</b></p>
<p>Displays the 4 user bits associated with this cache entry.</p>
<p><b>User</b></p>
<p>Indicates whether the first/second half of the cache line is valid. Each valid</p>
<p>bit corresponds to 32 bytes of cache data.</p>
<p><b>V0</b>,<b> V1</b></p>
<p>Indicates whether the cache line is valid.</p>
<p><b>Valid</b>*â¡</p>
<p><i>MULTI: Debugging</i></p>
<p><i>394</i></p>
<p><i>Chapter 18. Using Other View Windows</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Column</b></p>
<p>Displays the way of the cache line. Any address that maps to the current</p>
<p>set can be found in any way within that set. This column does not apply for</p>
<p>direct-mapped caches.</p>
<p><b>Way</b></p>
<p>*: On PowerPC 6xx, 7xx, 51xx, 52xx, 7400, 7410, 82xx, and 83xx, MESI states</p>
<p>are encoded in the<b> Valid</b> and<b> Dirty</b> bits as follows:</p>
<p><b>Dirty</b></p>
<p><b>Valid</b></p>
<p><b>State</b></p>
<p>1</p>
<p>1</p>
<p>Modified</p>
<p>0</p>
<p>1</p>
<p>Exclusive</p>
<p>1</p>
<p>0</p>
<p>Shared</p>
<p>0</p>
<p>0</p>
<p>Invalid</p>
<p>â¡: On PowerPC 744x, 745x, 85xx, 86xx, and QorIQ, MESI states are encoded in</p>
<p>the<b> Valid</b>,<b> Dirty</b>, and<b> Shared</b> bits as follows:</p>
<p><b>Shared</b></p>
<p><b>Dirty</b></p>
<p><b>Valid</b></p>
<p><b>State</b></p>
<p>0</p>
<p>1</p>
<p>1</p>
<p>Modified</p>
<p>0</p>
<p>0</p>
<p>1</p>
<p>Exclusive</p>
<p>1</p>
<p>0</p>
<p>1</p>
<p>Shared</p>
<p>x</p>
<p>x</p>
<p>0</p>
<p>Invalid</p>
<p>You can sort the data in the<b> Cache View</b> window by clicking the column header</p>
<p>above the column that you want to sort by. You can also change the display, refresh</p>
<p>the window, or open other windows using the buttons described in the following</p>
<p>table.</p>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Refreshes the current view by reloading cache data from the target.</p>
<p>Hides or shows all invalid cache entries. When the button is pushed down,</p>
<p>invalid caches entries are not displayed. Otherwise, all cache entries,</p>
<p>including invalid entries, are visible.</p>
<p>Opens a<b> Memory View</b> window at the address of the selected cache line.</p>
<p>Opens a<b> Cache Find</b> window at the address of the selected cache line. See</p>
<p>âThe Cache Find Windowâ on page 396.</p>
<p><i>395</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Cache View Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Contracts all entries in the<b> Cache View</b> window so that each cache line</p>
<p>takes up a single line in the cache list.</p>
<p>Expands all valid entries and contracts all invalid entries in the<b> Cache View</b></p>
<p>window so that each valid cache line is fully displayed and each invalid</p>
<p>entry takes up a single line.</p>
<p>Expands all entries in the<b> Cache View</b> window so that each cache line is</p>
<p>fully displayed.</p>
<p><b>The Cache Find Window</b></p>
<p>The<b> Cache Find</b> window allows you to view the contents of all of your processor's</p>
<p>caches, as well as the memory underneath the caches, at a specific address. To open</p>
<p>a<b> Cache Find</b> window, do one of the following:</p>
<p>â¢</p>
<p>Select<b> View</b> â<b> Find Address in Cache</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> cachefind</b> command. For information</p>
<p>about this command, see âCache View Commandsâ in Chapter 22, âView</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>In the<b> Cache View</b> window, click</p>
<p>.</p>
<p>The<b> Cache Find</b> window is shown next.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>396</i></p>
<p><i>Chapter 18. Using Other View Windows</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Cache Find</b> window displays the valid line that contains the specified address</p>
<p>for each cache. If the address is not found in a cache, the set that was searched will</p>
<p>be displayed and the window will indicate that the address was not found in that</p>
<p>cache. If a cache line is found that contains the address, the cache tags associated</p>
<p>with the cache line are displayed along with the data from the cache line.</p>
<p>The data in the<b> Cache Find</b> window is colored to indicate the state of the data. This</p>
<p>makes the display easy to read and can help you to find cache coherency problems.</p>
<p>A cache coherency problem occurs when there is data in the cache that is clean (not</p>
<p>dirty) and it differs from data in memory or a cache further from the processor. In</p>
<p>this case, the data that makes up the cache coherency conflict is colored in red. In</p>
<p>addition, data in memory that has a dirty cache line associated with it is colored</p>
<p>gray.</p>
<p><i>397</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Cache Find Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To refresh the cache data in the<b> Cache Find</b> window, click</p>
<p>. To change the</p>
<p>address to search for, enter a new address in the<b> Address</b> field and click<b> Go</b>.</p>
<p>To freeze the cache data in the<b> Cache Find</b> window so that it does not update when</p>
<p>the target changes state, click</p>
<p>. (The window is frozen when this button appears</p>
<p>pushed down. Click the button again to unfreeze the window.)</p>
<p>To open a<b> Memory View</b> window at the specified address, click</p>
<p>. (See Chapter 15,</p>
<p>âUsing the Memory View Windowâ on page 323 for information about using this</p>
<p>window.)</p>
<p>To open a<b> Cache View</b> window, click</p>
<p>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>398</i></p>
<p><i>Chapter 18. Using Other View Windows</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Part IV</b></p>
<p><b>TimeMachine Debugging</b></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 19</b></p>
<p><b>Analyzing Trace Data with</b></p>
<p><b>the TimeMachine Tool Suite</b></p>
<p><b>Contents</b></p>
<p>Quick Start</p>
<p>. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>403</p>
<p>Overview of Trace Analysis Tools . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>404</p>
<p>Managing Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>405</p>
<p>The TimeMachine Debugger . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>413</p>
<p>The PathAnalyzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>424</p>
<p>Viewing Trace Data in the Trace List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>434</p>
<p>Bookmarking Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>444</p>
<p>Searching Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>446</p>
<p>Saving and Loading a Trace Session . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>448</p>
<p>Browsing Trace Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>451</p>
<p>Viewing Trace Statistics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>460</p>
<p>The TimeMachine API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>466</p>
<p>Viewing Trace Events in the EventAnalyzer . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>474</p>
<p>Using Trace Data to Profile Your Target . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>475</p>
<p>Viewing Reconstructed Register Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>476</p>
<h1 style="page-break-before:always; "></h1>
<p>The MULTI Debugger is capable of collecting and storing trace data from supported</p>
<p>trace-capable targets. MULTI and TimeMachine currently support trace collection</p>
<p>and analysis with the following architectures:</p>
<p>â¢</p>
<p>ARM</p>
<p>â¢</p>
<p>Power Architecture</p>
<p>â¢</p>
<p>68K/ColdFire</p>
<p>â¢</p>
<p>Renesas V850E</p>
<p>â¢</p>
<p>MIPS</p>
<p>There are a number of interfaces that you can use to collect trace data, including:</p>
<p>â¢</p>
<p>ARM Embedded Trace Macrocell</p>
<p>â¢</p>
<p>PowerPC 405 and 440 built-in trace port</p>
<p>â¢</p>
<p>PowerPC 55xx Nexus trace port</p>
<p>â¢</p>
<p>Freescale MAC71xx Nexus trace port</p>
<p>â¢</p>
<p>ColdFire built-in trace port</p>
<p>â¢</p>
<p>Renesas V850E IECUBE</p>
<p>â¢</p>
<p>V850E RTE</p>
<p>â¢</p>
<p>Green Hills Simulators for ARM, MIPS, Power Architecture, V800,</p>
<p>68K/ColdFire</p>
<p>You can use the Green Hills SuperTrace Probe to collect trace data from any of the</p>
<p>trace ports listed above. No additional hardware is required for collecting trace data</p>
<p>from the simulators listed above.</p>
<p>Once you have collected trace data, you can analyze it with an array of tools provided</p>
<p>in the MULTI Debugger and with the powerful TimeMachine tool suite. The</p>
<p>TimeMachine tool suite expands MULTI's standard trace analysis capabilities to</p>
<p>allow you to step and run backward through time, examine process flow over</p>
<p>significant periods of time, analyze high-level execution patterns, and debug RTOS</p>
<p>applications from trace data. This chapter describes how to collect trace data and</p>
<p>how to analyze it with the TimeMachine tool suite and with the standard tools that</p>
<p>ship with the MULTI Debugger.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>402</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>TimeMachine is licensed separately from MULTI. For information about</p>
<p>purchasing a TimeMachine license, contact your Green Hills sales</p>
<p>representative.</p>
<p><b>Quick Start</b></p>
<p>When you establish a trace-enabled debug connection, trace collection is</p>
<p>automatically enabled. At any point when the target is halted, you can use the</p>
<p>TimeMachine run-control buttons (</p>
<p>,</p>
<p>,</p>
<p>, and</p>
<p>) to run or step backwards</p>
<p>through the trace data as though you were debugging your code while it executed.</p>
<p>For example, if your target hits an unexpected breakpoint, you can simply step</p>
<p>backwards through the code to determine what caused the breakpoint to be hit. If</p>
<p>your target supports data trace, you can even examine variables in the Data Explorer</p>
<p>as you step backwards. For information about the TimeMachine run-control buttons,</p>
<p>which are disabled if you do not have a TimeMachine license, see âTimeMachine</p>
<p>Run-Control Buttonsâ on page 416.</p>
<p>In addition to making it possible to run and step backwards, trace data enables many</p>
<p>other powerful tools, which are described in the next section. To use any of these</p>
<p>tools, you must retrieve trace data from your trace-enabled probe or target. Trace</p>
<p>data is automatically retrieved when you click one of the TimeMachine run-control</p>
<p>buttons. You can also retrieve it at any time by selecting<b> TimeMachine</b> â<b> Retrieve</b></p>
<p><b>Trace</b> or by clicking the<b> Retrieve Trace</b> button (</p>
<p>) located in the Trace List or</p>
<p>PathAnalyzer. In addition, you can configure MULTI to automatically retrieve trace</p>
<p>data each time your target halts. See the description of<b> Retrieve trace when target</b></p>
<p><b>halts</b> in âThe Collection Tabâ on page 481.</p>
<p><i>403</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Quick Start</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Overview of Trace Analysis Tools</b></p>
<p>Once you have collected trace data, you can analyze it with any of the TimeMachine</p>
<p>or trace tools listed next.</p>
<p>TimeMachine is a separately licensed tool suite that dramatically extends MULTI's</p>
<p>trace analysis and debugging capabilities. The TimeMachine tool suite includes the</p>
<p>following trace analysis tools and features:</p>
<p>â¢</p>
<p><i>TimeMachine Debugger</i> â Utilizes trace data to allow you to step backward</p>
<p>in time while you are debugging. The TimeMachine Debugger is similar to the</p>
<p>MULTI Debugger window and supports most of the main Debugger's features,</p>
<p>so you can continue to use breakpoints, view registers and memory, and examine</p>
<p>the call stack as you move backward and/or forward through the process.</p>
<p>TimeMachine makes it easy to quickly isolate and debug problems that are</p>
<p>otherwise hard to reproduce. For more information, see âThe TimeMachine</p>
<p>Debuggerâ on page 413.</p>
<p>â¢</p>
<p><i>PathAnalyzer</i> â Displays the sequence of function calls that occurred in call</p>
<p>stack order. The PathAnalyzer allows you to examine the flow of execution at</p>
<p>a high level or zoom in to see individual function calls at a low level. You can</p>
<p>also search for sequences of events that point out anomalies such as a failure</p>
<p>to meet a real-time deadline.</p>
<p>â¢</p>
<p><i>TimeMachine API</i> â Enables you to write custom analysis tools to solve</p>
<p>problems that may not be easily solved using the standard tool suite. This API</p>
<p>offers a DLL (Windows) or a shared object (Linux/Solaris) that allows you to</p>
<p>write a program or script that can interface with trace data to track down any</p>
<p>type of problem. Examples of problems that have been investigated with the</p>
<p>TimeMachine API are high power consumption, cache coherency problems,</p>
<p>and illegal memory writes. For more information, see âThe TimeMachine APIâ</p>
<p>on page 466.</p>
<p>â¢</p>
<p><i>EventAnalyzer Integration</i> â Displays a time line of task activity, OS API</p>
<p>calls, and system events. For more information, see âViewing Trace Events in</p>
<p>the EventAnalyzerâ on page 474.</p>
<p>â¢</p>
<p><i>MULTI Profiling Integration</i> â Allows you to convert trace data into</p>
<p>performance analysis data. Profiling data generated from trace data is much</p>
<p>more complete, in terms of which instructions are represented, than profiling</p>
<p>data generated by profiling methods that use sampling. For more information,</p>
<p>see âUsing Trace Data to Profile Your Targetâ on page 475.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>404</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Both the MULTI Debugger and the TimeMachine tool suite include the following</p>
<p>standard trace analysis tools:</p>
<p>â¢</p>
<p><i>Trace List</i> â Allows you to view and explore trace data at the function and</p>
<p>assembly levels and control trace collection. You can also access advanced</p>
<p>trigger, search, filter, and bookmark controls, in addition to various trace data</p>
<p>analysis tools. For more information, see âViewing Trace Data in the Trace</p>
<p>Listâ on page 434.</p>
<p>â¢</p>
<p><i>Trace Browsers</i> â Allow you to quickly locate events in your trace data by</p>
<p>finding similar events, such as instructions and memory accesses. For more</p>
<p>information, see âBrowsing Trace Dataâ on page 451.</p>
<p>â¢</p>
<p><i>Trace Statistics</i> â Calculates and displays statistical information about trace</p>
<p>data. For more information, see âViewing Trace Statisticsâ on page 460.</p>
<p><b>Managing Trace Data</b></p>
<p>Trace collection, retrieval, and deletion is highly configurable. By default, trace</p>
<p>collection is automatically enabled, and collected trace data is automatically retrieved</p>
<p>when you start using the TimeMachine Debugger by stepping or running backwards.</p>
<p>Collected trace data is also retrieved automatically when the program being debugged</p>
<p>exits, and it can be retrieved manually at any time. MULTI keeps the trace data as</p>
<p>long as the accumulated trace data files do not exceed the size specified.</p>
<p>When trace configuration options are set to their defaults, it is usually possible to</p>
<p>use TimeMachine to step or run backward in time from the current location. This</p>
<p>default trace configuration presents a convenient way to use trace data, but sometimes</p>
<p>you may require more precise control over when trace data is collected, retrieved,</p>
<p>and discarded. The following sections describe the many ways that you can manage</p>
<p>trace data in MULTI.</p>
<p><b>Enabling and Disabling Trace Collection</b></p>
<p>By default, MULTI automatically enables trace collection when you connect to a</p>
<p>trace-capable target. To disable this default behavior, clear the<b> Automatically</b></p>
<p><b>enable trace collection</b> option, which appears on the<b> Collection</b> tab of the<b> Trace</b></p>
<p><b>Options</b> window. To open the<b> Trace Options</b> window, select<b> TimeMachine</b> â</p>
<p><i>405</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Managing Trace Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Trace Options</b> from the Debugger. For more information, see âThe Trace Options</p>
<p>Windowâ on page 480.</p>
<p>You can also manually enable and disable trace collection. When you manually</p>
<p>enable trace collection, MULTI clears any previously collected data on the target.</p>
<p>Data that has already been retrieved is not cleared, but if trace retrieval is currently</p>
<p>in progress, it is aborted. To manually enable trace collection, do one of the</p>
<p>following:</p>
<p>â¢</p>
<p>In the MULTI Debugger, select<b> TimeMachine</b> â<b> Enable Trace</b>.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, click the<b> Enable Trace</b> button (</p>
<p>) so</p>
<p>that it appears to be pushed down.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, select<b> File</b> â<b> Enable Trace</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> trace enable</b> command. For</p>
<p>information about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>To manually disable trace collection, do one of the following:</p>
<p>â¢</p>
<p>In the MULTI Debugger, select<b> TimeMachine</b> â<b> Disable Trace</b>.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, click the<b> Disable Trace</b> button (</p>
<p>) so</p>
<p>that it does not appear to be pushed down.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, select<b> File</b> â<b> Disable Trace</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> trace disable</b> command. For</p>
<p>information about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>When you disable trace collection, all the trace data currently stored on the trace</p>
<p>collection device is retrieved.</p>
<p>You can also control trace collection via trace triggers. For information about trace</p>
<p>triggers, see âConfiguring Trace Collectionâ on page 489.</p>
<p><b>Collecting Operating System Trace Data</b></p>
<p>On the INTEGRITY, velOSity, and u-velOSity operating systems, TimeMachine</p>
<p>can record the operating system tasks and AddressSpaces that were executed. On</p>
<p><i>MULTI: Debugging</i></p>
<p><i>406</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>INTEGRITY, it can also filter out operating system AddressSpaces that you are</p>
<p>not interested in tracing, provided that your BSP supports this.</p>
<p><b>Note</b></p>
<p>Even if you have one of these operating systems and hardware trace</p>
<p>support, the operating system trace features may still be unavailable. For</p>
<p>fully functional use of TimeMachine with INTEGRITY, velOSity, or</p>
<p>u-velOSity, special hardware that records the process ID (PID) register</p>
<p>must be made available. Additionally, not all versions of these operating</p>
<p>systems support these features. For updated information about which</p>
<p>hardware and operating system versions support these enhanced features,</p>
<p>contact your Green Hills sales representative.</p>
<p><b>Note</b></p>
<p>Some target processors limit the number of unique AddressSpaces that</p>
<p>can be traced. Tracing a target on which the number of AddressSpaces</p>
<p>exceeds this limit is not supported.</p>
<p>MULTI uses the state of the operating system at the time when trace data is retrieved</p>
<p>for trace decoding. If a task or AddressSpace was traced, but is no longer present</p>
<p>on the target when trace data is retrieved, MULTI will be unable to decode the trace</p>
<p>data for that task or AddressSpace. Additionally, MULTI may not be able to decode</p>
<p>some or all of the subsequent trace data.</p>
<p>On INTEGRITY, establishing a run-mode partner connection alongside your</p>
<p>freeze-mode connection allows you to specify which AddressSpaces are traced. By</p>
<p>not tracing the entire system, you can more efficiently use your limited trace buffer.</p>
<p>A common use for tracing specific AddressSpaces is to disable trace collection for</p>
<p>any idle tasks you may have on your system. Typically, idle tasks take up a large</p>
<p>amount of trace buffer space or time and do not contain very interesting data. For</p>
<p>information about establishing a run-mode partner, see âAutomatically Establishing</p>
<p>Run-Mode Connectionsâ on page 69.</p>
<p>After you have established a run-mode partner, you can enable and disable the</p>
<p>tracing of specific AddressSpaces by right-clicking a task in the target list and</p>
<p>selecting<b> Trace</b>. This toggles trace collection for the AddressSpace that encapsulates</p>
<p>the selected task. Once you have toggled trace collection for an AddressSpace, any</p>
<p>new AddressSpaces that are created will not be traced until you enable tracing of</p>
<p>them.</p>
<p><i>407</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Collecting Operating System Trace Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>If you manually start your run-mode connection, the<b> Trace</b> menu entry</p>
<p>may not be available until MULTI offers to partner your connections the</p>
<p>first time you halt your freeze-mode connection or retrieve trace data.</p>
<p><b>Note</b></p>
<p>Interrupt and exception handlers in the kernel are traced if the interrupt</p>
<p>or exception occurs while executing in a traced AddressSpace.</p>
<p><b>Retrieving Trace Data</b></p>
<p>By default, MULTI automatically retrieves trace data when you first step or run</p>
<p>backwards, when you enable TimeMachine, or when the program being debugged</p>
<p>exits. You can also configure MULTI to automatically retrieve trace data when the</p>
<p>target halts:</p>
<p>1.</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> Trace Options</b> to open the<b> Trace</b></p>
<p><b>Options</b> window.</p>
<p>2.</p>
<p>Select the<b> Retrieve trace when target halts</b> option, which appears on the</p>
<p><b>Collection</b> tab of the<b> Trace Options</b> window.</p>
<p>You can manually retrieve trace data by doing one of the following:</p>
<p>â¢</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> Retrieve Trace</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> trace retrieve</b> command. For</p>
<p>information about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>In the Trace List or PathAnalyzer, click the<b> Retrieve Trace</b> button (</p>
<p>) at any</p>
<p>time.</p>
<p>To abort the retrieval of trace data, do one of the following:</p>
<p>â¢</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> Abort Trace Retrieval</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> trace abort</b> command. For</p>
<p>information about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>408</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the Trace List or PathAnalyzer, click the<b> Abort Trace Retrieval</b> button (</p>
<p>)</p>
<p>so that it no longer appears to be pushed down.</p>
<p>You can also control trace retrieval via trace triggers. For more information about</p>
<p>trace triggers, see âConfiguring Trace Collectionâ on page 489.</p>
<p><b>Retrieving Operating System Trace Data</b></p>
<p>TimeMachine may need to halt the kernel in order to retrieve system information</p>
<p>that aids in trace analysis. Halting the kernel allows MULTI to associate trace data</p>
<p>with corresponding AddressSpaces and tasks. The amount of time that the system</p>
<p>is halted varies depending on your hardware. If TimeMachine needs to halt the</p>
<p>system, a warning dialog box asking for your permission appears. If you decide not</p>
<p>to halt the system, MULTI may abort trace retrieval upon encountering instructions</p>
<p>from an AddressSpace it is unaware of, thereby making much of the trace analysis</p>
<p>unavailable. See also the<b> Assume static OSA</b> trace option in âThe Trace Options</p>
<p>Windowâ on page 480.</p>
<p><b>Retrieving Trace Data from a SuperTrace Probe v3</b></p>
<p>Green Hills SuperTrace Probes can collect a large amount of trace data. Retrieving</p>
<p>4 GB of trace data from a SuperTrace Probe v3 and decoding it takes at least five</p>
<p>minutes and in many cases may take much longer. In some cases, it may take an</p>
<p>hour or more. Decoding speed depends on many factors including your trace</p>
<p>configuration, the type of target being traced, the code traced, the performance of</p>
<p>the host machine, and local network conditions.</p>
<p>In many cases, the most interesting trace data is the most recent data near the end</p>
<p>of the trace buffer. With SuperTrace Probe v3, all available trace RAM is always</p>
<p>used regardless of the<b> Target buffer size</b> setting (see âThe Collection Tabâ</p>
<p>on page 481). However, it is still possible to step or run backwards quickly because</p>
<p>MULTI quickly retrieves the configured<b> Target buffer size</b> from the end of the</p>
<p>SuperTrace Probe's trace buffer. You can manually retrieve more data later if the</p>
<p>originally configured amount is insufficient.</p>
<p>If you have already retrieved some of the trace data, do one of the following things</p>
<p>to retrieve twice as much:</p>
<p>â¢</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> Retrieve Trace</b>.</p>
<p><i>409</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Retrieving Trace Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> trace retrieve</b> command. For</p>
<p>information about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>In the Trace List or PathAnalyzer, click the<b> Retrieve Trace</b> button (</p>
<p>).</p>
<p>To choose how much data is retrieved:</p>
<p>â¢</p>
<p>In the Trace List or PathAnalyzer, click and hold the<b> Retrieve Trace</b> button</p>
<p>(</p>
<p>). In the drop-down menu that appears, choose how much data to retrieve.</p>
<p>To retrieve all of the trace data from the SuperTrace Probe, do one of the following:</p>
<p>â¢</p>
<p>In the Trace List or PathAnalyzer, click and hold the<b> Retrieve Trace</b> button</p>
<p>(</p>
<p>). In the drop-down menu that appears, choose to retrieve all of the trace</p>
<p>data.</p>
<p>â¢</p>
<p>In the Debugger command pane, issue the<b> trace retrieve -all</b> command.</p>
<p><b>Note</b></p>
<p>If you retrieve more trace data than is configured by<b> Target buffer size</b>,</p>
<p>all of the data in the tools is cleared and retrieved from the SuperTrace</p>
<p>Probe again. This also ends TimeMachine Debugger sessions and clears</p>
<p>all bookmarks.</p>
<p><b>Discarding Trace Data</b></p>
<p>Trace collection devices such as the SuperTrace Probe are capable of quickly</p>
<p>collecting very large amounts of trace data. The trace data files become even larger</p>
<p>when they are retrieved by your PC, decompressed, and indexed. Because MULTI</p>
<p>always appends new trace data to the end of older trace data, the amount of disk</p>
<p>space used to store trace data can be very large. When the size of the accumulated</p>
<p>trace data files exceeds the<b> Host buffer size</b> setting, MULTI discards old trace data.</p>
<p>(For more information about the<b> Host buffer size</b> setting and other trace</p>
<p>configuration settings, see âThe Trace Options Windowâ on page 480.)</p>
<p>MULTI attempts to discard unnecessary trace data by basing its deletion on the age</p>
<p>of the trace data and the locations of triggers, bookmarks, and the current selection.</p>
<p>As trace data is discarded over time, you may encounter side effects such as gaps</p>
<p>in the timestamps displayed in the Trace List and Path Analyzer.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>410</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Sometimes you may want to discard all your trace data and start trace collection</p>
<p>over again. When you perform one of the following operations, MULTI clears all</p>
<p>current trace data on the host, trace probe, and target:</p>
<p>â¢</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> Clear Data</b>.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, select<b> File</b> â<b> Clear Data</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> trace clear</b> command. For</p>
<p>information about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Dealing with Incomplete Trace Data</b></p>
<p>An ideal trace target (such as a Green Hills instruction set simulator) generates trace</p>
<p>data that includes complete information about every instruction and data access that</p>
<p>occurs on the target. When used with such an ideal trace target, the TimeMachine</p>
<p>Debugger is capable of determining the value of almost every register and memory</p>
<p>location used by your program at any point during its execution. With an ideal trace</p>
<p>target, the behavior of the TimeMachine Debugger is almost identical to that of the</p>
<p>MULTI Debugger on a live target. The only differences are that you can run and</p>
<p>step backwards in the TimeMachine Debugger but cannot modify registers or</p>
<p>memory.</p>
<p>Unfortunately, most hardware devices compromise on trace capabilities because of</p>
<p>price, power, pin count, and performance constraints. Data trace is often one of the</p>
<p>first things to be sacrificed. Some architectures, such as PowerPC 4xx, do not support</p>
<p>tracing data accesses at all. Other architectures, such as ColdFire, trace values that</p>
<p>are loaded and stored to memory but do not trace the associated memory addresses.</p>
<p>ARM ETMv3 targets typically drop data trace packets when on-chip trace buffers</p>
<p>begin to fill. Very few devices support full data trace and have the trace port</p>
<p>bandwidth to output data trace without dropping packets when the processor is</p>
<p>running from cached memory. Some devices are capable of stalling the processor</p>
<p>when necessary to allow the trace port to keep up, but even this cannot always</p>
<p>prevent overflows.</p>
<p>Most trace tools, such as the PathAnalyzer,<b> Profile</b> window, and EventAnalyzer,</p>
<p>are unaffected by incomplete data trace; however, data trace is very important for</p>
<p>the TimeMachine Debugger. Incomplete data trace can prevent the TimeMachine</p>
<p>Debugger from determining the values of registers, memory, and, by extension,</p>
<p><i>411</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Dealing with Incomplete Trace Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>local and global variables. Values that the TimeMachine Debugger cannot determine</p>
<p>given the available trace data are displayed as<b> &lt;&lt;Unreadable/Unknown&gt;&gt;</b>.</p>
<p>Incomplete data trace can also prevent read/write hardware breakpoints from being</p>
<p>hit.</p>
<p>Some trace architectures also drop instruction trace when on-chip trace buffers</p>
<p>overflow. MULTI attempts to fill in the missing instruction trace by inferring it</p>
<p>from the trace data collected before and after the overflow (see the option<b> Attempt</b></p>
<p><b>to reconstruct gaps in trace data</b> in âThe Trace Options Windowâ on page 480).</p>
<p>Unfortunately, reconstruction is not always possible, and incomplete instruction</p>
<p>trace impacts all trace analysis tools. It can cause discontinuities in the PathAnalyzer</p>
<p>call stack, the exclusion of events from the EventAnalyzer, and problems when</p>
<p>running and stepping in the TimeMachine Debugger. In the Trace List window,</p>
<p>missing instruction trace is indicated by a line with the text<b> FIFO Overflow</b>. If the</p>
<p>TimeMachine Debugger encounters missing instruction trace while running or</p>
<p>stepping, it stops and prints:</p>
<p>Stopped by discontinuity in trace data</p>
<p>to avoid skipping over breakpoints that may have been set on instructions that were</p>
<p>not traced.</p>
<p>Many trace architectures can be configured to only generate instruction trace data</p>
<p>of certain functions or when certain conditions are met. All of the MULTI trace</p>
<p>tools attempt to deal with the sparse trace data that results from this trace suppression,</p>
<p>but as more instruction trace is disabled, the usefulness of high-level tools such as</p>
<p>the TimeMachine Debugger and the PathAnalyzer degrades rapidly. If instruction</p>
<p>trace is suppressed to the point that only short bursts of instructions are traced, the</p>
<p>TimeMachine API and the instruction pane in the Trace List are likely to be the</p>
<p>only useful trace analysis tools. In the Trace List window, suppressed instruction</p>
<p>trace is indicated by a line with the text<b> Trace Disabled</b>.</p>
<p>Most trace architectures provide some mechanism for configuring when data accesses</p>
<p>are traced or for completely disabling data trace. You can control this through the</p>
<p><b>Set Triggers</b> window (see âThe Set Triggers Windowâ on page 493). Limiting or</p>
<p>disabling data trace can prevent instruction trace from being lost. You may therefore</p>
<p>want to disable data trace if you are primarily using trace data for performance</p>
<p>analysis or for the PathAnalyzer, where data trace is not important. If you are</p>
<p>collecting trace data over Nexus, you may alternatively enable the option<b> Stall</b></p>
<p><b>Processor to Avoid Overflows</b> to prevent instruction trace from being lost. For</p>
<p><i>MULTI: Debugging</i></p>
<p><i>412</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>information about this option, see the documentation about target-specific trace</p>
<p>options in the<i> Green Hills Debug Probes User's Guide</i>.</p>
<p>It is also possible for trace data to include incomplete context switch markers. For</p>
<p>example, on some INTEGRITY targets, the raw trace data includes sufficient</p>
<p>information for MULTI to determine the active AddressSpace, but not enough</p>
<p>information for it to determine the active task. On some architectures, MULTI</p>
<p>attempts to infer the active task by leveraging data trace and knowledge of the</p>
<p>kernel. In this case, missing data trace may prevent MULTI from determining the</p>
<p>task associated with some context switches. Such context switches are marked as</p>
<p>switching into an unknown task. On other architectures, debug builds of the kernel</p>
<p>include special instrumentation that allows MULTI to extract active task information</p>
<p>from the trace data. In some cases, active task information is not available and trace</p>
<p>data for all tasks in the same AddressSpace is lumped together. In other cases, even</p>
<p>active AddressSpace information may not be available due to incomplete trace data.</p>
<p><b>The TimeMachine Debugger</b></p>
<p>With TimeMachine, you can step and run backward through your software, replaying</p>
<p>the execution of your trace data through the familiar Debugger interface. The</p>
<p>TimeMachine Debugger is completely integrated with the MULTI Debugger so</p>
<p>that you can also run and step forward and use most other features available in the</p>
<p>standard Debugger.</p>
<p>There are certain operations, however, that cannot be performed in a TimeMachine</p>
<p>Debugger (including writing registers and memory and invoking command line</p>
<p>procedure calls) and certain features for which support in TimeMachine is dependent</p>
<p>on MULTI's ability to reconstruct register and memory values.</p>
<p>If your trace data includes information about data accesses, MULTI uses that</p>
<p>information to infer as much as possible about the state of the target at each point</p>
<p>recorded in the trace log. If you have a complete log of the address and value of</p>
<p>every data access, TimeMachine is usually able to completely reconstruct the state</p>
<p>of all registers and memory accessed by your program. This allows features such</p>
<p>as the Data Explorer, the<b> Register View</b> window, and the<b> Memory View</b> window</p>
<p>to be used in the TimeMachine Debugger just as they are used in the standard</p>
<p>MULTI Debugger.</p>
<p><i>413</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The TimeMachine Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>However, if your trace log does not contain a complete log of the address and value</p>
<p>of every data access, or if the trace log does not go back far enough to include</p>
<p>necessary data accesses, MULTI may be unable to reconstruct some parts of the</p>
<p>target state. Values that MULTI cannot infer from the available trace data are</p>
<p>displayed as<b> &lt;&lt; Unreadable/Unknown &gt;&gt;</b>. For more information, see âDealing</p>
<p>with Incomplete Trace Dataâ on page 411.</p>
<p><b>Note</b></p>
<p>MULTI cannot infer register and memory values from trace data collected</p>
<p>on a MIPS target.</p>
<p><b>Enabling and Disabling TimeMachine</b></p>
<p>TimeMachine can only be used after you have collected trace data. (For information</p>
<p>about collecting trace data, see âEnabling and Disabling Trace Collectionâ</p>
<p>on page 405.) After you have run your program and collected trace data, you can</p>
<p>launch the TimeMachine Debugger on selected target list entries by doing one of</p>
<p>the following:</p>
<p>â¢</p>
<p>In the Debugger window, click the<b> TimeMachine Debugger</b> button (</p>
<p>) or</p>
<p>select<b> TimeMachine</b> â<b> TimeMachine Debugger</b>.</p>
<p>â¢</p>
<p>In the Debugger window, click any one of the TimeMachine run-control buttons</p>
<p>(</p>
<p>,</p>
<p>,</p>
<p>, or</p>
<p>) to step or run backward in TimeMachine. For more</p>
<p>information, see âTimeMachine Run-Control Buttonsâ on page 416.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> timemachine</b> command. For more</p>
<p>information, see the<b> timemachine</b> command in Chapter 20, âTrace Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, double-click an instruction or a function,</p>
<p>respectively.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, select<b> Tools</b> â<b> TimeMachine Debugger</b>.</p>
<p>The following things happen to indicate that you are in TimeMachine mode:</p>
<p>â¢</p>
<p>The PC pointer turns blue (</p>
<p>). (It is red otherwise.)</p>
<p>â¢</p>
<p>All run-control buttons turn blue.</p>
<p>â¢</p>
<p>The<b> TimeMachine Debugger</b> button (</p>
<p>) appears to be pushed down.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>414</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>The<b> Status</b> column in the target list indicates that you are in TimeMachine</p>
<p>mode.</p>
<p>To disable TimeMachine mode for selected target list entries, do one of the</p>
<p>following:</p>
<p>â¢</p>
<p>In the Debugger window, click the<b> TimeMachine Debugger</b> button (</p>
<p>) or</p>
<p>select<b> TimeMachine</b> â<b> TimeMachine Debugger</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> timemachine</b> command. For more</p>
<p>information, see the<b> timemachine</b> command in Chapter 20, âTrace Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>415</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Enabling and Disabling TimeMachine</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Location of the Program Counter in TimeMachine</b></p>
<p>When you first launch the TimeMachine Debugger, the blue program counter arrow</p>
<p>(</p>
<p>) indicates the last instruction recorded during the trace. You can change which</p>
<p>instruction the TimeMachine Debugger begins at by selecting the instruction in the</p>
<p>Trace List or by selecting a function in the PathAnalyzer (for more information,</p>
<p>see âViewing Trace Data in the Trace Listâ on page 434 and âThe PathAnalyzer</p>
<p>Windowâ on page 425).</p>
<p>If you enter TimeMachine by running or stepping backwards, TimeMachine begins</p>
<p>running backwards from the end of the trace data and not from a previous position</p>
<p>of TimeMachine.</p>
<p><b>TimeMachine Run-Control Buttons</b></p>
<p>The four buttons that are unique to the TimeMachine Debugger window are described</p>
<p>in the following table. (The rest of the buttons and the window function similarly</p>
<p>to a regular Debugger window. For more information, see âThe Debugger Window</p>
<p>Toolbarâ on page 691 and Chapter 2, âThe Main Debugger Windowâ on page 11.)</p>
<p><b>Tip</b></p>
<p>You can also issue TimeMachine Debugger commands in the command</p>
<p>pane to move backward through your code. The command equivalents</p>
<p>for each button are given in the following table. For more information</p>
<p>about these commands, see Chapter 13, âProgram Execution Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Description</b></p>
<p><b>Command</b></p>
<p><b>equivalent</b></p>
<p><b>Button</b></p>
<p>Runs backward to the previous breakpoint or, if no previous</p>
<p>breakpoint exists, to the first instruction in the trace data.</p>
<p><b>bc</b></p>
<p>Steps back up to the caller of the current function.</p>
<p><b>bcU</b></p>
<p>Steps back one line. If the TimeMachine Debugger is in</p>
<p>source display mode, clicking this button causes the</p>
<p>TimeMachine Debugger to step back a single source line. If</p>
<p>the TimeMachine Debugger is in an assembly mode, it steps</p>
<p>back a single machine instruction. For more information</p>
<p>about display modes, see âSource Pane Display Modesâ</p>
<p>on page 23.</p>
<p><b>bprev</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>416</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Command</b></p>
<p><b>equivalent</b></p>
<p><b>Button</b></p>
<p>Steps back one line, stepping into a function if the previous</p>
<p>line is in a different function. For more information, see</p>
<p>âSingle-Stepping Commandsâ in Chapter 13, âProgram</p>
<p>Execution Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>bs</b></p>
<p>If running or stepping backward in the TimeMachine Debugger brings you to an</p>
<p>unexpected location in your source code, you can issue the<b> trace history -</b> command</p>
<p>to undo the run or step operation. To redo the operation, enter the<b> trace history +</b></p>
<p>command. For information about the<b> trace</b> command, see Chapter 20, âTrace</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book. For</p>
<p>information about adding toolbar buttons that perform the same operations as the</p>
<p><b>trace history -</b> and<b> trace history +</b> commands, see âAdding, Removing, and</p>
<p>Rearranging Toolbar Buttonsâ on page 698.</p>
<p><b>Breakpoint Sharing</b></p>
<p>Because TimeMachine is so closely integrated with the MULTI Debugger,</p>
<p>TimeMachine and the live target share breakpoints. That is, if you set a breakpoint</p>
<p>while using TimeMachine and then disable TimeMachine, the breakpoint is applied</p>
<p>to the real target. Breakpoint sharing works both ways, so if you set a breakpoint</p>
<p>on the target and then launch TimeMachine, the breakpoint is also present in</p>
<p>TimeMachine.</p>
<p>An unlimited number of hardware breakpoints can be set in TimeMachine, but only</p>
<p>a target-specific number on the live target. If you set hardware breakpoints in</p>
<p>TimeMachine mode and then disable TimeMachine, MULTI applies as many of</p>
<p>those hardware breakpoints to the live target as are supported; the rest are retained</p>
<p>but disabled.</p>
<p>For information about setting, hitting, or sharing breakpoints while using</p>
<p>TimeMachine with an OS or while using Separate Session TimeMachine, see âUsing</p>
<p>TimeMachine with OS Tasksâ on page 418, âOSA Breakpoints in TimeMachineâ</p>
<p>on page 420, or âUsing Separate Session TimeMachineâ on page 422.</p>
<p><i>417</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Breakpoint Sharing</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Using TimeMachine with OS Tasks</b></p>
<p>When you retrieve INTEGRITY, velOSity, or u-velOSity trace data for the first</p>
<p>time, a list of the tasks on the system appears in the target list.</p>
<p>The first time you want to launch TimeMachine on a task, you must launch it</p>
<p>manually. After you have launched TimeMachine on the first task, TimeMachine</p>
<p>may be automatically launched on other tasks if hardware breakpoints are hit in</p>
<p>those tasks while TimeMachine is running. To launch TimeMachine on a task, do</p>
<p>one of the following:</p>
<p>â¢</p>
<p>Select the task in the target list and then click the<b> TimeMachine Debugger</b></p>
<p>button (</p>
<p>) or any one of the TimeMachine run-control buttons (</p>
<p>,</p>
<p>,</p>
<p>, or</p>
<p>). For information about the run-control buttons, see âTimeMachine</p>
<p>Run-Control Buttonsâ on page 416.</p>
<p>â¢</p>
<p>Select the task in the target list and then enter the<b> timemachine</b> command in</p>
<p>the Debugger command pane.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter<b> timemachine âtid<i> task_id</b></i> to launch</p>
<p>TimeMachine on the specified task.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter<b> timemachine âas_name<i> AddressSpace</b></i></p>
<p>to launch TimeMachine on the first task in the specified AddressSpace.</p>
<p>For more information about the<b> timemachine</b> command, see Chapter 20, âTrace</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>You may notice that even when you launch TimeMachine from a run-mode task,</p>
<p>TimeMachine is associated with the corresponding freeze-mode task in the target</p>
<p>list. This is because trace data is retrieved from the freeze-mode connection.</p>
<p><b>Note</b></p>
<p>You can only launch TimeMachine on tasks that exist on the target. If a</p>
<p>task has been removed or unloaded from the target, you will not be able</p>
<p>to launch TimeMachine on it even if it has trace data associated with it.</p>
<p>You can work around this behavior by saving the trace data to a file and</p>
<p>then loading it back into MULTI (see âSaving and Loading a Trace</p>
<p>Sessionâ on page 448). Once the trace file is loaded, TimeMachine is</p>
<p>automatically launched on all tasks that were traced.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>418</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>After TimeMachine has been launched on two or more tasks, the mode of these</p>
<p>tasks is synchronized. As a result, if you disable TimeMachine mode for one of the</p>
<p>tasks, it is also disabled for the other(s). Similarly, if you enable TimeMachine again</p>
<p>for one of the tasks, it is also enabled for the other(s). Tasks on which you never</p>
<p>launched TimeMachine are unaffected by these actions.</p>
<p>Once TimeMachine has been launched on several tasks, you can step or run forward</p>
<p>or backward from any of them. If you do so from a task that is not the currently</p>
<p>executing one, the step/run operation begins from the location of the blue program</p>
<p>counter arrow (</p>
<p>) in the currently executing task. The end location of a successful</p>
<p>step is relative to the location of the blue program counter displayed in the selected</p>
<p>task.</p>
<p>If you set a hardware breakpoint on a virtual address when TimeMachine is enabled,</p>
<p>and the target processor supports data trace, the hardware breakpoint is applied to</p>
<p>the corresponding physical address. This means that the hardware breakpoint could</p>
<p>be hit for any virtual or physical address in any AddressSpace that translates to the</p>
<p>physical address of the hardware breakpoint. If you set a hardware breakpoint on</p>
<p>a virtual address when TimeMachine is enabled, but the target processor does not</p>
<p>support data trace, the breakpoint is set on the virtual address and is triggered</p>
<p>whenever any task executes that virtual address.</p>
<p><b>Note</b></p>
<p>OS-awareness in TimeMachine requires specific parts of OS execution</p>
<p>to be reconstructed. If kernel trace data is incomplete, MULTI may discard</p>
<p>trace data for some tasks. For more information, see âDealing with</p>
<p>Incomplete Trace Dataâ on page 411.</p>
<p><b>OSA Tasks and the Master Process in TimeMachine</b></p>
<p>This section provides information about behavior that you can expect when</p>
<p>TimeMachine is enabled for a freeze-mode connection. It describes running through</p>
<p>traced interrupts and exceptions from the master process and running OSA tasks.</p>
<p>For information about freeze-mode debugging, see Chapter 26, âFreeze-Mode</p>
<p>Debugging and OS-Awarenessâ on page 605.</p>
<p>When you are debugging the OSA master process in TimeMachine mode, you can</p>
<p>single-step and run through traced interrupts and exceptions. TimeMachine treats</p>
<p>all execution inside of interrupts and exceptions as a separate logical task, even</p>
<p><i>419</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using TimeMachine with OS Tasks</i></p>
<h1 style="page-break-before:always; "></h1>
<p>though it does not correspond to any physical task. Note that this behavior differs</p>
<p>from that of the OSA master process when not in TimeMachine mode. When not</p>
<p>in TimeMachine mode, you can use the OSA master process to run through all the</p>
<p>different tasks on the target.</p>
<p>When you run an OSA task for which TimeMachine is enabled, other OSA tasks</p>
<p>on the same processor, and for which TimeMachine is also enabled, run as well.</p>
<p>If your freeze-mode target halts, and you want to step or run backward in the current</p>
<p>task, select the OSA task in the target list before stepping or running backward. If</p>
<p>you do not select the task first (that is, you leave the OSA master process selected),</p>
<p>stepping or running backward steps/runs you back in the task with the most recently</p>
<p>traced data. To step/run back through interrupts and exceptions, select the</p>
<p>TimeMachine target list entry associated with the OSA master process.</p>
<p><b>Tip</b></p>
<p>If you want the current task to be automatically selected whenever the</p>
<p>target halts, ensure that the<b> osaSwitchToUserTaskAutomatically</b></p>
<p>configuration option is set to</p>
<p>on</p>
<p>(the default). See the</p>
<p><b>osaSwitchToUserTaskAutomatically</b> option in âOther Debugger</p>
<p>Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ in the</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>OSA Breakpoints in TimeMachine</b></p>
<p>Software breakpoints set on tasks in TimeMachine mode are task specific. This</p>
<p>differs from software breakpoints set on tasks in freeze mode, which may be task</p>
<p>specific or AddressSpace specific (see âWorking with Freeze-Mode Breakpointsâ</p>
<p>on page 618). AddressSpace-specific breakpoints are referred to as<i> any-task</i></p>
<p>breakpoints.</p>
<p>Even though you cannot<i> set</i> any-task breakpoints on tasks in TimeMachine mode,</p>
<p>you can hit them. When TimeMachine is launched on an OSA task, TimeMachine</p>
<p>inherits any breakpoints set in the task. Additionally, any-task breakpoints existing</p>
<p>in TimeMachine tasks are copied to other tasks contained in the same AddressSpace</p>
<p>when TimeMachine is launched on these new tasks.</p>
<p>Because any-task breakpoints are inherited from OSA tasks, you can set an any-task</p>
<p>breakpoint in freeze mode and then enable TimeMachine if you want to hit the</p>
<p><i>MULTI: Debugging</i></p>
<p><i>420</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>breakpoint while in TimeMachine mode. Alternatively, you can simulate the behavior</p>
<p>of an any-task breakpoint without actually using one by setting a breakpoint in each</p>
<p>task of an AddressSpace.</p>
<p>In addition to encountering any-task breakpoints as a result of inheritance, you may,</p>
<p>in some limited cases, encounter other types of breakpoints behaving like any-task</p>
<p>breakpoints. Some targets do not provide enough information in the trace stream</p>
<p>for MULTI to determine the active task at each point in the trace. If such a target</p>
<p>traces data accesses, MULTI may attempt to infer task switch information by</p>
<p>utilizing knowledge of the kernel and watching for traced writes to certain addresses.</p>
<p>This is not infallible and sometimes results in incorrect task switch markers in the</p>
<p>trace data. If the trace data does not include task information or if the task</p>
<p>information may be unreliable, all breakpoints set on tasks behave like any-task</p>
<p>breakpoints in TimeMachine mode.</p>
<p>Unlike breakpoints set on tasks while in TimeMachine mode, breakpoints set on</p>
<p>the master process function as any-task breakpoints in the kernel AddressSpace</p>
<p>within TimeMachine.</p>
<p>In TimeMachine mode, breakpoints that are not task specific are only hit when the</p>
<p>breakpointed instruction is executed at the same virtual address and AddressSpace</p>
<p>where the breakpoint was originally set. This is in contrast to the way these</p>
<p>breakpoints behave on the live target, where regardless of how they are set, they</p>
<p>are hit when the breakpointed instruction is executed, even if that instruction has</p>
<p>been mapped to a different virtual address in a different AddressSpace and is</p>
<p>executed there.</p>
<p><b>Note</b></p>
<p>In TimeMachine mode, hardware breakpoints are only displayed in the</p>
<p>OSA master process; however, they still take effect in OSA tasks. Before</p>
<p>you can set a hardware breakpoint in an OSA task for which TimeMachine</p>
<p>is enabled, TimeMachine must be enabled for the master process. If</p>
<p>TimeMachine is not enabled for the master process, MULTI prompts</p>
<p>you to enable it.</p>
<p>When TimeMachine is disabled, any changes that you have made to software or</p>
<p>hardware breakpoints while in TimeMachine mode are applied to the live target.</p>
<p>All breakpoints in the master process revert to normal breakpoints on the target.</p>
<p><i>421</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using TimeMachine with OS Tasks</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Using Separate Session TimeMachine</b></p>
<p>Usually, you debug an OS task or a stand-alone application either in TimeMachine</p>
<p>mode or in live mode. In live mode, you can write registers and memory, invoke</p>
<p>command line procedure calls, collect trace data, run the real target, etc. However,</p>
<p>you cannot step or run backward. In TimeMachine mode, you can step and run</p>
<p>backward, but the live target must be halted. You cannot simultaneously debug a</p>
<p>process in TimeMachine mode and live mode.</p>
<p>For some applications, it is not practical or desirable to halt a live target. If you</p>
<p>want the capability to run and step backward while your live target is running, you</p>
<p>may debug the process by launching TimeMachine as a separate session (called</p>
<p><i>Separate Session TimeMachine</i>). Doing so creates an additional entry in the target</p>
<p>list. Selecting the original target list entry allows you to run and step the process in</p>
<p>live mode. Selecting the new target list entry allows you to run or step the process</p>
<p>backward in Separate Session TimeMachine.</p>
<p>Separate Session TimeMachine functions like regular TimeMachine except for one</p>
<p>key difference: breakpoints are not shared between Separate Session TimeMachine</p>
<p>and live mode. Breakpoints that exist in live mode are copied over to Separate</p>
<p>Session TimeMachine when it first starts, but from that point on, each has distinct</p>
<p>breakpoint sets. If you set a breakpoint on a process while in Separate Session</p>
<p>TimeMachine mode, the breakpoint does not appear in live mode, and vice versa.</p>
<p>To launch Separate Session TimeMachine on an application or on a freeze-mode</p>
<p>task, do one of the following:</p>
<p>â¢</p>
<p>Select the process in the target list and then enter the command<b> timemachine</b></p>
<p><b>ânewsession</b> in the Debugger command pane. See also the<b> timemachine</b></p>
<p>command in Chapter 20, âTrace Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>While the target is running, launch TimeMachine in any of the usual ways. In</p>
<p>the dialog box that appears, choose to launch TimeMachine as a separate</p>
<p>session.</p>
<p>To launch Separate Session TimeMachine from a run-mode task, perform the</p>
<p>following steps:</p>
<p>1.</p>
<p>Establish a freeze-mode connection, and maintain this connection for the</p>
<p>remaining steps.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>422</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>2.</p>
<p>Download and run the kernel.</p>
<p>3.</p>
<p>Establish a run-mode connection via a debug server such as<b> rtserv</b> or<b> rtserv2</b>.</p>
<p>The run-mode connection should be established in the same Debugger window</p>
<p>as the freeze-mode connection.</p>
<p>4.</p>
<p>Collect trace data.</p>
<p>5.</p>
<p>Launch TimeMachine while the kernel is running. In the dialog box that</p>
<p>appears, choose to launch TimeMachine as a separate session.</p>
<p><b>Note</b></p>
<p>Even when you launch TimeMachine from a run-mode task, TimeMachine</p>
<p>is associated with the corresponding freeze-mode task in the target list.</p>
<p>This is because trace data is retrieved from the freeze-mode connection.</p>
<p>All TimeMachine processes on a particular CPU are synchronized. When you debug</p>
<p>a process in Separate Session TimeMachine, any processes that are already in</p>
<p>TimeMachine mode are switched to Separate Session TimeMachine. Once a process</p>
<p>is in Separate Session TimeMachine, attempts to enter TimeMachine mode on any</p>
<p>other process automatically enable Separate Session TimeMachine. It is not possible</p>
<p>to simultaneously debug one process in TimeMachine mode and another in Separate</p>
<p>Session TimeMachine.</p>
<p>To disable Separate Session TimeMachine for a process, right-click the</p>
<p>corresponding target list entry and select<b> Remove</b> from the shortcut menu. If you</p>
<p>want to debug a process in TimeMachine mode, remove all Separate Session</p>
<p>TimeMachine entries from the target list and then launch TimeMachine in the normal</p>
<p>way.</p>
<p><i>423</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using Separate Session TimeMachine</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The PathAnalyzer</b></p>
<p>The PathAnalyzer shows your call stack over time so that you can analyze the</p>
<p>execution path of your program. In addition to displaying the relationship between</p>
<p>all functions, the PathAnalyzer keeps track of the number of times each function is</p>
<p>called and the execution time of every function called.</p>
<p>The PathAnalyzer is a great tool both for debugging and for optimizing for speed.</p>
<p>The graphical display allows you to look for anomalies in your program's execution</p>
<p>path. You might find functions calling functions they should not or taking much</p>
<p>longer than they should. Or you might discover the converse: functions not making</p>
<p>calls they should be making or exiting more quickly than expected. Because the</p>
<p>PathAnalyzer is linked with the TimeMachine Debugger, you need only double-click</p>
<p>a function in the PathAnalyzer to examine it more closely in the TimeMachine</p>
<p>Debugger. The PathAnalyzer's graphical display also makes the distribution of work</p>
<p>clear by showing the amount of work involved for each function. Once you know</p>
<p>what functions take longest, you can examine them in the TimeMachine Debugger</p>
<p>to see what you can do to speed them up.</p>
<p>The PathAnalyzer is also a great tool to use for getting a rough idea of how</p>
<p>unfamiliar code works. It usually only takes a couple minutes of exploring in the</p>
<p>PathAnalyzer to figure out what functions you need to examine in more detail to</p>
<p>solve a problem.</p>
<p><b>Opening the PathAnalyzer</b></p>
<p>To open the PathAnalyzer window, do one of the following:</p>
<p>â¢</p>
<p>In the Debugger window, select<b> TimeMachine</b> â<b> PathAnalyzer</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> tracepath</b> command. For information</p>
<p>about this command, see Chapter 20, âTrace Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>In the Trace List, click the<b> PathAnalyzer</b> button (</p>
<p>) located on the toolbar.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>424</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The PathAnalyzer Window</b></p>
<p>This section describes the basic parts of the PathAnalyzer window, how function</p>
<p>calls are colored in the PathAnalyzer, and how to display information for a function.</p>
<p>Additional information about features you can access from this window is located</p>
<p>in:</p>
<p>â¢</p>
<p>âNavigating Path Analysis Dataâ on page 428</p>
<p>â¢</p>
<p>âUsing Fast-Find in the PathAnalyzerâ on page 430</p>
<p>â¢</p>
<p>âBrowsing References of a Functionâ on page 431</p>
<p>â¢</p>
<p>âViewing, Editing, and Adding Bookmarks in the PathAnalyzerâ on page 432</p>
<p>â¢</p>
<p>âAnalyzing Operating System Trace Dataâ on page 432</p>
<p>Depending on the target you are tracing, the horizontal axis of the PathAnalyzer's</p>
<p>central pane can represent time, instruction counts, or cycle counts. If your trace</p>
<p>data includes timestamps, the horizontal axis represents time. If your trace data</p>
<p>includes cycle counts, but does not include timestamps, the horizontal axis uses</p>
<p>cycle counts. If neither timestamps nor cycle counts are available, the horizontal</p>
<p>axis uses instruction counts.</p>
<p>Some hardware targets support more than one type of data collection. To set which</p>
<p>type of trace data you want to collect, perform the following steps:</p>
<p>1.</p>
<p>In the PathAnalyzer, select<b> Config</b> â<b> Options</b>.</p>
<p>2.</p>
<p>In the<b> Trace Options</b> window that appears, click the<b> Target Specific Options</b></p>
<p>button located on the<b> Collection</b> tab, or click the target-specific tab. (Only one</p>
<p>or the other will appear.)</p>
<p><b>Tip</b></p>
<p>Typically, if you want to analyze performance, you should collect trace</p>
<p>data with timestamps. However, if you are tracking down a difficult bug</p>
<p>or race condition or are trying to get a better understanding of your code</p>
<p>flow, collecting trace data by instruction count is most helpful.</p>
<p>The vertical axis in the PathAnalyzer's central pane represents call stack depth. As</p>
<p>function calls are made, the stack depth increases downward.</p>
<p><i>425</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The PathAnalyzer Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Each colored bar in the PathAnalyzer represents a single function call. The bar's</p>
<p>length is proportional to the length of time (or the number of instructions) it has</p>
<p>executed. By default, the PathAnalyzer colors function calls by hashing the name</p>
<p>of the function. However, you can also color functions by their filename or class</p>
<p>name. To change the method by which functions are colored, select<b> PathAnalyzer</b></p>
<p>â<b> Color by Filename</b> or<b> PathAnalyzer</b> â<b> Color by Class</b>.</p>
<p>You can display information about a function in any one of the following ways:</p>
<p>â¢</p>
<p>Hover your mouse over a function to display a tool-tip with information about</p>
<p>the function.</p>
<p>â¢</p>
<p>Click a function to view information about it in the status bar (located at the</p>
<p>bottom of the PathAnalyzer window).</p>
<p>â¢</p>
<p>Click the</p>
<p>button or press the number 1 on your keyboard to access the</p>
<p><b>Measure Tool</b>. To measure the difference between two points, click a point</p>
<p><i>MULTI: Debugging</i></p>
<p><i>426</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>in the PathAnalyzer and drag your mouse right or left to create a selection. To</p>
<p>zoom in on your selection, click the<b> Zoom to Selection</b> button (</p>
<p>).</p>
<p><b>The Thumbnail Pane</b></p>
<p>The thumbnail pane (located at the bottom of the PathAnalyzer window) displays</p>
<p>PathAnalyzer data in summary, giving you a bird's-eye view of your call stack over</p>
<p>the entire span of your trace data.</p>
<p>The minimum call stack depth at a particular time is represented by the point where</p>
<p>the light blue color meets the dark blue line. The maximum call stack depth at a</p>
<p>particular time is represented by the point where the dark blue line meets the</p>
<p>background color. In the following graphic, the background color is white.</p>
<p>If you have not collected much trace data, the difference between the minimum and</p>
<p>the maximum values may not be very great, resulting in what appears to be a single</p>
<p>line.</p>
<p>You can zoom the PathAnalyzer in and out by clicking a point in the thumbnail</p>
<p>pane and dragging your mouse right or left. The wider your selection, the more</p>
<p>function calls are displayed in the central part of the window (equivalent to zooming</p>
<p>out). The narrower your selection, the fewer the function calls displayed in central</p>
<p>part of the window (equivalent to zooming in). After you have made your initial</p>
<p>selection, you can zoom in or out by dragging the right and left edges of your</p>
<p>selection.</p>
<p>The thumbnail pane also acts as the horizontal scroll bar for the PathAnalyzer. To</p>
<p>pan right or left from the thumbnail pane, do one of the following:</p>
<p>â¢</p>
<p>Click the center of the thumbnail pane selection and drag it right or left.</p>
<p><i>427</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The PathAnalyzer Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Click a new point in the thumbnail pane. If you click outside your current</p>
<p>thumbnail pane selection, the selection moves to your new location.</p>
<p>â¢</p>
<p>Click the<b> Pan Right</b> or<b> Pan Left</b> button. These buttons are located at either</p>
<p>end of the thumbnail pane, as shown in the following graphic.</p>
<p>Bookmarks are displayed as short vertical lines in the thumbnail pane. Each</p>
<p>bookmark is colored according to the color set in the<b> Trace Bookmarks</b> window.</p>
<p>For more information about bookmarks, see âViewing, Editing, and Adding</p>
<p>Bookmarks in the PathAnalyzerâ on page 432.</p>
<p><b>Navigating Path Analysis Data</b></p>
<p>Embedded processors generate massive amounts of trace data. As a result, it is</p>
<p>completely typical to analyze a path analysis run with hundreds of millions of</p>
<p>instructions. When that much complexity is involved, simply looking, function by</p>
<p>function, at your function flow is not feasible. To help you efficiently interact with</p>
<p>the generated data, the PathAnalyzer provides a variety of navigational tools, which</p>
<p>are described next. (See also âSearching Path Analysis Dataâ on page 430.)</p>
<p>â¢</p>
<p><i>Cursor</i> â When data is available in the PathAnalyzer, a cursor, which indicates</p>
<p>the position of the currently selected trace packet, is also available. The cursor</p>
<p>is the black vertical line displayed in the graphic in âThe PathAnalyzer Windowâ</p>
<p>on page 425. By default, the cursor's location is shared among other</p>
<p>TimeMachine tools. As a result, clicking a different location in the PathAnalyzer</p>
<p>changes not only the position of the cursor in the PathAnalyzer, but also the</p>
<p>selection in the Trace List and the state of the target in the TimeMachine</p>
<p>Debugger. Likewise, if you run or step in the TimeMachine Debugger, the</p>
<p>PathAnalyzer's cursor also moves. If the Debugger is not in TimeMachine</p>
<p>mode, clicking a different location in the PathAnalyzer will warp the Debugger</p>
<p>to show that location in the source pane and will highlight the associated source</p>
<p>line or instruction.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>428</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If you do not want the cursor to be synchronized with the Debugger and the</p>
<p>Trace List, you can âunlinkâ the tools by clicking the pushed down<b> Unlink</b></p>
<p><b>Selection</b> button (</p>
<p>).</p>
<p>â¢</p>
<p><i>Bookmarks</i> â When you find some interesting data in the PathAnalyzer, you</p>
<p>can bookmark it so that you can easily find it again later. You can assign each</p>
<p>bookmark a name and color. Bookmarks appear in the PathAnalyzer as colored</p>
<p>vertical lines. In addition to any bookmarks you might create yourself, MULTI</p>
<p>automatically selects and bookmarks the trigger packet when trace data is first</p>
<p>collected. The default name for the trigger bookmark is âTrigger,â and it is</p>
<p>colored red by default (see the graphic in âThe PathAnalyzer Windowâ</p>
<p>on page 425). For more information about using bookmarks with the</p>
<p>PathAnalyzer, see âViewing, Editing, and Adding Bookmarks in the</p>
<p>PathAnalyzerâ on page 432.</p>
<p>â¢</p>
<p><i>Smooth Scrolling</i> â When the location of the PathAnalyzer cursor is</p>
<p>synchronized with other TimeMachine tools (see preceding bullet point), and</p>
<p>the cursor moves because of a location change in another window, the</p>
<p>adjustment can be disorienting. To make the transition less sudden, the</p>
<p>PathAnalyzer has a smooth-scrolling feature. When the location of the cursor</p>
<p>is updated to reflect a change in another window, the Path Analyzer gradually</p>
<p>scrolls you to the new destination.</p>
<p>You can toggle smooth scrolling on and off by selecting<b> PathAnalyzer</b> â</p>
<p><b>Enable Smooth Scrolling</b>.</p>
<p>â¢</p>
<p><i>One-Click Zoom Tool</i> â The easiest way to zoom in is by using the zoom tool.</p>
<p>To access this tool, click the<b> Zoom Tool</b> button (</p>
<p>) or press the number 2 on</p>
<p>your keyboard. To zoom in, click a point in the PathAnalyzer and drag your</p>
<p>mouse right or left to create a selection. For more information about zooming</p>
<p>methods, see the following table.</p>
<p>â¢</p>
<p><i>Pan Tool</i> â To pan right and left, you can use the pan tool. To access this tool,</p>
<p>click the<b> Pan Tool</b> button (</p>
<p>) or press the number 3 on your keyboard. Click</p>
<p>a spot in the PathAnalyzer and drag right or left. For more information about</p>
<p>panning methods, see the following table.</p>
<p>The following table lists different ways to zoom and pan.</p>
<p><i>429</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Navigating Path Analysis Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Method</b></p>
<p><b>Desired Action</b></p>
<p>â¢</p>
<p>Click the<b> Zoom in</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>Press<b> Ctrl</b>+<b>UpArrow</b>.</p>
<p>â¢</p>
<p>Press<b> Ctrl</b> while using the mouse scroll wheel to scroll up.</p>
<p>Zoom in</p>
<p>â¢</p>
<p>Click the<b> Zoom Tool</b> button (</p>
<p>). Then click a point in the</p>
<p>PathAnalyzer and drag your mouse right or left to create a selection.</p>
<p>â¢</p>
<p>Press the number 2 on your keyboard. Then click a point in the</p>
<p>PathAnalyzer and drag your mouse right or left to create a selection.</p>
<p>Zoom in on a</p>
<p>selection</p>
<p>â¢</p>
<p>Click the<b> Zoom out</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>Press<b> Ctrl</b>+<b>DownArrow</b>.</p>
<p>â¢</p>
<p>Press<b> Ctrl</b> while using the mouse scroll wheel to scroll down.</p>
<p>Zoom out</p>
<p>â¢</p>
<p>Click the<b> Show entire timeline</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>Press<b> Ctrl</b>+<b>Home</b>.</p>
<p>Zoom out</p>
<p>completely</p>
<p>â¢</p>
<p>Click the<b> Pan Right</b> button located in the bottom-right corner of the</p>
<p>PathAnalyzer window. (See the second graphic in âThe Thumbnail</p>
<p>Paneâ on page 427.)</p>
<p>â¢</p>
<p>Press<b> Ctrl</b>+<b>RightArrow</b>.</p>
<p>Pan right</p>
<p>â¢</p>
<p>Click the<b> Pan Left</b> button located in the bottom-left corner of the</p>
<p>PathAnalyzer window. (See the second graphic in âThe Thumbnail</p>
<p>Paneâ on page 427.)</p>
<p>â¢</p>
<p>Press<b> Ctrl</b>+<b>LeftArrow</b>.</p>
<p>Pan left</p>
<p><b>Searching Path Analysis Data</b></p>
<p>To help you find important information, the PathAnalyzer provides two different</p>
<p>search mechanisms. These mechanisms are described in the following sections.</p>
<p>(See also âNavigating Path Analysis Dataâ on page 428.)</p>
<p><b>Using Fast-Find in the PathAnalyzer</b></p>
<p>The<b> Fast-Find</b> feature provides you with an easy way to search through trace data.</p>
<p>Simply type search term(s) into the<b> Fast-Find</b> text field located in the top-right</p>
<p><i>MULTI: Debugging</i></p>
<p><i>430</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>corner of the PathAnalyzer window. Everything in the PathAnalyzer that does not</p>
<p>match the search string turns gray.</p>
<p>You may enter as many search strings as you want. All search strings are processed</p>
<p>through a logical AND. That is, a function turns gray unless it contains all of the</p>
<p>search strings.</p>
<p>To eliminate functions from your search, use the</p>
<p>-</p>
<p>(minus) operator. A function is</p>
<p>eliminated when its name matches the string following the minus sign.</p>
<p>Searches are case-insensitive unless you use capital letters in the search string.</p>
<p>Example search strings follow:</p>
<p>â¢</p>
<p><b>Fast-Find:</b></p>
<p>foo -bar</p>
<p>â</p>
<p>This string is case-insensitive.</p>
<p>â</p>
<p>Entering this string displays all functions whose names contain the string</p>
<p>foo</p>
<p>but not the string</p>
<p>bar</p>
<p>.</p>
<p>â¢</p>
<p><b>Fast-Find:</b></p>
<p>sendMsg_ âsync</p>
<p>â</p>
<p>This string is case-sensitive.</p>
<p>â</p>
<p>Entering this string displays all functions whose names contain the string</p>
<p>sendMsg_</p>
<p>but not the string</p>
<p>sync</p>
<p>.</p>
<p><b>Browsing References of a Function</b></p>
<p>It is often useful to see a list of every call to a function with call sites and durations.</p>
<p>This can be accomplished with the<b> Trace Call Browser</b>. To open a<b> Trace Call</b></p>
<p><b>Browser</b> directly from the PathAnalyzer, right-click a single instance of a function,</p>
<p>and select<b> Find Function References</b>. If you cannot easily find the function you</p>
<p>are looking for in the PathAnalyzer, there are many other ways to open it in a<b> Trace</b></p>
<p><b>Call Browser</b>. For more information, see âThe Trace Call Browserâ on page 457.</p>
<p><i>431</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Searching Path Analysis Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing, Editing, and Adding Bookmarks in the PathAnalyzer</b></p>
<p>The TimeMachine bookmark system is tightly integrated with the PathAnalyzer,</p>
<p>through which you can view, edit, and add bookmarks.</p>
<p>Bookmarks appear in the PathAnalyzer as colored vertical lines. The color of the</p>
<p>line corresponds to the bookmark's color as set in the<b> Trace Bookmarks</b> window.</p>
<p>For more information, see âBookmarking Trace Dataâ on page 444.</p>
<p>To view a list of available bookmarks, select the PathAnalyzer's<b> Bookmarks</b> menu.</p>
<p>To jump to a particular bookmark, select the bookmark in the<b> Bookmarks</b> menu.</p>
<p>The easiest way to edit bookmarks is by using the<b> Trace Bookmarks</b> window.</p>
<p>Select<b> Bookmarks</b> â<b> Edit Bookmarks</b>. For more information, see âBookmarking</p>
<p>Trace Dataâ on page 444.</p>
<p>You can easily add a bookmark by right-clicking a function in the PathAnalyzer.</p>
<p>You have the option of adding the bookmark to the beginning of the selected function</p>
<p>(<b>Add Bookmark at Entry</b>), to the end of the selected function (<b>Add Bookmark</b></p>
<p><b>at Exit</b>), or to the point of selection (<b>Add Bookmark at Cursor</b>).</p>
<p><b>Analyzing Operating System Trace Data</b></p>
<p>The PathAnalyzer has two features that help you analyze operating system trace</p>
<p>data:</p>
<p>â¢</p>
<p>An EventAnalyzer pane within the PathAnalyzer</p>
<p>â¢</p>
<p>The ability to view a single AddressSpace in the PathAnalyzer</p>
<p>These features automatically become available when you trace an operating system</p>
<p>that is supported by the trace tools.</p>
<p><b>Viewing Data in the EventAnalyzer Pane</b></p>
<p>The EventAnalyzer pane appears directly above the PathAnalyzer. It displays</p>
<p>operating system events and context switches.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>432</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The name of each task is displayed in the topmost portion of the EventAnalyzer</p>
<p>pane. The current task is displayed as a green horizontal line. To highlight a task,</p>
<p>hover your mouse over it. When a task is highlighted, its name is prominently</p>
<p>displayed in the top portion of the EventAnalyzer pane and its context switches turn</p>
<p>a brighter shade of green.</p>
<p>The EventAnalyzer pane is not as fully featured as the MULTI EventAnalyzer. To</p>
<p>access the full MULTI EventAnalyzer, click the</p>
<p>button. For information about</p>
<p>the MULTI EventAnalyzer, see the<i> EventAnalyzer User's Guide</i> or the</p>
<p>documentation about using the MULTI EventAnalyzer for ThreadX in the<i> MULTI:</i></p>
<p><i>Developing for ThreadX</i> book.</p>
<p><b>Note</b></p>
<p>Certain architectures support AddressSpace tracing but not task tracing.</p>
<p>If this is the case, you are able to see context changes between different</p>
<p>AddressSpaces but not context switches within a single AddressSpace.</p>
<p>For more information, see âDealing with Incomplete Trace Dataâ</p>
<p>on page 411.</p>
<p><i>433</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Analyzing Operating System Trace Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing a Single AddressSpace in the Path Analyzer</b></p>
<p>When you trace an entire operating system, a large amount of information is</p>
<p>displayed in the PathAnalyzer. If you are only interested in seeing one AddressSpace,</p>
<p>you can launch a new PathAnalyzer that only displays function calls in that particular</p>
<p>AddressSpace. To view a single AddressSpace in a new PathAnalyzer, select the</p>
<p>AddressSpace you want to view from the<b> PathAnalyzer</b> menu.</p>
<p><b>Viewing Trace Data in the Trace List</b></p>
<p>The Trace List allows you to view and explore trace data at the function and</p>
<p>assembly levels and to control trace collection. It also provides access to advanced</p>
<p>trigger, search, filter, and bookmark controls, in addition to various trace data</p>
<p>analysis tools. To open the Trace List, do one of the following:</p>
<p>â¢</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> Trace List</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> trace list</b> command. For information</p>
<p>about this command, see Chapter 20, âTrace Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>434</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Trace List</b></p>
<p>The Trace List consists of three panes that make it easy to browse through trace</p>
<p>data:</p>
<p>â¢</p>
<p>The<i> tree pane</i>, which appears on the left side of the window, displays the call</p>
<p>stack in a tree view. Each node in the tree represents a function call. Expanding</p>
<p>a node displays additional, chronologically ordered nodes for all the functions</p>
<p>called during the associated function call. When you are tracing an application</p>
<p>with multiple tasks or AddressSpaces, top-level function nodes also display</p>
<p>the name of the associated task or AddressSpace.</p>
<p>â¢</p>
<p>The<i> instruction pane</i>, which appears on the right side of the window, displays</p>
<p>a list of executed instructions. This pane shows all the instructions in a single</p>
<p>list, regardless of what function or AddressSpace the instructions reside in.</p>
<p>â¢</p>
<p>The<i> thumbnail pane</i>, which appears in the bottom of the window, displays the</p>
<p>call stack of your program over time. This pane provides an overview that</p>
<p>shows when your program was calling many functions and when it was</p>
<p>executing a relatively shallow call stack. The thumbnail pane also displays the</p>
<p>amount of time you spent gathering trace data, any bookmarks you may have</p>
<p>set, and your current location in the trace buffer.</p>
<p><b>The Tree Pane</b></p>
<p>The tree pane groups trace data into function calls, enabling you to see where you</p>
<p>are browsing relative to other function calls. This eases the process of browsing</p>
<p>complicated code by allowing you to jump to a point in time by selecting a function.</p>
<p>To enable you to see what functions called what other functions, the tree pane's</p>
<p><b>Function Calls</b> column displays executed functions in tree form. At each level,</p>
<p>you can expand a function to display the functions it called. To navigate to the trace</p>
<p>data corresponding to a function, select the function in the tree list.</p>
<p>The tree pane's<b> Duration</b> column displays the amount of time that the given function</p>
<p>took to execute. Depending upon your trace collection settings, the duration is</p>
<p>displayed in instruction counts, cycles, or elapsed time. The duration includes the</p>
<p>time taken by the given function as well as the time taken by functions it called.</p>
<p>The splitter between the tree pane and the instruction pane allows you to resize the</p>
<p>tree pane for the appropriate amount of detail.</p>
<p><i>435</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Trace List</i></p>
<h1 style="page-break-before:always; "></h1>
<p>When you are tracing a target with multiple tasks, context switches between tasks</p>
<p>appear as multiple top-level entries in the tree pane. If the target operating system</p>
<p>supports multiple AddressSpaces, top-level entries include the AddressSpace name.</p>
<p>If task-aware trace is supported, they also include the task name. Colons are used</p>
<p>as delimiters between the AddressSpace name, task name, and function name. When</p>
<p>all three are available, top-level nodes have names of the form</p>
<p><i>AddressSpace</i></p>
<p>:</p>
<p><i>Task</i></p>
<p>:</p>
<p><i>Function</i></p>
<p>. Alternating colors ease readability and highlight</p>
<p>context switches.</p>
<p><b>The Instruction Pane</b></p>
<p>The instruction pane provides up to eleven columns of information for each</p>
<p>instruction. Some columns only apply to certain instructions.</p>
<p>If you want to focus only on certain columns of information in the instruction pane,</p>
<p>you can hide columns by right-clicking the column header. Then select the<b> Hide</b></p>
<p><b>column</b> menu option that corresponds to the column you want to hide. The menu</p>
<p>items corresponding to hidden columns appear ticked. To show the column again,</p>
<p>select the menu item and the column appears.</p>
<p>To rearrange the columns, click and drag the column header of the column you</p>
<p>want to move. Move it horizontally to the desired location and release the mouse</p>
<p>button. To resize a column, click and drag the right border of the column header.</p>
<p>To automatically resize a column so that all data in the column is shown, double-click</p>
<p>the right border of the column header. Column order and size are automatically</p>
<p>saved between sessions.</p>
<p>Each column and the information it contains is described in the following table.</p>
<p>Shows whether or not the instruction is bookmarked. When a</p>
<p>bookmark is present, a small flag is drawn in the color of the</p>
<p>bookmark. When no bookmark is present, a light gray line is</p>
<p>displayed. You can add or remove a bookmark by clicking the</p>
<p>vertical gray line or the flag, respectively.</p>
<p>Unlabeled left-most</p>
<p>column</p>
<p>The address of the instruction. If the instruction was in a known</p>
<p>function, the function name and offset into the function is also</p>
<p>displayed.</p>
<p><b>Address</b></p>
<p>The disassembled instruction.</p>
<p><b>Instruction</b></p>
<p>The opcode of the instruction.</p>
<p><b>Opcode</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>436</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The address that the instruction loaded from or stored to. This column</p>
<p>only applies if the instruction performed a traced load or store.</p>
<p><b>Data Address</b></p>
<p>The type of memory access performed by the instruction. If the</p>
<p>instruction read data from memory, this column contains an</p>
<p>R</p>
<p>. If the</p>
<p>instruction wrote data to memory, this column contains a</p>
<p>W</p>
<p>. This</p>
<p>column only applies if the instruction performed a traced load or</p>
<p>store.</p>
<p><b>Access</b></p>
<p>The value loaded from or stored to memory. This column only applies</p>
<p>if the instruction performed a traced load or store.</p>
<p><b>Value</b></p>
<p>Yes</p>
<p>if the instruction met its condition code requirements and was</p>
<p>executed,</p>
<p>No</p>
<p>if it did not. This column only applies if your target</p>
<p>has conditional execution.</p>
<p><b>Executed</b></p>
<p>The number of cycles the instruction took to execute. This column</p>
<p>only applies if your target supports cycle count tracing and cycle</p>
<p>counts are enabled.</p>
<p><b>Cycles</b></p>
<p>The time taken to execute the instruction. This column only applies</p>
<p>if your target supports trace timestamps and timestamps are enabled.</p>
<p><b>Time</b></p>
<p>The name of this column depends upon whether you have</p>
<p>timestamps, cycle counts, or neither enabled. If you have timestamps,</p>
<p>the cumulative time to that line is displayed. If you have no</p>
<p>timestamps but you do have cycle counts, this column displays the</p>
<p>cumulative cycle count up to this line. If you have neither timestamps</p>
<p>nor cycle counts, this column displays the total number of instructions</p>
<p>to this point in the trace data.</p>
<p>All values displayed in this column are relative to one lineâinitially</p>
<p>the triggerâwith negative numbers indicating that an instruction</p>
<p>was executed before the zero line.</p>
<p><b>Total Instructions,</b></p>
<p><b>Total Cycles, or Total</b></p>
<p><b>Time</b></p>
<p>If an instruction performed multiple data accesses, only the first data access is listed</p>
<p>on the same line as the instruction. The additional data accesses are shown on</p>
<p>separate lines that are initially hidden. To show the additional data accesses, click</p>
<p>the plus sign (</p>
<p>) to the left of the instruction.</p>
<p>In addition to lines representing instructions, functions, and AddressSpaces, the</p>
<p>Trace List also includes lines that represent trace events. Trace events include</p>
<p>exceptions, trace overflows, markers that indicate that the trace was disabled, markers</p>
<p>that indicate that the target entered debug mode, and trace processing errors. Each</p>
<p>of these events is displayed on a separate line in red text in the<b> Address</b> column.</p>
<p><i>437</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Trace List</i></p>
<h1 style="page-break-before:always; "></h1>
<p>With the default color scheme, normal instructions and data accesses are displayed</p>
<p>with black text. On some targets, you may see blocks of instructions and data</p>
<p>accesses highlighted in blue. This indicates that those instructions and data accesses</p>
<p>were not present in the raw trace data because of an on-chip trace FIFO overflow,</p>
<p>but that MULTI was able to determine with a high degree of certainty that those</p>
<p>instructions and data accesses actually occurred. MULTI accomplishes this by</p>
<p>examining the trace data both before and after the overflow and simulating the code</p>
<p>in between. A line with red text reading<b> FIFO Overflow</b> indicates that MULTI was</p>
<p>unable to reconstruct all of the instructions lost as a result of a FIFO overflow. For</p>
<p>more information, see the option<b> Attempt to reconstruct gaps in trace data</b> in</p>
<p>âThe Trace Options Windowâ on page 480. It is also possible to create filters that</p>
<p>color lines in the Trace List in any color. For more information, see âFiltering Trace</p>
<p>Data in the Trace Listâ on page 442.</p>
<p>You can print the contents of the instruction pane by selecting<b> File</b> â<b> Print</b> from</p>
<p>the Trace List menu bar. To print the contents of the instruction pane to a text file,</p>
<p>select<b> File</b> â<b> Print To Text File</b>. In both cases, the instruction pane is formatted</p>
<p>as it is currently displayed. If a column is not wide enough to display the full contents</p>
<p>of a cell, that cell's contents are truncated in the printed output as well. If you would</p>
<p>like to output the trace data in a program readable format, select<b> File</b> â<b> Export As</b></p>
<p><b>CSV</b>. This outputs the trace data in Comma Separated Value format to a text file.</p>
<p>You can control which columns appear in the CSV file by showing and hiding them</p>
<p>in the instruction pane. Columns that are displayed in the instruction pane are</p>
<p>exported to the CSV file, columns that are hidden are not.</p>
<p>All three of the preceding menu options open the<b> Choose a region</b> dialog box,</p>
<p>which asks you to select a region of trace data to act upon.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>438</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>By default, only the visible portion of the instruction pane is printed or exported,</p>
<p>but you can select the<b> All</b> radio button to print or export the entire contents of the</p>
<p>instruction pane. Alternatively, select the<b> Custom Region</b> radio button to print or</p>
<p>export a specific range of data. To identify a custom region, select bookmarks that</p>
<p>delimit the region or specify start and end times by manually typing them into the</p>
<p><b>Start</b> and<b> End</b> fields or by clicking the box to the right of either field and then</p>
<p>clicking an instruction in the Trace List. If you selected<b> File</b> â<b> Print</b>, the dialog</p>
<p>box indicates the number of lines of text that will be printed when you click<b> OK</b>.</p>
<p>If you selected<b> File</b> â<b> Print To Text File</b>, the dialog box shows the estimated size</p>
<p>of the resulting file.</p>
<p><b>The Thumbnail Pane</b></p>
<p>The thumbnail pane is a graphical representation of your call stack over the entire</p>
<p>time span of your trace buffer. The thumbnail pane in the Trace List is equivalent</p>
<p>to that in the PathAnalyzer except that the Trace List's thumbnail pane lacks pan</p>
<p>and zoom controls. See âThe Thumbnail Paneâ on page 427.</p>
<p>The thumbnail pane allows you to quickly navigate to any data point by clicking a</p>
<p>point in the pane. The thumbnail pane indicates the position of the selected</p>
<p>instruction with a vertical cursor.</p>
<p>Any bookmarks that you set are displayed as short vertical lines in the thumbnail</p>
<p>pane. Each bookmark is colored according to the color set in the<b> Trace Bookmarks</b></p>
<p>window. To display a bookmark in the instruction pane, click the bookmark's vertical</p>
<p>line in the thumbnail pane. For more information about bookmarks, see</p>
<p>âBookmarking Trace Dataâ on page 444.</p>
<p><b>Time Analysis</b></p>
<p>One of the major benefits of collecting trace data is that it allows you to</p>
<p>non-intrusively determine what the processor is doing while the processor is running</p>
<p>at full speed. Analyzing trace data allows you to determine the time between two</p>
<p>events. In this context, an event can be anything that appears in the Trace List,</p>
<p>including instructions, function calls, memory accesses, and even interrupts.</p>
<p><i>439</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Time Analysis</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Total</b> column in the Trace List always displays the cumulative time before the</p>
<p>instruction on a line is executed. This column displays the following information</p>
<p>in each of these cases:</p>
<p>â¢</p>
<p>When you have time tags enabled on your trace collection device, this column</p>
<p>is called<b> Total Time</b> and displays the total time before each instruction.</p>
<p>â¢</p>
<p>When you have no time tags enabled, but you have cycle-accurate mode</p>
<p>enabled, this column is called<b> Total Cycles</b> and displays the total number of</p>
<p>cycles elapsed before each instruction is executed.</p>
<p>â¢</p>
<p>When you have neither time tags nor cycle-accurate mode enabled, this column</p>
<p>is called<b> Total Instructions</b> and displays the total number of instructions</p>
<p>executed before each instruction is executed.</p>
<p>This information allows you to find two points in your trace data and determine the</p>
<p>total amount of time, number of cycles, or number of instructions elapsed, between</p>
<p>two points.</p>
<p>In addition, you can set the<b> Total</b> column to 0 at any line so that the Trace List can</p>
<p>do the required subtraction. This makes it easy, for example, to find what was</p>
<p>happening exactly 10 milliseconds after an interrupt. It also allows you to easily</p>
<p>find the time between 2 events of interest. For example, if you want to know exactly</p>
<p>how long the interrupt handler for a high-priority interrupt takes, you can set the</p>
<p><b>Total</b> column to 0 when the interrupt occurs, then find the return from the interrupt</p>
<p>handler and see what the elapsed time is.</p>
<p>To set the<b> Total</b> column to 0 on a line, simply right-click the line and select<b> Set</b></p>
<p><b>Total Time to 0 on this Line</b>. When this option is selected, the Trace List will</p>
<p>refresh and the selected line will have its<b> Total</b> column set to 0. All other instructions</p>
<p>will now have their<b> Total</b> value relative to the selected line. Negative numbers</p>
<p>indicate that an instruction executed before the selected line and positive numbers</p>
<p>indicate that an instruction executed after the selected line.</p>
<p><b>Navigating through Trace Data</b></p>
<p>The Trace List has many features to make it easy to navigate through large trace</p>
<p>buffers. These features allow you to easily find occurrences of instructions, functions</p>
<p>and variables in your trace data as well as recall previous lines you have viewed.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>440</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Navigating Based on Trace Data</b></p>
<p>If you are looking for an event of interest, you may not find the specific execution</p>
<p>of an address or data access that you are looking for on the first try. The Trace List</p>
<p>allows you to easily navigate to the previous or next execution of an instruction or</p>
<p>access to a data address.</p>
<p>â¢</p>
<p>To navigate to the previous execution of an instruction, right-click the</p>
<p>instruction of interest. In the shortcut menu that appears, select<b> Go to Previous</b></p>
<p><b>Execution</b>. The Trace List selects the previous execution of the selected</p>
<p>instruction.</p>
<p>â¢</p>
<p>To navigate to the next execution of an instruction, right-click the instruction</p>
<p>of interest. In the shortcut menu that appears, select<b> Go to Next Execution</b>.</p>
<p>The Trace List selects the next execution of the selected instruction.</p>
<p>â¢</p>
<p>To navigate to the previous data access at an address, right-click a line that</p>
<p>shows an access of the data address of interest. In the shortcut menu that</p>
<p>appears, select<b> Go to Previous Data Access</b>. The Trace List selects the</p>
<p>instruction that last accessed the selected data address.</p>
<p>â¢</p>
<p>To navigate to the next data access at an address, right-click a line that shows</p>
<p>an access of the data address of interest. In the shortcut menu that appears,</p>
<p>select<b> Go to Next Data Access</b>. The Trace List selects the next instruction that</p>
<p>accessed the selected data address.</p>
<p>If no previous or next instance of an event exists, the Trace List prints an error</p>
<p>message in its status bar.</p>
<p>By default, the selected instruction is shared among other TimeMachine tools. As</p>
<p>a result, clicking a different line in the Trace List also moves the cursor in the</p>
<p>PathAnalyzer and changes the state of the target in the TimeMachine Debugger.</p>
<p>Likewise, if you click a different location in the PathAnalyzer or if you run or step</p>
<p>in the TimeMachine Debugger, the selection in the Trace List also changes. If the</p>
<p>Debugger is not in TimeMachine mode, clicking a different line in the Trace List</p>
<p>will warp the Debugger to show that location in the source pane and will highlight</p>
<p>the associated source line or instruction.</p>
<p>If you do not want the selection to be synchronized with the Debugger and the</p>
<p>PathAnalyzer, you can âunlinkâ the tools by clicking the pushed down<b> Unlink</b></p>
<p><b>Selection</b> button (</p>
<p>).</p>
<p><i>441</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Navigating through Trace Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Browse History</b></p>
<p>The</p>
<p>and</p>
<p>buttons allow you to move to the previous and next instructions that</p>
<p>have been selected in the Trace List. These buttons work just like similar buttons</p>
<p>on standard Web browsers. This allows you to easily move between various</p>
<p>instructions that you have examined in your trace data.</p>
<p><b>Filtering Trace Data in the Trace List</b></p>
<p>The Trace List provides the ability to filter trace data, which makes it easier for you</p>
<p>to find the data that you are looking for. You can hide, show or color groups of</p>
<p>instructions based on various criteria. Filtering only affects the instruction pane so</p>
<p>that you do not lose your context in the tree pane.</p>
<p>To hide all executions of a function in the instruction pane, simply right-click an</p>
<p>instruction from the function you want to hide and select<b> Hide Function</b></p>
<p><i><b>function_name</b></i>. The data redisplays with the selected function hidden.</p>
<p>In addition, you can define more complex filters using the<b> Trace Filters</b> dialog. To</p>
<p>access this dialog, select<b> Search</b> â<b> Filters</b> from the menu bar or click</p>
<p>on the</p>
<p>toolbar.</p>
<p>The<b> Trace Filters</b> dialog consists of a list of currently active filters as well as</p>
<p>controls to add new filters. To add a filter, select the action you would like the filter</p>
<p>to have and the type of event to filter. Then enter a function name, source line,</p>
<p>address, or variable name and an optional value for data accesses. When you select</p>
<p><i>MULTI: Debugging</i></p>
<p><i>442</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>the<b> Color</b> action, you can also specify the color for the matching lines. Then click</p>
<p>the<b> Add</b> button. You can add as many filters as you would like in this manner.</p>
<p><b>Note</b></p>
<p>On INTEGRITY, you may only use kernel space symbols when creating</p>
<p>filters. Also note that Trace List filters currently match virtual addresses</p>
<p>in all AddressSpaces. For example, if you create a filter on a<b> Data Read</b></p>
<p>at<b> Address</b></p>
<p>0x1000</p>
<p>, MULTI triggers the filter when</p>
<p>0x1000</p>
<p>is read in</p>
<p>any AddressSpace.</p>
<p>Filters are applied in the order that they are added and once a line matches a single</p>
<p>filter, processing for that line stops. This means that if multiple filters match on a</p>
<p>given line, the action specified by the first one in the<b> Active Filters</b> list is performed.</p>
<p>For example, if two filters match on a line and the first is to<b> Color</b> and the second</p>
<p>is to<b> Hide</b> that line, the line is colored rather than hidden.</p>
<p>You can edit an existing filter by selecting it in the<b> Active Filters</b> list and changing</p>
<p>the values associated with it. Then click the<b> Set</b> button to confirm the new filter</p>
<p>settings. The<b> Add</b> button remains active, allowing you to add a new filter based on</p>
<p>the previous filter.</p>
<p>In addition, you can edit a filter to specify a complex event by selecting an existing</p>
<p>filter and clicking the<b> Advanced Edit</b> button. This opens the<b> Advanced Event</b></p>
<p><b>Editor</b> window, which allows you to define a complex event. When you click<b> OK</b></p>
<p>in the<b> Advanced Event Editor</b> window, the changes are automatically applied to</p>
<p>the selected filter. For more information about using the<b> Advanced Event Editor</b></p>
<p>window, see âEditing Complex Eventsâ on page 497.</p>
<p>You can also manage your list of filters either by clearing all filters or by deleting</p>
<p>an individual filter.</p>
<p>â¢</p>
<p>To clear all existing filters, click the<b> Clear All</b> button.</p>
<p>â¢</p>
<p>To delete an individual filter, select it in the<b> Active Filters</b> list and click the</p>
<p><b>Delete</b> button.</p>
<p><i>443</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Filtering Trace Data in the Trace List</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Accessing TimeMachine Analysis Tools</b></p>
<p>The Trace List's menu items and toolbar buttons allow you to access advanced</p>
<p>TimeMachine functions and tools. The following list outlines how to access</p>
<p>TimeMachine features from the Trace List:</p>
<p>â¢</p>
<p>TimeMachine â Double-click a line in the Trace List. A TimeMachine</p>
<p>Debugger opens at the selected instruction. Alternatively, select<b> Tools</b> â</p>
<p><b>TimeMachine Debugger</b> or press the</p>
<p>button. For more information about</p>
<p>TimeMachine, see âThe TimeMachine Debuggerâ on page 413.</p>
<p>â¢</p>
<p><b>Profile</b> window â Select<b> Tools</b> â<b> Profile</b> or click the</p>
<p>button. For more</p>
<p>information, see âUsing Trace Data to Profile Your Targetâ on page 475 and</p>
<p>Chapter 17, âCollecting and Viewing Profiling Dataâ on page 353.</p>
<p>â¢</p>
<p>PathAnalyzer â Select<b> Tools</b> â<b> PathAnalyzer</b> or click the</p>
<p>button. For</p>
<p>more information, see âThe PathAnalyzerâ on page 424.</p>
<p>â¢</p>
<p>EventAnalyzer â Select<b> Tools</b> â<b> EventAnalyzer</b> or click the</p>
<p>button. For</p>
<p>more information, see âViewing Trace Events in the EventAnalyzerâ</p>
<p>on page 474.</p>
<p><b>Bookmarking Trace Data</b></p>
<p>When you find an interesting point in a trace run, you may want to bookmark it so</p>
<p>that you can go back to it later. To bookmark a point in your trace data, do one of</p>
<p>the following.</p>
<p>â¢</p>
<p>In the Trace List, right-click the instruction you would like to bookmark and</p>
<p>then select the<b> Add Bookmark</b> menu item.</p>
<p>â¢</p>
<p>In the PathAnalyzer, right-click the function you would like to bookmark and</p>
<p>then select<b> Add Bookmark at Entry</b>,<b> Add Bookmark at Exit</b>, or<b> Add</b></p>
<p><b>Bookmark at Cursor</b>.</p>
<p>â¢</p>
<p>In the Trace List or in any of the<b> Trace Browsers</b>, click the gray line that</p>
<p>appears to the left of the instruction.</p>
<p><b>Note</b></p>
<p>The right-click menu items are also available via the<b> Bookmarks</b> menu.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>444</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>In windows such as the Trace Browsers and Trace List, a flag is drawn next to</p>
<p>bookmarked instructions. In the Trace List, the text of bookmarked instructions is</p>
<p>also colored. In windows such as the Trace List and PathAnalyzer, vertical lines</p>
<p>representing bookmarks are added to the thumbnail pane at the bottom of the</p>
<p>window.</p>
<p>In addition to the manually added bookmarks, when a trigger is found in the trace</p>
<p>data, a bookmark is automatically added to allow you to easily navigate to the trigger</p>
<p>position. The default name for trigger bookmarks is âTrigger,â and they are colored</p>
<p>red by default.</p>
<p>Once there are one or more bookmarks, you can view all of the defined bookmarks</p>
<p>through the<b> Trace Bookmarks</b> window. To open the<b> Trace Bookmarks</b> window,</p>
<p>do one of the following:</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, select<b> Bookmarks</b> â<b> Edit Bookmarks</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> trace bookmarks</b> command. For</p>
<p>information about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>The following graphic displays the<b> Trace Bookmarks</b> window.</p>
<p>Each bookmark has a name and a color associated with it. By default, bookmarks</p>
<p>are named for the function they correspond to.</p>
<p>The<b> Name</b> column in the<b> Trace Bookmarks</b> window displays the bookmark's</p>
<p>name. The<b> Delta</b> column displays the difference (in instructions, time, or cycles)</p>
<p>between a bookmark and the previous bookmark. For a description of the remaining</p>
<p>data columns, see âThe Instruction Paneâ on page 436.</p>
<p><i>445</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Bookmarking Trace Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To change the name of a bookmark, select it in the<b> Trace Bookmarks</b> window.</p>
<p>Then change the value in the<b> Name</b> field and press<b> Enter</b>.</p>
<p>To change the color of a bookmark, select it in the<b> Trace Bookmarks</b> window.</p>
<p>Then double-click the color box in the lower-right corner of the window. Select a</p>
<p>new color in the color chooser dialog that appears. When you click<b> OK</b>, the</p>
<p>bookmark's color is updated.</p>
<p>To jump to a bookmarked instruction, do any one of the following.</p>
<p>â¢</p>
<p>In the<b> Trace Bookmarks</b> window, double-click a bookmark.</p>
<p>â¢</p>
<p>In the<b> Trace Bookmarks</b> window, select a bookmark and click<b> Jump To</b>.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, choose a bookmark from the<b> Bookmarks</b></p>
<p>menu.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, click a bookmark line in the thumbnail</p>
<p>pane.</p>
<p>To remove selected bookmarks, do any one of the following.</p>
<p>â¢</p>
<p>In the<b> Trace Bookmarks</b> window, select a bookmark and click<b> Remove</b>.</p>
<p>â¢</p>
<p>In the Trace List or in one of the Trace Browsers, click the flag next to an</p>
<p>instruction.</p>
<p>To remove all bookmarks, do one of the following:</p>
<p>â¢</p>
<p>In the<b> Trace Bookmarks</b> window, click<b> Remove All</b>.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, select<b> Bookmarks</b> â<b> Delete All</b></p>
<p><b>Bookmarks</b>.</p>
<p><b>Searching Trace Data</b></p>
<p>The Trace List has powerful search capabilities to enable you to quickly find specific</p>
<p>information in a large trace run.</p>
<p>The simplest searching capability allows you to search through the data that currently</p>
<p>appears in either the tree or instruction pane of the Trace List. To perform a search</p>
<p>of this type, click in the pane you want to search, press<b> Ctrl</b>+<b>F</b>, and then enter a</p>
<p>string. Matching strings are highlighted as you type. To search again for the same</p>
<p><i>MULTI: Debugging</i></p>
<p><i>446</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>string, press<b> Ctrl</b>+<b>F</b> again. To search backward for a string, press<b> Ctrl</b>+<b>B</b>. To abort</p>
<p>the current search, press<b> Esc</b>.</p>
<p>In addition to this simple searching mechanism, you can use the<b> Trace Search</b></p>
<p>dialog box to search for various events in your trace data. To open this dialog box,</p>
<p>do one of the following:</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, select<b> Search</b> â<b> Search</b>.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, click the</p>
<p>button.</p>
<p>The<b> Trace Search</b> dialog, shown above, allows you to search your trace data for</p>
<p>the events listed in the following table.</p>
<p><b>Description</b></p>
<p><b>Event</b></p>
<p>Searches for execution of a specific instruction. The address of the</p>
<p>instruction may be specified by entering a function name and offset, function</p>
<p>name and line number, or the address.</p>
<p><b>Address</b></p>
<p><b>Executed</b></p>
<p>Searches for execution of any instruction in a specific function.</p>
<p><b>Function</b></p>
<p><b>Executing</b></p>
<p>Searches for execution of any instruction not in a specific function.</p>
<p><b>Function Not</b></p>
<p><b>Executing</b></p>
<p>Searches for reads from or writes to a variable or address. You can also</p>
<p>search only for accesses that read or wrote a specific value.</p>
<p><b>Data</b></p>
<p><b>Read/Written</b></p>
<p>Searches for reads from a variable or address. You can also search only for</p>
<p>reads that read a specific value.</p>
<p><b>Data Read</b></p>
<p>Searches for writes to a variable or address. You can also search only for</p>
<p>writes that wrote a specific value.</p>
<p><b>Data Written</b></p>
<p><i>447</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Searching Trace Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Event</b></p>
<p>Searches for a specific type of trace event. The available events are described</p>
<p>in âEvent Type Descriptionsâ on page 501.</p>
<p><b>Event</b></p>
<p>Searches for a specific type of exception. The available exceptions are</p>
<p>described in âException Type Descriptionsâ on page 502. The<b> Exception</b></p>
<p>option is not available on all targets.</p>
<p><b>Exception</b></p>
<p>Searches for a complex event. You can specify the complex event with the</p>
<p><b>Advanced Edit</b> button. See âEditing Complex Eventsâ on page 497 for</p>
<p>details.</p>
<p><b>Custom Event</b></p>
<p>To search for an event, select the type of event to search for from the<b> Find</b></p>
<p>drop-down list. Then enter the appropriate information for the event and click the</p>
<p><b>Find Next</b> button to find the next occurrence, or click the<b> Find Previous</b> button to</p>
<p>find the previous occurrence.</p>
<p>If you have collected trace data from multiple AddressSpaces, you can limit your</p>
<p>event search to only one of the AddressSpaces by selecting one from the</p>
<p><b>AddressSpace</b> drop-down list. Any symbols specified in the search are looked up</p>
<p>in the selected AddressSpace or, if<b> All</b> is selected, in the kernel AddressSpace.</p>
<p>You can also bookmark all matches to a search with the<b> Bookmark All</b> button.</p>
<p>Clicking this button adds bookmarks for all matches, indicating their locations in</p>
<p>the thumbnail pane and allowing you to view them in the<b> Trace Bookmarks</b></p>
<p>window. When there are more than 100 search matches, you are offered the choice</p>
<p>of adding bookmarks for all search matches, for only the first 100 search matches,</p>
<p>or for none of the search matches.</p>
<p>In addition to the predefined events described above, you can find arbitrarily complex</p>
<p>events by using the<b> Advanced Edit</b> button. The interface to specify these complex</p>
<p>events is described in âEditing Complex Eventsâ on page 497.</p>
<p><b>Saving and Loading a Trace Session</b></p>
<p>MULTI provides a simple mechanism to save your trace data and everything needed</p>
<p>to analyze it in a single file. Imagine that you have captured trace of a bug that is</p>
<p>extremely difficult to reproduce and is only triggered by a specific environment</p>
<p>that takes a long time to replicate. You have tracked the problem to part of the</p>
<p>system that is maintained by a colleague. Now regardless of whether that colleague</p>
<p>is located down the hall or across the world, you can save the trace session, including</p>
<p><i>MULTI: Debugging</i></p>
<p><i>448</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>all applicable ELF files and debug information, and send it to her. She can load the</p>
<p>trace session and use the TimeMachine Debugger to step through her code and find</p>
<p>the problem, or use the PathAnalyzer or any of the other trace tools to see what</p>
<p>went wrong. Perform one of the following actions to save a trace session (note that</p>
<p>source files are not saved):</p>
<p>â¢</p>
<p>In the Trace List or PathAnalyzer, select<b> File</b> â<b> Save Session</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> tracesave</b> command. You may</p>
<p>optionally specify a file to save the trace data to. For more information, see the</p>
<p><b>tracesave</b> command in Chapter 20, âTrace Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>If you are concerned for intellectual property reasons about saving your ELF image</p>
<p>and/or debug information, you can optionally not include them in the trace session.</p>
<p>To save only the trace data, enter the command<b> tracesave --data</b>. To save the trace</p>
<p>data and ELF image but not the debug information, enter the command<b> tracesave</b></p>
<p><b>--data_elf</b>. (For more information about the<b> tracesave</b> command, see Chapter 20,</p>
<p>âTrace Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.) Note that certain trace tools, such as the PathAnalyzer, require debug</p>
<p>information in order to display useful data.</p>
<p><b>Note</b></p>
<p>Large temporary files may be created during the process of saving a trace</p>
<p>session. By default, these files are created in the directory where the trace</p>
<p>session file is created. As a result, more space will be needed on that file</p>
<p>system than is needed to store just the trace session file. You can specify</p>
<p>an alternative location for the temporary files with the<b> tracesave</b> command</p>
<p>(see Chapter 20, âTrace Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p>The information you save in the trace session file determines how you load the file.</p>
<p>For details, see the following table.</p>
<p><b>To load the trace file, you must:</b></p>
<p><b>If you saved:</b></p>
<p>â¢</p>
<p>Open the Debugger, and then load the trace session as</p>
<p>described below*, or</p>
<p>â¢</p>
<p>Start the Debugger from the command line, and specify the</p>
<p>trace session file on the command line as described in</p>
<p>âStarting the Debugger in GUI Modeâ on page 6.</p>
<p>A trace session that includes</p>
<p>the ELF file(s)</p>
<p>(This is the default.)</p>
<p><i>449</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Saving and Loading a Trace Session</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>To load the trace file, you must:</b></p>
<p><b>If you saved:</b></p>
<p>1.</p>
<p>If you are using INTEGRITY, locate and debug the kernel</p>
<p>executable.</p>
<p>If you are not using INTEGRITY, locate and debug the ELF</p>
<p>file that was used when you saved the trace data.</p>
<p>2.</p>
<p>Load the trace session as described below.*</p>
<p><b>Note:</b> If you have rebuilt the program since you collected the</p>
<p>trace data, loading and/or using the saved trace data may produce</p>
<p>unexpected behavior.</p>
<p>Only the trace data</p>
<p>1.</p>
<p>If you are using INTEGRITY, locate and debug the kernel</p>
<p>executable, and connect to a simulator that can run the</p>
<p>executable.</p>
<p>If you are not using INTEGRITY, locate and debug the ELF</p>
<p>file that was used when you saved the trace data, and connect</p>
<p>to a simulator that can run the ELF file.</p>
<p>2.</p>
<p>Load the trace session as described below.*</p>
<p><b>Note:</b> If you have rebuilt the program since you collected the</p>
<p>trace data, loading and/or using the saved trace data may produce</p>
<p>unexpected behavior.</p>
<p>Trace data saved with</p>
<p>MULTI 4.x</p>
<p>*: To load the trace session:</p>
<p>â¢</p>
<p>In the Trace List or PathAnalyzer, select<b> File</b> â<b> Load Session</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> traceload</b> command. You may</p>
<p>optionally specify a file to load. For more information about the<b> traceload</b></p>
<p>command, see Chapter 20, âTrace Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>Because MULTI does not save source files when you save a trace session,</p>
<p>you will be unable to see source if MULTI cannot locate the original</p>
<p>source files when you load the trace session. If MULTI can locate the</p>
<p>source files, but they have been modified since originally being traced,</p>
<p>they will not accurately match the saved trace data. To load source files</p>
<p>that you have saved, use the<b> source</b> or<b> sourceroot</b> command. For</p>
<p>information about these commands, see âGeneral Configuration</p>
<p><i>MULTI: Debugging</i></p>
<p><i>450</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Commandsâ in Chapter 6, âConfiguration Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Tip</b></p>
<p>If a large number of tasks will be loaded from trace, it may be useful to</p>
<p>set the configuration option<b> osaTaskAutoAttachLimit</b>, which allows</p>
<p>you to specify the maximum number of OSA tasks that are displayed in</p>
<p>the target list (the default is 32). If the number of tasks exceeds this limit,</p>
<p>one task per AddressSpace is displayed in the target list. To manually</p>
<p>display additional tasks loaded from trace, open the Trace List or</p>
<p>PathAnalyzer and select an instruction or function call corresponding to</p>
<p>the task you want to view. For information about opening the Trace List,</p>
<p>see âViewing Trace Data in the Trace Listâ on page 434. For information</p>
<p>about opening the PathAnalyzer, see âOpening the PathAnalyzerâ</p>
<p>on page 424. For more information about the configuration option</p>
<p><b>osaTaskAutoAttachLimit</b>, see âOther Debugger Configuration Optionsâ</p>
<p>in Chapter 8, âConfiguration Optionsâ in the<i> MULTI: Managing Projects</i></p>
<p><i>and Configuring the IDE</i> book.</p>
<p>To exit a loaded trace session, do one of the following:</p>
<p>â¢</p>
<p>Disconnect from the simulated target.</p>
<p>â¢</p>
<p>Right-click the simulated program or each individual OS task and select</p>
<p><b>Remove</b>.</p>
<p><b>Browsing Trace Data</b></p>
<p>The Trace Browsers allow you to quickly locate events in your trace data by finding</p>
<p>similar events, such as instructions and memory accesses. There are four types of</p>
<p>Trace Browsers:</p>
<p>â¢</p>
<p><b>Trace Memory Browser</b> (see âThe Trace Memory Browserâ on page 452)</p>
<p>â¢</p>
<p><b>Trace Branch Browser</b> (see âThe Trace Branch Browserâ on page 454)</p>
<p>â¢</p>
<p><b>Trace Instruction Browser</b> (see âThe Trace Instruction Browserâ on page 456)</p>
<p>â¢</p>
<p><b>Trace Call Browser</b> (see âThe Trace Call Browserâ on page 457)</p>
<p><i>451</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Browsing Trace Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Trace Memory Browser</b></p>
<p>The<b> Trace Memory Browser</b> allows you to quickly view each time that a specific</p>
<p>memory address is referenced in your trace data.</p>
<p>To open a<b> Trace Memory Browser</b>, do one of the following:</p>
<p>â¢</p>
<p>In the<b> Trace Statistics</b> window, double-click one of the memory locations</p>
<p>listed in the<b> Memory</b> tab.</p>
<p>â¢</p>
<p>In the Trace List, right-click a line that shows an access of the data address of</p>
<p>interest. In the shortcut menu that appears, select<b> Browse Accesses of</b></p>
<p><i><b>data_address</b></i>.</p>
<p>â¢</p>
<p>In the Debugger window, find a global or static variable that you are interested</p>
<p>in accesses to. Right-click the variable name and select<b> Trace</b> â<b> Browse</b></p>
<p><b>Traced Accesses</b>. Note that this only displays accesses of the first address of</p>
<p>the variable. If the variable is a struct or class with multiple member variables,</p>
<p>the<b> Trace Memory Browser</b> only displays accesses of the first one.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> tracebrowse</b> command. For</p>
<p>information about the<b> tracebrowse</b> command, see Chapter 20, âTrace Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>452</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p><i>453</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Trace Memory Browser</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Trace Memory Browser</b> contains a list of all the memory accesses to a specific</p>
<p>memory location. From left to right, this list displays the following information for</p>
<p>each memory access:</p>
<p>â¢</p>
<p>Whether or not the instruction that caused the memory access is bookmarked.</p>
<p>In the narrow, left-most column, you can add or remove a bookmark by clicking</p>
<p>the vertical gray line or the flag, respectively.</p>
<p>â¢</p>
<p>The PC and function in which the access occurred.</p>
<p>â¢</p>
<p>The value that was read or written to this memory location.</p>
<p>â¢</p>
<p>The type of access. This indicates whether the access was a read or a write.</p>
<p>â¢</p>
<p>The cumulative time at which the access occurred. This column corresponds</p>
<p>to the<b> Total Time</b>,<b> Total Cycles</b>, or<b> Total Instructions</b> column of the Trace</p>
<p>List.</p>
<p>Initially, MULTI sorts the memory accesses by the cumulative time column. You</p>
<p>can sort by any column other than the first one.</p>
<p>For information about the<b> Trace Memory Browser</b> toolbar, see âTrace Browsers</p>
<p>Toolbarâ on page 459.</p>
<p><b>The Trace Branch Browser</b></p>
<p>The<b> Trace Branch Browser</b> displays a list of all executions of a single branch</p>
<p>instruction from your trace data.</p>
<p>To open a<b> Trace Branch Browser</b>, open the<b> Trace Statistics</b> window and</p>
<p>double-click one of the branches listed in the<b> Branches</b> tab.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>454</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>From left to right, the<b> Trace Branch Browser</b> displays the following information</p>
<p>for each execution of the branch:</p>
<p>â¢</p>
<p>Whether or not the instruction is bookmarked. In the narrow, left-most column,</p>
<p>you can add or remove a bookmark by clicking the vertical gray line or the</p>
<p>flag, respectively.</p>
<p>â¢</p>
<p>Whether the branch was taken or not. A branch that is taken indicates that the</p>
<p>execution flow of your program was altered at this point. For conditional</p>
<p>branches, it generally indicates that the condition evaluated to true.</p>
<p>â¢</p>
<p>The destination address of the branch. This is the PC of the next instruction</p>
<p>that executed after each instance of the branch.</p>
<p>â¢</p>
<p>The cumulative time at which the branch occurred. This column corresponds</p>
<p>to the<b> Total Time</b>,<b> Total Cycles</b>, or<b> Total Instructions</b> column of the Trace</p>
<p>List.</p>
<p>Initially, MULTI sorts the executions of the branch by the cumulative time column.</p>
<p>You can sort by any column other than the first one.</p>
<p>For information about the<b> Trace Branch Browser</b> toolbar, see âTrace Browsers</p>
<p>Toolbarâ on page 459.</p>
<p><i>455</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Trace Branch Browser</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Trace Instruction Browser</b></p>
<p>The<b> Trace Instruction Browser</b> displays a list of all executions of a single</p>
<p>instruction in the trace data.</p>
<p>To open a<b> Trace Instruction Browser</b>, do one of the following:</p>
<p>â¢</p>
<p>In the Trace List, right-click the instruction you want to browse and select</p>
<p><b>Browse Executions</b>.</p>
<p>â¢</p>
<p>In the Debugger, right-click the instruction of interest and select<b> Trace</b> â</p>
<p><b>Browse Traced Executions</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> tracebrowse -line</b> command. For</p>
<p>information about the<b> tracebrowse</b> command, see Chapter 20, âTrace Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>From left to right, the<b> Trace Instruction Browser</b> displays the following information</p>
<p>for each execution of the instruction:</p>
<p>â¢</p>
<p>Whether or not the instruction is bookmarked. In the narrow, left-most column,</p>
<p>you can add or remove a bookmark by clicking the vertical gray line or the</p>
<p>flag, respectively.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>456</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Whether the instruction was executed or not. This column only applies if the</p>
<p>target supports conditional execution of instructions.</p>
<p>â¢</p>
<p>The cumulative time at which the instruction was traced. This column</p>
<p>corresponds to the<b> Total Time</b>,<b> Total Cycles</b>, or<b> Total Instructions</b> column</p>
<p>of the Trace List.</p>
<p>Initially, MULTI sorts the executions of the instruction by the cumulative time</p>
<p>column. You can sort by any column other than the first one.</p>
<p>For information about the<b> Trace Instruction Browser</b> toolbar, see âTrace Browsers</p>
<p>Toolbarâ on page 459.</p>
<p><b>The Trace Call Browser</b></p>
<p>The<b> Trace Call Browser</b> displays a list of each call site of a single function in the</p>
<p>trace data.</p>
<p>To open a<b> Trace Call Browser</b>, do one of the following:</p>
<p>â¢</p>
<p>In the Trace List, right-click a function node and select<b> Browse Function Calls</b>.</p>
<p>â¢</p>
<p>In the PathAnalyzer, right-click a function and select<b> Find Function</b></p>
<p><b>References</b>.</p>
<p>â¢</p>
<p>In the<b> Functions</b> tab of the<b> Trace Statistics</b> window, double-click a function,</p>
<p>or select a function and click the<b> Details</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>In the Debugger, right-click a function name and select<b> Trace</b> â<b> Browse</b></p>
<p><b>Traced Calls</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> tracebrowse</b> command. For</p>
<p>information about the<b> tracebrowse</b> command, see Chapter 20, âTrace Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>457</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Trace Call Browser</i></p>
<h1 style="page-break-before:always; "></h1>
<p>From left to right, the<b> Trace Call Browser</b> displays the following information for</p>
<p>each call of the function:</p>
<p>â¢</p>
<p>Whether or not the call site of the function is bookmarked. In the narrow,</p>
<p>left-most column, you can add or remove a bookmark by clicking the vertical</p>
<p>gray line or the flag, respectively.</p>
<p>â¢</p>
<p>The call site, which is the location that the function was called from. This will</p>
<p>include an address and, if available, the function and offset of that address.</p>
<p>â¢</p>
<p>The duration, which is the total time that the function was on the stack. This</p>
<p>is counted from the time the function or its called functions were first observed</p>
<p>to the time the function or its called functions were last executed. If trace data</p>
<p>is available for the function's entire execution, this value is simply the time</p>
<p>elapsed between the function's call and its return.</p>
<p>â¢</p>
<p>The cumulative time at the start of the function. If the start of the function is</p>
<p>not in the trace data, the time at which the function was first known to be on</p>
<p>the call stack is used instead. This column corresponds to the<b> Total Time</b>,</p>
<p><b>Total Cycles</b>, or<b> Total Instructions</b> column of the Trace List.</p>
<p>Initially, MULTI sorts the calls of the function by the cumulative time column. You</p>
<p>can sort by any column other than the first one.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>458</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>The following situations can cause the function start time, duration, and</p>
<p>call site to be incorrect:</p>
<p>â¢</p>
<p>If the trace buffer starts after the call to the function.</p>
<p>â¢</p>
<p>If the trace buffer ends before the function returns.</p>
<p>â¢</p>
<p>If an exception is taken while the function is executing. In this case,</p>
<p>a single function call may be broken up into two separate calls in</p>
<p>the list. The call site of the second one will be unknown.</p>
<p>â¢</p>
<p>If there are gaps in the trace data due to on-chip trace buffer overflow</p>
<p>or trace filtering.</p>
<p>For information about the<b> Trace Call Browser</b> toolbar, see the next section.</p>
<p><b>Trace Browsers Toolbar</b></p>
<p>The toolbar that appears at the top of the Trace Browsers contains the following</p>
<p>buttons:</p>
<p>â¢</p>
<p>â Saves the list of instruction, branch, or function executions (whichever</p>
<p>the Trace Browser lists) to a text file.</p>
<p>â¢</p>
<p>â Toggles synchronization of the selection in this window with the current</p>
<p>position in TimeMachine.</p>
<p>â¢</p>
<p>â Resumes the search for instruction, branch, or function executions</p>
<p>(whichever the Trace Browser lists) in the trace data if processing was stopped</p>
<p>before completion and was not automatically resumed.</p>
<p><i>459</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Trace Browsers Toolbar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Trace Statistics</b></p>
<p>The<b> Trace Statistics</b> window generates and displays statistical information about</p>
<p>your trace data. To open the<b> Trace Statistics</b> window, do one of the following:</p>
<p>1.</p>
<p>Select<b> TimeMachine</b> â<b> Trace Statistics</b>.</p>
<p>2.</p>
<p>In the Trace List or the PathAnalyzer, click the</p>
<p>button.</p>
<p>3.</p>
<p>In the Trace List or the PathAnalyzer, select<b> Tools</b> â<b> Statistics</b>.</p>
<p>4.</p>
<p>In the Debugger command pane, enter the<b> trace stats</b> command. For</p>
<p>information about the<b> trace</b> command, see Chapter 20, âTrace Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>The<b> Trace Statistics</b> window is broken up into five tabs:<b> Summary</b>,<b> AddressSpaces</b>,</p>
<p><b>Memory</b>,<b> Branches</b>, and<b> Functions</b>. The<b> AddressSpaces</b> tab is only available if</p>
<p>you collected trace data from an INTEGRITY application. The<b> Memory</b> tab is only</p>
<p>available if your trace data includes the data addresses associated with memory</p>
<p>access instructions.</p>
<p>When you trace an INTEGRITY application, there will be one or two drop-down</p>
<p>lists at the bottom of the window. These drop-down lists allow you to select an</p>
<p>AddressSpace and a task that apply to all the tabs (except the<b> AddressSpaces</b> tab,</p>
<p>which displays summary information about all traced AddressSpaces and tasks).</p>
<p><b>Note</b></p>
<p>The trace data collected from some targets does not include sufficient</p>
<p>information to determine which INTEGRITY task was executing at any</p>
<p>particular time (see âDealing with Incomplete Trace Dataâ on page 411).</p>
<p>With those targets there will not be a task drop-down list.</p>
<p><b>Summary</b></p>
<p>The<b> Summary</b> tab of the<b> Trace Statistics</b> window contains summary statistics for</p>
<p>either the entire trace buffer or for traced instructions from the currently selected</p>
<p>task or AddressSpace.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>460</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The information that this tab contains is detailed in the following table.</p>
<p><b>Description</b></p>
<p><b>Item</b></p>
<p>The total number of instructions found in the trace buffer.</p>
<p><b>Instructions</b></p>
<p>The total number of 16-bit instructions that were executed as well as the</p>
<p>percentage of total instructions that were 16âbit instructions. This item only</p>
<p>appears when trace data was collected from a target that has both 32âbit and</p>
<p>16âbit instruction sets.</p>
<p><b>16 bit</b></p>
<p>The total number of cycles elapsed as well as the average number of cycles</p>
<p>per instruction. This item only appears when cycle-accurate mode is enabled.</p>
<p><b>Cycles</b></p>
<p>The total number of data accesses.</p>
<p><b>Data Accesses</b></p>
<p>The total number of loads as well as the percentage of data accesses that were</p>
<p>loads.</p>
<p><b>Loads</b></p>
<p>The total number of stores as well as the percentage of data accesses that were</p>
<p>stores.</p>
<p><b>Stores</b></p>
<p>The total number of branch instructions.</p>
<p><b>Branches</b></p>
<p>The total number of branch instructions that were taken, meaning that they</p>
<p>caused a change-of-flow in your process. The percentage of total branch</p>
<p>instructions that were taken is also printed.</p>
<p><b>Taken</b></p>
<p>The total number of branch instructions that were not taken, meaning that their</p>
<p>conditions failed and execution continued on the next instruction. The</p>
<p>percentage of total branch instructions that were not taken is also printed.</p>
<p><b>Not Taken</b></p>
<p><i>461</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Summary</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>AddressSpace Statistics</b></p>
<p>When tracing an INTEGRITY target, the<b> AddressSpaces</b> tab will display statistics</p>
<p>about each AddressSpace in which a task executed during the trace run.</p>
<p>The following information will be displayed for each AddressSpace and, if task</p>
<p>information is available, for each task:</p>
<p><b>Description</b></p>
<p><b>Column</b></p>
<p>The total number of traced instructions from the task or AddressSpace.</p>
<p><b>Instructions</b></p>
<p>The total number of 16-bit instructions that were traced from the task or</p>
<p>AddressSpace. This column only appears when trace data was collected from</p>
<p>a target that has both 32âbit and 16âbit instruction sets.</p>
<p><b>16 bit</b></p>
<p>The total number of cycles spent executing instructions from the task or</p>
<p>AddressSpace. This item only appears when cycle-accurate mode is enabled.</p>
<p><b>Cycles</b></p>
<p>The total number of data accesses performed by instructions from the task or</p>
<p>AddressSpace.</p>
<p><b>Accesses</b></p>
<p>The total number of loads performed by instructions from the task or</p>
<p>AddressSpace.</p>
<p><b>Loads</b></p>
<p>The total number of stores performed by instructions from the task or</p>
<p>AddressSpace.</p>
<p><b>Stores</b></p>
<p>The total number of branch instructions traced from the task or AddressSpace.</p>
<p><b>Branches</b></p>
<p>The total number of branch instructions from the task or AddressSpace that</p>
<p>were taken, meaning that they caused a change-of-flow in your process.</p>
<p><b>Taken</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>462</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Memory Statistics</b></p>
<p>The<b> Memory</b> tab of the<b> Trace Statistics</b> window contains a list of all the addresses</p>
<p>that were read or written during the trace run. This list displays the following</p>
<p>information for each memory location accessed:</p>
<p>â¢</p>
<p>The number of loads from this address as well as the percentage of all loads</p>
<p>that were from this address. For addresses that were only loaded from, the text</p>
<p>of the row is green.</p>
<p>â¢</p>
<p>The number of stores to this address as well as the percentage of all stores that</p>
<p>were to this address. For addresses that were only stored to, the text of the row</p>
<p>is red.</p>
<p>â¢</p>
<p>The total number of accesses to this address as well as the percentage of all</p>
<p>accesses that were to this address.</p>
<p>To display detailed information about the memory accesses to a specific location,</p>
<p>do one of the following:</p>
<p>â¢</p>
<p>Double-click the corresponding line.</p>
<p>â¢</p>
<p>Select an address and click the<b> Details</b> button (</p>
<p>).</p>
<p>A<b> Trace Memory Browser</b> opens for the selected memory location. See âThe</p>
<p>Trace Memory Browserâ on page 452.</p>
<p><i>463</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Memory Statistics</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Branch Statistics</b></p>
<p>The<b> Branches</b> tab of the<b> Trace Statistics</b> window contains a list of all of the</p>
<p>branches that were collected during the trace run. This list displays the following</p>
<p>information about each branch executed:</p>
<p>â¢</p>
<p>The number of times that the branch was executed.</p>
<p>â¢</p>
<p>The number of times that the branch was taken. This indicates the number of</p>
<p>times that this branch changed the execution flow of your program. For branches</p>
<p>that were never taken, the text of the row is red. For branches that were always</p>
<p>taken, the text of the row is green.</p>
<p>To display detailed information about a specific branch, do one of the following:</p>
<p>â¢</p>
<p>Double-click the corresponding line.</p>
<p>â¢</p>
<p>Select a branch and click the<b> Details</b> button (</p>
<p>).</p>
<p>A<b> Trace Branch Browser</b> opens for the selected branch. See âThe Trace Branch</p>
<p>Browserâ on page 454.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>464</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Function Statistics</b></p>
<p>The<b> Functions</b> tab of the<b> Trace Statistics</b> window contains a list of all of the</p>
<p>functions that were called during the trace run. This list displays the following</p>
<p>information about each function called:</p>
<p>â¢</p>
<p>The number of times the function was called.</p>
<p>â¢</p>
<p>The function's shortest run time during the trace run.</p>
<p>â¢</p>
<p>The function's average run time during the trace run. (This is a simple average.)</p>
<p>â¢</p>
<p>The function's longest run time during the trace run.</p>
<p>All run times are reported in the units available from the trace data.</p>
<p><b>Note</b></p>
<p>Function run times shown on this tab may be less than the actual function</p>
<p>run times in the following cases:</p>
<p>â¢</p>
<p>If the trace buffer starts after the call to the function.</p>
<p>â¢</p>
<p>If the trace buffer ends before the function returns.</p>
<p>â¢</p>
<p>If an exception is taken while the function is executing. In this case</p>
<p>a single function call may be broken up into two separate function</p>
<p>calls in the list.</p>
<p>â¢</p>
<p>If there are gaps in the trace data due to on-chip trace buffer overflow</p>
<p>or trace filtering.</p>
<p><i>465</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Function Statistics</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To display detailed information about a specific function call, do one of the</p>
<p>following:</p>
<p>â¢</p>
<p>Double-click the corresponding line.</p>
<p>â¢</p>
<p>Select an address and click the<b> Details</b> button (</p>
<p>).</p>
<p>A<b> Trace Call Browser</b> opens for the selected function. See âThe Trace Call</p>
<p>Browserâ on page 457.</p>
<p><b>The TimeMachine API</b></p>
<p>The TimeMachine API is a TimeMachine component that enables you to perform</p>
<p>custom analysis on your trace data. The TimeMachine API consists of a dynamic</p>
<p>library that you can link against a C program, a C++ program, or a script written in</p>
<p>any scripting language that can import functions from a DLL. You can access your</p>
<p>trace data either from a saved trace file or by connecting to a running trace session.</p>
<p>The TimeMachine API files are located at<i><b> ide_install_dir</i>/timemachine_api</b>. In</p>
<p>this directory, you will find an example C/C++ program and Python scripts that use</p>
<p>the TimeMachine API. These examples may be useful to you both as a reference</p>
<p>and as a starting point for creating your own custom analysis tools. For more</p>
<p>information about these examples, see âExample Python Scriptsâ on page 471 and</p>
<p>âThe Example C/C++ Applicationâ on page 473. For information about specific API</p>
<p>functions, see the<b> timemachine_api.h</b> header file. For information about data stored</p>
<p>in the trace stream, see<b> ts_packet.h</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>466</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The TimeMachine API provides two interfaces that allow you to access your trace</p>
<p>data:</p>
<p>â¢</p>
<p>A live interface (</p>
<p>tm_*</p>
<p>functions) â Connects to a running MULTI Debugger</p>
<p>session and accesses trace data by reading it from the active MULTI trace</p>
<p>session.</p>
<p>â¢</p>
<p>A file interface (</p>
<p>tm_file_*</p>
<p>functions) â Allows you to save MULTI trace</p>
<p>data to a file and then analyze it later. Alternatively, you can create files of</p>
<p>saved trace data outside of MULTI and then load them in MULTI for analysis.</p>
<p>Both of these interfaces allow you to access the trace packet stream and then perform</p>
<p>custom analysis. In addition, the live interface enables you to look up symbol values</p>
<p>for your program, which provide useful trace analysis information. Applications</p>
<p>and scripts using the live interface are usually launched from the MULTI Debugger</p>
<p>with the<b> trace api</b> command. (For information about the<b> trace</b> command, see Chapter</p>
<p>20, âTrace Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.) Applications and scripts using the file interface are usually launched outside</p>
<p>of MULTI because they do not require a connection to an active trace session.</p>
<p><b>Note</b></p>
<p>If you want to access the TimeMachine API using Python, you must</p>
<p>install Python and the ctypes Python module. Some of the Python</p>
<p>examples also require that you install the Tkinter Python module and</p>
<p>Tcl/Tk.</p>
<p><b>Accessing Trace Data via the Live TimeMachine Interface</b></p>
<p>Before you can run an application or script that uses the live interface, you must</p>
<p>first collect some trace data in the MULTI Debugger. For information about</p>
<p>collecting trace data, see âEnabling and Disabling Trace Collectionâ on page 405.</p>
<p>To launch a C/C++ application, enter the following command in the Debugger</p>
<p>command pane:</p>
<p>&gt; trace api<i> application_name</i></p>
<p><i>467</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Accessing Trace Data via the Live TimeMachine Interface</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To launch a Python script, enter the following command in the Debugger command</p>
<p>pane:</p>
<p>&gt; trace api<i> path_to_Python_application path_to_script</i></p>
<p>where:</p>
<p>â¢</p>
<p><i>path_to_Python_application</i></p>
<p>is the full path to the installed Python</p>
<p>interpreter (a Python 2.3.3 installation is included with the MULTI IDE</p>
<p>installation).</p>
<p>â¢</p>
<p><i>path_to_script</i></p>
<p>is the full path to the Python script.</p>
<p>The list below specifies the functions that your application or script must call to</p>
<p>establish a live TimeMachine connection. The functions must be called in the</p>
<p>specified order.</p>
<p>1.</p>
<p>Initialize the TimeMachine API by:</p>
<p>â¢</p>
<p>C/C++ â Calling</p>
<p>tm_init_arg(<i>&amp;argc</i>,<i> argv</i>)</p>
<p>.</p>
<p>â¢</p>
<p>Python â Instantiating the</p>
<p>timemachine_api</p>
<p>class</p>
<p>(</p>
<p>my_timemachine_api = timemachine_api()</p>
<p>).</p>
<p>2.</p>
<p>Establish a connection to the MULTI Debugger by:</p>
<p>â¢</p>
<p>C/C++ â Calling</p>
<p>tm_connect(0)</p>
<p>.</p>
<p>â¢</p>
<p>Python â Calling the</p>
<p>live_connect()</p>
<p>function of the</p>
<p>timemachine_api</p>
<p>class instance.</p>
<p>When the connection is established, you can call live interface functions to access</p>
<p>the number of trace packets, access an array of trace packets, and control the trace</p>
<p>collection process. In addition, you can query the Debugger for information about</p>
<p>symbols and addresses in your program, which enables you to easily correlate your</p>
<p>results back to your system's source code. You can find a comprehensive list of live</p>
<p>interface functions in the<b> timemachine_api.h</b> header file located at</p>
<p><i><b>ide_install_dir</i>/timemachine_api</b>. For information about data stored in the trace</p>
<p>stream, see<b> ts_packet.h</b>.</p>
<p>Your application must call</p>
<p>tm_process_events()</p>
<p>regularlyâtypically in the</p>
<p>main event loopâto ensure that events are handled and callbacks are called in a</p>
<p>timely manner. TimeMachine API live interface applications that do not call</p>
<p><i>MULTI: Debugging</i></p>
<p><i>468</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>tm_process_events()</p>
<p>regularly can cause the MULTI Debugger to appear to</p>
<p>hang.</p>
<p><b>Accessing Trace Data via the TimeMachine File Interface</b></p>
<p>To run an application or script that accesses saved trace data from MULTI, perform</p>
<p>the following steps:</p>
<p>1.</p>
<p>Collect some trace data in the MULTI Debugger. For information about</p>
<p>collecting trace data, see âEnabling and Disabling Trace Collectionâ</p>
<p>on page 405.</p>
<p>2.</p>
<p>Save the trace data. For information about saving trace data, see âSaving and</p>
<p>Loading a Trace Sessionâ on page 448.</p>
<p>3.</p>
<p>You may optionally close the Debugger at this point.</p>
<p>4.</p>
<p>Launch the application or script. You can do this outside of MULTI.</p>
<p>The list below specifies the functions that your application or script must call to</p>
<p>open a file of saved trace data. The functions must be called in the specified order.</p>
<p>1.</p>
<p>Initialize the TimeMachine API by:</p>
<p>â¢</p>
<p>C/C++ â Calling</p>
<p>tm_init(<i>ide_install_dir</i>)</p>
<p>.</p>
<p>â¢</p>
<p>Python â Instantiating the</p>
<p>timemachine_api</p>
<p>class</p>
<p>(</p>
<p>my_timemachine_api = timemachine_api()</p>
<p>).</p>
<p>2.</p>
<p>Open the trace file by:</p>
<p>â¢</p>
<p>C/C++ â Calling</p>
<p>tm_file_open(<i>trace_file_name</i>)</p>
<p>.</p>
<p>â¢</p>
<p>Python â Calling the</p>
<p>trace_file_open(<i>trace_file_name</i>)</p>
<p>function</p>
<p>of the</p>
<p>timemachine_api</p>
<p>class instance.</p>
<p>When the trace file is opened, you can call file interface functions to access the</p>
<p>number of trace packets and access an array of trace packets. For a comprehensive</p>
<p>list of file interface functions, see the<b> timemachine_api.h</b> header file located at</p>
<p><i><b>ide_install_dir</i>/timemachine_api</b>. For information about data stored in the trace</p>
<p>stream, see<b> ts_packet.h</b>.</p>
<p><i>469</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Accessing Trace Data via the TimeMachine File Interface</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Creating Trace Data via the TimeMachine File Interface</b></p>
<p>To run an application or script that creates trace data, perform the following steps:</p>
<p>1.</p>
<p>Launch the application or script. You can do this outside of MULTI.</p>
<p>2.</p>
<p>Launch the MULTI Debugger on the program associated with the trace data</p>
<p>you created.</p>
<p>3.</p>
<p>Connect to a simulator.</p>
<p>4.</p>
<p>Load the trace data file in the Debugger. For information about loading trace,</p>
<p>see âSaving and Loading a Trace Sessionâ on page 448.</p>
<p>The list below specifies the functions that your application or script must call to</p>
<p>create a file of saved trace data. The functions must be called in the specified order.</p>
<p>1.</p>
<p>Initialize the TimeMachine API by:</p>
<p>â¢</p>
<p>C/C++ â Calling</p>
<p>tm_init(<i>ide_install_dir</i>)</p>
<p>.</p>
<p>â¢</p>
<p>Python â Instantiating the</p>
<p>timemachine_api</p>
<p>class</p>
<p>(</p>
<p>my_timemachine_api = timemachine_api()</p>
<p>).</p>
<p>2.</p>
<p>Create a trace file by:</p>
<p>â¢</p>
<p>C/C++ â Calling</p>
<p>tm_file_create(<i>trace_file_name</i>)</p>
<p>.</p>
<p>â¢</p>
<p>Python â Calling the</p>
<p>trace_file_create(<i>trace_file_name</i>)</p>
<p>function of the</p>
<p>timemachine_api</p>
<p>class instance.</p>
<p>3.</p>
<p>Specify the trace data properties of the file by:</p>
<p>â¢</p>
<p>C/C++ â Calling</p>
<p>tm_file_set_info(<i>trace_file</i>,<i>info</i>,sizeof(TM_DATA_INFO))</p>
<p>.</p>
<p>â¢</p>
<p>Python â Calling the</p>
<p>set_info(<i>info</i>)</p>
<p>function of the</p>
<p>timemachine_trace_file</p>
<p>class instance.</p>
<p>4.</p>
<p>Add trace packets to the file by:</p>
<p>â¢</p>
<p>C/C++ â Calling</p>
<p>tm_file_append_packet(<i>trace_file,trace_packet</i>)</p>
<p>for each</p>
<p>packet to be added to the file.</p>
<p>â¢</p>
<p>Python â Calling the</p>
<p>append_packet(<i>trace_packet</i>)</p>
<p>function of</p>
<p>the</p>
<p>timemachine_trace_file</p>
<p>class instance for each packet to be</p>
<p>added to the file.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>470</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>5.</p>
<p>Save and close the trace file by:</p>
<p>â¢</p>
<p>C/C++ â Calling</p>
<p>tm_file_save(<i>trace_file</i>)</p>
<p>and then calling</p>
<p>tm_file_close(<i>trace_file</i>)</p>
<p>.</p>
<p>â¢</p>
<p>Python â Calling the</p>
<p>close()</p>
<p>function of the</p>
<p>timemachine_trace_file</p>
<p>class instance.</p>
<p>For a comprehensive list of file interface functions, see the<b> timemachine_api.h</b></p>
<p>header file located at<i><b> ide_install_dir</i>/timemachine_api</b>. For information about data</p>
<p>stored in the trace stream, see<b> ts_packet.h</b>.</p>
<p><b>Example Python Scripts</b></p>
<p>The MULTI IDE installation includes Python script examples that use the</p>
<p>TimeMachine API:</p>
<p>â¢</p>
<p><b>timemachine_api_test.py</b></p>
<p>â¢</p>
<p><b>timemachine_api_test2.py</b></p>
<p>â¢</p>
<p><b>timemachine_api_test3.py</b></p>
<p>â¢</p>
<p><b>timemachine_api_file_test.py</b></p>
<p>These example scripts are located at:</p>
<p><i><b>ide_install_dir</i>/timemachine_api/example_python</b></p>
<p>For information about how to launch a Python script, see âAccessing Trace Data</p>
<p>via the Live TimeMachine Interfaceâ on page 467.</p>
<p>The following sections provide more detailed instructions about how to run these</p>
<p>examples and information about what each one demonstrates.</p>
<p><b>Live Interface Python Examples</b></p>
<p>The live interface examples demonstrate how you can use Python scripts to perform</p>
<p>custom analysis from the MULTI Debugger.</p>
<p>Before you can run these examples, you must first collect some trace data in the</p>
<p>MULTI Debugger. For information about collecting trace data, see âEnabling and</p>
<p>Disabling Trace Collectionâ on page 405. If you do not already have a program in</p>
<p><i>471</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Example Python Scripts</i></p>
<h1 style="page-break-before:always; "></h1>
<p>which to collect trace data, you can use the Project Manager to access the</p>
<p><b>TimeMachine Debugging</b> demo project. For information about creating a project,</p>
<p>see Chapter 1, âCreating a Projectâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book.</p>
<p>After you have collected trace data, you can launch the following example scripts:</p>
<p>â¢</p>
<p><b>timemachine_api_test.py</b> â Displays trace packets and counts packets,</p>
<p>instructions, and data accesses.</p>
<p>â¢</p>
<p><b>timemachine_api_test2.py</b> â Displays trace packets using Tcl/Tk.</p>
<p>â¢</p>
<p><b>timemachine_api_test3.py</b> â Looks up the address of a symbol.</p>
<p>For information about how to launch a Python script, see âAccessing Trace Data</p>
<p>via the Live TimeMachine Interfaceâ on page 467.</p>
<p><b>The File Interface Python Example</b></p>
<p>The file interface example demonstrates how you can use a Python script to perform</p>
<p>custom analysis on saved trace data. This example prints out trace packets stored</p>
<p>in the trace file, properties of the trace data, and statistics calculated on the trace</p>
<p>data.</p>
<p>To run this example, perform the following steps:</p>
<p>1.</p>
<p>Collect some trace data in the MULTI Debugger. For information about</p>
<p>collecting trace data, see âEnabling and Disabling Trace Collectionâ</p>
<p>on page 405.</p>
<p>2.</p>
<p>Save the trace data as<b> timemachine_api_file_test.trs</b>. Save the file to the</p>
<p><i><b>ide_install_dir</i>/timemachine_api/example_python</b> directory. For information</p>
<p>about saving trace data, see âSaving and Loading a Trace Sessionâ on page 448.</p>
<p>3.</p>
<p>You may optionally close the Debugger at this point.</p>
<p>4.</p>
<p>Launch the application or script in one of the following ways:</p>
<p>â¢</p>
<p>Windows â From the command prompt, run the following command in</p>
<p>the<i><b> ide_install_dir</i>\timemachine_api\example_python</b> directory:</p>
<p>&gt; python timemachine_api_file_test.py</p>
<p><i>MULTI: Debugging</i></p>
<p><i>472</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Linux/Solaris â In a Linux/Solaris shell, run the following command in</p>
<p>the<i><b> ide_install_dir</i>/timemachine_api/example_python</b> directory:</p>
<p>&gt; python timemachine_api_file_test.py</p>
<p><b>The Example C/C++ Application</b></p>
<p>The C/C++ example is located at:</p>
<p><i><b>ide_install_dir</i>/timemachine_api/example_c/timemachine_api_test.cc</b>.</p>
<p>You can use this example source code to build a native application that links against</p>
<p>the TimeMachine API library. To build a native application, you must use native</p>
<p>development tools for your host operating system, such as Green Hills MULTI for</p>
<p>x86 Linux Native, Microsoft Visual C++, or GNU GCC. After building the native</p>
<p>application, you can use MULTI to invoke it and to print basic statistics for any</p>
<p>trace data you have collected.</p>
<p>The C/C++ example provides you with a good starting point from which to create</p>
<p>a TimeMachine API application for your own custom analysis of trace data.</p>
<p>To set up this example, perform the following steps:</p>
<p>1.</p>
<p>Use your native development tools to create a project. Then adapt the following</p>
<p>steps to your native tools:</p>
<p>â¢</p>
<p>Add the<b> timemachine_api_test.cc</b> C++ source file to your project. This</p>
<p>file is located at<i><b> ide_install_dir</i>/timemachine_api/example_c</b>.</p>
<p>â¢</p>
<p>Add<i><b> ide_install_dir</i>/timemachine_api</b> as an include directory. This is the</p>
<p>location of the<b> timemachine_api.h</b> and<b> ts_packet.h</b> header files, which</p>
<p>are included by<b> timemachine_api_test.cc</b>.</p>
<p>â¢</p>
<p>Windows â Link against the<b> timemachine_api.lib</b> library file, which is</p>
<p>located at<i><b> ide_install_dir</b></i>.</p>
<p>â¢</p>
<p>Linux/Solaris â Link against the<b> timemachine_api.so</b> library file, which</p>
<p>is located at<i><b> ide_install_dir</b></i>.</p>
<p>2.</p>
<p>Build the native project you just created.</p>
<p><i>473</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Example C/C++ Application</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Set aside the native application you just built, and use the MULTI Debugger</p>
<p>to collect trace data from your target. For information about collecting trace</p>
<p>data, see âEnabling and Disabling Trace Collectionâ on page 405.</p>
<p>4.</p>
<p>Retrieve the trace data. For more information, see âRetrieving Trace Dataâ</p>
<p>on page 408.</p>
<p>5.</p>
<p>Enter the following command in the MULTI Debugger command pane to run</p>
<p>the application built in step 2:</p>
<p>&gt; trace api<i> application_name</i></p>
<p><b>Viewing Trace Events in the EventAnalyzer</b></p>
<p>MULTI can convert trace data into an EventAnalyzer log that you can view in the</p>
<p>MULTI EventAnalyzer. This allows the MULTI EventAnalyzer to be used without</p>
<p>instrumenting the code, which can often cause changes in process behavior.</p>
<p><b>Note</b></p>
<p>Generating EventAnalyzer information is only available when using an</p>
<p>operating system that supports the MULTI EventAnalyzer with trace.</p>
<p><b>Note</b></p>
<p>The EventAnalyzer requires that your trace data either include data</p>
<p>accesses or task switch markers. If neither is available, all events are</p>
<p>gathered in a common task denoted<b> Unknown Context</b>.<b> Unknown</b></p>
<p><b>Context</b> is also used to display events at the beginning of the trace before</p>
<p>the current task is known.</p>
<p>To generate EventAnalyzer information from the current trace data and open the</p>
<p>EventAnalyzer on that information, do one of the following:</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, click the<b> EventAnalyzer</b> button (</p>
<p>).</p>
<p>(If the operating system does not support the MULTI EventAnalyzer, this</p>
<p>button will be dimmed.)</p>
<p>â¢</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> EventAnalyzer</b>. (If the operating</p>
<p>system is not supported by the EventAnalyzer, this option will be dimmed.)</p>
<p><i>MULTI: Debugging</i></p>
<p><i>474</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> tracemevsys</b> command. For</p>
<p>information about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>MULTI will display a progress window while it converts the trace data. When the</p>
<p>conversion is complete, the MULTI EventAnalyzer will launch automatically. For</p>
<p>information about the MULTI EventAnalyzer, see the<i> EventAnalyzer User's Guide</i></p>
<p>or the documentation about using the MULTI EventAnalyzer for ThreadX in the</p>
<p><i>MULTI: Developing for ThreadX</i> book.</p>
<p><b>Note</b></p>
<p>The EventAnalyzer does not display relevant information in the<b> More</b></p>
<p><b>Info</b> field of the<b> Event View</b> window or in the tooltip that is displayed</p>
<p>when you click an event. All event parameters except for</p>
<p>PC</p>
<p>are displayed</p>
<p>as</p>
<p>0</p>
<p>(zero). To view these parameters, use the TimeMachine Debugger.</p>
<p>In addition, task statuses are not displayed. Tasks are either in a running</p>
<p>or non-running state.</p>
<p><b>Using Trace Data to Profile Your Target</b></p>
<p>MULTI can convert trace data into performance analysis data that can be displayed</p>
<p>in the<b> Profile</b> window. Profiling data generated from trace data is much more</p>
<p>complete, in terms of which instructions are represented, than data generated by</p>
<p>profiling methods that use sampling. (Sampling methods are usually timer-driven</p>
<p>and can miss important hot spots in a process.) MULTI can generate program counter</p>
<p>samples, call count with call graph data, and coverage analysis data from trace data.</p>
<p>For information about these data types, see âTypes of Profiling Dataâ on page 354.</p>
<p>For information about generating profiling data from trace data, see âCollecting</p>
<p>Profiling Data for a Trace-Enabled Targetâ on page 358.</p>
<p><i>475</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using Trace Data to Profile Your Target</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Reconstructed Register Values</b></p>
<p>If your trace data includes the addresses and values associated with traced memory</p>
<p>access instructions, MULTI is capable of inferring register values from the trace</p>
<p>data (see âDealing with Incomplete Trace Dataâ on page 411). To view the register</p>
<p>values that MULTI was able to reconstruct at a particular point in your trace data,</p>
<p>select an instruction and either click the</p>
<p>button or select<b> Tools</b> â<b> Registers</b> from</p>
<p>the Trace List or the PathAnalyzer. This opens the<b> Reconstructed Registers</b></p>
<p>window.</p>
<p>The<b> Reconstructed Registers</b> window displays a list of all the registers that MULTI</p>
<p>can reconstruct from the trace data.</p>
<p>If a register's value prior to executing the selected instruction can be inferred, the</p>
<p>value will be displayed. If not,</p>
<p>?</p>
<p>will be displayed to indicate that the register value</p>
<p>is unknown.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>476</i></p>
<p><i>Chapter 19. Analyzing Trace Data with the TimeMachine Tool Suite</i></p>
<h1 style="page-break-before:always; "></h1>
<p>In the<b> Reconstructed Registers</b> window, you can navigate to the previous or next</p>
<p>write to the selected register:</p>
<p>â¢</p>
<p>To navigate to the next write to the selected register, either click</p>
<p>or</p>
<p>right-click the register to display a shortcut menu and select<b> Next Write to</b></p>
<p><b>this Register</b>.</p>
<p>â¢</p>
<p>To navigate to the previous write to the selected register, either click</p>
<p>or</p>
<p>right-click the register to display the shortcut menu and select<b> Previous Write</b></p>
<p><b>to this Register</b>.</p>
<p><i>477</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Reconstructed Register Values</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 20</b></p>
<p><b>Advanced Trace</b></p>
<p><b>Configuration</b></p>
<p><b>Contents</b></p>
<p>The Trace Options Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>480</p>
<p>Configuring Target-Specific Trace Options . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>488</p>
<p>Viewing Target-Specific Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>489</p>
<p>Configuring Trace Collection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>489</p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Trace Options Window</b></p>
<p>The<b> Trace Options</b> window allows you to configure many aspects of trace</p>
<p>collection, retrieval, display, and deletion. To open the<b> Trace Options</b> window, do</p>
<p>one of the following:</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, select<b> Config</b> â<b> Options</b>.</p>
<p>â¢</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> Trace Options</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> trace options</b> command. For more</p>
<p>information about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>A sample<b> Trace Options</b> window is shown next.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>480</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Collection Tab</b></p>
<p>The following table describes each option available from the<b> Collection</b> tab of the</p>
<p><b>Trace Options</b> window. Unless otherwise stated, all descriptions of<b> Trace Options</b></p>
<p>window toggle options explain the behavior of the option when enabled.</p>
<p><b>Description</b></p>
<p><b>Collection</b></p>
<p><b>Option</b></p>
<p>Automatically enables trace collection when you establish a connection</p>
<p>to a target that supports trace. By default, this option is selected.</p>
<p><b>Automatically</b></p>
<p><b>enable trace</b></p>
<p><b>collection</b></p>
<p>Disables additional trace collection when trace is automatically retrieved</p>
<p>due to a trigger event. Disabling this option causes MULTI to automatically</p>
<p>re-enable trace collection after trace is retrieved due to a trigger. This can</p>
<p>be useful for collecting a large amount of trace data consisting of</p>
<p>independent trace buffers each centered around a trigger.</p>
<p>By default, this option is selected.</p>
<p><b>Disable trace</b></p>
<p><b>when trace</b></p>
<p><b>retrieved due to</b></p>
<p><b>trigger</b></p>
<p>Automatically downloads collected trace data when the target halts. This</p>
<p>means that when your target halts, trace data is immediately available for</p>
<p>use with TimeMachine.</p>
<p>Note that trace data is available for downloading only if trace collection</p>
<p>is enabled.</p>
<p>By default, this option is cleared.</p>
<p><b>Retrieve trace</b></p>
<p><b>when target halts</b></p>
<p>Automatically downloads collected trace data when the target's trace buffer</p>
<p>fills. Enabling this option results in trace data periodically being</p>
<p>downloaded when the target is running and when trace collection is</p>
<p>enabled.</p>
<p>By default, this option is cleared.</p>
<p><b>Retrieve trace</b></p>
<p><b>when buffer fills</b></p>
<p><i>481</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Collection Tab</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Collection</b></p>
<p><b>Option</b></p>
<p>With SuperTrace Probe v3 targets:</p>
<p>Specifies the number of bytes of trace data to retrieve from the end of the</p>
<p>SuperTrace Probe's trace buffer. The SuperTrace Probe v3 always uses</p>
<p>all of its trace RAM as a large circular buffer. However, since it takes a</p>
<p>long time to retrieve all of the data, MULTI can be configured to initially</p>
<p>retrieve only a portion of the data from the end of the buffer. For more</p>
<p>information, see âRetrieving Trace Data from a SuperTrace Probe v3â</p>
<p>on page 409.</p>
<p><b>Note</b>: Triggering on the SuperTrace Probe v3 uses the configured<b> Target</b></p>
<p><b>buffer size</b> rather than all available trace RAM. For example, if the<b> Target</b></p>
<p><b>buffer size</b> is set to 16 MB and the trigger position is set to 50%, trace</p>
<p>collection stops when 8 MB of data has been collected after the trigger</p>
<p>has occurred. For more information, see âConfiguring Trace Collectionâ</p>
<p>on page 489.</p>
<p>With other targets:</p>
<p>Specifies the number of bytes to use for collecting trace data on the target</p>
<p>or probe. The most recent trace data of the quantity specified here is</p>
<p>buffered while trace collection is enabled.</p>
<p>When you need a large, contiguous capture of trace data, select a large</p>
<p>value. Large captures may take longer to download and analyze, and they</p>
<p>require more disk space to cache, so choosing the largest possible buffer</p>
<p>size is rarely preferable.</p>
<p>For all targets:</p>
<p>The<b> traced instructions</b> field displays an estimate of the number of</p>
<p>instructions that will be traced by a full trace buffer of the size specified.</p>
<p>The<b> target memory</b> field displays the value of the target buffer size that</p>
<p>is currently specified. Moving the<b> Target buffer size</b> slider left and right</p>
<p>decreases and increases this value, respectively.</p>
<p><b>Target buffer size</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>482</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Collection</b></p>
<p><b>Option</b></p>
<p>Retrieves/synchronizes OSA data only for the first trace data retrieval after</p>
<p>each time the program is loaded. When disabled [default], OSA data is</p>
<p>retrieved every time trace data is retrieved.</p>
<p>This option should be enabled only if the set of tasks and AddressSpaces</p>
<p>in a system is static. Enabling this option is preferable on hardware</p>
<p>configurations for which retrieving OSA data from the target takes a</p>
<p>prohibitively long time. When new trace data is retrieved and analyzed</p>
<p>without new OSA data, the trace data may be decoded using the wrong</p>
<p>opcodes. For more information, see âCollecting Operating System Trace</p>
<p>Dataâ on page 406.</p>
<p>You can manually retrieve OSA data by executing the<b> trace updateosa</b></p>
<p>command. For more information about this command, see Chapter 20,</p>
<p>âTrace Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>Changes you make to this option take effect the next time trace data is</p>
<p>retrieved.</p>
<p>For information about OSA data, see Chapter 26, âFreeze-Mode Debugging</p>
<p>and OS-Awarenessâ on page 605.</p>
<p><b>Assume static</b></p>
<p><b>OSA</b></p>
<p>Opens a configuration window that contains target-specific options. This</p>
<p>button does not appear if the<b> Trace Options</b> window contains a</p>
<p>target-specific tab.</p>
<p>For more information, see the documentation about target-specific trace</p>
<p>options in the<i> Green Hills Debug Probes User's Guide</i> or, if you are using</p>
<p>a V850 target, the documentation about V850 trace options in the<i> MULTI:</i></p>
<p><i>Configuring Connections</i> book.</p>
<p><b>Target Specific</b></p>
<p><b>Options</b></p>
<p><i>483</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Collection Tab</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Collection</b></p>
<p><b>Option</b></p>
<p>Specifies the percentage of free disk space to use for storing collected trace</p>
<p>data on your computer. When this space has been filled, older trace data</p>
<p>is deleted to make space for newly collected trace data. A heuristic, which</p>
<p>considers triggers, bookmarks, and the currently selected instruction, selects</p>
<p>which previous downloads are deleted first.</p>
<p>The<b> whole buffers from target</b> field displays the estimated number of</p>
<p>full buffers (of the size specified by the<b> Target buffer size</b> slider) that can</p>
<p>be stored on the host (in the space currently specified by the<b> Host buffer</b></p>
<p><b>size</b> slider). The value in this field turns red if the host buffer size is</p>
<p>estimated to be too small. The size is estimated to be too small when a full</p>
<p>buffer from the target would be larger than the specified size.</p>
<p>The<b> host disk space</b> field displays the host buffer size that is currently</p>
<p>specified. Moving the slider left and right decreases and increases this</p>
<p>value, respectively.</p>
<p>The host buffer is only temporary storage and is not saved across sessions.</p>
<p>However, you may choose to save the trace data that has been collected.</p>
<p>For more information, see âSaving and Loading a Trace Sessionâ</p>
<p>on page 448.</p>
<p><b>Host buffer size</b></p>
<p>Displays the location on your computer of the temporary files that store</p>
<p>downloaded trace buffers. The environment variable that specifies this</p>
<p>path is shown above the text box.</p>
<p>To change the directory of the temporary trace files, change the value of</p>
<p>the environment variable TMP (Windows) or TMPDIR (Linux/Solaris),</p>
<p>and restart MULTI. To collect a large amount of trace data, the specified</p>
<p>directory must be on a drive with several gigabytes of free space.</p>
<p><b>Directory used</b></p>
<p><b>for trace data</b></p>
<p><b>buffers</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>484</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Analysis Tab</b></p>
<p>The following table describes each option available from the<b> Analysis</b> tab of the</p>
<p><b>Trace Options</b> window.</p>
<p><b>Description</b></p>
<p><b>Analysis Option</b></p>
<p>Enables reconstruction of trace data that was lost due to FIFO overflows.</p>
<p>In many cases it is possible to use TimeMachine technology to examine</p>
<p>the trace data before and after an overflow and determine which instructions</p>
<p>were executed during the overflow. In addition to reconstructing missing</p>
<p>instructions, this feature also attempts to determine the addresses and</p>
<p>values of data accesses performed by those instructions. Reconstructed</p>
<p>trace data is colored blue in the Trace List.</p>
<p>Depending on the code being traced, the frequency of overflows, and the</p>
<p>number of instructions that are typically lost per overflow on your target,</p>
<p>you can expect to see between 50 and 90 percent of FIFO overflows</p>
<p>reconstructed. For more information, see âDealing with Incomplete Trace</p>
<p>Dataâ on page 411.</p>
<p>This option is only available with certain targets.</p>
<p>By default, this option is selected.</p>
<p><b>Attempt to</b></p>
<p><b>reconstruct gaps</b></p>
<p><b>in trace data</b></p>
<p><i>485</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Analysis Tab</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Analysis Option</b></p>
<p>Controls the aggressiveness of the gap reconstruction algorithm. If the gap</p>
<p>reconstruction algorithm is allowed to make certain assumptions, it can</p>
<p>often reconstruct the missing trace data more successfully. This option</p>
<p>allows you to enable specific assumptions in the gap reconstruction</p>
<p>algorithm. These assumptions are generally correct, but when an incorrect</p>
<p>assumption is made, incorrect reconstruction of the missing trace data can</p>
<p>occur.</p>
<p>The three aggressiveness levels are:</p>
<p>â¢</p>
<p><b>Level 0 â No Assumptions</b> â No assumptions are made.</p>
<p>â¢</p>
<p><b>Level 1 â Partial Reconstruction</b> â [default] Partial reconstruction</p>
<p>of gaps in the trace data is allowed. This means that even if the entire</p>
<p>gap cannot be reconstructed, any instructions that can be reconstructed</p>
<p>are inserted into the trace. The assumption being made is that an</p>
<p>interrupt or exception did not occur during the trace gap.</p>
<p>â¢</p>
<p><b>Level 2 â Don't Invalidate</b> â The gap reconstruction algorithm</p>
<p>does not invalidate the register and memory values it has inferred</p>
<p>from earlier trace data when it fails to reconstruct a gap. The</p>
<p>assumption being made is that the missing instructions did not modify</p>
<p>any of those register or memory values.</p>
<p>This option is only available if<b> Attempt to reconstruct gaps in trace</b></p>
<p><b>data</b> is enabled.</p>
<p><b>Aggressiveness</b></p>
<p>Aborts trace decompression when a PC is encountered for which the opcode</p>
<p>cannot be identified by using binary image or target memory reads. Reading</p>
<p>from target memory is not attempted if the option<b> Read unknown opcodes</b></p>
<p><b>from target (may halt target)</b> (below) is disabled.</p>
<p>By default, this option is selected. It can only be cleared if<b> Read unknown</b></p>
<p><b>opcodes from target (may halt target)</b> is also cleared.</p>
<p><b>Abort processing</b></p>
<p><b>on opcode failure</b></p>
<p>Allows opcodes necessary for trace decompression to be read from target</p>
<p>memory. Opcodes are only read from the target if they cannot be found</p>
<p>in the ELF file. The target may be briefly halted to allow target memory</p>
<p>to be read. This behavior may interfere with your target process but is</p>
<p>necessary in order to reconstruct trace data for code that was not</p>
<p>downloaded by MULTI.</p>
<p>By default, this option is cleared.</p>
<p><b>Read unknown</b></p>
<p><b>opcodes from</b></p>
<p><b>target (may halt</b></p>
<p><b>target)</b></p>
<p>Specifies the maximum number of packets that should be analyzed at any</p>
<p>one time to reconstruct the state of registers and memory for TimeMachine.</p>
<p>Increasing this number lengthens the delay required for analyzing packets</p>
<p>and increases the amount of memory used by the tools, but also results in</p>
<p>a more complete reconstruction of the state of registers and memory.</p>
<p><b>Packets to</b></p>
<p><b>analyze for</b></p>
<p><b>register</b></p>
<p><b>reconstruction</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>486</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Analysis Option</b></p>
<p>Stops the TimeMachine Debugger when it encounters discontinuities in</p>
<p>the trace data. When this happens, the message</p>
<p>Stopped by</p>
<p>discontinuity in trace data</p>
<p>is printed in the MULTI command</p>
<p>pane. Different types of discontinuities occur in trace data. Some common</p>
<p>types are FIFO overflows and gaps between subsequent trace runs. For</p>
<p>more information, see âDealing with Incomplete Trace Dataâ on page 411.</p>
<p>By default, this option is selected.</p>
<p><b>Stop at</b></p>
<p><b>discontinuities</b></p>
<p><b>The Debug Tab</b></p>
<p>The following table describes each option available from the<b> Debug</b> tab of the</p>
<p><b>Trace Options</b> window.</p>
<p><b>Description</b></p>
<p><b>Debug Option</b></p>
<p>Interleaves information about raw compressed trace with instructions in</p>
<p>the Trace List. You should not enable this option unless instructed to do</p>
<p>so by Green Hills Technical Support. This option is only available for</p>
<p>some hardware trace targets.</p>
<p>By default, this option is cleared.</p>
<p><b>Display raw trace</b></p>
<p><b>packets</b></p>
<p>This option is for debugging only. You should not enable this option unless</p>
<p>instructed to do so by Green Hills Technical Support. This option is only</p>
<p>available for some trace targets.</p>
<p>By default, this option is cleared.</p>
<p><b>Enable debug</b></p>
<p><b>logging</b></p>
<p><b>The Target-Specific Tab</b></p>
<p>Each option available from the target-specific tab (if any) of the<b> Trace Options</b></p>
<p>window is described in the documentation pane in the right of the window and also</p>
<p>in the documentation about target-specific trace options in the<i> Green Hills Debug</i></p>
<p><i>Probes User's Guide</i> or, if you are using a V850 target, in the documentation about</p>
<p>V850 trace options in the<i> MULTI: Configuring Connections</i> book.</p>
<p>To set an option on this tab, select the option from the list on the left, and modify</p>
<p>its value in the upper-right corner of the window.</p>
<p><i>487</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Debug Tab</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Tip</b></p>
<p>You can quickly set toggle options (<b>On</b>/<b>Off</b>) by double-clicking them.</p>
<p>Modified options are highlighted until you click<b> Apply</b>.</p>
<p><b>Action Buttons</b></p>
<p>If the<b> Save configuration as default</b> option is selected when you click<b> OK</b> or</p>
<p><b>Apply</b>, your current settings in the<b> Trace Options</b> and<b> Set Triggers</b> windows,</p>
<p>along with your current target-specific settings, are applied to your current trace</p>
<p>session and are saved and automatically loaded each time you use the trace tools.</p>
<p>Click the<b> Save</b> button to save these settings to a file so that you can load them later</p>
<p>by clicking the<b> Load</b> button.</p>
<p><b>Configuring Target-Specific Trace Options</b></p>
<p>Many targets have target-specific trace configuration options. To configure the</p>
<p>options specific to your target (if any):</p>
<p>â¢</p>
<p>Click the button labeled<b> Target Specific Options</b> on the<b> Collection</b> tab of the</p>
<p><b>Trace Options</b> window</p>
<p>or</p>
<p>Click the target-specific tab (the fourth tab) in the<b> Trace Options</b> window.</p>
<p>If your target supports target-specific trace configuration options, the<b> Target</b></p>
<p><b>Specific Options</b> button or the target-specific tab will be available, but not</p>
<p>both.</p>
<p>â¢</p>
<p>Select<b> Config</b> â<b> Target Specific Options</b> in the Trace List or the</p>
<p>PathAnalyzer. This menu item opens the same dialog box as the<b> Target Specific</b></p>
<p><b>Options</b> button and is only available when the button is available.</p>
<p>For information about target-specific options, see the documentation about</p>
<p>target-specific trace options in the<i> Green Hills Debug Probes User's Guide</i> or, if</p>
<p>you are using a V850 target, the documentation about V850 trace options in the</p>
<p><i>MULTI: Configuring Connections</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>488</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Target-Specific Information</b></p>
<p>To view the capabilities of the hardware target that you are connected to, select</p>
<p><b>Config</b> â<b> Show Target Info</b> from the Trace List or the PathAnalyzer. This opens</p>
<p>the<b> Additional Target Info</b> window, which displays information about the specific</p>
<p>hardware device you are connected to.</p>
<p>For example, when you are connected to an ARM ETM target, this window displays</p>
<p>information about triggering resources available, the maximum width of the trace</p>
<p>port, and the size of the trace buffer.</p>
<p><b>Configuring Trace Collection</b></p>
<p>You can configure trace collection by setting triggers and other target-specific</p>
<p>events. Trace collection systems generally have a circular buffer that wraps around</p>
<p>when it fills. A trigger event controls when the trace collection system stops</p>
<p>collecting data. When a trigger event is encountered, the system continues collecting</p>
<p>data until a user-specified percentage of the buffer is filled.</p>
<p>For example, when a trigger is configured to occur in the center of the trace buffer,</p>
<p>the trace collection system continues to collect data until 50 percent of the buffer</p>
<p>has been filled after the trigger occurs. In this way, the trigger is always present in</p>
<p>the trace buffer after it is encountered. When trace collection stops as a result of a</p>
<p>trigger event, trace is automatically retrieved. (For information about other ways</p>
<p>to control trace collection and retrieval, see âManaging Trace Dataâ on page 405.)</p>
<p><i>489</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Target-Specific Information</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The trigger location is automatically bookmarked so that it is easy to find. The</p>
<p>default name for trigger bookmarks is âTrigger,â and they are colored red by default.</p>
<p>The trigger location is also automatically selected when trace is first collected. All</p>
<p>trace displays initially center on the trigger.</p>
<p>On most architectures, the bookmarked instruction is not the exact instruction that</p>
<p>caused the trigger. The trigger bookmark could be as many as several thousand</p>
<p>instructions before or after the instruction that caused the trigger. This is due to the</p>
<p>fact that most trace architectures output trace data in such a way that it is impossible</p>
<p>to determine the exact instruction that caused the trigger.</p>
<p>You can use Debugger shortcut menus or the<b> Set Triggers</b> window to set the trigger</p>
<p>for your trace run. For more information, see âThe Set Triggers Windowâ</p>
<p>on page 493.</p>
<p><b>Note</b></p>
<p>On INTEGRITY, it is not possible to configure trigger and trace events</p>
<p>in a specific AddressSpace. The Debugger shortcut menus, commands,</p>
<p>and the<b> Set Triggers</b> window only allow you to configure triggers and</p>
<p>trace events for the kernel AddressSpace. However, most trace hardware</p>
<p>and the Green Hills simulators respond to triggers and trace events when</p>
<p>the associated virtual addresses are executed or accessed in any</p>
<p>AddressSpace. For example, most trace hardware configured to trigger</p>
<p>upon execution of address</p>
<p>0x1000</p>
<p>will trigger upon execution of</p>
<p>0x1000</p>
<p>in any AddressSpace. Refer to your processor's documentation for details</p>
<p>about how triggers interact with virtual AddressSpaces.</p>
<p><b>Note</b></p>
<p>It may be necessary to halt certain targets before changes to trace triggers</p>
<p>will take effect.</p>
<p>In addition to trigger configuration, many trace architectures also allow you to</p>
<p>configure when different types of trace data will be generated. For example, you</p>
<p>may be able to configure your target to only trace certain functions or to only trace</p>
<p>data accesses to a range of addresses corresponding to memory-mapped registers.</p>
<p>This can be useful if your target has very limited trace bandwidth and you know</p>
<p>exactly what you are looking for, or if you are only interested in tracing a subset of</p>
<p>the code running on the target. However, the usefulness of MULTI's high-level</p>
<p>trace analysis tools such as the TimeMachine Debugger and PathAnalyzer degrades</p>
<p><i>MULTI: Debugging</i></p>
<p><i>490</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p>rapidly as trace data is suppressed. For more information, see âDealing with</p>
<p>Incomplete Trace Dataâ on page 411.</p>
<p><b>Configuring Trace Directly from MULTI</b></p>
<p>When you are connected to a target that supports trace, the following trace options</p>
<p>appear in the shortcut menu that opens when you right-click in the Debugger's</p>
<p>source pane. Each of these options configures trace hardware and immediately</p>
<p>enables tracing.</p>
<p><b>Note</b></p>
<p>These options are not available with all targets.</p>
<p><b>Effect</b></p>
<p><b>Then select</b></p>
<p><b>Right-click</b></p>
<p>Sets the trigger event to be any execution of the</p>
<p>selected line.</p>
<p>You can also use the<b> traceline</b> Debugger</p>
<p>command to achieve this effect. For information</p>
<p>about this command, see Chapter 20, âTrace</p>
<p>Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Trace</b> â<b> Trace Around</b></p>
<p><b>This Line</b></p>
<p>Any</p>
<p>executable</p>
<p>line in the</p>
<p>source pane</p>
<p>Enables trace only when executing the selected</p>
<p>function. Tracing will not occur when executing</p>
<p>subfunctions.</p>
<p>You can also use the<b> tracefunction</b> Debugger</p>
<p>command to achieve this effect. For information</p>
<p>about this command, see Chapter 20, âTrace</p>
<p>Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Trace</b> â<b> Trace This</b></p>
<p><b>Function</b></p>
<p>A function</p>
<p>Allows you to create conditions that enable and</p>
<p>disable trace based on executions in specific</p>
<p>functions. For more information, see âSpecifying</p>
<p>a Trace Function Intervalâ on page 492.</p>
<p><b>Trace</b> â<b> Trace Function</b></p>
<p><b>Interval</b></p>
<p>A function</p>
<p><i>491</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Configuring Trace Directly from MULTI</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Then select</b></p>
<p><b>Right-click</b></p>
<p>Sets the trigger event to be any access of the</p>
<p>selected global variable.</p>
<p>You can also use the<b> tracedata</b> Debugger</p>
<p>command to achieve this effect. For information</p>
<p>about this command, see Chapter 20, âTrace</p>
<p>Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Trace</b> â<b> Trace Around</b></p>
<p><b>Data Access</b></p>
<p>A global</p>
<p>variable</p>
<p>These options overwrite any events and states in the current trace configuration. To</p>
<p>view or modify the current trace configuration, use the<b> Set Triggers</b> window. See</p>
<p>âThe Set Triggers Windowâ on page 493 for more information.</p>
<p><b>Specifying a Trace Function Interval</b></p>
<p>MULTI provides very powerful tools to specify complex scenarios for collecting</p>
<p>and displaying trace data. For simple tracing, however, you can use the<b> Trace</b></p>
<p><b>Function Interval</b> option to quickly configure a trace scenario (or to view the</p>
<p>configuration of a previously set trace function interval).</p>
<p>To define a trace function interval, right-click a function in the source pane and</p>
<p>select<b> Trace</b> â<b> Trace Function Interval</b> from the shortcut menu. This opens a</p>
<p><b>Configure Trace Interval</b> window.</p>
<p>When tracing using the<b> Trace Function Interval</b> option, trace begins in the disabled</p>
<p>state. Once the start condition is met, trace begins to be recorded. To set the start</p>
<p><i>MULTI: Debugging</i></p>
<p><i>492</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p>condition, select the option that corresponds to the desired behavior from the<b> Start</b></p>
<p><b>trace</b> drop-down box. To set the stop condition, select the desired behavior from</p>
<p>the<b> Stop trace</b> drop-down box. The following table describes the options available</p>
<p>from these drop-down boxes.</p>
<p><b>Behavior</b></p>
<p><b>Start/Stop Trace Options</b></p>
<p>Trace starts in the enabled state. The selected function is</p>
<p>ignored.</p>
<p><b>Initially (ignores function)</b></p>
<p>Trace is never disabled after it is enabled. The selected function</p>
<p>is ignored.</p>
<p><b>Never (ignores function)</b></p>
<p>Trace starts/stops when the entry point of the selected function</p>
<p>is executed. (This is the default setting for the left side of the</p>
<p>window.)</p>
<p><b>On entry into</b></p>
<p>Trace starts/stops when the epilogue of the selected function is</p>
<p>executed. (This is the default setting for the right side of the</p>
<p>window.)</p>
<p><b>On exit (epilogue) from</b></p>
<p>Trace starts/stops when any instruction of the specified function</p>
<p>is executed.</p>
<p><b>On any execution in</b></p>
<p>Lists of all the functions in the program are displayed below the<b> Start trace</b> and</p>
<p><b>Stop trace</b> drop-down boxes. By default, the function that was highlighted when</p>
<p>you selected<b> Trace Function Interval</b> will be the selected function, but you can</p>
<p>click another function to change the selection.</p>
<p>To confirm your settings, click<b> OK</b>. This will replace your existing trace</p>
<p>configuration with the trace function interval configuration you selected. To view</p>
<p>or modify the current trace configuration, use the<b> Set Triggers</b> window. See âThe</p>
<p>Set Triggers Windowâ on page 493 for more information.</p>
<p><b>The Set Triggers Window</b></p>
<p>The<b> Set Triggers</b> window provides control over the various trace events defined</p>
<p>by each trace architecture. To open the<b> Set Triggers</b> window, do one of the</p>
<p>following:</p>
<p>â¢</p>
<p>In the Debugger, select<b> TimeMachine</b> â<b> Set Triggers</b>.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, click the</p>
<p>button.</p>
<p>â¢</p>
<p>In the Trace List or the PathAnalyzer, select<b> Config</b> â<b> Set Triggers</b>.</p>
<p><i>493</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Set Triggers Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the MULTI Debugger command pane, enter the<b> trace triggers</b> command.</p>
<p>For information about this command, see Chapter 20, âTrace Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>The<b> Set Triggers</b> window allows you to modify triggers as well as other trace</p>
<p>events.</p>
<p><b>Note</b></p>
<p>The<b> Set Triggers</b> window settings are saved on a per executable basis</p>
<p>because they often reference function and variable names that are specific</p>
<p>to the current project.</p>
<p>The events available in this window are target dependent. The most common events</p>
<p>are described below.</p>
<p><b>Description</b></p>
<p><b>Event</b></p>
<p>Stops trace collection when the data you are interested in has been</p>
<p>collected. For more information, see âConfiguring Trace Collectionâ</p>
<p>on page 489.</p>
<p><b>Trigger</b></p>
<p>Filters out unwanted trace data at the hardware level. Trace data is</p>
<p>generated only while this event is active.</p>
<p><b>Trace</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>494</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Event</b></p>
<p>Filters out unwanted data trace. Memory accesses will only be traced</p>
<p>while both this event and the<b> Trace</b> event are active.</p>
<p><b>Data Trace</b></p>
<p>Asserts an output signal of the trace hardware when active.</p>
<p><b>External Output</b></p>
<p>Some targets have very limited triggering hardware while others provide extensive</p>
<p>triggering and filtering capabilities. Even if your target has extensive triggering</p>
<p>hardware, there is always a limit to the number of each type of resource that can be</p>
<p>used when defining events in the<b> Set Triggers</b> window. If you exceed this limit,</p>
<p>the trigger will fail to be set and an error message will be displayed in the status</p>
<p>area at the bottom of the window.</p>
<p>The<b> Set Triggers</b> window displays each event supported by your current trace</p>
<p>architecture in the<b> Events</b> list. You can select an event to see the current setting for</p>
<p>that event. In addition, you can modify the current value and click<b> Set</b> to apply the</p>
<p>new setting to the selected event. When you click the<b> Set</b> button, the new values</p>
<p>are transferred to the trace target in anticipation of the next trace run.</p>
<p>You can set events to occur on the following conditions.</p>
<p><b>Description</b></p>
<p><b>Condition</b></p>
<p>Always active. This condition is displayed as<b> Trigger</b></p>
<p><b>Immediately</b> with trigger events. When<b> Trigger Immediately</b></p>
<p>is selected, the first instruction executed after trace is started</p>
<p>will cause trace collection to trigger. This results in trace</p>
<p>collection stopping automatically as soon as the trace buffer</p>
<p>fills.</p>
<p><b>Always</b> or<b> Trigger</b></p>
<p><b>Immediately</b></p>
<p>Never active. This condition is displayed as<b> Don't Trigger</b></p>
<p>with trigger events.</p>
<p><b>Never</b> or<b> Don't Trigger</b></p>
<p>Active when the instruction at the specified address is</p>
<p>executing.</p>
<p><b>Address Executed</b></p>
<p>Active when any instruction in the specified function is</p>
<p>executing.</p>
<p><b>Function Executing</b></p>
<p>Active when any instruction not in the specified function is</p>
<p>executing.</p>
<p><b>Function Not Executing</b></p>
<p><i>495</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Set Triggers Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Condition</b></p>
<p>Active when a function and the functions it calls are executing.</p>
<p>This condition is activated when the first instruction of the</p>
<p>specified function executes, and it is deactivated when the</p>
<p>last instruction of the same function executes. As a result of</p>
<p>this behavior, this condition is not activated during a call to</p>
<p>the specified function if the trace starts in the middle of the</p>
<p>call. Functions with multiple return points are not supported.</p>
<p>This condition is not available for all events.</p>
<p><b>Function and Callees</b></p>
<p><b>Executing</b></p>
<p>Active when any instruction not in the specified function or</p>
<p>in a function called by the specified function is executing.</p>
<p>This condition is the inverse of<b> Function and Callees</b></p>
<p><b>Executing</b> and is affected by the same limitations. This</p>
<p>condition is not available for all events.</p>
<p><b>Function and Callees Not</b></p>
<p><b>Executing</b></p>
<p>Activates when the start condition is true and deactivates when</p>
<p>the end condition is true. This condition is not available for</p>
<p>all events. For more information about function interval</p>
<p>tracing, see âSpecifying a Trace Function Intervalâ</p>
<p>on page 492.</p>
<p><b>Function Interval Executing</b></p>
<p>Active when a variable or address is read from or written to.</p>
<p><b>Data Read/Written</b></p>
<p>Active when a variable or address is read from.</p>
<p><b>Data Read</b></p>
<p>Active when a variable or address is written to.</p>
<p><b>Data Written</b></p>
<p>Active when the specified exception is taken. This condition</p>
<p>is only available on ARM ETM targets.</p>
<p><b>Exception</b></p>
<p>Active when a complex event is enabled. You can specify the</p>
<p>complex event with the<b> Advanced Edit</b> button. For details,</p>
<p>see âEditing Complex Eventsâ on page 497.</p>
<p><b>Custom Event</b></p>
<p>For the function and address executing conditions, you can enter a function name,</p>
<p>a function and line number, a function plus offset or an address in the<b> Address</b></p>
<p>field.</p>
<p>For the various data conditions, you can enter a global or static variable or an address</p>
<p>in the<b> Address</b> field. You can also optionally enter a data value and the event will</p>
<p>only occur when that value is read or written. If a data value is specified, the event</p>
<p>will only activate if a single data access reads or writes the specified value. For</p>
<p>example, these simple data conditions cannot be used to detect a write of a specific</p>
<p>64-bit value to a 64-bit variable if the 64-bit write is broken up into two 32-bit stores</p>
<p>by the compiler.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>496</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Setting the Trigger Position</b></p>
<p>For targets that support a trigger, the trigger position slider appears when you edit</p>
<p>the<b> Trigger</b> event. This slider allows you to set the desired trigger position as a</p>
<p>percentage of the trace buffer being collected. The number displayed indicates the</p>
<p>desired percentage of the buffer that comes before the trigger event in the final trace</p>
<p>buffer. However, in the following circumstances, the selected trigger position has</p>
<p>no impact on the trigger position in the final trace buffer:</p>
<p>â¢</p>
<p>If a trigger occurs shortly after trace collection is enabled, the actual location</p>
<p>of the trigger may be before the desired trigger position.</p>
<p>â¢</p>
<p>If a trigger occurs and then trace is manually or automatically retrieved before</p>
<p>enough trace data is collected, the actual location of the trigger will be after</p>
<p>the desired trigger position.</p>
<p>In all other cases, the trigger will be at the desired position in the trace buffer. For</p>
<p>example, if you set the trigger position to 15 percent, 15 percent of the trace buffer</p>
<p>will contain trace data from before the trigger, and 85 percent of the buffer will</p>
<p>contain trace data from after the trigger.</p>
<p><b>Editing Complex Events</b></p>
<p>When you select the<b> Advanced Edit</b> button in the<b> Set Triggers</b>,<b> Trace Filters</b>, and</p>
<p><b>Trace Search</b> dialogs, you are presented with the<b> Advanced Event Editor</b> window.</p>
<p>This window allows you to specify arbitrarily complex events built from simple</p>
<p>events.</p>
<p>The<b> Advanced Event Editor</b> window allows you to specify an event by defining</p>
<p><b>Resources</b> and combining them in various ways. The top of the window displays</p>
<p>the current event and allows you to modify it while the bottom pane displays the</p>
<p>currently defined<b> Resources</b>.</p>
<p><i>497</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Editing Complex Events</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The first step of defining an event is to create the<b> Resources</b> that you will use to</p>
<p>build the event.<b> Resources</b> can be defined to activate when:</p>
<p>â¢</p>
<p>The target processor executes from a specific address or within a range of</p>
<p>addresses.</p>
<p>â¢</p>
<p>The target processor reads or writes at a specific address or within a range of</p>
<p>addresses.</p>
<p>â¢</p>
<p>The target processor reads or writes a specific data pattern at a specific address</p>
<p>or within a range of addresses.</p>
<p>â¢</p>
<p>An external input to the target trace hardware is asserted (only available if</p>
<p>supported by target hardware).</p>
<p>â¢</p>
<p>An event such as a trace overflow, exception, or debug mode entry occurs.</p>
<p>This type of<b> Resource</b> is not available through the<b> Set Triggers</b> window</p>
<p>because it can only be used when analyzing trace data after it has already been</p>
<p>collected.</p>
<p>In addition, you can create state machines that allow you to specify events that occur</p>
<p>in a specific order. Finally, two<b> Resources</b>,<b> on</b> and<b> off</b>, are predefined; these events</p>
<p>are always true and always false, respectively.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>498</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Creating Resources</b></p>
<p>To create a new resource, either click the<b> New Resource</b> button or right-click in</p>
<p>the Resource List and select the<b> New Resource</b> menu option. This will open the</p>
<p><b>Resource Editor</b> dialog, which allows you to define the attributes for this resource.</p>
<p>The available attributes are described in the table below.</p>
<p><b>Description</b></p>
<p><b>Attribute</b></p>
<p>The name of the resource. The name is used to represent the resource when</p>
<p>defining events and must be composed of alphanumeric characters and</p>
<p>underscores with the first character not a numeral.</p>
<p><b>Resource</b></p>
<p><b>Name</b></p>
<p>Determines what must happen in order for this resource to activate.</p>
<p><b>Resource Type</b></p>
<p><i>499</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Editing Complex Events</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Attribute</b></p>
<p>Defines the address or address range that the target must execute or access</p>
<p>in order for this resource to activate.</p>
<p>The radio buttons allow you to select between 4 different ways of specifying</p>
<p>the<b> Address</b> attribute.</p>
<p>â¢</p>
<p>In<b> Single</b> mode, the resource will only activate when one specific address</p>
<p>is matched.</p>
<p>â¢</p>
<p>In<b> Range</b> mode, both a start and end address are specified.</p>
<p>â¢</p>
<p>In<b> Array</b> mode, a start address and an offset are specified. The offset</p>
<p>may be specified using the</p>
<p>sizeof</p>
<p>operator on a symbol name. For</p>
<p>example, to specify an event that is true when any element of an array</p>
<p>is accessed, you can set the<b> Offset</b> field to</p>
<p>sizeof(<i>array_name</i>)</p>
<p>.</p>
<p>â¢</p>
<p>In<b> Symbol</b> mode, the start and end addresses associated with the given</p>
<p>symbol define the address range which is used.</p>
<p>For those modes in which a range or offset is used (the<b> Range</b>,<b> Array</b>, and</p>
<p><b>Symbol</b> modes), the end address is exclusive.</p>
<p>In both<b> Single</b> and<b> Range</b> modes, the</p>
<p>exit</p>
<p>operator can be used on a function</p>
<p>name to give the address of the last instruction in the function. For example,</p>
<p>to create a resource that evaluates to true when a function called</p>
<p>increment</p>
<p>returns, set the address field to</p>
<p>exit(increment)</p>
<p>.</p>
<p>The<b> Bitmask</b> is</p>
<p>ANDed</p>
<p>with the accessed address before any comparisons</p>
<p>are made. This required attribute applies to<b> Read/Write</b>,<b> Read</b>,<b> Write</b>, and</p>
<p><b>Execute</b> resources.</p>
<p>The<b> Access Size</b> specifies a memory access size that must be matched by a</p>
<p>read or write in order for this resource to activate. This optional attribute</p>
<p>applies to<b> Read/Write</b>,<b> Read</b>, and<b> Write</b> resources and is only available with</p>
<p>some targets.</p>
<p><b>Address</b></p>
<p>Allows a data pattern to be specified that must be matched by the read or</p>
<p>write in order for this resource to activate. The<b> Bitmask</b> is</p>
<p>ANDed</p>
<p>with the</p>
<p>data value transferred by the target before it is compared with the specified</p>
<p>data value.</p>
<p>The resource only activates if a single data access reads or writes the specified</p>
<p>value. For example, a single<b> Write</b> resource cannot be used to detect a write</p>
<p>of a specific 64-bit value to a 64-bit variable if the 64-bit write is broken up</p>
<p>into two 32-bit stores by the compiler.</p>
<p>This optional attribute applies to<b> Read/Write</b>,<b> Read</b>, and<b> Write</b> resources.</p>
<p><b>Value</b></p>
<p>Specifies which external input signal to your target's triggering hardware will</p>
<p>activate this<b> Resource</b>. This required attribute only applies to<b> External</b></p>
<p>resources.</p>
<p><b>Index</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>500</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Description</b></p>
<p><b>Attribute</b></p>
<p>Specifies which type of event will activate this<b> Resource</b>. The available types</p>
<p>are described in the next section. This required attribute only applies to<b> Event</b></p>
<p>resources.</p>
<p><b>Event Type</b></p>
<p>Specifies which type of exception will activate this<b> Resource</b>. The available</p>
<p>types are described in âException Type Descriptionsâ on page 502. This</p>
<p>required attribute only applies to<b> Exception</b> resources, which are only</p>
<p>available on ARM ETM targets.</p>
<p><b>Exception</b></p>
<p>Specifies which memory map decode will activate this<b> Resource</b>. For more</p>
<p>information, see the documentation for your processor. This required attribute</p>
<p>only applies to<b> Memory Map Decode</b> resources, which are only available</p>
<p>on ARM ETM targets.</p>
<p><b>MMD Index</b></p>
<p>Event Type Descriptions</p>
<p>The trace trigger point.</p>
<p><b>Trigger</b></p>
<p>One or more instructions that were not traced as a result of filtering</p>
<p>configured with the<b> Set Triggers</b> window.</p>
<p><b>Trace Disabled</b></p>
<p>A trace port overflow that caused a gap of one or more instructions in the</p>
<p>trace.</p>
<p><b>Overflow</b></p>
<p>An entry into debug mode caused by the target processor hitting a breakpoint</p>
<p>or being halted by the Debugger.</p>
<p><b>Debug Mode</b></p>
<p>On most targets: any exception. On ARM targets: one of the exceptions</p>
<p>described in the next section.</p>
<p><b>Exception</b></p>
<p>A trace processing error.</p>
<p><b>Error</b></p>
<p>An instruction that was lost as a result of trace port overflows but was</p>
<p>reconstructed by automatic gap reconstruction. For more information, see</p>
<p>the option<b> Attempt to reconstruct gaps in trace data</b> in âThe Trace Options</p>
<p>Windowâ on page 480.</p>
<p><b>Reconstructed</b></p>
<p><i>501</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Editing Complex Events</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Exception Type Descriptions</p>
<p>Exception resources are implemented by an Address Execute resource on the</p>
<p>exception vector address. Therefore MULTI provides two versions of each of the</p>
<p>following exception options. If your application uses high exception vectors (starting</p>
<p>at</p>
<p>0xffff0000</p>
<p>), you should choose the<b> (High)</b> version.</p>
<p>The following exceptions are only available for triggering on ARM.</p>
<p>The traced processor was reset.</p>
<p><b>Reset</b></p>
<p>The traced processor attempted to execute an invalid instruction.</p>
<p><b>Undefined</b></p>
<p><b>Instruction</b></p>
<p>The traced processor executed a software interrupt instruction.</p>
<p><b>Software</b></p>
<p><b>Interrupt</b></p>
<p>The traced processor attempted to execute an instruction for which a memory</p>
<p>abort was signaled while the instruction was being fetched.</p>
<p><b>Prefetch Abort</b></p>
<p>The traced processor failed to read or write memory due to a memory abort.</p>
<p><b>Data Abort</b></p>
<p>The traced processor handled an interrupt request.</p>
<p><b>IRQ</b> (Interrupt</p>
<p>request</p>
<p>exception)</p>
<p>The traced processor handled a fast interrupt request.</p>
<p><b>FIQ</b> (Fast</p>
<p>interrupt request</p>
<p>exception)</p>
<p>Creating State Machine Resources</p>
<p>State machine resources allow you to specify events that are active after certain</p>
<p>events have occurred and optionally before some others have happened. For example,</p>
<p>this allows you to create complex events that are true after a function has been called</p>
<p>but before it has returned. This type of event would be true as long as the specified</p>
<p>function is present in the call stack.</p>
<p><b>Note</b></p>
<p>Support for state machines and the number of supported states depends</p>
<p>on your trace architecture. For more information, see the specification</p>
<p>for your trace architecture.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>502</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To add a state machine, click the<b> New State Machine</b> button. This opens the state</p>
<p>machine editor, which allows you to create a state machine by adding states and</p>
<p>defining state transition events.</p>
<p>There are two ways to add a state to a state machine:</p>
<p>â¢</p>
<p>Click the<b> New State</b> button. Then click the state and move it to a location on</p>
<p>the canvas.</p>
<p>â¢</p>
<p>Right-click the background canvas and select<b> Add State</b>. Then click the state</p>
<p>and move it to a location on the canvas.</p>
<p><i>503</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Editing Complex Events</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To rename a state, double-click it and enter a new name in the<b> Set State Name</b></p>
<p>dialog.</p>
<p>To delete a state, select it and click the<b> Delete</b> button or press the<b> Delete</b> key.</p>
<p>A<i> state transition</i> defines the events on which the state machine changes state. Once</p>
<p>you have added all of the states you want, you can create transitions by right-clicking</p>
<p>the source state and selecting<b> Add Link</b>. Then click the destination state to create</p>
<p>the link. Alternatively, you can right-click and drag to the destination state to define</p>
<p>a new state transition.</p>
<p>Once you have defined a transition's start and destination states, the<b> Advanced</b></p>
<p><b>Event Editor</b> window will open so that you can define an event on which this</p>
<p>transition will occur. The transition will occur when the event evaluates to true.</p>
<p>To edit the event of an existing link, either double-click it or right-click and select</p>
<p><b>Edit</b>.</p>
<p>The state machine starts in the start state, which is denoted by</p>
<p>(S)</p>
<p>after the state</p>
<p>name. To mark a state as the start state, right-click it and select the<b> Set as Start</b></p>
<p><b>State</b> menu option.</p>
<p><b>Defining Complex Events</b></p>
<p>After creating the resources and state machines that you need for your event,</p>
<p>construct the event by inserting the resources into the event field. This field contains</p>
<p>a string that consists of a Boolean combination of resources. In addition, you can</p>
<p>specify the count of a resource and the state when a state machine resource is active.</p>
<p>To clear your event, you can click the<b> Clear</b> button. When you clear the event field,</p>
<p>the<b> Event Progress Indicator</b> will display âEvent not complete,â which indicates</p>
<p>that you must enter more text to define a valid event.</p>
<p>To insert a new resource, select it in the<b> Resource List</b> and either click the<b> Insert</b></p>
<p><b>Resource</b> button or right-click and select<b> Insert Resource</b>. The selected resource</p>
<p>name will appear in the event field.</p>
<p>To create a Boolean combination of two resources, insert a resource and then click</p>
<p>one of the Boolean operator buttons (<b>AND</b> or<b> OR</b>). The corresponding Boolean</p>
<p><i>MULTI: Debugging</i></p>
<p><i>504</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p>operation will appear in the event field. You can now insert another resource to</p>
<p>combine with the first one.</p>
<p>You can specify the precedence of multiple Boolean combinations by using</p>
<p>parentheses. Simply type them in the event field around the combinations that you</p>
<p>want to have the highest priority and they will be evaluated first. When parentheses</p>
<p>are not properly matched, the Event Progress Indicator will display âUnmatched</p>
<p>parentheses,â which means that you do not have valid matching parentheses.</p>
<p><b>Count Expression</b></p>
<p>Sometimes you may want an event to be active when an event has occurred a certain</p>
<p>number of times. For example, if you have a bug that occurs after a function has</p>
<p>been executed 10,000 times, then you may want to trigger after the function has</p>
<p>been called 10,000 times. Count expressions allow you to define events of this form.</p>
<p>Any time that a resource can appear in the event field, you can also specify the</p>
<p>count of a resource. To insert a resource with a count, click the<b> count()</b> button. This</p>
<p>will open the<b> Count</b> dialog, shown below.</p>
<p>This dialog allows you to specify the event to count as well as a comparison operator</p>
<p>and a number. A count expression is true whenever the number of times the<b> Count</b></p>
<p><b>Event</b> has occurred during trace collection is such that comparing the count to the</p>
<p>specified number with the specified comparison operator evaluates to true.</p>
<p><i>505</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Editing Complex Events</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To set the<b> Count Event</b>, click the<b> Edit Count Event</b> button. This opens another</p>
<p><b>Advanced Event Editor</b> window that allows you to specify the event to count. It</p>
<p>is impossible to create nested count statements, so the<b> count()</b> button is disabled in</p>
<p>this new window. Once you have selected the<b> Count Event</b>, use the six operator</p>
<p>buttons to select the<b> Count Operation</b>. Finally, either type or use the keypad to</p>
<p>enter a number in the count field. The expression that will be entered into your event</p>
<p>is displayed at the top of this window so that you can tell exactly what will be</p>
<p>inserted. To accept this string, click the<b> OK</b> button and the string will be inserted</p>
<p>into the event field.</p>
<p>To enter a count expression manually, the syntax is</p>
<p>count(<i>event</i>)<i> op value</i></p>
<p>where</p>
<p><i>event</i></p>
<p>is the event to count,</p>
<p><i>op</i></p>
<p>is the count operator (one of</p>
<p>==</p>
<p>,</p>
<p>!=</p>
<p>,</p>
<p>&gt;</p>
<p>,</p>
<p>&gt;=</p>
<p>,</p>
<p>&lt;</p>
<p>, or</p>
<p>&lt;=</p>
<p>) and</p>
<p><i>value</i></p>
<p>is the number to compare against. You can type an expression</p>
<p>of this form directly into the event field in the<b> Advanced Event Editor</b> window.</p>
<p><b>Note</b></p>
<p>When using hardware counters to control trace collection, the counter</p>
<p>may count each cycle, rather than each instruction, when the count</p>
<p>expression evaluates to true. This may inflate the count. Please refer to</p>
<p>the manual for your trace hardware.</p>
<p><b>Note</b></p>
<p>For ETM trace, if you are counting accesses to or execution of a single</p>
<p>address with a count, the count is exact. It counts the number of times</p>
<p>the address was accessed or executed. If you are counting accesses to or</p>
<p>execution within an address range or a symbol, the count is sticky. It</p>
<p>counts the number of cycles between access or execution of an address</p>
<p>in the range and access or execution of an address outside the range. For</p>
<p>practical purposes, this means that using a count with an address range</p>
<p>is unlikely to yield the desired results.</p>
<p><b>State Machine Expressions</b></p>
<p>You can also insert State Machine resources into the event field any time that another</p>
<p>resource can be used. To insert a State Machine resource, click the<b> state()</b> button.</p>
<p>The<b> State Expression Generator</b> dialog will appear. This dialog allows you to</p>
<p>select the state that is the active state in a state machine. A State Machine resource</p>
<p>evaluates to true when it is in the active state defined by a state expression.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>506</i></p>
<p><i>Chapter 20. Advanced Trace Configuration</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To create a state expression, select the State Machine to insert. Then select whether</p>
<p>you want the event to be active when you are in a given state or when you are not</p>
<p>in a given state by selecting</p>
<p>==</p>
<p>or</p>
<p>!=</p>
<p>. Finally, select the desired state from the</p>
<p><b>States</b> list. The<b> State Expression Generator</b> displays the string that will be inserted</p>
<p>into the event field in the<b> State Condition</b> field.</p>
<p>To enter a State Expression manually, the syntax is</p>
<p>state(&lt;machine&gt;) &lt;op&gt;</p>
<p>&lt;state&gt;</p>
<p>where</p>
<p>&lt;machine&gt;</p>
<p>is the name of the State Machine resource,</p>
<p>&lt;op&gt;</p>
<p>is</p>
<p>the operator (either</p>
<p>==</p>
<p>or</p>
<p>!=</p>
<p>) and</p>
<p>&lt;state&gt;</p>
<p>is the name of the active state.</p>
<p><i>507</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Editing Complex Events</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Part V</b></p>
<p><b>Advanced Debugging in</b></p>
<p><b>Specific Environments</b></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 21</b></p>
<p><b>Testing Target Memory</b></p>
<p><b>Contents</b></p>
<p>Quick Memory Testing: Using the Memory Test Wizard . . . . . . . . . . . . . . . . .</p>
<p>512</p>
<p>Advanced Memory Testing: Using the Perform Memory Test Window . . . .</p>
<p>515</p>
<p>Viewing Memory Test Results . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>523</p>
<p>Continuous Memory Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>524</p>
<p>Memory Testing with a Target Agent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>524</p>
<p>Types of Memory Tests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>525</p>
<p>Efficient Testing Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>535</p>
<p>Running Memory Tests from the Command Line . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>535</p>
<p>Detecting Coherency Errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>536</p>
<h1 style="page-break-before:always; "></h1>
<p>MULTI allows you to perform a number of destructive and nondestructive tests on</p>
<p>your target's memory. Destructive tests overwrite the contents of memory in the</p>
<p>test region. Two graphical tools, the<b> Memory Test Wizard</b> and the<b> Perform</b></p>
<p><b>Memory Test</b> window, provide a simple way to configure and perform memory</p>
<p>tests.</p>
<p>Additionally, MULTI offers manual and optional automatic methods for checking</p>
<p>coherency between target memory and an original executable program file. These</p>
<p>tools and available types of memory testing are described in this chapter.</p>
<p><b>Note</b></p>
<p>You can perform all memory tests by issuing the<b> memtest</b> command in</p>
<p>the Debugger command pane. However, the<b> Perform Memory Test</b></p>
<p>window provides a simpler way to control all of the same behaviors and</p>
<p>parameters that you can configure with the more complicated<b> memtest</b></p>
<p>command. For the complete syntax of the<b> memtest</b> command, see</p>
<p>âGeneral Memory Commandsâ in Chapter 10, âMemory Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>We recommend that you run your target's setup script before testing</p>
<p>memory. Memory testing generally requires that your target be in a good</p>
<p>state; for example, your target's memory controller should be initialized.</p>
<p>If accessing memory via your target connection (for example, Green Hills</p>
<p>Probe) does not work, memory testing via the Debugger will not work.</p>
<p>In order to test memory using a target agent, you must also be able to</p>
<p>download a program (the target agent) onto your target and run it.</p>
<p><b>Quick Memory Testing: Using the Memory Test Wizard</b></p>
<p>The<b> Memory Test Wizard</b> allows you to configure and launch the most common</p>
<p>memory tests quickly. If you want to set options or run tests other than those listed</p>
<p>on the<b> Memory Test Wizard</b>, click<b> Advanced</b> to open the<b> Perform Memory Test</b></p>
<p>window. For more information, see âAdvanced Memory Testing: Using the Perform</p>
<p>Memory Test Windowâ on page 515.</p>
<p>To launch the<b> Memory Test Wizard</b>, connect to your target, and select<b> Target</b> â</p>
<p><b>Memory Test</b> from the Debugger.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>512</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>A sample<b> Memory Test Wizard</b> is shown next.</p>
<p>This window allows you to set the basic parameters for your memory test (i.e., the</p>
<p>start address and end address of the area of memory to be tested, and the access size</p>
<p>to be used while performing the test) and quickly launch one of three common test</p>
<p>combinations.</p>
<p>To configure your memory test from the<b> Memory Test Wizard</b>, first use the fields</p>
<p>described next to define the memory area and access size for the test.</p>
<p>Defines the lowest address to test.</p>
<p>Enter a valid address in this field. The<b> Memory Test Wizard</b></p>
<p>interprets the value as a signed 32-bit integer, so you may only enter</p>
<p>addresses between</p>
<p>0</p>
<p>and</p>
<p>0x7fffffff</p>
<p>. (Note that the<b> memtest</b></p>
<p>command supports addresses up to</p>
<p>0xffffffff</p>
<p>. For information</p>
<p>about the<b> memtest</b> command, see âGeneral Memory Commandsâ in</p>
<p>Chapter 10, âMemory Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.)</p>
<p>This field defaults to</p>
<p>0x00000000</p>
<p>.</p>
<p><b>Start address</b></p>
<p><i>513</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Quick Memory Testing: Using the Memory Test Wizard</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Defines the highest address to test.</p>
<p>Enter a valid address in this field. This address must be greater than</p>
<p>the start address. The<b> Memory Test Wizard</b> interprets the value as</p>
<p>a signed 32-bit integer, so you may only enter addresses between</p>
<p>0</p>
<p>and</p>
<p>0x7fffffff</p>
<p>. (Note that the<b> memtest</b> command supports</p>
<p>addresses up to</p>
<p>0xffffffff</p>
<p>. For information about the<b> memtest</b></p>
<p>command, see âGeneral Memory Commandsâ in Chapter 10,</p>
<p>âMemory Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.)</p>
<p>This field defaults to</p>
<p>0x00000000</p>
<p>.</p>
<p>The end address should be equal to:</p>
<p><i>start_address</i> +<i> size</i> â 1</p>
<p><b>End address</b></p>
<p>Specifies the access size, in bytes, to be used while performing the</p>
<p>memory test. Select 1, 2, or 4. The default is</p>
<p>4</p>
<p>.</p>
<p><b>Access size</b></p>
<p><b>Note</b></p>
<p>Valid values that you enter in the<b> Start address</b>,<b> End address</b>, and<b> Access</b></p>
<p><b>size</b> fields are carried over to the<b> Perform Memory Test</b> window if you</p>
<p>select<b> Advanced</b>.</p>
<p>The<b> Test choice</b> section of the<b> Memory Test Wizard</b> allows you to select one of</p>
<p>the tests or test combinations listed in the following table.</p>
<p>Performs the address bus walking test and data bus walking test, with</p>
<p>both walking ones and zeros. When launched with this button, these</p>
<p>tests are performed by the Debugger.</p>
<p>See âAddress Bus Walking Testâ on page 525 and âData Bus Walking</p>
<p>Testâ on page 527 for a full description of these tests.</p>
<p><b>Quick (using</b></p>
<p><b>Debugger)</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>514</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Performs the address bus walking test and data bus walking test, with</p>
<p>both walking ones and zeros, as well as the data pattern test. The</p>
<p>pattern test uses the pseudorandom pattern and the maximize address</p>
<p>bus transition options (see âData Pattern Testâ on page 529 for details).</p>
<p>When launched with this button, these tests are performed using a</p>
<p>target agent. The target agent is not available for all targets. If no</p>
<p>target agent is available for your target environment, this button will</p>
<p>be dimmed. For more information about target agents, see âMemory</p>
<p>Testing with a Target Agentâ on page 524. This test uses the target</p>
<p>agent positioned at the start of the test range.</p>
<p>See âAddress Bus Walking Testâ on page 525, âData Bus Walking</p>
<p>Testâ on page 527, and âData Pattern Testâ on page 529 for a full</p>
<p>description of these tests.</p>
<p><b>Exhaustive (using</b></p>
<p><b>target agent)</b></p>
<p>Performs the memory read test. When launched with this button, this</p>
<p>test is performed by the Debugger.</p>
<p>See âMemory Read Testâ on page 532 for a full description of this</p>
<p>test.</p>
<p><b>Memory read</b></p>
<p><b>(nondestructive)</b></p>
<p>Clicking one of the preceding buttons launches the corresponding memory test(s)</p>
<p>on the target that was selected in the target list when you opened the<b> Memory Test</b></p>
<p><b>Wizard</b>. A<b> Memory Test Results</b> window opens (see âViewing Memory Test</p>
<p>Resultsâ on page 523) and remains open after the test completes or is aborted.</p>
<p><b>Note</b></p>
<p>To abort memory testing, press the<b> Esc</b> key.</p>
<p><b>Advanced Memory Testing: Using the Perform Memory Test</b></p>
<p><b>Window</b></p>
<p>The<b> Perform Memory Test</b> window provides more options and control for</p>
<p>configuring memory tests than the<b> Memory Test Wizard</b>.</p>
<p>To open the<b> Perform Memory Test</b> window:</p>
<p>1.</p>
<p>Connect to your target.</p>
<p>2.</p>
<p>Select<b> Target</b> â<b> Memory Test</b> from the Debugger window.</p>
<p>3.</p>
<p>Click<b> Advanced</b> in the<b> Memory Test Wizard</b> that appears.</p>
<p><i>515</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Advanced Memory Testing: Using the Perform Memory Test Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>A sample<b> Perform Memory Test</b> window is pictured below. Valid values specified</p>
<p>in the<b> Memory Test Wizard</b> are carried over to the<b> Perform Memory Test</b> window.</p>
<p>This window allows you to specify the area of memory to be tested, the type of</p>
<p>memory tests to be performed, and various options about how those tests are</p>
<p>performed. The following sections explain how to configure all of these settings.</p>
<p><b>Defining Memory Areas to Test</b></p>
<p>The fields at the top section of the<b> Perform Memory Test</b> allow you to define the</p>
<p>memory area and access size for your memory test.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>516</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>These fields are described in the following table.</p>
<p><b>Note</b></p>
<p>Three of these fields are identical to fields in the<b> Memory Test Wizard</b>.</p>
<p>Any valid values you may have input in these fields in the wizard are</p>
<p>carried over to the<b> Perform Memory Test</b> window.</p>
<p>Defines the lowest address to test.</p>
<p>Enter a valid address in this field. The<b> Memory Test Wizard</b></p>
<p>interprets the value as a signed 32-bit integer, so you may only enter</p>
<p>addresses between</p>
<p>0</p>
<p>and</p>
<p>0x7fffffff</p>
<p>. (Note that the<b> memtest</b></p>
<p>command supports addresses up to</p>
<p>0xffffffff</p>
<p>. For information</p>
<p>about the<b> memtest</b> command, see âGeneral Memory Commandsâ in</p>
<p>Chapter 10, âMemory Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.)</p>
<p>This field defaults to</p>
<p>0x00000000</p>
<p>, or to the value entered in the</p>
<p><b>Memory Test Wizard</b>, if any.</p>
<p><b>Start address</b></p>
<p>Defines the highest address to test.</p>
<p>Enter a valid address in this field. This address must be greater than</p>
<p>the start address. The<b> Memory Test Wizard</b> interprets the value as</p>
<p>a signed 32-bit integer, so you may only enter addresses between</p>
<p>0</p>
<p>and</p>
<p>0x7fffffff</p>
<p>. (Note that the<b> memtest</b> command supports</p>
<p>addresses up to</p>
<p>0xffffffff</p>
<p>. For information about the<b> memtest</b></p>
<p>command, see âGeneral Memory Commandsâ in Chapter 10,</p>
<p>âMemory Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.)</p>
<p>This field defaults to</p>
<p>0x00000000</p>
<p>, or to the value entered in the</p>
<p><b>Memory Test Wizard</b>, if any.</p>
<p>The end address should be equal to:</p>
<p><i>start_address</i> +<i> size</i> â 1</p>
<p><b>End address</b></p>
<p><i>517</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Defining Memory Areas to Test</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Displays the total size of the area of memory to be tested. This field</p>
<p>is provided for your information; the memory test itself uses the</p>
<p>specified<b> Start address</b> and<b> End address</b> values.</p>
<p>Click the<b> Size (bytes)</b> button if you want to calculate or recalculate</p>
<p>the size after changing the<b> Start address</b> or<b> End address</b>.</p>
<p><b>Size (bytes)</b></p>
<p>Specifies the access size, in bytes, to be used while performing the</p>
<p>memory test. Select 1, 2, or 4.</p>
<p>This setting defaults to</p>
<p>4</p>
<p>, or to the choice entered in the<b> Memory</b></p>
<p><b>Test Wizard</b>, if any.</p>
<p><b>Access size</b></p>
<p><b>Selecting Memory Tests</b></p>
<p>The second section of the<b> Perform Memory Test</b> window allows you to select</p>
<p>which memory test(s) to perform.</p>
<p>The test choices include both<i> destructive</i> and<i> nondestructive</i> tests. Destructive tests</p>
<p>overwrite the contents of memory in the test region. You can run more than one</p>
<p>type of destructive test simultaneously, but nondestructive tests must be run</p>
<p>individually. The following table briefly describes the test choices. Each test is</p>
<p>described in more detail in âTypes of Memory Testsâ on page 525.</p>
<p>Selects the address bus walking test.</p>
<p>This destructive memory test verifies that address lines are not stuck</p>
<p>at one or zero and are not tied together. For more details about this</p>
<p>test, see âAddress Bus Walking Testâ on page 525.</p>
<p>This test can be run at the same time as other destructive memory tests.</p>
<p><b>Address walking</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>518</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Selects the data bus walking test.</p>
<p>This destructive memory test verifies that data bus lines are not stuck</p>
<p>at one or zero and are not tied together. For more details about this</p>
<p>test, see âData Bus Walking Testâ on page 527.</p>
<p>This test can be run at the same time as other destructive memory tests.</p>
<p><b>Data walking</b></p>
<p>Determines the walking value for address walking and/or data walking</p>
<p>tests.</p>
<p>Make a selection to specify whether these tests should be performed</p>
<p>with a walking value that is a single one bit surrounded by zero bits</p>
<p>(<b>One</b>) or a single zero bit surrounded by one bits (<b>Zero</b>), or if walking</p>
<p>tests should be performed twice, once with the walking value<i> one</i> and</p>
<p>once with the walking value<i> zero</i> (<b>Both</b>). The default setting is<b> Both</b>.</p>
<p>This option is only available if you have selected the address walking</p>
<p>and/or data walking test(s).</p>
<p><b>Walking value</b></p>
<p>Selects the data pattern test.</p>
<p>This destructive memory test verifies that all memory addresses in the</p>
<p>range can successfully store values. For more details about this test,</p>
<p>see âData Pattern Testâ on page 529.</p>
<p>This test can be run at the same time as other destructive memory tests.</p>
<p><b>Data pattern</b></p>
<p>Determines what type of modifications will be performed on the data</p>
<p>pattern between iterations when performing a data pattern test.</p>
<p>Select<b> Static</b>,<b> Complement</b>,<b> Rotate</b>,<b> Rotate and Complement</b>, or</p>
<p><b>Pseudorandom</b>. The default is<b> Complement</b>. For more detail about</p>
<p>these options, see âData Pattern Testâ on page 529.</p>
<p>This option is only available if you have selected the data pattern test.</p>
<p><b>Pattern option</b></p>
<p>Specifies the pattern to use when performing a data pattern test. The</p>
<p>default value is</p>
<p>0x55555555</p>
<p>, which is a sequence of alternating binary</p>
<p>zeros and ones.</p>
<p>This option is only available if you have selected the data pattern test.</p>
<p><b>Pattern value</b></p>
<p>Selects the memory read test, which checks that each memory address</p>
<p>obtains the same value when the address is read twice.</p>
<p>For more details about this test, see âMemory Read Testâ on page 532.</p>
<p>This test cannot be run at the same time as any other memory tests.</p>
<p><b>Memory read</b></p>
<p><b>(nondestructive)</b></p>
<p>Selects the CRC computation test, which computes a CRC checksum</p>
<p>on a range of memory.</p>
<p>For more details about this test, see âCRC Computeâ on page 532.</p>
<p>This test cannot be run at the same time as any other memory tests.</p>
<p><b>CRC computation</b></p>
<p><b>(nondestructive)</b></p>
<p><i>519</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Selecting Memory Tests</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Selects the CRC compare test, which repeatedly computes CRC</p>
<p>checksums for a range of memory, in order to verify that memory can</p>
<p>be read reliably.</p>
<p>For more details about this test, see âCRC Compareâ on page 533.</p>
<p>This test cannot be run at the same time as any other memory tests.</p>
<p><b>CRC compare</b></p>
<p><b>(nondestructive)</b></p>
<p>Selects the find start/end ranges test, which locates possibly unused</p>
<p>memory at the start and end of the range being tested.</p>
<p>For more details about this test, see âFind Start/End Rangesâ</p>
<p>on page 533.</p>
<p>This test cannot be run at the same time as any other memory tests.</p>
<p><b>Find start/end ranges</b></p>
<p><b>(nondestructive)</b></p>
<p><b>Setting Test Options</b></p>
<p>The third section of the<b> Perform Memory Test</b> window allows you to choose</p>
<p>options that will apply to the tests you have selected. (Options that do not apply to</p>
<p>the tests you have selected are dimmed.)</p>
<p>The available options and their effects are listed in the following table. Not all</p>
<p>options are available with all tests.</p>
<p>Uses a sequence of addresses in the data pattern test or memory read</p>
<p>test that maximizes the address line transitions between accesses.</p>
<p>If this option is not selected, the default behavior accesses memory</p>
<p>sequentially from low addresses to high addresses.</p>
<p>When this option is selected, the sequence of memory accesses would</p>
<p>begin</p>
<p>start</p>
<p>,</p>
<p>end</p>
<p>,</p>
<p>start+1</p>
<p>,</p>
<p>end-1</p>
<p>, and so on; assuming that</p>
<p>start</p>
<p>and</p>
<p>end</p>
<p>define a power of two sized and aligned region and the access</p>
<p>size is one byte. If</p>
<p>start</p>
<p>and</p>
<p>end</p>
<p>do not define a power of two sized</p>
<p>and aligned range, the range is split into sequential power of two sized</p>
<p>and aligned ranges for the purposes of this test.</p>
<p><b>Maximize address</b></p>
<p><b>bus transitions</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>520</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Executes the selected tests on every iteration rather than attempting</p>
<p>to use different starting pattern values on successive test iterations.</p>
<p>This option is only valid if the<b> Repeat test</b> value is greater than one</p>
<p>or if the<b> Run test continuously</b> option is used. For pattern tests, this</p>
<p>option has no effect if the<b> Pattern option</b> is<b> Static</b>.</p>
<p><b>Reset pattern value</b></p>
<p><b>between iterations</b></p>
<p>Repeats memory test(s) the indicated number of times. If unspecified,</p>
<p>the test(s) will be performed only once.</p>
<p><b>Repeat test</b></p>
<p>Repeats memory test(s) continuously.</p>
<p><b>Run test continuously</b></p>
<p>Aborts memory test(s) after detecting the specified number of errors.</p>
<p>This value must be between 1 and 1000. If unspecified, MULTI will</p>
<p>abort the test after 10 errors.</p>
<p><b>Max. errors</b></p>
<p>Skips the reading phase of the address bus walking, data bus walking,</p>
<p>and/or data pattern tests. Since no reading is performed, no errors can</p>
<p>be reported.</p>
<p><b>Write-only test (no</b></p>
<p><b>errors)</b></p>
<p><b>Specifying Test Methods</b></p>
<p>This last section of the<b> Perform Memory Test</b> window allows you to choose</p>
<p>whether tests will be performed by the Debugger reading and writing memory</p>
<p>directly, or by MULTI downloading a small target agent program that will perform</p>
<p>the memory accesses. (See âMemory Testing with a Target Agentâ on page 524 for</p>
<p>more details about using a target agent.)</p>
<p>The options available in this section and their effects are described in the table</p>
<p>below.</p>
<p>Specifies that the Debugger should perform the test or tests directly.</p>
<p><b>Debugger</b></p>
<p>Specifies that a target agent should be used to perform the test or tests.</p>
<p>For more information, see âMemory Testing with a Target Agentâ</p>
<p>on page 524.</p>
<p><b>Target agent</b></p>
<p><i>521</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Specifying Test Methods</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Specifies where the target agent is downloaded. Select<b> Start of test</b></p>
<p><b>range</b> or<b> End of test range</b>, or specify another location by entering it</p>
<p>in the field, replacing the<b> &lt;specify location&gt;</b> choice. The default is to</p>
<p>download the target agent at the start of the address range being tested.</p>
<p>For more details, see âMemory Testing with a Target Agentâ</p>
<p>on page 524.</p>
<p><b>Agent location</b></p>
<p><b>Running Memory Tests</b></p>
<p>After you have specified the memory range to be tested, the access size, the test(s)</p>
<p>to perform, your test options, and your desired test method in the<b> Perform Memory</b></p>
<p><b>Test</b> window, as described in the previous sections, click the<b> Test memory</b> button</p>
<p>to run the selected test(s). The test(s) run on the target that was selected in the target</p>
<p>list when you opened the<b> Memory Test Wizard</b>.</p>
<p>A<b> Memory Test Results</b> window is displayed and shows the test progress and</p>
<p>results. For more information, see âViewing Memory Test Resultsâ on page 523.</p>
<p>This window remains open after the test completes or is aborted.</p>
<p><b>Note</b></p>
<p>To abort memory testing, press the<b> Esc</b> key.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>522</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Memory Test Results</b></p>
<p>After you launch one or more memory tests using the<b> Memory Test Wizard</b> or the</p>
<p><b>Perform Memory Test</b> window, a<b> Memory Test Results</b> window will appear.</p>
<p>The<b> Memory Test Results</b> window will contain the following information:</p>
<p>â¢</p>
<p>A<b> memtest</b> command that is equivalent to the various tests and options selected</p>
<p>in the<b> Memory Test Wizard</b> or<b> Perform Memory Test</b> window. (This is</p>
<p>provided to make it easier to write MULTI Debugger scripts that can</p>
<p>automatically perform memory tests.) For information about the<b> memtest</b></p>
<p>command, see âGeneral Memory Commandsâ in Chapter 10, âMemory</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>The printed output of the command, including any memory test errors. (This</p>
<p>appears below the line of dashes.)</p>
<p>â¢</p>
<p>A test progress indicator.</p>
<p>â¢</p>
<p>A status bar, which displays messages about the success or failure of the test(s).</p>
<p><i>523</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Viewing Memory Test Results</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Continuous Memory Testing</b></p>
<p>Continuous memory testing can be helpful when you are debugging hardware</p>
<p>problems with a logic analyzer or other diagnostic equipment. To perform continuous</p>
<p>testing, select the<b> Run test continuously</b> option in the<b> Perform Memory Test</b></p>
<p>window, or pass the<b> -continuous</b> option to the<b> memtest</b> command. To terminate</p>
<p>the test after a specific number of errors, enter the number of errors in the<b> Max.</b></p>
<p><b>errors</b> field, or pass the<b> -maxerr=<i>number_of_errors</b></i> option to the<b> memtest</b></p>
<p>command. For information about the<b> memtest</b> command, see âGeneral Memory</p>
<p>Commandsâ in Chapter 10, âMemory Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>To terminate a continuous test manually, press<b> Esc</b>.</p>
<p><b>Memory Testing with a Target Agent</b></p>
<p>You can perform memory tests using either the Debugger or a small target agent</p>
<p>program. Running memory tests from the Debugger is slower than running the tests</p>
<p>using a target agent, but a target agent requires that the memory be initialized</p>
<p>correctly. To specify which method you want MULTI to use, select either<b> Debugger</b></p>
<p>or<b> Target agent</b> in the bottom section of the<b> Perform Memory Test</b> window (see</p>
<p>âSpecifying Test Methodsâ on page 521).</p>
<p>When using a target agent, you must specify where MULTI should load the target</p>
<p>agent code. To do this, use the<b> Agent location</b> field of the<b> Perform Memory Test</b></p>
<p>window to select one of the following locations for target agent placement:</p>
<p>â¢</p>
<p>Start of test range (This is the default location)</p>
<p>â¢</p>
<p>End of test range</p>
<p>â¢</p>
<p>Specified location outside the test range</p>
<p><b>Note</b></p>
<p>Keep the following restrictions and conditions in mind when specifying</p>
<p>the location of your target agent:</p>
<p>â¢</p>
<p>If you select the start or end of the test range, the test range must be</p>
<p>at least twice as large as the target agent. This allows the complete</p>
<p>range to be tested, by first placing the target agent at the start of the</p>
<p><i>MULTI: Debugging</i></p>
<p><i>524</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>range, and then placing the target agent at the end of the range. (The</p>
<p>target agent requires an estimated 10â20 KB of memory for its code</p>
<p>and data. However this varies by target CPU architecture and is</p>
<p>subject to change.)</p>
<p>â¢</p>
<p>The target agent should not be located at the start or end of the test</p>
<p>range for nondestructive tests, or else the target agent will overwrite</p>
<p>that memory.</p>
<p>â¢</p>
<p>If you specify a target agent location other than the start or end of</p>
<p>the test range, it must not overlap the test range.</p>
<p>If you are running memory tests using the<b> memtest</b> command, use the<b> -tgtagent</b></p>
<p>option to specify that memory testing be performed with a target agent. To specify</p>
<p>the location of the target agent code, use one of the following options:</p>
<p>â¢</p>
<p><b>-tgtagentstart</b> â Place target agent at the start of the test range.</p>
<p>â¢</p>
<p><b>-tgtagentend</b> â Place target agent at the end of the test range.</p>
<p>â¢</p>
<p><b>-tgtagentloc=<i>expr</b></i> â Place target agent at the location specified by the</p>
<p>expression</p>
<p><i>expr</i></p>
<p>.</p>
<p>For more information about the<b> memtest</b> command, see âGeneral Memory</p>
<p>Commandsâ in Chapter 10, âMemory Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Types of Memory Tests</b></p>
<p>The sections below describe the different types of memory testing in detail. For</p>
<p>information about launching these tests, see âQuick Memory Testing: Using the</p>
<p>Memory Test Wizardâ on page 512, âAdvanced Memory Testing: Using the Perform</p>
<p>Memory Test Windowâ on page 515, or âRunning Memory Tests from the Command</p>
<p>Lineâ on page 535.</p>
<p><b>Address Bus Walking Test</b></p>
<p>The address bus walking test is a destructive memory test that provides an efficient</p>
<p>way to verify that address lines are not stuck at one or zero and are not tied together.</p>
<p>This test is usually fast enough to be run from the Debugger, so it generally is not</p>
<p><i>525</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Types of Memory Tests</i></p>
<h1 style="page-break-before:always; "></h1>
<p>necessary to use a target agent (see âSpecifying Test Methodsâ on page 521 for</p>
<p>information about these two test methods).</p>
<p>In this test, the range of memory is divided into sequential regions that are sized</p>
<p>and aligned to a power of two. For example, if memory from</p>
<p>0xa00</p>
<p>to</p>
<p>0xffffff</p>
<p>is to be tested, the actual ranges that will be tested are as follows:</p>
<p>0xa00 to 0xbff</p>
<p>0b1010 0000 0000</p>
<p>(512 B)</p>
<p>0b1011 1111 1111</p>
<p>0xc00 to 0xfff</p>
<p>0b1100 0000 0000</p>
<p>(1KB)</p>
<p>0b1111 1111 1111</p>
<p>0x1000 to 0x1fff</p>
<p>0b0001 0000 0000 0000</p>
<p>(2KB)</p>
<p>0b0001 1111 1111 1111</p>
<p>and so on, up to:</p>
<p>0x800000 to 0xffffff</p>
<p>0b1000 0000 0000 0000 0000 0000</p>
<p>(8MB)</p>
<p>0b1111 1111 1111 1111 1111 1111</p>
<p>This test can be performed as a<i> walking one test</i> or a<i> walking zero test</i>, or you can</p>
<p>set it to run twice, testing once for ones and once for zeros. Depending on the</p>
<p>walking value selected (one or zero), a pattern value is written to an address in the</p>
<p>range with a single address bit set to</p>
<p>1</p>
<p>(walking one test) or to</p>
<p>0</p>
<p>(walking zero test).</p>
<p>All other address bits that reference that region are set to the opposite value. The</p>
<p>low bits are cleared, as appropriate for the access size used. The pattern's complement</p>
<p>is written to locations in the test range with a different address bit set (walking one</p>
<p>test) or cleared (walking zero test). The pattern's complement is also written to the</p>
<p>location at the start of the range (walking one test) or the end of the range (walking</p>
<p>zero test). After the complement values are written, the original pattern value that</p>
<p>was written is verified to make sure it has not changed. This is repeated for every</p>
<p>address bit that references the range of memory to be tested.</p>
<p>The default pattern is</p>
<p>0x55555555</p>
<p>,</p>
<p>0x5555</p>
<p>, or</p>
<p>0x55</p>
<p>, depending on the access</p>
<p>size.</p>
<p>For example, using the range</p>
<p>0x0000</p>
<p>to</p>
<p>0xffff</p>
<p>, a walking one test with an access</p>
<p>size of 4 produces a sequence that begins as follows.</p>
<p>Write 0x55555555 to address 0x0004</p>
<p>Write 0xaaaaaaaa to address 0x0008</p>
<p>Write 0xaaaaaaaa to address 0x0010</p>
<p>...</p>
<p>Write 0xaaaaaaaa to address 0x8000</p>
<p><i>MULTI: Debugging</i></p>
<p><i>526</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Write 0xaaaaaaaa to address 0x0000</p>
<p>Read from address 0x0004 and verify that the value is 0x55555555.</p>
<p>Write 0x55555555 to address 0x0008</p>
<p>Write 0xaaaaaaaa to address 0x0004</p>
<p>Write 0xaaaaaaaa to address 0x0010</p>
<p>...</p>
<p>Read from address 0x0008 and verify that the value is 0x55555555.</p>
<p>...</p>
<p>Write 0x55555555 to address 0x0000</p>
<p>Write 0xaaaaaaaa to address 0x0004</p>
<p>Write 0xaaaaaaaa to address 0x0008</p>
<p>...</p>
<p>Read from address 0x0000 and verify that the value is 0x55555555.</p>
<p>To run this test from the<b> Perform Memory Test</b> window, select the<b> Address</b></p>
<p><b>walking</b> radio button, then select a<b> Walking value</b> (<b>One</b>,<b> Zero</b>, or<b> Both</b>). See</p>
<p>âAdvanced Memory Testing: Using the Perform Memory Test Windowâ on page 515.</p>
<p>This test is also run twice, once with walking ones and once with walking zeros, if</p>
<p>you select the<b> Quick</b> or<b> Exhaustive</b> buttons on the<b> Memory Test Wizard</b>. See</p>
<p>âQuick Memory Testing: Using the Memory Test Wizardâ on page 512.</p>
<p>To run this test using the<b> memtest</b> command, use the<b> -test=a0</b> option (for a walking</p>
<p>zero test) and/or the<b> -test=a1</b> options (for a walking one test). See the description</p>
<p>of the<b> memtest</b> command in âGeneral Memory Commandsâ in Chapter 10, âMemory</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Data Bus Walking Test</b></p>
<p>The data bus walking test is a destructive memory test that provides a way to verify</p>
<p>that data bus lines are not stuck at one or zero and are not tied together. This test is</p>
<p>usually fast enough to be run from the Debugger, so it generally is not necessary</p>
<p>to use a target agent (see âSpecifying Test Methodsâ on page 521 for more</p>
<p>information about these different approaches).</p>
<p>This test can be performed as a<i> walking one test</i> or a<i> walking zero test</i>, or you can</p>
<p>set it to run twice, testing once for ones and once for zeros. Depending on the</p>
<p>walking value selected (one or zero), successive values containing either a single</p>
<p>one bit (walking one test) or a single zero bit (walking zero test) are written to</p>
<p>successive memory locations and then read back. Only the first 8, 32, or 128 bytes</p>
<p>of memory in the range are modified by this test, depending on the access size</p>
<p>specified.</p>
<p><i>527</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Bus Walking Test</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For example, using the range</p>
<p>0x0000</p>
<p>to</p>
<p>0xffff</p>
<p>, a data walking one test with an</p>
<p>access size of 4 produces a sequence that begins as follows:</p>
<p>Write 0x00000001 to address 0x0000</p>
<p>Write 0x00000002 to address 0x0004</p>
<p>Write 0x00000004 to address 0x0008</p>
<p>...</p>
<p>Write 0x80000000 to address 0x007c</p>
<p>Read from address 0x0000 and verify that the data value</p>
<p>is 0x00000001</p>
<p>Read from all other addresses written and verify that the</p>
<p>value is as expected.</p>
<p>You can specify a repeat count, which will rotate the initial data pattern at the start</p>
<p>of each test. Using the same options utilized in the previous example, a repeat count</p>
<p>will produce a sequence that begins with the following:</p>
<p>Iteration 1:</p>
<p>Write 0x00000001 to address 0x0000</p>
<p>...</p>
<p>Iteration 2:</p>
<p>Write 0x00000002 to address 0x0000</p>
<p>...</p>
<p>Iteration 3:</p>
<p>Write 0x00000004 to address 0x0000</p>
<p>...</p>
<p>If the memory range is not large enough to write all distinct values, the test will</p>
<p>write some of the walking data values, read them back to verify that the value is</p>
<p>what is expected, then start from the beginning of the memory range and write more</p>
<p>of the walking data values.</p>
<p>To run this test from the<b> Perform Memory Test</b> window, select the<b> Data walking</b></p>
<p>radio button, then select a<b> Walking value</b> (<b>One</b>,<b> Zero</b>, or<b> Both</b>). See âAdvanced</p>
<p>Memory Testing: Using the Perform Memory Test Windowâ on page 515.</p>
<p>This test is also run twice, once with walking ones and once with walking zeros, if</p>
<p>you select the<b> Quick</b> or<b> Exhaustive</b> buttons on the<b> Memory Test Wizard</b>. See</p>
<p>âQuick Memory Testing: Using the Memory Test Wizardâ on page 512.</p>
<p>To run this test using the<b> memtest</b> command, use the<b> -test=d0</b> option (for a walking</p>
<p>zero test) and/or the<b> -test=d1</b> options (for a walking one test). See the description</p>
<p>of the<b> memtest</b> command in âGeneral Memory Commandsâ in Chapter 10, âMemory</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>528</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Data Pattern Test</b></p>
<p>The data pattern test is a destructive memory test that provides a way to</p>
<p>comprehensively test that all memory addresses in the range can successfully store</p>
<p>values. This test can help diagnose ground bounce and voltage problems in the</p>
<p>memory range.</p>
<p>The data pattern test writes a specified pattern to successive memory locations. The</p>
<p>same pattern value can be written to all locations, or you can specify that certain</p>
<p>modifications be made between iterations. The options for how the pattern is handled</p>
<p>are listed in the table below.</p>
<p><b>Effect</b></p>
<p><b>Pattern option</b></p>
<p>Writes the same value to all locations.</p>
<p><b>Static</b></p>
<p>The specified pattern is complemented after each write.</p>
<p>You can use this option to generate a large number of address</p>
<p>and data bus transitions on successive memory accesses.</p>
<p>For example, if the range</p>
<p>0x0000</p>
<p>to</p>
<p>0xffff</p>
<p>is tested with the</p>
<p>pattern</p>
<p>0x01234567</p>
<p>, an access size of 4, and the pattern is</p>
<p>complemented, the test sequence for the pattern test would be:</p>
<p>Write 0x01234567 to address 0x0000</p>
<p>Write 0xfedcba98 to address 0x0004</p>
<p>Write 0x01234567 to address 0x0008</p>
<p>...</p>
<p>Read from all addresses written and verify</p>
<p>that the value is as written.</p>
<p><b>Complement</b></p>
<p>The specified pattern is rotated each time it is written. The</p>
<p>previous pattern value is shifted one bit position to the left and</p>
<p>the most significant bit of the previous pattern value is copied to</p>
<p>the least significant bit position of the next pattern value.</p>
<p><b>Rotate</b></p>
<p><i>529</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Pattern Test</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Pattern option</b></p>
<p>The specified pattern is rotated after its value and its complement</p>
<p>are written.</p>
<p>For example, if the range</p>
<p>0x0000</p>
<p>to</p>
<p>0xffff</p>
<p>is tested with the</p>
<p>pattern</p>
<p>0x01234567</p>
<p>, an access size of 4, and the pattern is rotated</p>
<p>and complemented, the test sequence for the pattern test would</p>
<p>be:</p>
<p>Write 0x01234567 to address 0x0000</p>
<p>Write 0xfedcba98 to address 0x0004</p>
<p>Write 0x02468ace to address 0x0008</p>
<p>Write 0xfdb97531 to address 0x000c</p>
<p>...</p>
<p>Read from all addresses written and verify</p>
<p>that the value is the same as was written.</p>
<p><b>Rotate and Complement</b></p>
<p>The specified value is fed through a linear feedback shift register</p>
<p>(LFSR) that generates a sequence of</p>
<p>2^n-1</p>
<p>values.</p>
<p>If this method is selected, the next value in a sequence is generated</p>
<p>as follows (bit positions are indicated with bit</p>
<p>0</p>
<p>as the least</p>
<p>significant bit):</p>
<p>1.</p>
<p>Compute a new bit</p>
<p>0</p>
<p>value by performing the exclusive-or</p>
<p>of four bits in the current value. Bit positions in this</p>
<p>description are numbered starting with the least significant</p>
<p>bit.</p>
<p>2.</p>
<p>Shift the current value left by one.</p>
<p>3.</p>
<p>Insert the computed bit</p>
<p>0</p>
<p>value in the new value.</p>
<p>The four bit positions vary according to access size, as follows:</p>
<p>â¢</p>
<p>If the access size is 8, the bit positions are 3, 4, 5, and 7.</p>
<p>â¢</p>
<p>If the access size is 16, the bit positions are 3, 12, 14, and</p>
<p>15.</p>
<p>â¢</p>
<p>If the access size is 32, the bit positions are 0, 1, 21, and 31.</p>
<p>The data pattern consisting of all zeros is not permitted, since the</p>
<p>LFSR will always generate a zero in that case.</p>
<p><b>Pseudorandom</b></p>
<p><b>Note</b></p>
<p>You can use the<b> Maximize address bus transitions</b> option in the</p>
<p><b>Perform Memory Test</b> window or the<b> -maxtransitions</b> option with the</p>
<p><b>memtest</b> command to cause MULTI to use a sequence of addresses for</p>
<p>this test that maximizes the address line transitions between accesses. If</p>
<p><i>MULTI: Debugging</i></p>
<p><i>530</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>this option is not specified, the default behavior is to access memory</p>
<p>sequentially from low to high addresses. When this option is selected,</p>
<p>the sequence of memory accesses would begin</p>
<p>start</p>
<p>,</p>
<p>end</p>
<p>,</p>
<p>start+1</p>
<p>,</p>
<p>end-1</p>
<p>, and so on; assuming that</p>
<p>start</p>
<p>and</p>
<p>end</p>
<p>define a power of two</p>
<p>sized and aligned region and the access size is one byte. If</p>
<p>start</p>
<p>and</p>
<p>end</p>
<p>do not define a power of two sized and aligned range, the range is</p>
<p>split into sequential power of two sized and aligned ranges for the</p>
<p>purposes of this test. For information about the<b> memtest</b> command, see</p>
<p>âGeneral Memory Commandsâ in Chapter 10, âMemory Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>To run this test from the<b> Perform Memory Test</b> window, select the<b> Data pattern</b></p>
<p>radio button, then select a<b> Pattern option</b> (<b>Static</b>,<b> Complement</b>,<b> Rotate</b>,<b> Rotate</b></p>
<p><b>and Complement</b>, or<b> Pseudorandom</b>) and specify a<b> Pattern value</b>. See âAdvanced</p>
<p>Memory Testing: Using the Perform Memory Test Windowâ on page 515.</p>
<p>This test is also run, using a target agent, the pseudorandom pattern option, and the</p>
<p><b>Maximize address bus transitions</b> option, if you select the<b> Exhaustive</b> button on</p>
<p>the<b> Memory Test Wizard</b>. See âQuick Memory Testing: Using the Memory Test</p>
<p>Wizardâ on page 512.</p>
<p>To run this test using the<b> memtest</b> command, use the<b> -test=p</b> option and specify</p>
<p>the pattern with the<b> -pattern=<i>value</b></i> option. To specify the pattern behavior, use the</p>
<p>following options:</p>
<p>â¢</p>
<p><b>-complement</b> â To complement the data pattern value between memory writes.</p>
<p>â¢</p>
<p><b>-rotate</b> â To rotate the data pattern for the pattern test between writes.</p>
<p>â¢</p>
<p><b>-random</b> â To use a pseudorandom sequence of values for the pattern test.</p>
<p>You can pass the<b> -complement</b> and<b> -rotate</b> options together. See âGeneral Memory</p>
<p>Commandsâ in Chapter 10, âMemory Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><i>531</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Pattern Test</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Memory Read Test</b></p>
<p>The memory read test is a nondestructive memory test that verifies that each memory</p>
<p>address retains the same value when the address is read twice.</p>
<p>This test reads memory from successive memory locations. After reading each</p>
<p>address for the first time, the test reads back the value from the prior address and</p>
<p>verifies that the values are identical.</p>
<p>This test does not destroy the memory in the range. For example, to test the range</p>
<p>0x0000</p>
<p>to</p>
<p>0xffff</p>
<p>with an access size of 4, the test sequence begins:</p>
<p>Read from address 0x0000</p>
<p>Read from address 0x0004</p>
<p>Check: Read from address 0x0000 and verify that the value</p>
<p>matches the earlier read.</p>
<p>Read from address 0x0008</p>
<p>Check: Read from address 0x0004 and verify that the value</p>
<p>matches the earlier read.</p>
<p>...</p>
<p>To run this test from the<b> Perform Memory Test</b> window, select the<b> Memory read</b></p>
<p><b>(nondestructive)</b> radio button. See âAdvanced Memory Testing: Using the Perform</p>
<p>Memory Test Windowâ on page 515.</p>
<p>This test is also run if you select the<b> Memory read (nondestructive)</b> buttons on</p>
<p>the<b> Memory Test Wizard</b>. See âQuick Memory Testing: Using the Memory Test</p>
<p>Wizardâ on page 512.</p>
<p>To run this test using the<b> memtest</b> command, use the<b> -test=r</b> option. See âGeneral</p>
<p>Memory Commandsâ in Chapter 10, âMemory Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>CRC Compute</b></p>
<p>CRC compute provides a way to compute a CRC checksum on a range of memory.</p>
<p>This nondestructive test reads bytes from successive memory locations and computes</p>
<p>a CRC checksum from the result. The algorithm used is a standard 32-bit CRC and</p>
<p>matches the algorithm used by default in the Green Hills Software linker's</p>
<p><b>-checksum</b> option.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>532</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To run this test from the<b> Perform Memory Test</b> window, select the<b> CRC</b></p>
<p><b>computation (nondestructive)</b> radio button. See âAdvanced Memory Testing:</p>
<p>Using the Perform Memory Test Windowâ on page 515.</p>
<p>To run this test using the<b> memtest</b> command, use the<b> -test=cr</b> option. See âGeneral</p>
<p>Memory Commandsâ in Chapter 10, âMemory Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>CRC Compare</b></p>
<p>CRC compare provides a way to repeatedly compute a CRC checksum for a range</p>
<p>of memory, in order to verify that memory can be read reliably. This nondestructive</p>
<p>test reads bytes from successive memory locations and computes a CRC checksum</p>
<p>from the result. It then recomputes the CRC checksum and verifies that the</p>
<p>recomputed checksum matches the original computed value. You can specify how</p>
<p>many times the test should be repeated. If the checksum does not match, an error</p>
<p>is printed and the most recent checksum value is used from that point on for any</p>
<p>further verify iterations.</p>
<p>The algorithm used is a standard 32-bit CRC and matches the algorithm used by</p>
<p>default in the Green Hills Software linker's<b> -checksum</b> option.</p>
<p>To run this test from the<b> Perform Memory Test</b> window, select the<b> CRC compare</b></p>
<p><b>(nondestructive)</b> radio button. To run the test repeatedly, also select the<b> Repeat</b></p>
<p><b>test</b> radio button and specify the number of times the test should run. See âAdvanced</p>
<p>Memory Testing: Using the Perform Memory Test Windowâ on page 515.</p>
<p>To run this test using the<b> memtest</b> command, use the<b> -test=cc</b> option. To cause the</p>
<p>CRC compare to run more than once, use<b> -repeat=<i>number_of_tests</b></i> to specify the</p>
<p>number of times the operation will be performed. See âGeneral Memory Commandsâ</p>
<p>in Chapter 10, âMemory Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Find Start/End Ranges</b></p>
<p>The find start/end ranges test is a nondestructive test used to discover possibly</p>
<p>unused memory at the start and end of the specified range. Sequences of identical</p>
<p>values of the specified access size at the start or end of the specified range, if present,</p>
<p>are reported as possibly unused memory.</p>
<p><i>533</i></p>
<p><i>Green Hills Software</i></p>
<p><i>CRC Compare</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>The term<i> range</i> is used in different ways in this test. The<i> specified range</i></p>
<p>represents the entire area of memory to be examined and is an input to</p>
<p>this test. The<i> start range</i> and<i> end range</i>, if present, are subranges of the</p>
<p>specified range and are the outputs of this test.</p>
<p>This test consists of two parts. First, the test reads memory locations sequentially</p>
<p>from the start of the specified range. If multiple consecutive memory locations</p>
<p>contain the same value, those consecutive, identical memory locations are reported</p>
<p>as a potentially unused memory range. When the test reads the first memory location</p>
<p>that contains a value different from all the earlier values, the first part of the test</p>
<p>stops. The second part of the test is similar to the first part of the test, except that</p>
<p>memory locations are read sequentially from the end of the specified range toward</p>
<p>the start of the specified range. The output indicates the extent of identical memory</p>
<p>values at the start and end of the provided range. (If the entire specified range</p>
<p>contains the same value, the test will only report a single range equal to the specified</p>
<p>range.)</p>
<p>For example, if the range</p>
<p>0x0000</p>
<p>to</p>
<p>0xffff</p>
<p>is tested with an access size of 4, the</p>
<p>test output might be something like:</p>
<p>Start range: 0x00000000</p>
<p>to: 0x000000ff</p>
<p>value: 0x00000000</p>
<p>End range: 0x0000ba4c</p>
<p>to: 0x0000ffff</p>
<p>value: 0xffffffff</p>
<p>This output indicates that the first</p>
<p>0x100</p>
<p>bytes of the range contain the 4-byte value</p>
<p>0x00000000</p>
<p>. This output also implies that the next memory location contains a</p>
<p>value other than</p>
<p>0x00000000</p>
<p>. The final</p>
<p>0x45b4</p>
<p>bytes of the specified range</p>
<p>(</p>
<p>0xba4c-0xffff</p>
<p>) contain the 4-byte value</p>
<p>0xffffffff</p>
<p>. This output also implies</p>
<p>that the location</p>
<p>0xba48</p>
<p>contains a value other than</p>
<p>0xffffffff</p>
<p>.</p>
<p>To run this test from the<b> Perform Memory Test</b> window, select the<b> Find start/end</b></p>
<p><b>ranges (nondestructive)</b> radio button. See âAdvanced Memory Testing: Using the</p>
<p>Perform Memory Test Windowâ on page 515.</p>
<p>To run this test using the<b> memtest</b> command, use the<b> -test=fr</b> option. See âGeneral</p>
<p>Memory Commandsâ in Chapter 10, âMemory Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>534</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Efficient Testing Methods</b></p>
<p>MULTI provides a wide variety of memory testing options ranging from simple to</p>
<p>complex. You may want to devise a testing scheme to reap the most benefit from</p>
<p>the various testing options. For instance, you might first use Debugger-based tests</p>
<p>to verify that memory is initialized correctly and that there are no problems with</p>
<p>data or address lines, and then move on to running tests using a target agent, in</p>
<p>order to obtain broader testing coverage. A sample testing sequence using this model</p>
<p>might be:</p>
<p>1.</p>
<p>Perform one or more address and/or data walking tests from the Debugger.</p>
<p>2.</p>
<p>Perform one or more pattern tests over a small area of memory from the</p>
<p>Debugger.</p>
<p>3.</p>
<p>Perform one or more of the other tests using the target agent across the entire</p>
<p>range of memory.</p>
<p><b>Running Memory Tests from the Command Line</b></p>
<p>Memory testing can be performed using the<b> memtest</b> command. However, due to</p>
<p>the vast array of test types and options, the syntax for this command can be quite</p>
<p>complex. For this reason, we recommend that you use the<b> Memory Test Wizard</b></p>
<p>or the<b> Perform Memory Test</b> window to configure and run memory tests.</p>
<p><b>Note</b></p>
<p>If you want to write scripts that contain memory testing commands, you</p>
<p>can still use the<b> Memory Test Wizard</b> or the<b> Perform Memory Test</b></p>
<p>window to help you determine the exact command syntax for the specific</p>
<p>test and testing options you want to use. To do this, first use one of these</p>
<p>graphical tools to configure the test you want to run, and then run the</p>
<p>test. When the test completes, the<b> Memory Test Results</b> window will</p>
<p>display the exact command syntax that corresponds to the testing options</p>
<p>you specified in the GUI. You can use the command syntax given there</p>
<p>in the Debugger command pane or in customized scripts.</p>
<p>For information about the<b> memtest</b> command, see âGeneral Memory Commandsâ</p>
<p>in Chapter 10, âMemory Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><i>535</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Efficient Testing Methods</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Detecting Coherency Errors</b></p>
<p>If the contents of memory differ from what you loaded onto your target, a coherency</p>
<p>error may exist. In this context,<i> coherency</i> refers to the byte-value agreement between</p>
<p>memory and the file that you originally loaded. For example, most programs contain</p>
<p>a</p>
<p>.text</p>
<p>section that is not modified. As a result, the byte values of the</p>
<p>.text</p>
<p>section that appears in the executable program file should match the byte values of</p>
<p>the</p>
<p>.text</p>
<p>section that is loaded into memory while the process is running.</p>
<p>Coherency errors may occur as the result of self-modifying code, buffer or stack</p>
<p>overruns, bad memory hardware, or simply the wrong version of code being</p>
<p>debugged. In the worst case scenario, code in memory is only slightly different</p>
<p>from code in the executable program file, making it difficult to detect the</p>
<p>discrepancy. MULTI offers two complementary ways of detecting this problem:</p>
<p>manual coherency checking via the<b> verify</b> command and automatic coherency</p>
<p>checking via a debugging setting. The next two sections describe each of these</p>
<p>coherency checking methods.</p>
<p><b>Note</b></p>
<p>MULTI supports coherency checking with most debug servers. However,</p>
<p>if the<b> Debug</b> â<b> Debug Settings</b> â<b> Auto Check Coherency</b> menu item</p>
<p>is dimmed, most automatic coherency checking is not available in your</p>
<p>current environment.</p>
<p><b>Checking Coherency Manually</b></p>
<p>To manually check the coherency of an address range, enter the following command</p>
<p>in the command pane:</p>
<p><b>verify<i></b> address_expression</i> [<i>num_addresses</i>]</p>
<p>where:</p>
<p>â¢</p>
<p><i>address_expression</i></p>
<p>specifies the address expression at which to begin</p>
<p>coherency checking.</p>
<p>â¢</p>
<p><i>num_addresses</i></p>
<p>specifies the number of addresses to verify past</p>
<p><i>address_expression</i></p>
<p>. If you omit</p>
<p><i>num_addresses</i></p>
<p>, this command verifies</p>
<p>until the end of the function that encloses</p>
<p><i>address_expression</i></p>
<p>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>536</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The Debugger compares the bytes in the specified range of target memory against</p>
<p>the bytes in the content of the executable program file, and prints a list of addresses</p>
<p>where they differ. The Debugger also highlights the lines in the source pane</p>
<p>corresponding to those addresses to warn you that their contents differ.</p>
<p>To manually check the coherency of all downloaded non-data sections that cannot</p>
<p>be written to, enter the<b> verify -all</b> command in the command pane. The</p>
<p>.text</p>
<p>section is one example of a section that you cannot write to. Because certain sections</p>
<p>of memory, such as</p>
<p>.bss</p>
<p>,</p>
<p>.data</p>
<p>, and</p>
<p>.heap</p>
<p>, may be written to during program</p>
<p>execution, you can expect them to differ from the executable program file. When</p>
<p>you specify the<b> -all</b> option, the<b> verify</b> command does not check these sections.</p>
<p>However, you can verify them manually by entering<b> verify -section<i> section_name</b></i></p>
<p>in the command pane.</p>
<p>For comprehensive information about the<b> verify</b> command, see Chapter 10, âMemory</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Checking Coherency Automatically</b></p>
<p>When automatic coherency checking is enabled, MULTI checks the coherency of</p>
<p>the specified number of addresses at every stop. If it finds discrepancies, it highlights</p>
<p>the differing lines in the source pane.</p>
<p>To enable automatic coherency checking, do one of the following:</p>
<p>â¢</p>
<p>Select<b> Debug</b> â<b> Debug Settings</b> â<b> Auto Check Coherency</b>.</p>
<p>â¢</p>
<p>Set the</p>
<p>_AUTO_CHECK_COHERENCY</p>
<p>system variable. Set this variable to nonzero</p>
<p>to enable automatic checking; set it to zero to disable automatic checking. See</p>
<p>also the</p>
<p>_AUTO_CHECK_COHERENCY</p>
<p>variable in âSystem Variablesâ on page 310.</p>
<p>MULTI attempts to check an equal number of addresses before and after the current</p>
<p>program counter; however, it does not cross procedure boundaries. For example,</p>
<p>if MULTI is stopped at the first instruction of a procedure, automatic checking</p>
<p>inspects addresses only after the program counter. It continues for the specified</p>
<p>number of addresses.</p>
<p><i>537</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Checking Coherency Automatically</i></p>
<h1 style="page-break-before:always; "></h1>
<p>By default, MULTI checks either 16 addresses or the number of addresses lasting</p>
<p>the length of 4 instructions (whichever is fewer). To change the number of addresses</p>
<p>checked, do one of the following:</p>
<p>â¢</p>
<p>Select<b> Debug</b> â<b> Debug Settings</b> â<b> Number Of Addresses To Check</b>. In</p>
<p>the dialog box that appears, enter the number of addresses you want checked</p>
<p>on each stop.</p>
<p>â¢</p>
<p>Set the</p>
<p>_AUTO_CHECK_NUM_ADDRS</p>
<p>system variable to an appropriate value.</p>
<p>See also the</p>
<p>_AUTO_CHECK_NUM_ADDRS</p>
<p>variable in âSystem Variablesâ</p>
<p>on page 310.</p>
<p><b>Note</b></p>
<p>Because extra memory is read on every stop, use care when setting the</p>
<p>number of addresses to be read. Setting a large number of addresses may</p>
<p>slow normal run control.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>538</i></p>
<p><i>Chapter 21. Testing Target Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 22</b></p>
<p><b>Programming Flash Memory</b></p>
<p><b>Contents</b></p>
<p>The MULTI Fast Flash Programmer Window . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>540</p>
<p>Prerequisites to Working with Flash . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>541</p>
<p>Using the MULTI Fast Flash Programmer . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>541</p>
<p>The MULTI Fast Flash Programmer GUI Reference . . . . . . . . . . . . . . . . . . . .</p>
<p>545</p>
<p>Flash Configuration File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>546</p>
<p>Troubleshooting Flash Memory Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>547</p>
<h1 style="page-break-before:always; "></h1>
<p>MULTI provides a graphical interface that makes it easy to write a memory image</p>
<p>(either unformatted, in ELF format, or in S-Record format) from the host to flash</p>
<p>memory on the target. Because flash memory is non-volatile, writing your program</p>
<p>to flash memory allows it to run when the target is reset. This chapter describes</p>
<p>how to erase, program, and verify flash memory using the<b> MULTI Fast Flash</b></p>
<p><b>Programmer</b>.</p>
<p><b>The MULTI Fast Flash Programmer Window</b></p>
<p>The simplest way to program, verify, or erase flash memory is to use the<b> MULTI</b></p>
<p><b>Fast Flash Programmer</b>.</p>
<p>To open this window, do one of the following:</p>
<p>â¢</p>
<p>In the Debugger, select<b> Debug</b> â<b> Prepare Target</b>. In the<b> Prepare Target</b></p>
<p>dialog box that appears, select<b> Program Flash ROM</b>.</p>
<p>â¢</p>
<p>In the Project Manager, select<b> Tools</b> â<b> Flash<i> Selected Program</b></i>. (This option</p>
<p>is only available if the selected file is a compiled program and you are connected</p>
<p>to the target.)</p>
<p>â¢</p>
<p>In the Debugger, select<b> Target</b> â<b> Flash</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>540</i></p>
<p><i>Chapter 22. Programming Flash Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> flash gui</b> command. For information</p>
<p>about this command, see âGeneral Memory Commandsâ in Chapter 10,</p>
<p>âMemory Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p><b>Prerequisites to Working with Flash</b></p>
<p>Before you can use MULTI to work with flash memory, you must ensure that you</p>
<p>have met the following prerequisites:</p>
<p>â¢</p>
<p>The setup script initializes the board so that flash memory is accessible and</p>
<p>not cached.</p>
<p>â¢</p>
<p>The setup script disables any external interrupts or watchdog timers that may</p>
<p>interfere with flash programming.</p>
<p>â¢</p>
<p>Your project's link map is linked for ROM and not RAM.</p>
<p>Flash programming speed is greatly enhanced by allocating more RAM for use by</p>
<p>target agents. Choose the largest segment of RAM that can be accessed over the</p>
<p>debug connection.</p>
<p>If the flash device has protected sectors that you need to overwrite, select the<b> Unlock</b></p>
<p><b>sectors</b> option in the<b> MULTI Fast Flash Programmer</b>. Protected sectors may</p>
<p>contain vital initialization code, so verify that the program image will not overwrite</p>
<p>important data before setting this option. (This option is only available if you have</p>
<p>selected<b> Erase</b> or<b> Program</b> in the top-right corner of the<b> MULTI Fast Flash</b></p>
<p><b>Programmer</b>.)</p>
<p><b>Using the MULTI Fast Flash Programmer</b></p>
<p>The following sections describe how to perform important setup tasks and how to</p>
<p>write to, verify, or erase flash memory.</p>
<p><b>Specifying Flash Banks</b></p>
<p>To add a flash memory bank, enter the base address in the<b> Base address of bank</b></p>
<p>field. (Base addresses can be specified in either decimal or hexadecimal format.)</p>
<p><i>541</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Prerequisites to Working with Flash</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Then click the<b> Add New</b> button. To change the base address of a bank already in</p>
<p>the list, select it, enter the new base address, and click the<b> Apply</b> button.</p>
<p>Suppose your board has a CPU internal flash memory device and an external</p>
<p>CFI-compatible flash memory device. You would need to specify two flash banks.</p>
<p>To do so, you could:</p>
<p>1.</p>
<p>Select the base address in the<b> Flash banks</b> pane.</p>
<p>2.</p>
<p>Change the value in the<b> Base address of bank</b> field to be the base address of</p>
<p>the internal device.</p>
<p>3.</p>
<p>Click the<b> Apply</b> button.</p>
<p>4.</p>
<p>Enter the address of the external flash device in the<b> Base address of bank</b></p>
<p>field.</p>
<p>5.</p>
<p>Click the<b> Add New</b> button.</p>
<p>Performing these steps results in a list of two flash banks. The flash utility programs</p>
<p>both of them as needed.</p>
<p><b>Choosing a File for Flash Operations</b></p>
<p>To select the file you want to write to flash memory, verify in flash memory, or</p>
<p>erase from flash memory, enter the pathname of the file in the<b> File</b> field. You can</p>
<p>also click</p>
<p>to open a file chooser and browse to the appropriate file. After selecting</p>
<p>the file, use the<b> File Type</b> drop-down list to specify whether the selected file is in</p>
<p>ELF format, S-Record format, or is unformatted (<b>Raw Binary</b>). If the file is</p>
<p>unformatted, be sure to set the offset from the base of flash memory.</p>
<p><b>Setting a Write Offset</b></p>
<p>You can set a write offset by entering an offset value in the<b> Program offset</b> field.</p>
<p>The meaning of the offset value differs for each file type, as described in the</p>
<p>following list. (The offset value is optional and defaults to 0.)</p>
<p>â¢</p>
<p><i>ELF or S-Record format</i> â If the file you are writing to flash memory is in</p>
<p>ELF or S-Record format, the offset is added to each address location specified</p>
<p>in the file memory map. If the map correctly specifies where the program should</p>
<p>be written, enter an offset of 0.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>542</i></p>
<p><i>Chapter 22. Programming Flash Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Offsetting an ELF or S-Record format file is helpful if you are downloading a</p>
<p>program to flash memory and the flash bank has been mapped to a new location</p>
<p>in memory. For example, the flash memory could be mapped to the same</p>
<p>location as memory-mapped registers. If this is the case, you should re-map</p>
<p>the flash memory. Because re-mapped flash memory is in a different location</p>
<p>during programming than it is at reset, link the ELF program for the location</p>
<p>where flash memory will be at reset, and enter the difference in addresses as</p>
<p>the offset value.</p>
<p><b>Note</b></p>
<p>To write a program linked for RAM to flash memory, you must edit</p>
<p>the linker directives file (see the documentation about linker</p>
<p>directives files in the<i> MULTI: Building Applications</i> book). A</p>
<p>program linked for RAM will not run if the offset is used to move</p>
<p>the program to the flash area of the memory map.</p>
<p>â¢</p>
<p><i>Raw image</i> â If the file you are writing to flash memory is an unformatted</p>
<p>memory image, the offset value specifies the location where the image will be</p>
<p>written, relative to the first base address in the list. If you erase flash memory,</p>
<p>the erase begins at the base address plus the offset.</p>
<p><b>Writing to Flash Memory</b></p>
<p>To write a file to flash memory on the target, use the<b> MULTI Fast Flash</b></p>
<p><b>Programmer</b> to set the programming options. Select the<b> Erase</b> option in addition</p>
<p>to the<b> Program</b> option if the flash sectors have not previously been erased. For a</p>
<p>description of each option, see âThe MULTI Fast Flash Programmer GUI Referenceâ</p>
<p>on page 545. When you have set the applicable options, click the<b> Program Flash</b></p>
<p>button. MULTI downloads and runs target agents to modify the flash memory,</p>
<p>unless no RAM was allocated.</p>
<p>The status of the flash operation is listed in the output pane of the window. You</p>
<p>can cancel the operation at any time by clicking the<b> Cancel</b> button, which is enabled</p>
<p>while the operation is in progress. Some flash operations may not respond</p>
<p>immediately to the cancel request, and the<b> MULTI Fast Flash Programmer</b> may</p>
<p>also wait for certain operations to complete before returning control to you.</p>
<p><i>543</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Writing to Flash Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Tip</b></p>
<p>If you experience problems, see âTroubleshooting Flash Memory</p>
<p>Operationsâ on page 547.</p>
<p>For information about programming flash from a script, see the<b> flash burn</b> command</p>
<p>in âGeneral Memory Commandsâ in Chapter 10, âMemory Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Erasing Flash Memory</b></p>
<p>You can also use the<b> MULTI Fast Flash Programmer</b> to initialize the flash device</p>
<p>without writing an image to it. To do this, select<b> Erase</b>, clear<b> Program</b>, and set the</p>
<p>other options with the same values that you would use for writing an image. For a</p>
<p>description of each field, see âThe MULTI Fast Flash Programmer GUI Referenceâ</p>
<p>on page 545.</p>
<p>When you click<b> Erase Flash</b>, the target agent erases a region of flash memory the</p>
<p>same size as the chosen image. For example, if you select an ELF file with 1 MB</p>
<p>of data at the start of flash memory, this feature erases only the first 1 MB of flash.</p>
<p>You can cancel the operation at any time by clicking the<b> Cancel</b> button. The window</p>
<p>indicates the status of the erase in the output pane.</p>
<p><b>Tip</b></p>
<p>If you experience problems, see âTroubleshooting Flash Memory</p>
<p>Operationsâ on page 547.</p>
<p><b>Verifying Flash Memory</b></p>
<p>To verify that the data written to the flash device contains a complete and up-to-date</p>
<p>image of your program, open the<b> MULTI Fast Flash Programmer</b>, select<b> Verify</b>,</p>
<p>and clear<b> Erase</b> and<b> Program</b>. Fill in the remaining settings as you would for a</p>
<p>download. For a description of each field, see âThe MULTI Fast Flash Programmer</p>
<p>GUI Referenceâ on page 545.</p>
<p>When you click<b> Verify</b>, the<b> MULTI Fast Flash Programmer</b> compares the</p>
<p>executable with the data on the target and stops when a difference is found.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>544</i></p>
<p><i>Chapter 22. Programming Flash Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The MULTI Fast Flash Programmer GUI Reference</b></p>
<p>The following table provides a brief description of the fields and buttons of the</p>
<p><b>MULTI Fast Flash Programmer</b>.</p>
<p>Specifies the base addresses of the flash memory in the target memory</p>
<p>map.</p>
<p><b>Flash banks</b></p>
<p>Allows you to modify the address of the flash bank selected in the<b> Flash</b></p>
<p><b>banks</b> pane. Base addresses can be specified in either decimal or</p>
<p>hexadecimal format. See also âSpecifying Flash Banksâ on page 541.</p>
<p><b>Base address of</b></p>
<p><b>bank</b></p>
<p>Adds the new flash bank (whose base address is specified in the<b> Base</b></p>
<p><b>address of bank</b> field) to the<b> Flash banks</b> pane.</p>
<p><b>Add New</b></p>
<p>Applies changes made in the<b> Base address of bank</b> field.</p>
<p><b>Apply</b></p>
<p>Removes the flash bank selected in the<b> Flash banks</b> pane.</p>
<p><b>Remove</b></p>
<p>Allows protected sectors of your flash device to be overwritten. Protected</p>
<p>sectors may contain vital initialization code, so verify that the program</p>
<p>image will not overwrite important data before selecting this option. This</p>
<p>option is only available if you have selected<b> Erase</b> or<b> Program</b>.</p>
<p><b>Unlock sectors</b></p>
<p>Specifies whether MULTI attempts to erase flash memory, program flash</p>
<p>memory, or verify flash memory when you click the<b> Erase Flash</b>,<b> Program</b></p>
<p><b>Flash</b>, or<b> Verify Flash</b> button at the bottom of the window.</p>
<p>The<b> Erase</b> option erases all the flash sectors in the programming range.</p>
<p>Select this option to erase the flash chip, or select it in addition to the</p>
<p><b>Program</b> option to reprogram a chip whose flash range has previously</p>
<p>been programmed.</p>
<p>See also âUsing the MULTI Fast Flash Programmerâ on page 541.</p>
<p><b>Erase</b></p>
<p><b>Program</b></p>
<p><b>Verify</b></p>
<p>â¢</p>
<p>If the<b> Erase</b> operation is selected â Specifies the file to use to</p>
<p>determine the amount of memory to erase.</p>
<p>â¢</p>
<p>If the<b> Program</b> operation is selected â Specifies the name of the file</p>
<p>to be written.</p>
<p>â¢</p>
<p>If the<b> Verify</b> operation is selected â Specifies the source file for</p>
<p>verification.</p>
<p>Enter the name of the appropriate file or click</p>
<p>to open a file chooser</p>
<p>and browse to the appropriate file. See also âChoosing a File for Flash</p>
<p>Operationsâ on page 542.</p>
<p><b>File</b></p>
<p>Specifies the format of the selected file. Select either<b> ELF</b>,<b> Raw Binary</b>,</p>
<p>or<b> S-Record</b>.</p>
<p><b>File type</b></p>
<p><i>545</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The MULTI Fast Flash Programmer GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Specifies a program offset value. For ELF and S-Record format</p>
<p>executables, this value is added to the addresses encoded in the file. For</p>
<p>unformatted memory images, the first base address is added to this value</p>
<p>to determine where in memory the file should be programmed. For more</p>
<p>information, see âSetting a Write Offsetâ on page 542.</p>
<p><b>Program offset</b></p>
<p>Allows you to specify the size and location of RAM to be used by the flash</p>
<p>utility. If the memory at the beginning of RAM is unusable, you should</p>
<p>enter the first usable address, and leave the RAM size control set to the</p>
<p>size of the full memory block. The RAM location field is only available</p>
<p>if the RAM size selection is more than<b> 0 KB</b>.</p>
<p><b>Use<i> size</i> of target</b></p>
<p><b>RAM at<i> location</b></i></p>
<p>Allows you to specify the<b> .mbs</b> format script that is run before accessing</p>
<p>flash memory. If this field is empty, the<b> MULTI Fast Flash Programmer</b></p>
<p>will run the default setup script for the debug connection.</p>
<p><b>Target setup</b></p>
<p><b>script</b></p>
<p>Prints warning and status messages that may be helpful for troubleshooting</p>
<p>purposes.</p>
<p><b>Verbose output</b></p>
<p>Begins the flash operation according to the specifications you have entered</p>
<p>in the window.</p>
<p><b>Note</b>: Because programming flash memory involves downloading target</p>
<p>agents and running them, you should kill any processes running on the</p>
<p>target before clicking the<b> Erase Flash</b>,<b> Program Flash</b>, or<b> Verify Flash</b></p>
<p>button. If the flash operation begins while other processes are running, the</p>
<p>running processes terminate.</p>
<p><b>Erase Flash</b></p>
<p><b>Program Flash</b></p>
<p><b>Verify Flash</b></p>
<p>Closes the<b> MULTI Fast Flash Programmer</b> window.</p>
<p><b>Close</b></p>
<p><b>Flash Configuration File</b></p>
<p>The settings in the<b> MULTI Fast Flash Programmer</b> are persistently stored in the</p>
<p>file<b> flash.cfg</b>, which is located in your personal configuration directory:</p>
<p>â¢</p>
<p>Windows 7/Vista â<i><b> user_dir</i>\AppData\Roaming\GHS\</b></p>
<p>â¢</p>
<p>Windows XP â<i><b> user_dir</i>\Application Data\GHS\</b></p>
<p>â¢</p>
<p>Linux/Solaris â<i><b> user_dir</i>/.ghs/</b></p>
<p>The<b> flash.cfg</b> file contains an entry for each target type. Entries are updated after</p>
<p>successful flash programming sessions. When the<b> MULTI Fast Flash Programmer</b></p>
<p>opens, these saved configuration settings replace any defaults read from the ELF</p>
<p>file or debug information. Because the settings are indexed by target and not by</p>
<p><i>MULTI: Debugging</i></p>
<p><i>546</i></p>
<p><i>Chapter 22. Programming Flash Memory</i></p>
<h1 style="page-break-before:always; "></h1>
<p>project, a new project for a target that has been successfully programmed will use</p>
<p>the target's most recent settings rather than the default settings for a new project.</p>
<p>To restore all<b> MULTI Fast Flash Programmer</b> settings to the default values,</p>
<p>remove or rename the<b> flash.cfg</b> file.</p>
<p><b>Troubleshooting Flash Memory Operations</b></p>
<p>The following text lists some problems that are commonly encountered when</p>
<p>working with flash memory and gives some troubleshooting steps for each.</p>
<p>If the<b> MULTI Fast Flash Programmer</b> does not detect any flash memory after</p>
<p>you click the<b> Program Flash</b> or<b> Erase Flash</b> button:</p>
<p>1.</p>
<p>Check that the setup script initializes the board so that flash memory is</p>
<p>accessible for both reads and writes.</p>
<p>2.</p>
<p>Verify that the base addresses entered in the<b> MULTI Fast Flash Programmer</b></p>
<p>are the starting addresses of the flash chips.</p>
<p>3.</p>
<p>Your flash chip may not be supported. For information about adding support</p>
<p>for new flash memory chips, see the<b> flash_chips.odb</b> file located at</p>
<p><i><b>compiler_install_dir</i>/defaults</b>.</p>
<p>If the<b> MULTI Fast Flash Programmer</b> prints messages indicating that writing</p>
<p>the program sections was successful, but then fails to verify the image, the flash</p>
<p>memory may have protected sectors that the flash driver cannot unlock. To fix this:</p>
<p>1.</p>
<p>Refer to your flash chip documentation about procedures to unlock the protected</p>
<p>sectors.</p>
<p>2.</p>
<p>Following the procedure given in your flash chip datasheet, unlock the flash</p>
<p>sectors in the setup script.</p>
<p>If the<b> MULTI Fast Flash Programmer</b> prints an error about a protected section</p>
<p>of memory, set the<b> Unlock sectors</b> option. For more information about this option,</p>
<p>see âThe MULTI Fast Flash Programmer GUI Referenceâ on page 545.</p>
<p><i>547</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Troubleshooting Flash Memory Operations</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 23</b></p>
<p><b>Working with ROM</b></p>
<p><b>Contents</b></p>
<p>Building an Executable for ROM . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>550</p>
<p>Executing a ROM Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>552</p>
<p>Debugging a ROM Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>554</p>
<p>Building an Executable for ROM-to-RAM . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>554</p>
<p>Executing a ROM-to-RAM Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>556</p>
<p>Debugging a ROM-to-RAM Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>557</p>
<h1 style="page-break-before:always; "></h1>
<p>The MULTI Integrated Development Environment enables embedded system</p>
<p>programmers to:</p>
<p>â¢</p>
<p>Build a project that can be transferred to the target's nonvolatile memory (ROM)</p>
<p>â¢</p>
<p>Transfer a project's executable image to a target's flash memory</p>
<p>â¢</p>
<p>Run and debug an executable that is located in ROM</p>
<p>â¢</p>
<p>Run and debug an executable that is copied from ROM to RAM at startup</p>
<p><b>Building an Executable for ROM</b></p>
<p>An executable that is executed out of ROM has two primary differences from a</p>
<p>RAM executable:</p>
<p>1.</p>
<p>The linker directives file used to create the executable specifies that all of the</p>
<p>compiled sections are in ROM.</p>
<p>2.</p>
<p>Any necessary target board initialization may need to be done as part of the</p>
<p>program's initialization instead of in a MULTI target setup script.</p>
<p><b>Creating a New Program</b></p>
<p>To create a new ROM executable image, perform the following steps:</p>
<p>1.</p>
<p>If you do not already have one, create a MULTI project for your target</p>
<p>configuration. For information about how to do this, see Chapter 1, âCreating</p>
<p>a Projectâ in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p>2.</p>
<p>If you just created a MULTI project, you are automatically prompted to add</p>
<p>items to it. Otherwise, select the Top Project and click the<b> Add Items</b> button</p>
<p>(</p>
<p>) in the Project Manager.</p>
<p>3.</p>
<p>On the<b> Project Manager: Select Item to Add</b> screen that appears, select a</p>
<p>demo or example. If you want a framework to which you can add your own</p>
<p>source code, select<b> Program</b>. Click<b> Next</b>.</p>
<p>4.</p>
<p>Change the next screen's information as desired. Click<b> Next</b>.</p>
<p>5.</p>
<p>Select<b> Link to and Execute out of ROM</b> from the<b> Program Layout</b></p>
<p>drop-down list, and make other selections as appropriate. Click<b> Finish</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>550</i></p>
<p><i>Chapter 23. Working with ROM</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Your new program uses a Green-Hills-provided linker directives file that links all</p>
<p>of the sections into ROM.</p>
<p>For more information about adding to projects, see âManaging Your Projectâ in</p>
<p>Chapter 2, âManaging and Building Projects with the Project Managerâ in the</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>Configuring an Existing Program</b></p>
<p>Your linker directives file must place all sections into ROM instead of RAM. If</p>
<p>your existing program is not already using a Green-Hills-provided linker directives</p>
<p>file configured for ROM, you can switch to using one by performing the following</p>
<p>steps:</p>
<p>1.</p>
<p>In the Project Manager, select the program.</p>
<p>2.</p>
<p>Select<b> Edit</b> â<b> Configure</b>.</p>
<p>3.</p>
<p>In the dialog box that appears, select<b> Link to and Execute out of ROM</b> from</p>
<p>the<b> Program Layout</b> drop-down list.</p>
<p>For more information, see the documentation about linker directives files in the</p>
<p><i>MULTI: Building Applications</i> book.</p>
<p>If your program does not use a Green Hills linker directives file, modify it so that</p>
<p>all sections will be placed into ROM instead of RAM. You must also define several</p>
<p>special linker symbols in your linker directives file. This ensures that all MULTI</p>
<p>ROM debugging features work properly. The special linker symbols you should</p>
<p>define are:</p>
<p><b>Value</b></p>
<p><b>Symbol</b></p>
<p>The beginning of RAM.</p>
<p>__ghs_ramstart</p>
<p>The end of RAM.</p>
<p>__ghs_ramend</p>
<p>The beginning of ROM.</p>
<p>__ghs_romstart</p>
<p>The end of ROM.</p>
<p>__ghs_romend</p>
<p>The beginning of the sections located in RAM. Should</p>
<p>be 0 for ROM programs.</p>
<p>__ghs_rambootcodestart</p>
<p>The end of the sections located in RAM. Should be 0</p>
<p>for ROM programs.</p>
<p>__ghs_rambootcodeend</p>
<p><i>551</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Configuring an Existing Program</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Value</b></p>
<p><b>Symbol</b></p>
<p>The beginning of the sections located in ROM.</p>
<p>__ghs_rombootcodestart</p>
<p>The end of the sections located in ROM.</p>
<p>__ghs_rombootcodeend</p>
<p>Ranges of memory defined by</p>
<p>__ghs_*start</p>
<p>and</p>
<p>__ghs_*end</p>
<p>must follow these</p>
<p>rules:</p>
<p>â¢</p>
<p>The</p>
<p>__ghs_*end</p>
<p>symbol address should be after the corresponding</p>
<p>__ghs_*start</p>
<p>symbol address. Ranges are allowed to span address</p>
<p>0</p>
<p>as long</p>
<p>as they do not wrap around the entire address space.</p>
<p>â¢</p>
<p>The</p>
<p>__ghs_*start</p>
<p>symbol address should be the address of the first byte of</p>
<p>the region you are describing. For example, if RAM is 8 megabytes starting</p>
<p>from address</p>
<p>0x10000000</p>
<p>,</p>
<p>__ghs_ramstart</p>
<p>would be</p>
<p>0x10000000</p>
<p>.</p>
<p>â¢</p>
<p>The</p>
<p>__ghs_*end</p>
<p>symbol address should be the address of the byte after the</p>
<p>region you are describing. For example, if RAM is 8 megabytes starting from</p>
<p>address</p>
<p>0x10000000</p>
<p>,</p>
<p>__ghs_ramend</p>
<p>would be</p>
<p>0x10800000</p>
<p>, not</p>
<p>0x107fffff</p>
<p>.</p>
<p>â¢</p>
<p>If the</p>
<p>__ghs_*start</p>
<p>symbol is defined, the corresponding</p>
<p>__ghs_*end</p>
<p>symbol must be defined, and vice versa.</p>
<p>â¢</p>
<p>Neither</p>
<p>__ghs_*start</p>
<p>nor</p>
<p>__ghs_*end</p>
<p>may have the value</p>
<p>0xffffffff</p>
<p>(on 32-bit systems) or</p>
<p>0xffffffffffffffff</p>
<p>(on 64-bit systems). If need be,</p>
<p>you may be able to work around this restriction by subtracting</p>
<p>1</p>
<p>from the actual</p>
<p>address.</p>
<p><b>Executing a ROM Program</b></p>
<p>Running a program that loads from ROM is different than running an executable</p>
<p>that has been downloaded from the host to the target. First, you must transfer the</p>
<p>image into ROM. For more information about transferring an image to ROM, see</p>
<p>âFlashing Your Executableâ on page 114.</p>
<p><b>Attaching to a Running ROM Process</b></p>
<p>If your program runs automatically when the target board is reset, you can attach</p>
<p>to it after it has started running and begin debugging.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>552</i></p>
<p><i>Chapter 23. Working with ROM</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To attach to the process:</p>
<p>1.</p>
<p>Reset your target to start your program.</p>
<p><b>Note</b></p>
<p>All target initialization must be done as part of the program's</p>
<p>initialization instead of in a target setup script.</p>
<p>2.</p>
<p>Open your program in the Debugger.</p>
<p>3.</p>
<p>Select<b> Debug</b> â<b> Prepare Target</b>. In the<b> Prepare Target</b> dialog box that</p>
<p>appears, select<b> Program already present on target</b>. MULTI matches the</p>
<p>information on the target with the executable image you are debugging.</p>
<p>4.</p>
<p>You may now begin debugging.</p>
<p><b>Advanced: Starting a ROM Program from the Debugger</b></p>
<p>You may be able to start your ROM program from the Debugger. To do so, perform</p>
<p>the following steps:</p>
<p>1.</p>
<p>Open your program in the Debugger.</p>
<p>2.</p>
<p>Initialize your target board to the point where it can successfully start the</p>
<p>program. For example, you can use the<b> setup</b> command to run your target</p>
<p>setup script. If your program contains its own target initialization code, running</p>
<p>the setup script is unnecessary, but you may still need to reset your target. To</p>
<p>do so from the Debugger, you can click the<b> Reset</b> button (</p>
<p>) or issue the</p>
<p><b>reset</b> command. For information about the<b> setup</b> and<b> reset</b> commands, see</p>
<p>âGeneral Target Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>3.</p>
<p>Select<b> Debug</b> â<b> Prepare Target</b>. In the<b> Prepare Target</b> dialog box that</p>
<p>appears, select<b> Program already present on target</b>.</p>
<p>4.</p>
<p>MULTI presents your target in its current state. If your target is not already at</p>
<p>the beginning of your program, set the program counter to the beginning of</p>
<p>the code you want to execute by entering</p>
<p>$pc =<i> starting_address</i></p>
<p>in the</p>
<p>Debugger command pane. For example, if your ROM boot code begins at the</p>
<p>program's entry point address, you may want to enter</p>
<p>$pc = _ENTRYPOINT</p>
<p>.</p>
<p><i>553</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Advanced: Starting a ROM Program from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>5.</p>
<p>Enter<b> rominithbp -setup</b> in the Debugger command pane to set the</p>
<p>post-initialization hardware breakpoint. For information about the<b> rominithbp</b></p>
<p>command, see Chapter 3, âBreakpoint Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>6.</p>
<p>You may now begin debugging.</p>
<p><b>Debugging a ROM Program</b></p>
<p>Debugging a process running in ROM is very similar to debugging in RAM. The</p>
<p>primary differences are:</p>
<p>â¢</p>
<p>Software breakpoints cannot be used in ROM sections. Since software</p>
<p>breakpoints are unavailable, clicking a breakdot will attempt to set a hardware</p>
<p>breakpoint. The number of hardware breakpoints available varies from target</p>
<p>to target, but it is usually fewer than four.</p>
<p><b>Note</b></p>
<p>MULTI uses hardware breakpoints to implement source-line (<b>s</b>) and</p>
<p>function (<b>n</b>) stepping in ROM. If a hardware breakpoint is</p>
<p>unavailable, the target may start running instead of stopping after</p>
<p>executing the source line or function. Instruction stepping (<b>si</b>) is</p>
<p>unaffected.</p>
<p>â¢</p>
<p>ROM programs built with run-time error checking enabled handle run-time</p>
<p>errors as if the Debugger is not connected. For more information, see the</p>
<p>documentation about run-time error checks in the<i> MULTI: Building Applications</i></p>
<p>book.</p>
<p><b>Building an Executable for ROM-to-RAM</b></p>
<p>An executable which is loaded from ROM and copied into RAM has two primary</p>
<p>differences from a RAM executable:</p>
<p>1.</p>
<p>The linker directives file used to create the executable specifies the locations</p>
<p>of uncompressed boot code sections in ROM, compressed code sections in</p>
<p>ROM, and uncompressed code sections in RAM. The RAM code sections are</p>
<p><i>MULTI: Debugging</i></p>
<p><i>554</i></p>
<p><i>Chapter 23. Working with ROM</i></p>
<h1 style="page-break-before:always; "></h1>
<p>not actually part of the executable image, instead they are copied from ROM</p>
<p>at run time by the boot code.</p>
<p>2.</p>
<p>Any necessary target board initialization may need to be done as part of the</p>
<p>program's initialization instead of in a MULTI target setup script.</p>
<p><b>Creating a New Program</b></p>
<p>To create a new ROM-to-RAM executable image, perform the steps listed in</p>
<p>âCreating a New Programâ on page 550, but instead of choosing<b> Link to and Execute</b></p>
<p><b>out of ROM</b> from the<b> Program Layout</b> drop-down list, choose<b> Link to ROM and</b></p>
<p><b>Execute out of RAM</b>.</p>
<p>Your new program contains a Green-Hills-provided linker directives file that links</p>
<p>all of the sections into ROM and specifies which sections will be copied into RAM.</p>
<p><b>Configuring an Existing Program</b></p>
<p>Your linker directives file must place all boot code into ROM, and compressed</p>
<p>versions of the remaining code into ROM. Additionally, the linker directives file</p>
<p>must specify the destination in RAM of each code section.</p>
<p>If your existing program is not already using a Green-Hills-provided linker directives</p>
<p>file configured for ROM-to-RAM, you can switch to using one by following the</p>
<p>steps listed in âConfiguring an Existing Programâ on page 551, but instead of</p>
<p>choosing<b> Link to and Execute out of ROM</b> from the<b> Program Layout</b> drop-down</p>
<p>list, choose<b> Link to ROM and Execute out of RAM</b>. For more information, see</p>
<p>the documentation about linker directives files in the<i> MULTI: Building Applications</i></p>
<p>book.</p>
<p>If your program does not use a Green Hills linker directives file, modify it so that</p>
<p>it meets the requirements specified at the beginning of this section. Additionally,</p>
<p>you must define several special linker symbols in your linker directives file. This</p>
<p>ensures that all MULTI ROM-to-RAM debugging features work properly. The</p>
<p>special linker symbols you should define are:</p>
<p><b>Value</b></p>
<p><b>Symbol</b></p>
<p>The beginning of RAM.</p>
<p>__ghs_ramstart</p>
<p>The end of RAM.</p>
<p>__ghs_ramend</p>
<p><i>555</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Creating a New Program</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Value</b></p>
<p><b>Symbol</b></p>
<p>The beginning of ROM.</p>
<p>__ghs_romstart</p>
<p>The end of ROM.</p>
<p>__ghs_romend</p>
<p>The beginning of the sections located in RAM. All of</p>
<p>the destination sections should be included.</p>
<p>__ghs_rambootcodestart</p>
<p>The end of the sections located in RAM. All of the</p>
<p>destination sections should be included.</p>
<p>__ghs_rambootcodeend</p>
<p>The beginning of boot code sections located in ROM.</p>
<p>Do not include any of the compressed sections.</p>
<p>__ghs_rombootcodestart</p>
<p>The end of boot code sections located in ROM. Do not</p>
<p>include any of the compressed sections.</p>
<p>__ghs_rombootcodeend</p>
<p>The first address executed after the ROM-to-RAM copy</p>
<p>is complete.</p>
<p>__ghs_after_romcopy</p>
<p>For rules governing the use of</p>
<p>__ghs_*start</p>
<p>and</p>
<p>__ghs_*end</p>
<p>, see âConfiguring</p>
<p>an Existing Programâ on page 551.</p>
<p><b>Executing a ROM-to-RAM Program</b></p>
<p>Running a ROM-to-RAM program is the same as running a ROM program. For</p>
<p>instructions, see âExecuting a ROM Programâ on page 552.</p>
<p><b>Note</b></p>
<p>Your ROM-to-RAM program must be copied into RAM before software</p>
<p>breakpoints can be set on the target and before system calls can be routed</p>
<p>through the MULTI Debugger.</p>
<p>By default, MULTI adheres to the rules explained next when determining whether</p>
<p>ROM-to-RAM copy initialization has occurred. You can use the<b> rominithbp</b></p>
<p>command to manually signal to MULTI when the ROM-to-RAM copy initialization</p>
<p>is complete. For information about the<b> rominithbp</b> command, see Chapter 3,</p>
<p>âBreakpoint Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>After you prepare your target with the<b> Program already present on target</b> option,</p>
<p>MULTI determines the location of the program counter (PC) the first time the target</p>
<p>halts. If the PC indicates that the next instruction is in RAM, MULTI assumes that</p>
<p><i>MULTI: Debugging</i></p>
<p><i>556</i></p>
<p><i>Chapter 23. Working with ROM</i></p>
<h1 style="page-break-before:always; "></h1>
<p>the program has been copied to RAM and lifts ROM debugging restrictions. If,</p>
<p>however, the PC indicates that the next instruction is in ROM, MULTI assumes</p>
<p>that the program has not yet been copied to RAM. In this case, MULTI automatically</p>
<p>sets a hardware breakpoint, called the<i> post-initialization hardware breakpoint</i>, at</p>
<p>__ghs_after_romcopy</p>
<p>, which defaults to one of the first instructions in RAM.</p>
<p>When this hardware breakpoint is hit, MULTI is signalled that ROM initialization</p>
<p>is complete and that the program has been copied into RAM.</p>
<p>After MULTI has determined that the program has been copied to RAM, it performs</p>
<p>all post-initialization actions (such as setting software breakpoints and triggering</p>
<p>Debugger hooks). If the target was halted by the post-initialization hardware</p>
<p>breakpoint, MULTI resumes it.</p>
<p><b>Debugging a ROM-to-RAM Program</b></p>
<p>Because the process is running out of RAM, there are no special limitations on</p>
<p>debugging. However, if you need to debug any of the boot code that is executed</p>
<p>before the copy into RAM occurs, you will be debugging in ROM. For more</p>
<p>information, see âDebugging a ROM Programâ on page 554.</p>
<p><i>557</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Debugging a ROM-to-RAM Program</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 24</b></p>
<p><b>Non-Intrusive Debugging</b></p>
<p><b>with Tracepoints</b></p>
<p><b>Contents</b></p>
<p>About Tracepoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>560</p>
<p>Working with Tracepoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>561</p>
<p>Collecting Debugging Information Non-Intrusively: Example . . . . . . . . . . . .</p>
<p>567</p>
<p>The Tracepoints Tab of the Breakpoints Window . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>571</p>
<p>Debugging in Passive Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>574</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes how to perform non-intrusive debugging (also known as</p>
<p>field debugging) using tracepoints, which allow you to collect useful debugging</p>
<p>data without halting a process.</p>
<p><b>About Tracepoints</b></p>
<p>The MULTI Debugger allows you to perform non-intrusive debugging using</p>
<p>tracepoints. A tracepoint is set at a particular instruction and collects the values of</p>
<p>one or more variables each time the tracepoint is hit. Unlike the processing for</p>
<p>standard breakpoints, all tracepoint processing is performed by the target. Thus, a</p>
<p>tracepoint can be hit and collect data even when the Debugger is not connected to</p>
<p>the target. Additionally, since MULTI does not have to stop the target to perform</p>
<p>processing, using tracepoints should not significantly impede the normal functioning</p>
<p>of the target.</p>
<p>Data collected by tracepoints accumulates in the tracepoint buffer for later retrieval.</p>
<p>If the tracepoint buffer becomes full, then tracepoints will stop collecting data until</p>
<p>more buffer space is made available by a purge operation (see âPurging the</p>
<p>Tracepoint Bufferâ on page 567). If a tracepoint is being hit more frequently than</p>
<p>the threshold specified by the user when the tracepoint was created, then that</p>
<p>particular tracepoint will be disabled and will no longer collect data.</p>
<p>Tracepoints are invaluable in situations where normal invasive debugging techniques,</p>
<p>such as halting the process, may have negative consequences. If tracepoints are</p>
<p>supported, you can use the MULTI Debugger's passive mode, which allows</p>
<p>tracepoints but rejects more invasive debugging actions, such as setting breakpoints</p>
<p>or halting the target. For more information, see âDebugging in Passive Modeâ</p>
<p>on page 574.</p>
<p><b>Note</b></p>
<p>Not all targets and operating systems support tracepoints. You must be</p>
<p>connected to a target and operating system that support tracepoints in</p>
<p>order to perform the actions described in this chapter.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>560</i></p>
<p><i>Chapter 24. Non-Intrusive Debugging with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Working with Tracepoints</b></p>
<p>Like breakpoints, tracepoints are displayed with an icon (</p>
<p>) in the Debugger source</p>
<p>pane and are also listed in the<b> Breakpoints</b> window. To open the<b> Breakpoints</b></p>
<p>window, do one of the following:</p>
<p>â¢</p>
<p>In the Debugger, click the<b> Breakpoints</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>In the Debugger, select<b> View</b> â<b> Breakpoints</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, issue the<b> breakpoints</b> command. For</p>
<p>information about this command, see Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Choose the<b> Tracepoints</b> tab of the<b> Breakpoints</b> window to view tracepoint</p>
<p>information. For a detailed description of all the tracepoint options available in this</p>
<p>window, see âThe Tracepoints Tab of the Breakpoints Windowâ on page 571.</p>
<p>The following sections describe how to perform the most common tracepoint tasks.</p>
<p><b>Note</b></p>
<p>Tracepoints, which are are stored on the target, can collect information</p>
<p>about the target even when MULTI is not connected to it.</p>
<p><b>Setting a Tracepoint</b></p>
<p>A tracepoint can be set in any of the following ways:</p>
<p>â¢</p>
<p>From the Debugger source pane:</p>
<p>1.</p>
<p>Right-click the breakdot to the left of the source line on which you want</p>
<p>to set a new tracepoint.</p>
<p>2.</p>
<p>Choose<b> Set Tracepoint</b> from the shortcut menu that appears. This will</p>
<p>open the<b> Tracepoint Editor</b> dialog.</p>
<p>3.</p>
<p>Enter appropriate values in the fields of the<b> Tracepoint Editor</b> dialog</p>
<p>(see âTracepoint Editor Dialogâ on page 562) and click<b> OK</b>.</p>
<p>â¢</p>
<p>From the<b> Breakpoints</b> window:</p>
<p>1.</p>
<p>Choose the<b> Tracepoints</b> tab.</p>
<p>2.</p>
<p>Click the<b> New Tracepoint</b> button to open the<b> Tracepoint Editor</b> dialog.</p>
<p><i>561</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Working with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Enter appropriate values in the fields of the<b> Tracepoint Editor</b> dialog</p>
<p>(see âTracepoint Editor Dialogâ on page 562) and click<b> OK</b>.</p>
<p>â¢</p>
<p>From the command pane, enter the<b> tpset</b> command with appropriate arguments.</p>
<p>For information about this command, see âTracepoint Commandsâ in Chapter</p>
<p>21, âTracepoint Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Note</b></p>
<p>It may not be possible to set tracepoints on some variables. For more</p>
<p>information, see âLimitations: Information You Cannot Collect with</p>
<p>Tracepointsâ on page 570.</p>
<p><b>Tracepoint Editor Dialog</b></p>
<p>Tracepoints have several properties that you can modify. When you create or edit</p>
<p>a tracepoint, a<b> Tracepoint Editor</b> dialog box opens that allows you to set these</p>
<p>properties. None of your changes to the tracepoint will take effect until you click</p>
<p><b>OK</b>. You can click<b> Cancel</b> at any time to discard the changes you have made.</p>
<p>The table below lists the properties of a tracepoint that can be edited from this</p>
<p>dialog.</p>
<p><b>Meaning</b></p>
<p><b>Property</b></p>
<p>Indicates whether the tracepoint is active. When the tracepoint is active,</p>
<p>a check appears in this box and the tracepoint records the values of its</p>
<p>variables (see below) whenever the process reaches the tracepoint's</p>
<p>location. When the tracepoint is inactive, it will not record any data</p>
<p>when it is hit.</p>
<p><b>Active</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>562</i></p>
<p><i>Chapter 24. Non-Intrusive Debugging with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Property</b></p>
<p>Specifies a maximum number of times the tracepoint can be hit in a</p>
<p>timeout period before being disabled. If the tracepoint is hit more than</p>
<p><b>Count</b> times in a period of<b> Timeout</b> time units, the tracepoint will</p>
<p>automatically be disabled to prevent excessive performance degradation.</p>
<p>If this field is set to 0, the tracepoint will never be automatically</p>
<p>disabled.</p>
<p><b>Count</b></p>
<p>Specifies the length of a timeout period as a multiple of time units. The</p>
<p>exact length and definition of the time units used by tracepoints is</p>
<p>implementation-specific. If the tracepoint is hit more than<b> Count</b> times</p>
<p>in a period of<b> Timeout</b> units, the tracepoint will automatically be</p>
<p>disabled to prevent excessive performance degradation. If this field is</p>
<p>set to 0, the tracepoint will never be automatically disabled.</p>
<p><b>Timeout</b></p>
<p>Specifies an address expression representing where this tracepoint will</p>
<p>be set.</p>
<p><b>Location</b></p>
<p>Specifies a comma-delimited list of symbols whose values should be</p>
<p>stored when the tracepoint is hit. The symbols will be evaluated in the</p>
<p>context of the tracepoint's source line.</p>
<p><b>Variables</b></p>
<p>Specifies an optional condition. For many targets, this condition is</p>
<p>ignored, but in some cases it can be used by the operating system</p>
<p>integration to determine if the tracepoint should collect data when it is</p>
<p>hit. The format and interpretation of this field is implementation-specific.</p>
<p>(For more information, consult the documentation for your specific</p>
<p>operating system integration.)</p>
<p><b>Condition</b></p>
<p><b>Editing a Tracepoint</b></p>
<p>Once a tracepoint is set, you can use the<b> Tracepoint Editor</b> dialog to modify its</p>
<p>settings. To open this dialog, do one of the following:</p>
<p>â¢</p>
<p>In the source pane, right-click the tracepoint icon (</p>
<p>) and choose<b> Edit</b></p>
<p><b>Tracepoint</b> from the shortcut menu that appears.</p>
<p>â¢</p>
<p>In the<b> Tracepoints</b> tab of the<b> Breakpoints</b> window, double-click the tracepoint.</p>
<p>â¢</p>
<p>In the<b> Tracepoints</b> tab of the<b> Breakpoints</b> window, select a tracepoint and</p>
<p>click the<b> Edit</b> button.</p>
<p>â¢</p>
<p>In the<b> Tracepoints</b> tab of the<b> Breakpoints</b> window, right-click a tracepoint</p>
<p>and choose<b> Edit Selected Tracepoint</b> from the shortcut menu that appears.</p>
<p><i>563</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Editing a Tracepoint</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> edittp</b> command. (For information</p>
<p>about this command, see Chapter 21, âTracepoint Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.)</p>
<p>See âTracepoint Editor Dialogâ on page 562 for a description of tracepoint properties</p>
<p>you can edit from this dialog.</p>
<p><b>Listing Tracepoints</b></p>
<p>To view the list of active tracepoints, do one of the following:</p>
<p>â¢</p>
<p>From the<b> Breakpoints</b> window, choose the<b> Tracepoints</b> tab, which displays</p>
<p>all of the currently set tracepoints, both active and inactive (see âThe Tracepoints</p>
<p>Tab of the Breakpoints Windowâ on page 571 for more information).</p>
<p>â¢</p>
<p>From the Debugger command pane, issue the<b> tplist</b> command. For information</p>
<p>about this command, see Chapter 21, âTracepoint Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>The Debugger caches the list of tracepoints to improve performance. To</p>
<p>update the cache to reflect any tracepoints that have been automatically</p>
<p>disabled, click the<b> Refresh</b> button on the<b> Tracepoints</b> tab in the</p>
<p><b>Breakpoints</b> window, or use the command<b> tplist refresh</b>.</p>
<p><b>Deleting a Tracepoint</b></p>
<p>To delete a tracepoint, do one of the following:</p>
<p>â¢</p>
<p>From the Debugger source pane, click a tracepoint icon (</p>
<p>).</p>
<p>â¢</p>
<p>From the<b> Breakpoints</b> window:</p>
<p>1.</p>
<p>Choose the<b> Tracepoints</b> tab.</p>
<p>2.</p>
<p>Select the tracepoint to be deleted.</p>
<p>3.</p>
<p>Click the<b> Delete</b> button.</p>
<p>â¢</p>
<p>From the command pane, enter the<b> tpdel</b> command, using an address expression</p>
<p>or an ID to indicate which tracepoint to delete.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>564</i></p>
<p><i>Chapter 24. Non-Intrusive Debugging with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For example, the tracepoint set in previous examples could be deleted by</p>
<p>entering either</p>
<p>tpdel main#2</p>
<p>or</p>
<p>tpdel %0</p>
<p>. For more information, see the</p>
<p><b>tpdel</b> command in Chapter 21, âTracepoint Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Enabling or Disabling a Tracepoint</b></p>
<p>Tracepoints can be enabled and disabled. Disabled, or inactive, tracepoints do not</p>
<p>collect data. To enable or disable a tracepoint, do one of the following:</p>
<p>â¢</p>
<p>From the Debugger source pane, right-click the tracepoint icon (</p>
<p>), and select</p>
<p><b>Enable Tracepoint</b> or<b> Disable Tracepoint</b>.</p>
<p>â¢</p>
<p>From the<b> Breakpoints</b> window:</p>
<p>1.</p>
<p>Choose the<b> Tracepoints</b> tab.</p>
<p>2.</p>
<p>In the list of tracepoints, click in the<b> Active</b> column next to the line for</p>
<p>the tracepoint to be enabled or disabled.</p>
<p>â¢</p>
<p>From the Debugger command pane, use the<b> tpenable true</b> or<b> tpenable false</b></p>
<p>command, using an address expression or an ID to indicate which tracepoint</p>
<p>to enable or disable, respectively.</p>
<p>For example:</p>
<p>&gt; tpenable false %0</p>
<p>0 main#2:</p>
<p>0x101f4 200/400 &lt;disabled&gt; (argc,argv)</p>
<p>&gt; tpenable true main#2</p>
<p>0 main#2:</p>
<p>0x101f4 200/400 (argc,argv)</p>
<p>For more information, see the<b> tpenable</b> command in Chapter 21, âTracepoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Resetting a Tracepoint</b></p>
<p>The<b> tpreset</b> command resets the hit count for a tracepoint to</p>
<p>0</p>
<p>(zero). You can use</p>
<p>an address expression or an ID to specify which tracepoint to reset. For example,</p>
<p>tpreset %0</p>
<p>or</p>
<p>tpreset main#2</p>
<p>would reset the tracepoint. For more information,</p>
<p>see the<b> tpreset</b> command in Chapter 21, âTracepoint Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><i>565</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Enabling or Disabling a Tracepoint</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing the Tracepoint Buffer</b></p>
<p>The data collected by tracepoints accumulates in the tracepoint buffer. To view the</p>
<p>tracepoint buffer, do one of the following:</p>
<p>â¢</p>
<p>From the<b> Breakpoints</b> window:</p>
<p>1.</p>
<p>Choose the<b> Tracepoints</b> tab.</p>
<p>2.</p>
<p>Click the<b> Dump Recorded Data</b> button.</p>
<p>â¢</p>
<p>From the Debugger command pane, issue the<b> tpprint</b> command.</p>
<p>For example, the tracepoint used in the previous examples might yield the</p>
<p>following data:</p>
<p>&gt; tpprint</p>
<p>-------------TRACEPOINT BUFFER CONTENTS---------------------</p>
<p>Tracepoint buffer contains 78 bytes.</p>
<p>Tracepoint Set</p>
<p>TID = 0x00005a5d (current name: &lt;unknown&gt;)</p>
<p>hello.c:main#2: 0x101f4</p>
<p>Timestamp = 0x00000001</p>
<p>Tracepoint Hit</p>
<p>TID = 0x00005a5d (current name: &lt;unknown&gt;)</p>
<p>hello.c:main#2: 0x101f4</p>
<p>Timestamp = 0x0000058c</p>
<p>(argc)</p>
<p>Memory =</p>
<p>0x00000001</p>
<p>(argv)</p>
<p>Memory =</p>
<p>0x00195010</p>
<p>Task Resumed</p>
<p>TID = 0x00005a5d (current name: &lt;unknown&gt;)</p>
<p>hello.c:main#2: 0x101f4</p>
<p>Timestamp = 0x0000058d</p>
<p>--------------END TRACEPOINT BUFFER CONTENTS----------------</p>
<p>In this example, three events are logged in the tracepoint buffer. First, a</p>
<p>tracepoint is set at</p>
<p>main#2</p>
<p>. Then the tracepoint is hit at timestamp</p>
<p>0x0000058c</p>
<p>and logs the value</p>
<p>0x00000001</p>
<p>for</p>
<p>argc</p>
<p>and the value</p>
<p>0x00195010</p>
<p>for</p>
<p>argv</p>
<p>.</p>
<p>Finally, at timestamp</p>
<p>0x0000058d</p>
<p>, the task is resumed after hitting the</p>
<p>tracepoint. The amount of space used in the buffer is 78 bytes.</p>
<p>For more information, see the<b> tpprint</b> command in Chapter 21, âTracepoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>566</i></p>
<p><i>Chapter 24. Non-Intrusive Debugging with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Purging the Tracepoint Buffer</b></p>
<p>The size of the tracepoint buffer is finite, so it is useful to remove old data from the</p>
<p>tracepoint buffer to make room for new data to be collected. This operation is</p>
<p>performed with the<b> tppurge</b> command. The command<b> tppurge all</b> removes all data</p>
<p>from the tracepoint buffer, while the command<b> tppurge<i> size</b></i> removes</p>
<p><i>size</i></p>
<p>bytes</p>
<p>from the beginning of the tracepoint buffer.</p>
<p><b>Caution</b></p>
<p>If the entire buffer is not purged, the user is responsible for selecting a</p>
<p>size that specifies an integral number of events. It is recommended that</p>
<p>only sizes displayed by the<b> tpprint</b> command be used when manually</p>
<p>specifying</p>
<p><i>size</i></p>
<p>.</p>
<p>For more information, see the<b> tppurge</b> command in Chapter 21, âTracepoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Collecting Debugging Information Non-Intrusively: Example</b></p>
<p>This section contains an extended example that is designed to demonstrate what</p>
<p>information can and cannot be collected using tracepoints. The example is divided</p>
<p>into the following parts:</p>
<p>â¢</p>
<p>âSource Code for the Sample Programâ on page 567</p>
<p>â¢</p>
<p>âExamples of Valid tpset Commandsâ on page 568</p>
<p>â¢</p>
<p>âLimitations: Information You Cannot Collect with Tracepointsâ on page 570</p>
<p><b>Source Code for the Sample Program</b></p>
<p>This example uses a program compiled from the source code that follows. For</p>
<p>simplicity, this program uses a naming convention in which</p>
<p>G</p>
<p>indicates<i> global</i>,</p>
<p>L</p>
<p>indicates<i> local</i>, and</p>
<p>M</p>
<p>indicates<i> member</i>. For example,</p>
<p>Gstruct</p>
<p>refers to a global</p>
<p>structure.</p>
<p>struct my_struct</p>
<p>{</p>
<p>int Mint;</p>
<p>};</p>
<p><i>567</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Purging the Tracepoint Buffer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>class UT2</p>
<p>{</p>
<p>private:</p>
<p>static int Mstaticint;</p>
<p>int Mint;</p>
<p>public:</p>
<p>UT2(int);</p>
<p>};</p>
<p>int Gint = 5;</p>
<p>int Garray[5] = {10, 11, 5, 7, 3};</p>
<p>my_struct</p>
<p>Gstruct;</p>
<p>my_struct</p>
<p>Garraystruct[1] = { Gstruct };</p>
<p>my_struct * Gstructptr = &amp;Gstruct;</p>
<p>UT2* Gut2ptr;</p>
<p>int UT2::Mstaticint = 1;</p>
<p>int foo(int val)</p>
<p>{</p>
<p>return val + 1;</p>
<p>}</p>
<p>int main(int Argint, char **argv)</p>
<p>{</p>
<p>int Lint = 2;</p>
<p>char Lchar = 'c';</p>
<p>char* Lcharptr = &quot;tpexample.cc&quot;;</p>
<p>int Larray[4] = {1, 2, 3, 4};</p>
<p>my_struct Lstruct;</p>
<p>// variables and expressions that can be collected directly</p>
<p>Lstruct.Mint = Argint + Lint;</p>
<p>Garraystruct[0].Mint = (int) Lcharptr;</p>
<p>Gint = Argint + Lchar + Lint;</p>
<p>Gstruct.Mint = Lstruct.Mint + Larray[2] + Garray[1];</p>
<p>Gut2ptr = new UT2(Lint);</p>
<p>LABEL:</p>
<p>return 0;</p>
<p>}</p>
<p>UT2::UT2(int param)</p>
<p>{</p>
<p>this-&gt;Mint = param;</p>
<p>}</p>
<p><b>Examples of Valid tpset Commands</b></p>
<p>The following examples demonstrate how to collect information, change the type</p>
<p>of information being collected, and specify the tracepoint address using the<b> tpset</b></p>
<p>command. Most of these actions can also be performed using the<b> Tracepoint Editor</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>568</i></p>
<p><i>Chapter 24. Non-Intrusive Debugging with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p>dialog (see âTracepoint Editor Dialogâ on page 562). For a full description of the</p>
<p><b>tpset</b> command and other tracepoint commands, see Chapter 21, âTracepoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>To collect structure members, enter:</p>
<p>tpset 0/0 (Gstruct.Mint, Lstruct.Mint) main##LABEL</p>
<p>â¢</p>
<p>To collect an array element, enter:</p>
<p>tpset 0/0 (Larray[1], Garray[2]) main##LABEL</p>
<p>â¢</p>
<p>To collect an entire array, enter:</p>
<p>tpset 0/0 (Garray) main##LABEL</p>
<p>â¢</p>
<p>To collect the value of an expression where the resulting value's location can</p>
<p>be statically calculated, enter:</p>
<p>tpset 0/0 (Garraystruct[1].Mint) main##LABEL</p>
<p>â¢</p>
<p>To collect member values when in a method, enter:</p>
<p>tpset 0/0 (Mint) UT2::UT2(int)#2</p>
<p>â¢</p>
<p>To collect a string (note that the</p>
<p>char*</p>
<p>type is treated specially when gathering</p>
<p>data), enter:</p>
<p>tpset 0/0 (Lcharptr) main##LABEL</p>
<p>â¢</p>
<p>To collect a char pointer only, not the string, enter:</p>
<p>tpset 0/0 ((void*)Lcharptr) main##LABEL</p>
<p>â¢</p>
<p>To collect a block of memory (for example, to collect 80 bytes at address</p>
<p>0x12345</p>
<p>), enter:</p>
<p>tpset 0/0 ((unsigned char[80])0x12345) main##LABEL</p>
<p><i>569</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Examples of Valid tpset Commands</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>To use a cast operation to change the kind of information collected (for example,</p>
<p>to gather the integer value at the beginning of the string pointed to by</p>
<p>Lcharptr</p>
<p>), enter:</p>
<p>tpset 0/0 (*(int*)Lcharptr) main##LABEL</p>
<p>â¢</p>
<p>To specify a tracepoint by a procedure-relative line number, enter:</p>
<p>tpset 0/0 (Gint) main#16</p>
<p>â¢</p>
<p>To specify a tracepoint by a file-relative line number (</p>
<p>main##LABEL</p>
<p>is on line</p>
<p>46 of the sample source code), enter:</p>
<p>tpset 0/0 (Gint) &quot;sample.cxx&quot;#46</p>
<p>â¢</p>
<p>To specify a tracepoint by address (for example, if</p>
<p>0x101d4</p>
<p>is the address of</p>
<p>an instruction in the sample program), enter:</p>
<p>tpset 0/0 (Gint) 0x101d4</p>
<p>â¢</p>
<p>To specify a tracepoint by a C++ method-relative line number, enter:</p>
<p>tpset 0/0 (Mint) UT2::UT2(int)#2</p>
<p><b>Limitations: Information You Cannot Collect with Tracepoints</b></p>
<p>Listed below are some examples of information that cannot be collected with</p>
<p>tracepoints. Where possible, an example of an invalid<b> tpset</b> command that attempts</p>
<p>to collect this information is given. For information about the<b> tpset</b> command, see</p>
<p>Chapter 21, âTracepoint Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p>â¢</p>
<p>You cannot collect a variable that requires multiple dereferences. For example,</p>
<p>the following command is invalid:</p>
<p>tpset 0/0 (**argv) main##LABEL</p>
<p><i>MULTI: Debugging</i></p>
<p><i>570</i></p>
<p><i>Chapter 24. Non-Intrusive Debugging with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>You cannot collect an array element indexed dynamically. For example, the</p>
<p>following command is invalid:</p>
<p>tpset 0/0 (Garray[Lint]) main##LABEL</p>
<p>â¢</p>
<p>You cannot collect a struct member from a struct pointer. For example, the</p>
<p>following command is invalid:</p>
<p>tpset 0/0 (Gstructptr-&gt;Mint) main##LABEL</p>
<p>â¢</p>
<p>You cannot collect the value of an expression where one or more portions</p>
<p>cannot be determined statically (for example, the value of</p>
<p>Lstruct.Mintptr</p>
<p>is dynamic). For example, the following command is invalid:</p>
<p>tpset 0/0 (*Lstruct.Mintptr) main##LABEL</p>
<p>â¢</p>
<p>You cannot collect the value of an expression that includes a function call or</p>
<p>that would require execution of the application's target code. For example, the</p>
<p>following command is invalid:</p>
<p>tpset 0/0 (foo(5)) main##LABEL</p>
<p>â¢</p>
<p>You cannot collect a C++ class member when the</p>
<p>this</p>
<p>pointer does not exist.</p>
<p>In some cases, when a member function makes no reference to the class</p>
<p>members, the</p>
<p>this</p>
<p>pointer will be optimized away by the compiler.</p>
<p>Consequently, the tracepoint processing has no way of statically determining</p>
<p>where the class's members are at run time.</p>
<p><b>The Tracepoints Tab of the Breakpoints Window</b></p>
<p>The<b> Tracepoints</b> tab of the<b> Breakpoints</b> window contains a list of all the tracepoints</p>
<p>in your program, along with some buttons to help you work with them.</p>
<p>To access the currently set tracepoints, open the<b> Breakpoints</b> window and choose</p>
<p>the<b> Tracepoints</b> tab. To open the<b> Breakpoints</b> window, do one of the following:</p>
<p>â¢</p>
<p>In the Debugger, click the<b> Breakpoints</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>In the Debugger, select<b> View</b> â<b> Breakpoints</b>.</p>
<p><i>571</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Tracepoints Tab of the Breakpoints Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> breakpoints</b> command. For</p>
<p>information about this command, see Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>The table below describes the buttons on the<b> Tracepoints</b> tab.</p>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Reloads the list of tracepoints from the target. The target may deactivate</p>
<p>tracepoints during your program's execution if their<b> Count</b> per<b> Timeout</b></p>
<p>limit is reached, so you may want to refresh the list of tracepoints</p>
<p>periodically to see if any of them have been deactivated. In order to</p>
<p>conserve target connection bandwidth, this is not done automatically.</p>
<p><b>Refresh</b></p>
<p>Downloads any data that the tracepoints have recorded from the target</p>
<p>and prints it to the command pane. In order to conserve target connection</p>
<p>bandwidth, this is not done automatically.</p>
<p><b>Dump Recorded</b></p>
<p><b>Data</b></p>
<p>Deletes the selected tracepoints. Once a tracepoint is deleted from its</p>
<p>source line, your program will not record data there anymore until you</p>
<p>set another tracepoint on the same line.</p>
<p>If you only want to remove a tracepoint temporarily, you can disable</p>
<p>it by clicking in the<b> Active</b> column.</p>
<p><b>Delete</b></p>
<p>Opens the<b> Tracepoint Editor</b> dialog (see âTracepoint Editor Dialogâ</p>
<p>on page 562).</p>
<p><b>Edit</b></p>
<p>Opens a dialog box that allows you to create a new tracepoint.</p>
<p><b>New Tracepoint</b></p>
<p>For information about the MULTI commands corresponding to these buttons, see</p>
<p>Chapter 21, âTracepoint Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>572</i></p>
<p><i>Chapter 24. Non-Intrusive Debugging with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The mouse and keyboard actions listed next are available from the<b> Tracepoints</b></p>
<p>tab.</p>
<p><b>Effect</b></p>
<p><b>Action</b></p>
<p>Displays the tracepoint's location in the Debugger.</p>
<p>Click a tracepoint</p>
<p>Opens the<b> Tracepoint Editor</b> dialog (see âTracepoint Editor Dialogâ</p>
<p>on page 562).</p>
<p>Double-click a</p>
<p>tracepoint</p>
<p>or</p>
<p>Press<b> Enter</b></p>
<p>Toggles the tracepoint to active or inactive.</p>
<p>Click the<b> Active</b> cell</p>
<p>of a tracepoint</p>
<p>Deletes the selected tracepoint(s).</p>
<p>Press<b> Delete</b></p>
<p>Opens a shortcut menu of common actions. See the following table for</p>
<p>a description of the menu items.</p>
<p>Right-click a</p>
<p>tracepoint</p>
<p>In the<b> Tracepoints</b> tab, you can use a context-sensitive menu to perform actions</p>
<p>on selected tracepoints. To open this menu, select one or more tracepoints from the</p>
<p>list and right-click. The shortcuts available from this menu are listed in the following</p>
<p>table.</p>
<p><b>Action</b></p>
<p><b>Item</b></p>
<p>Displays the tracepoint's location in the Debugger.</p>
<p><b>Show In Debugger</b></p>
<p>Makes all of the selected tracepoints active, so that the target will record</p>
<p>their associated data when they are hit.</p>
<p><b>Enable Selected</b></p>
<p><b>Tracepoints</b></p>
<p>Makes all of the selected tracepoints inactive, so that the target will not</p>
<p>record their associated data when they are hit.</p>
<p><b>Disable Selected</b></p>
<p><b>Tracepoints</b></p>
<p>Opens the<b> Tracepoint Editor</b> dialog on the selected tracepoint (see</p>
<p>âTracepoint Editor Dialogâ on page 562).</p>
<p><b>Edit Selected</b></p>
<p><b>Tracepoint</b></p>
<p>Deletes the selected tracepoints.</p>
<p><b>Delete Selected</b></p>
<p><b>Tracepoints</b></p>
<p>Opens the<b> Tracepoint Editor</b> dialog, which allows you to create a new</p>
<p>tracepoint (see âTracepoint Editor Dialogâ on page 562).</p>
<p><b>New Tracepoint</b></p>
<p><i>573</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Tracepoints Tab of the Breakpoints Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Debugging in Passive Mode</b></p>
<p>MULTI can operate in passive mode, which causes the Debugger to reject invasive</p>
<p>debugging actions that would significantly impact the functioning of the process</p>
<p>being debugged. For example, while in passive mode, MULTI rejects attempts to</p>
<p>halt the process, set breakpoints, write to memory, or write to registers. Setting</p>
<p>tracepoints, however, is permitted in passive mode. MULTI determines the current</p>
<p>mode (passive or non-passive) by querying the target when a connection is</p>
<p>established.</p>
<p><b>Note</b></p>
<p>Passive mode is not available with all targets. Additionally, passive mode</p>
<p>is not supported for programs compiled with run-time error checking</p>
<p>information. (The MULTI Debugger sets a breakpoint in these programs</p>
<p>to help it determine when a run-time error has occurred. This can result</p>
<p>in your target halting while the Debugger is still in passive mode.)</p>
<p>For those operating system integrations that support passive mode, it is possible to</p>
<p>enable or disable passive mode from the MULTI command pane. However, some</p>
<p>operating system integrations require a password to enter or exit passive mode.</p>
<p>Please refer to the documentation for your specific operating system integration to</p>
<p>determine whether a password is necessary, and if so, what the default value of the</p>
<p>password is.</p>
<p><b>Entering and Exiting Passive Mode</b></p>
<p>The<b> passive</b> command is used to enter and exit passive mode. For example, suppose</p>
<p>the current operating system integration supports both passive mode and passive</p>
<p>mode passwords, and that the current password for passive mode is</p>
<p>opensesame</p>
<p>.</p>
<p>Below is an example of a series of commands that demonstrate the function of</p>
<p>passive mode:</p>
<p>&gt; passive on opensesame</p>
<p>Passive mode state successfully changed.</p>
<p>&gt; halt</p>
<p>halting process...Halting is not allowed in passive mode.</p>
<p>&gt; passive off opensesame</p>
<p>Passive mode state successfully changed.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>574</i></p>
<p><i>Chapter 24. Non-Intrusive Debugging with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p>&gt; halt</p>
<p>halting process...done.</p>
<p>The</p>
<p>passive on opensesame</p>
<p>line causes MULTI to enter passive mode (if the</p>
<p>current operating system integration did not require a password, then the first line</p>
<p>would have been</p>
<p>passive on</p>
<p>). In this mode, intrusive debugging commands (such</p>
<p>as the</p>
<p>halt</p>
<p>command issued in line three of the example) are rejected. The</p>
<p>passive</p>
<p>off opensesame</p>
<p>line causes MULTI to exit passive mode. Thus, the</p>
<p>halt</p>
<p>command issued in the next line succeeds.</p>
<p>For more information about the<b> passive</b> command, see Chapter 21, âTracepoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>Entering passive mode disables all active software and hardware</p>
<p>breakpoints in the program you are debugging. These breakpoints must</p>
<p>be re-enabled manually after exiting passive mode (that is, they are not</p>
<p>automatically re-enabled).</p>
<p>The current state of passive mode is saved on the target for as long as the target is</p>
<p>running. MULTI queries the target upon connection to determine whether the target</p>
<p>is currently in passive mode. For example, if you connect to a target, enter passive</p>
<p>mode, disconnect from the target (but leave the target running), and then reconnect</p>
<p>to it, MULTI will still be in passive mode when you reconnect.</p>
<p><b>Setting the Passive Mode Password</b></p>
<p>The command:</p>
<p>passive password<i> old_pw new_pw</i></p>
<p>can be used to change the passive mode password. Again, suppose the current</p>
<p>password for passive mode is</p>
<p>opensesame</p>
<p>:</p>
<p>&gt; passive password opensesame albatross</p>
<p>Passive mode state successfully changed.</p>
<p>This command changes the password for entering and exiting passive mode from</p>
<p>opensesame</p>
<p>to</p>
<p>albatross</p>
<p>. This use of the<b> passive</b> command has no meaning</p>
<p>for operating system integrations that do not support passive mode passwords.</p>
<p><i>575</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Setting the Passive Mode Password</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For more information about the<b> passive</b> command, see Chapter 21, âTracepoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>For those operating system integrations that do support passive mode</p>
<p>passwords, the default password is implementation specific. For more</p>
<p>information, consult the documentation for your operating system</p>
<p>integration.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>576</i></p>
<p><i>Chapter 24. Non-Intrusive Debugging with Tracepoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 25</b></p>
<p><b>Run-Mode Debugging</b></p>
<p><b>Contents</b></p>
<p>Establishing Run-Mode Connections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>578</p>
<p>Loading a Run-Mode Program . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>579</p>
<p>The Task Manager . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>580</p>
<p>Working with AddressSpaces and Tasks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>581</p>
<p>Working with Task Groups in the Task Manager . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>584</p>
<p>Working with Run-Mode Breakpoints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>587</p>
<p>Task Manager GUI Reference . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>592</p>
<p>Task Group Configuration File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>600</p>
<p>OS-Awareness in Run Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>601</p>
<p>Profiling All Tasks in Your System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>603</p>
<h1 style="page-break-before:always; "></h1>
<p>When you debug a multitasking application, MULTI interacts with the target's</p>
<p>operating system in run mode, in freeze mode, or in both run and freeze mode</p>
<p>simultaneously. In run mode, the operating system kernel continues to run as you</p>
<p>halt and examine individual tasks. In freeze mode, the entire target system stops</p>
<p>when you examine tasks. For information about freeze-mode debugging, see</p>
<p>Chapter 26, âFreeze-Mode Debugging and OS-Awarenessâ on page 605. For</p>
<p>information about debugging in run mode and freeze mode, see âAutomatically</p>
<p>Establishing Run-Mode Connectionsâ on page 69.</p>
<p>MULTI supports run-mode debugging for special target environments comprised</p>
<p>of specific processor/RTOS/debug server combinations. The debug server must</p>
<p>support multitasking applications.</p>
<p><b>Note</b></p>
<p>In this chapter,<i> task</i> is used as a general term to describe the real-time</p>
<p>operating system's unit of execution. Specific terminology varies</p>
<p>according to the target's operating system (for example, a task may also</p>
<p>be called a<i> process</i> or a<i> thread</i>).</p>
<p><b>Establishing Run-Mode Connections</b></p>
<p>Before utilizing the run-mode debugging features described in this chapter, you</p>
<p>must establish a run-mode connection to your target via a debug server that supports</p>
<p>multitasking debugging, such as<b> rtserv</b> or<b> rtserv2</b>. For general information about</p>
<p>connecting, see Chapter 3, âConnecting to Your Targetâ on page 39. For specific</p>
<p>information about connecting with<b> rtserv</b> or<b> rtserv2</b>, see Chapter 5, âINDRT (rtserv)</p>
<p>Connectionsâ on page 77, or see Chapter 4, âINDRT2 (rtserv2) Connectionsâ</p>
<p>on page 59.</p>
<p>After you have connected to your target, the connection appears in the target list.</p>
<p>It's usually denoted by an entry labeled<b> Run mode target</b>. For information about</p>
<p>the way in which run-mode AddressSpaces and tasks appear in the target list, see</p>
<p>âDebugging Target List Itemsâ on page 16.</p>
<p><b>Note</b></p>
<p>If you want to simultaneously debug multiple targets in run mode, use</p>
<p>one instance of MULTI to establish all of the corresponding run-mode</p>
<p>connections. Distinct targets and applications are accessible for debugging</p>
<p><i>MULTI: Debugging</i></p>
<p><i>578</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>via the Debugger's target list (see âThe Target Listâ on page 15). If you</p>
<p>launch multiple instances of MULTI (for example, by double-clicking</p>
<p>the MULTI shortcut twice or by launching MULTI from the command</p>
<p>line twice), the result of operations between MULTI IDE tools is</p>
<p>undefined.</p>
<p><b>Loading a Run-Mode Program</b></p>
<p>Some run-mode targets, including INTEGRITY, allow you to dynamically download</p>
<p>programs onto the target after it has booted.</p>
<p>After establishing a run-mode connection, do one of the following to dynamically</p>
<p>download a program:</p>
<p>â¢</p>
<p>In the Debugger, select<b> Target</b> â<b> Load Module</b>.</p>
<p>â¢</p>
<p>In the Task Manager, select<b> Load</b> â<b> Load Module</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> load</b> command. For information</p>
<p>about this command, see âGeneral Target Connection Commandsâ in Chapter</p>
<p>18, âTarget Connection Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>The exact requirements for loading a module depend on your target operating system.</p>
<p>If you are running INTEGRITY, your target must be configured with a dynamic</p>
<p>loader. For more information, see âDynamic Downloadingâ in the<i> INTEGRITY</i></p>
<p><i>Development Guide</i>. For general information about debugging dynamically</p>
<p>downloaded INTEGRITY applications, see âRun-Mode Debuggingâ in the</p>
<p><i>INTEGRITY Development Guide</i> and âTroubleshootingâ in the<i> INTEGRITY</i></p>
<p><i>Development Guide</i>.</p>
<p><b>Note</b></p>
<p>Depending on your configuration, MULTI may attempt to restore</p>
<p>breakpoints saved from previous debugging sessions when you download</p>
<p>a program. (See the description of the<b> rememberBreakpoints</b> option in</p>
<p>âSession Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ</p>
<p>in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.)</p>
<p>INTEGRITY targets also allow programs to specify one or more tasks</p>
<p>that may automatically start as soon as the program has finished</p>
<p>downloading. Note that INTEGRITY versions 5 and earlier do not</p>
<p><i>579</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Loading a Run-Mode Program</i></p>
<h1 style="page-break-before:always; "></h1>
<p>guarantee that MULTI will be able to install breakpoints on the target</p>
<p>before tasks are allowed to begin execution. If you are using INTEGRITY</p>
<p>version 5 or earlier and you want breakpoints to be restored, perform one</p>
<p>of the following operations to prevent tasks from starting automatically:</p>
<p>â¢</p>
<p>In the applicable</p>
<p>Task</p>
<p>section(s) of your Integrate configuration file</p>
<p>(<b>.int</b>), set</p>
<p>StartIt</p>
<p>to</p>
<p>false</p>
<p>. Then rebuild your application.</p>
<p>â¢</p>
<p>Before downloading your program in MULTI, enable<b> Debug</b> â</p>
<p><b>Target Settings</b> â<b> Stop on Task Creation</b>.</p>
<p><b>The Task Manager</b></p>
<p>During a run-mode debugging session, you can use the Task Manager to work with</p>
<p>tasks created by your application. After connecting to a debug server that supports</p>
<p>multitasking debugging (see âEstablishing Run-Mode Connectionsâ on page 578),</p>
<p>do one of the following to open the Task Manager:</p>
<p>â¢</p>
<p>In the<b> Connection Organizer</b>, select<b> Target</b> â<b> Show Task Manager</b>.</p>
<p>â¢</p>
<p>In the Debugger, select<b> View</b> â<b> Task Manager</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> taskwindow</b> command. For</p>
<p>information about this command, see âGeneral View Commandsâ in Chapter</p>
<p>22, âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>580</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Each tab of the Task Manager corresponds to a<i> task group</i> (see âWorking with Task</p>
<p>Groups in the Task Managerâ on page 584).</p>
<p><b>Working with AddressSpaces and Tasks</b></p>
<p><b>Run-Mode AddressSpaces</b></p>
<p>Run-mode AddressSpaces are located in the target list under a CPU node of a</p>
<p>run-mode connection to the target, or they are located under an application (kernel</p>
<p>image or dynamically downloaded module). The application is in turn located under</p>
<p>a CPU node. A run-mode connection to a target is usually denoted by<b> Run mode</b></p>
<p><b>target</b>.</p>
<p><i>581</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Working with AddressSpaces and Tasks</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If you are using INTEGRITY version 10 or later and you select a run-mode</p>
<p>AddressSpace in the target list, the AddressSpace's source code appears in the source</p>
<p>pane. In general, the following operations are available:</p>
<p>â¢</p>
<p>Source browsing</p>
<p>â¢</p>
<p>Breakpoint manipulation (All breakpoints set here are any-task breakpoints.</p>
<p>For more information, see âAny-Task Breakpointsâ on page 587.)</p>
<p>If you are not using INTEGRITY version 10 or later and you select a run-mode</p>
<p>AddressSpace in the target list, the source pane is empty and the preceding operations</p>
<p>are unavailable.</p>
<p><b>Attaching to Tasks</b></p>
<p>Attaching to a task allows MULTI to obtain debugging access to that task. When</p>
<p>you attach to a task, MULTI automatically displays the task in a Debugger window.</p>
<p>Some operating systems require that you attach to a task before halting, killing, or</p>
<p>running it, while other operating systems allow you to perform these actions on</p>
<p>unattached tasks.</p>
<p>To attach to a task, do one of the following:</p>
<p>â¢</p>
<p>In the Task Manager, double-click the task.</p>
<p>â¢</p>
<p>In the Debugger's target list, select the task. (For information about identifying</p>
<p>run-mode tasks in the target list, see âDebugging Target List Itemsâ</p>
<p>on page 16.)</p>
<p><b>Note</b></p>
<p>When you have attached to a task that is listed as<b> Halted</b> in the target</p>
<p>list's<b> Status</b> column, you should avoid using programmatic means (for</p>
<p>example, INTEGRITY's</p>
<p>RunTask()</p>
<p>kernel call) to cause that task to</p>
<p>run. MULTI is not guaranteed to detect such target-initiated status</p>
<p>changes. To work around this problem, issue the<b> detach</b> command to</p>
<p>detach from the task, preferably before the target causes it to run. For</p>
<p>information about the<b> detach</b> command, see Chapter 2, âGeneral</p>
<p>Debugger Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>582</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Halting Tasks On Attach</b></p>
<p>Some operating systems require that you attach to a task before halting it. To</p>
<p>automatically halt a task as soon as you attach to it, do one of the following:</p>
<p>â¢</p>
<p>In the Task Manager, select<b> Options</b> â<b> Halt on Attach</b>.</p>
<p>â¢</p>
<p>In the Debugger, select<b> Debug</b> â<b> Target Settings</b> â<b> Halt on Attach</b>.</p>
<p>When the attached task opens in the Debugger, it is already halted.</p>
<p><b>Note</b></p>
<p>The<b> Halt on Attach</b> option is not available when MULTI is in passive</p>
<p>mode (see âDebugging in Passive Modeâ on page 574).</p>
<p><b>Debugging Run-Mode Tasks</b></p>
<p>When you attach to a task, MULTI automatically displays the task in the Debugger</p>
<p>window. To automatically display tasks in the Debugger as soon as the application</p>
<p>creates them, enable<b> Stop On Task Creation</b> and<b> Attach on Task Creation</b> from</p>
<p>the Task Manager's<b> Options</b> menu or from the Debugger's<b> Debug</b> â<b> Target</b></p>
<p><b>Settings</b> menu.</p>
<p>If you open a new Debugger window to debug each new task (see âOpening Multiple</p>
<p>Debugger Windowsâ on page 14), MULTI color-codes each task according to its</p>
<p>corresponding Debugger window. Any window that relates to debugging a particular</p>
<p>task is shaded in the same color as the task is shaded in the Task Manager. For</p>
<p>example, suppose you attach to a task that is shaded blue in the Task Manager. The</p>
<p>Debugger window that shows the task's code is also shaded blue. If you use a Browse</p>
<p>window to look at the procedures of the task, the Browse window is also shaded</p>
<p>blue.</p>
<p>Once a task is open in a Debugger window, you can halt or run the task from the</p>
<p>Debugger window itself or from the Task Manager. If a breakpoint is hit in a task</p>
<p>other than the one currently selected in the target list, the Debugger switches to that</p>
<p>task by default (provided that no other Debugger window is open on it and that the</p>
<p>currently selected task is not halted). For information about the configuration option</p>
<p>that allows you to control this behavior, see<b> targetWindowSwitchViewOnBpHit</b></p>
<p>in âOther Debugger Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ</p>
<p>in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><i>583</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Halting Tasks On Attach</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For information about debugging with TimeMachine, see âUsing TimeMachine</p>
<p>with OS Tasksâ on page 418.</p>
<p><b>Freezing the Task Manager's Task List Display</b></p>
<p>Because run-mode debugging allows some tasks to continue running while you</p>
<p>debug other tasks, the data in the Task Manager changes constantly. If you want to</p>
<p>take a snapshot of all the tasks at a certain moment, choose<b> View</b> â<b> Freeze Task</b></p>
<p><b>List</b>. This option freezes the task list display (see âTask List Paneâ on page 596),</p>
<p>not the underlying operating system. When the display is frozen, a message appears</p>
<p>in the status bar at the bottom of the Task Manager. You can modify task groups</p>
<p>while the window is frozen.</p>
<p><b>Tip</b></p>
<p>To change the rate at which MULTI refreshes the tasks in an unfrozen</p>
<p>Task Manager:</p>
<p>1.</p>
<p>In the Debugger or Project Manager, select<b> Config</b> â<b> Options</b>.</p>
<p>2.</p>
<p>In the<b> Options</b> window that appears, click the<b> Debugger</b> tab.</p>
<p>3.</p>
<p>Click the<b> More Debugger Options</b> button.</p>
<p>4.</p>
<p>Edit the<b> Interval to refresh Task Manager</b> field. For more</p>
<p>information, see âThe More Debugger Options Dialogâ in Chapter</p>
<p>8, âConfiguration Optionsâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book.</p>
<p><b>Working with Task Groups in the Task Manager</b></p>
<p>Task groups allow you to organize tasks, making it easier to work with multiple</p>
<p>tasks simultaneously. In addition, task groups provide the approach for group</p>
<p>breakpoints. (For information about group breakpoints, see âGroup Breakpointsâ</p>
<p>on page 588.)</p>
<p><b>Note</b></p>
<p>The Task Manager must be open in order to guarantee the availability of</p>
<p>all task group features.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>584</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>A task group can contain any task in the system, including tasks running on different</p>
<p>processors or in different address spaces. As you create task groups, they are</p>
<p>displayed as new tabs in the Task Manager. The name of the task group must consist</p>
<p>of one or more characters and cannot contain square brackets (</p>
<p>[</p>
<p>and</p>
<p>]</p>
<p>). In addition,</p>
<p>you cannot name a task group with one of the default task group names created by</p>
<p>MULTI (see next section).</p>
<p>To quickly create a task group that contains the appropriate tasks, select the tasks</p>
<p>in the Task Manager and click</p>
<p>.</p>
<p>You can attach to, halt, kill, and run all the tasks in a task group with a single action.</p>
<p>The<b> Group</b> menu contains several options that act on all of the tasks in the current</p>
<p>task group.</p>
<p>MULTI supports task groups whether or not the underlying debug server and debug</p>
<p>agent on the target support task groups. The ability of the underlying debug server</p>
<p>and target debug agent to support task groups affects synchronous operation latency.</p>
<p>For more information, see âSynchronous Operationsâ on page 589.</p>
<p><b>Default Task Groups</b></p>
<p>MULTI creates the following two default task groups:</p>
<p>â¢</p>
<p><b>All</b> â Contains all tasks that the operating system is using to run the application.</p>
<p>There are some internal RTOS tasks, however, that the operating system may</p>
<p>not include in the<b> All</b> group.</p>
<p>â¢</p>
<p><b>System</b> â Contains all tasks running on the target system, including the internal</p>
<p>RTOS tasks that the operating system excludes from the<b> All</b> group. For some</p>
<p>operating system/debug server combinations, the set of tasks contained in the</p>
<p><b>System</b> group is identical to the set of tasks contained in the<b> All</b> group.</p>
<p>In general, task group names are case-sensitive, but MULTI treats the two default</p>
<p>groups as being case-insensitive. As a result, you cannot create a group named<b> All</b></p>
<p>or<b> System</b>, no matter what the case combination. The<b> All</b> group has a tab in the</p>
<p>Task Manager, but the<b> System</b> group does not.</p>
<p>You cannot add tasks into or delete tasks from the<b> All</b> or<b> System</b> default groups.</p>
<p><i>585</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Default Task Groups</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Tip</b></p>
<p>When both the operating system and the debug server support task groups</p>
<p>and distinguish between the<b> System</b> and<b> All</b> default groups, halting the</p>
<p>group<b> System</b> freezes the target board and all application tasks. In this</p>
<p>environment, you can execute operations such as reliably dumping the</p>
<p>event log section, browsing kernel objects with the<b> OSA Explorer</b>, etc.</p>
<p>To halt the<b> System</b> task group, select<b> Group</b> â<b> Halt System</b>.</p>
<p>MULTI reserves the following task group names. They are not shown as tabs in</p>
<p>the Task Manager, but you should not use them for groups you create:</p>
<p>â¢</p>
<p><b>Current Task</b> â A label used to represent the special task group containing</p>
<p>only the corresponding task in the<b> Software Breakpoint Editor</b> (see âCreating</p>
<p>and Editing Software Breakpointsâ on page 130).</p>
<p>â¢</p>
<p><b>Group N/A</b> â A label used to indicate that task group is not available in the</p>
<p><b>Software Breakpoint Editor</b> (see âCreating and Editing Software Breakpointsâ</p>
<p>on page 130).</p>
<p>â¢</p>
<p><b>__multi_tmp_op_grp_*</b> â A temporary group name created by MULTI to</p>
<p>perform synchronous operations on the selected task if the underlying debug</p>
<p>server supports task groups. Whenever MULTI sends the synchronous operation</p>
<p>to the underlying debug server, the temporary group is automatically destroyed.</p>
<p>For more information, see âSynchronous Operationsâ on page 589.</p>
<p>â¢</p>
<p><b>__multi_tmp_bp_grp_*</b> â A temporary group name created by MULTI to set</p>
<p>a group breakpoint on one task. The group only contains the corresponding</p>
<p>task. When the corresponding group breakpoint is deleted, the temporary group</p>
<p>is automatically destroyed.</p>
<p>â¢</p>
<p><b>All AddressSpace names for INTEGRITY</b> â On INTEGRITY versions 5</p>
<p>and later, AddressSpace names can be used as groups when using group</p>
<p>breakpoints. However, on INTEGRITY version 5 only, AddressSpace names</p>
<p>cannot be used as groups when using the<b> groupaction</b> command. (For</p>
<p>information about the<b> groupaction</b> command, see Chapter 19, âTask Group</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.)</p>
<p>You cannot add tasks into or delete tasks from any AddressSpace group via</p>
<p>the Task Manager.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>586</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Configuring Task Group Settings</b></p>
<p>For advanced configuration options, see âTask Group Configuration Fileâ</p>
<p>on page 600.</p>
<p><b>Working with Run-Mode Breakpoints</b></p>
<p>MULTI supports three types of run-mode breakpoints: task-specific breakpoints,</p>
<p>any-task breakpoints, and group breakpoints. Each of these is described in the</p>
<p>following sections.</p>
<p><b>Task-Specific Breakpoints</b></p>
<p>A task-specific breakpoint is a breakpoint that only a single task can hit. To set a</p>
<p>task-specific breakpoint, perform the following steps:</p>
<p>1.</p>
<p>Attach to a task by double-clicking it in the Task Manager or selecting it in</p>
<p>the Debugger's target list.</p>
<p>2.</p>
<p>In the Debugger window, click a breakdot (</p>
<p>).</p>
<p>A task-specific breakpoint is indicated by a normal breakpoint icon (</p>
<p>).</p>
<p><b>Any-Task Breakpoints</b></p>
<p>An any-task breakpoint is a breakpoint that every task in the AddressSpace (except</p>
<p>system tasks, which cannot be debugged in run mode) can hit. An any-task</p>
<p>breakpoint is indicated by a breakpoint icon with the letters</p>
<p>AT</p>
<p>inside of it (</p>
<p>).</p>
<p>You can set an any-task breakpoint in a run-mode AddressSpace (if the target RTOS</p>
<p>is supported) or in a task. To set the breakpoint from a run-mode AddressSpace,</p>
<p>select the AddressSpace in the target list and then click a breakdot (</p>
<p>) in the</p>
<p>Debugger window.</p>
<p>To set the breakpoint from a task, select the task in the target list and hold the<b> Shift</b></p>
<p>key as you click a breakdot (</p>
<p>) in the Debugger window.</p>
<p>To set an any-task breakpoint from the command pane, use the<b> sb at</b> command.</p>
<p><i>587</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Configuring Task Group Settings</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For example:</p>
<p><b>sb at<i></b> function#5</i></p>
<p>sets an any-task breakpoint at line 5 of the function</p>
<p><i>function</i></p>
<p>. For more information</p>
<p>about the<b> sb</b> command, see Chapter 3, âBreakpoint Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>When a task hits an any-task breakpoint, all other running tasks continue to execute.</p>
<p><b>Group Breakpoints</b></p>
<p>A group breakpoint is a breakpoint set on a group of tasks such that any task in the</p>
<p>group can hit the breakpoint. When a task hits the breakpoint, the task, the whole</p>
<p>group, or another group of tasks stops. In addition to saving time, applying a halt</p>
<p>operation to an entire task group allows you to perform synchronous halts on multiple</p>
<p>tasks (see âSynchronous Operationsâ on page 589). A group breakpoint is indicated</p>
<p>by a breakpoint icon with the letters</p>
<p>GT</p>
<p>inside it (</p>
<p>).</p>
<p>You can set a group breakpoint via the<b> Software Breakpoint Editor</b> (see âCreating</p>
<p>and Editing Software Breakpointsâ on page 130) or via the<b> b</b> command. For</p>
<p>information about the<b> b</b> command, see Chapter 3, âBreakpoint Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>Group breakpoints are not available in all environments. If you cannot set a group</p>
<p>breakpoint but want to make use of a similar behavior, you can use the<b> b</b> command</p>
<p>to set one or more individual breakpoints that invoke the<b> groupaction</b> command.</p>
<p>The<b> groupaction</b> command allows you to halt all tasks belonging to the specified</p>
<p>task group(s). For an example, see âSetting Breakpoints for Task Groupsâ</p>
<p>on page 589. For more information about the<b> b</b> command, see Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book. For</p>
<p>more information about the<b> groupaction</b> command, see Chapter 19, âTask Group</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b></p>
<p>The Debugger may not be able to restore saved group breakpoints.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>588</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Synchronous Operations</b></p>
<p><i>Synchronous operations</i> run and/or halt a group of tasks<i> almost</i> at the same time.</p>
<p>The accuracy of synchronous operations varies for different debugging environments.</p>
<p>If the debug server and the corresponding RTOS debug agent support task groups</p>
<p>(as is the case with INTEGRITY), accurate synchronous operations and group</p>
<p>breakpoints can be achieved; otherwise, group breakpoints are not supported. In</p>
<p>this case MULTI sends out separate commands to each task, and the latency time</p>
<p>for the operations on different tasks is unpredictable (depending on various factors</p>
<p>such as network traffic, the RTOS debug agent's status, the target's speed, etc.).</p>
<p>On an RTOS that supports task groups, operations on a group will be synchronous</p>
<p>if the group is<i> fine</i>. To determine whether a group is fine, select<b> View</b> â<b> Visualize</b></p>
<p><b>Fine Groups</b> in the Task Manager. If the tab corresponding to the group is marked</p>
<p>with an asterisk, the group is fine.</p>
<p>Manipulating a group may change its status. For example, if you are using a debug</p>
<p>server that does not support tasks from different CPUs in the same group, and you</p>
<p>try to add tasks from different CPUs into an existing fine group, the group's status</p>
<p>becomes<i> not fine</i>.</p>
<p>When performing operations on multiple tasks selected in the Task Manager, MULTI</p>
<p>attempts to take advantage of task group support in the debug server and in the</p>
<p>corresponding RTOS debug agent. For example, when you halt selected tasks,</p>
<p>MULTI attempts to create a temporary task group for the selected tasks. If such a</p>
<p>fine group can be created on the debug server, MULTI sends one command to the</p>
<p>debug server for the entire group, thus guaranteeing synchronization accuracy by</p>
<p>the debug server and the RTOS debug agent. When performing operations on</p>
<p>multiple tasks selected in the target list, however, MULTI does not attempt to</p>
<p>construct a fine group. Instead, MULTI sends separate commands for each task</p>
<p>selected, performing run-control operations one at a time.</p>
<p><b>Setting Breakpoints for Task Groups</b></p>
<p>This section contains specific information about using task groups when setting</p>
<p>breakpoints. For information about task groups, see âWorking with Task Groups</p>
<p>in the Task Managerâ on page 584. For more information about the<b> b</b> command</p>
<p>referenced in this section, see Chapter 3, âBreakpoint Command Referenceâ in the</p>
<p><i>589</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Synchronous Operations</i></p>
<h1 style="page-break-before:always; "></h1>
<p><i>MULTI: Debugging Command Reference</i> book. For more information about group</p>
<p>breakpoints, also referenced in this section, see âGroup Breakpointsâ on page 588.</p>
<p>Task groups are very powerful when setting breakpoints. By using task groups, you</p>
<p>can:</p>
<p>â¢</p>
<p>Set a group breakpoint such that any task in the group can hit the breakpoint.</p>
<p>For example, to set a group breakpoint at address</p>
<p>0x1423</p>
<p>on the<b> Tasks in</b></p>
<p><b>App1</b> task group, enter the following in the Debugger's command pane:</p>
<p>b /type_gt @&quot;Tasks in App1&quot; 0x1423</p>
<p>When any task that belongs to the<b> Tasks in App1</b> task group hits the breakpoint,</p>
<p>that task is stopped.</p>
<p>â¢</p>
<p>Stop an entire task group when a group breakpoint is hit.</p>
<p>For example, suppose you want to halt all tasks in the<b> Callers</b> task group</p>
<p>whenever a task in the<b> Tasks in App1</b> task group hits a breakpoint. You would</p>
<p>enter:</p>
<p>b /type_gt @&quot;Tasks in App1&quot; /trigger @&quot;Callers&quot; 0x1423</p>
<p>When any task that belongs to the<b> Tasks in App1</b> task group hits the breakpoint,</p>
<p>that task, along with all tasks in the<b> Callers</b> task group, is stopped. (The</p>
<p>/trigger @<i>task_group</i></p>
<p>argument simultaneously stops multiple tasks when</p>
<p>a breakpoint is hit.)</p>
<p>If you want to create a group breakpoint only on the current task to stop all</p>
<p>tasks in another group, it is not necessary for you to explicitly create a task</p>
<p>group only containing the current task. MULTI does so automatically, and</p>
<p>when the breakpoint is removed, the corresponding temporary task group is</p>
<p>automatically destroyed.</p>
<p>For example, suppose you want to halt all tasks in the<b> Callers</b> task group</p>
<p>whenever the current task hits a breakpoint. You would enter:</p>
<p>b /type_gt /trigger @&quot;Callers&quot;</p>
<p>0x1423</p>
<p><i>MULTI: Debugging</i></p>
<p><i>590</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If, as in the following command, you do not specify</p>
<p>/trigger @<i>task_group</i></p>
<p>:</p>
<p>b /type_gt 0x1423</p>
<p>the effect of the group breakpoint is equivalent to the effect of a normal</p>
<p>breakpoint.</p>
<p>â¢</p>
<p>Use an individual breakpoint to invoke an action on an entire task group. For</p>
<p>example, to create a breakpoint on the current task that will halt all tasks in the</p>
<p><b>Pizza Tasks</b> group, enter:</p>
<p>b main#21 {groupaction -h @&quot;Pizza Tasks&quot;}</p>
<p>The<b> groupaction</b> command also supports running tasks (</p>
<p>-r</p>
<p>) and, for some</p>
<p>operating systems, stepping tasks (</p>
<p>-s</p>
<p>). For more information about this</p>
<p>command, see Chapter 19, âTask Group Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>As long as the target operating system supports task groups, these actions are</p>
<p>performed on individual tasks almost simultaneously. If an operating system</p>
<p>does not support task groups, MULTI sends out separate commands to each</p>
<p>task in the task group. In this case, the latency time for the operations on</p>
<p>different tasks is unpredictable, depending on various factors such as network</p>
<p>traffic, the RTOS debug agent's status, and the target's speed.</p>
<p><b>Note</b></p>
<p>When synchronous group operations are specified in a breakpoint</p>
<p>command list (as in the preceding example), the amount of time that</p>
<p>elapses between hitting the breakpoint and executing the synchronous</p>
<p>group operations is not predictable.</p>
<p><i>591</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Synchronous Operations</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Task Manager GUI Reference</b></p>
<p>This section describes the individual options available in the Task Manager.</p>
<p><b>Note</b></p>
<p>If a debugging environment does not support a certain option, that option</p>
<p>is not displayed in the Task Manager.</p>
<p><b>Menu Bar</b></p>
<p>The Task Manager contains the following menus:</p>
<p>â¢</p>
<p>The<b> Options</b>,<b> View</b>, and<b> Group</b> menus are described below.</p>
<p>â¢</p>
<p>The<b> Target</b>,<b> Load</b>, and<b> Unload</b> menus contain menu items that are duplicated</p>
<p>in the Debugger's<b> Target</b> menu. See âThe Target Menuâ on page 680.</p>
<p>â¢</p>
<p>The<b> Tools</b> menu contains menu items that are duplicated in the Debugger's</p>
<p><b>Tools</b> menu. See âThe Tools Menuâ on page 685.</p>
<p>â¢</p>
<p>The<b> Config</b> menu is the same as the Debugger's<b> Config</b> menu. See âThe Config</p>
<p>Menuâ on page 687.</p>
<p>â¢</p>
<p>The<b> Windows</b> menu is the same as the Debugger's<b> Windows</b> menu. See âThe</p>
<p>Windows Menuâ on page 690.</p>
<p>â¢</p>
<p>The<b> Help</b> menu contains menu items that are duplicated in the Debugger's</p>
<p><b>Help</b> menu. See âThe Help Menuâ on page 691. In addition, the<b> Task Manager</b></p>
<p><b>Help</b> menu item has been added to show Task Manager online help information.</p>
<p><b>Options Menu</b></p>
<p>The Task Manager<b> Options</b> menu contains the following menu items.</p>
<p><b>Note</b></p>
<p>MULTI remembers the settings of the toggle menu items across debugging</p>
<p>sessions.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Specifies whether you want the target's operating system to halt each</p>
<p>task as soon as it is created by the application.</p>
<p><b>Stop on Task</b></p>
<p><b>Creation</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>592</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Specifies whether you want to debug the newly created task. If enabled,</p>
<p>each newly created task is halted and opened in the Debugger window.</p>
<p>This option is applicable only when the<b> Stop on Task Creation</b> menu</p>
<p>item is selected.</p>
<p><b>Attach on Task</b></p>
<p><b>Creation</b></p>
<p>Specifies whether you want MULTI to automatically halt tasks when</p>
<p>you attach to them. You cannot use this option when MULTI is in passive</p>
<p>mode (see âDebugging in Passive Modeâ on page 574).</p>
<p><b>Halt on Attach</b></p>
<p>Specifies whether you want MULTI to automatically run tasks when</p>
<p>you detach from them. You cannot use this option when MULTI is in</p>
<p>passive mode (see âDebugging in Passive Modeâ on page 574).</p>
<p><b>Run on Detach</b></p>
<p>Prints the tasks currently listed in the Task Manager.</p>
<p><b>Print</b></p>
<p>Closes the Task Manager.</p>
<p><b>Close</b></p>
<p><b>View Menu</b></p>
<p>The Task Manager<b> View</b> menu contains the following menu items.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Recursively expands all selected entries in the task list hierarchy.</p>
<p><b>Expand Selected</b></p>
<p><b>Entries</b></p>
<p>Recursively expands all entries in the task list hierarchy.</p>
<p><b>Expand All Entries</b></p>
<p>Collapses all selected entries in the task list hierarchy.</p>
<p><b>Collapse Selected</b></p>
<p><b>Entries</b></p>
<p>Collapses all entries in the task list hierarchy.</p>
<p><b>Collapse All Entries</b></p>
<p>Freezes or unfreezes the task list display. For more information, see</p>
<p>âFreezing the Task Manager's Task List Displayâ on page 584.</p>
<p><b>Freeze Task List</b></p>
<p>Changes how tasks are displayed. When<b> Flat View</b> is selected, the tasks</p>
<p>are combined together in a single list, regardless of whether they belong</p>
<p>to the same processor or high-level RTOS object. When<b> Flat View</b> is</p>
<p>cleared, tasks are organized according to processor or high-level object.</p>
<p>For more information, see âTask List Paneâ on page 596.</p>
<p><b>Flat View</b></p>
<p>Toggles the display of an asterisk (</p>
<p>*</p>
<p>) on Task Manager tabs that</p>
<p>correspond to fine task groups. For more information, see âSynchronous</p>
<p>Operationsâ on page 589.</p>
<p><b>Visualize Fine</b></p>
<p><b>Groups</b></p>
<p>Toggles the display of Address Space IDs in the second column of the</p>
<p>Task Manager.</p>
<p><b>Show AddressSpace</b></p>
<p><b>IDs</b></p>
<p><i>593</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Menu Bar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Opens the OSA Explorer for the RTOS running on the target. For more</p>
<p>information, see âThe OSA Explorerâ on page 602.</p>
<p>This menu item is only available for some RTOSes.</p>
<p><b>OSA Explorer</b></p>
<p>Opens the<b> Breakpoints</b> window for group breakpoints set on the current</p>
<p>connection. For reference information about the<b> Breakpoints</b> window,</p>
<p>see âThe Breakpoints Windowâ on page 146.</p>
<p><b>Group Breakpoints</b></p>
<p><b>Group Menu</b></p>
<p>The Task Manager<b> Group</b> menu contains the following menu items.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Creates a new task group.</p>
<p><b>Create New Group</b></p>
<p>Deletes an existing task group.</p>
<p><b>Delete Existing</b></p>
<p><b>Group</b></p>
<p>Adds the selected tasks in the current task group into another task group.</p>
<p><b>Add Selected Tasks</b></p>
<p><b>into Another Group</b></p>
<p>Removes the selected tasks from the current task group. You cannot</p>
<p>delete tasks from the default task group<b> All</b>.</p>
<p><b>Delete Selected</b></p>
<p><b>Tasks</b></p>
<p>Resumes the selected tasks in the current task group.</p>
<p><b>Continue Selected</b></p>
<p><b>Tasks</b></p>
<p>Halts the selected tasks in the current task group.</p>
<p><b>Halt Selected Tasks</b></p>
<p>Single-steps the selected tasks in the current task group, stepping into</p>
<p>functions.</p>
<p><b>Single Step (into</b></p>
<p><b>function) Selected</b></p>
<p><b>Tasks</b></p>
<p>Single-steps the selected tasks in the current task group, stepping over</p>
<p>functions.</p>
<p><b>Single Step (over</b></p>
<p><b>function) Selected</b></p>
<p><b>Tasks</b></p>
<p>Kills the selected tasks in the current task group.</p>
<p><b>Kill Selected Tasks</b></p>
<p>Attaches to the selected tasks in the current task group.</p>
<p><b>Attach to Selected</b></p>
<p><b>Tasks</b></p>
<p>Detaches from the selected tasks in the current task group.</p>
<p><b>Detach from</b></p>
<p><b>Selected Tasks</b></p>
<p>Resumes all tasks in the current task group.</p>
<p><b>Continue Tasks in</b></p>
<p><b>Current Group</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>594</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Halts all tasks in the current task group.</p>
<p><b>Halt Tasks in</b></p>
<p><b>Current Group</b></p>
<p>Kills all tasks in the current task group.</p>
<p><b>Kill Tasks in</b></p>
<p><b>Current Group</b></p>
<p>Attaches to all tasks in the current task group.</p>
<p><b>Attach to Tasks in</b></p>
<p><b>Current Group</b></p>
<p>Detaches from all tasks in the current task group.</p>
<p><b>Detach from Tasks</b></p>
<p><b>in Current Group</b></p>
<p>Halts all tasks on the target system, thereby freezing the target. This</p>
<p>option is not supported on all operating systems.</p>
<p><b>Halt System</b></p>
<p>Restores the tasks on the target to the status they held before the system</p>
<p>was halted.</p>
<p><b>Run System</b></p>
<p>For more information about task groups, refer to âWorking with Task Groups in</p>
<p>the Task Managerâ on page 584.</p>
<p><b>Toolbar</b></p>
<p>The Task Manager toolbar contains the following buttons.</p>
<p><b>Meaning</b></p>
<p><b>Button</b></p>
<p>Single-steps the selected tasks in the current task group, stepping into</p>
<p>functions.</p>
<p>Single-steps the selected tasks in the current task group, stepping over</p>
<p>functions.</p>
<p>Resumes the selected tasks in the current task group.</p>
<p>Halts the selected tasks in the current task group.</p>
<p>Kills the selected tasks in the current task group.</p>
<p>Attaches to the selected tasks in the current task group.</p>
<p>Detaches from the selected tasks in the current task group.</p>
<p>Adds the selected tasks in the current task group into another task group.</p>
<p><i>595</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Toolbar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Button</b></p>
<p>Removes the selected tasks from the current task group. You cannot</p>
<p>delete tasks from the default task group<b> All</b>.</p>
<p>Freezes or unfreezes the display of the Task Manager window. When</p>
<p>the display is frozen (the button is down), a message appears in the</p>
<p>status bar at the bottom of the window. For more information, see</p>
<p>âFreezing the Task Manager's Task List Displayâ on page 584.</p>
<p>Disconnects from the target.</p>
<p>Opens a<b> Breakpoints</b> window for the group breakpoints set on the</p>
<p>current connection. See âViewing Breakpoint and Tracepoint</p>
<p>Informationâ on page 128.</p>
<p>Opens the current task's program in the Project Manager. If there is no</p>
<p>current task, the default project opens in the Project Manager.</p>
<p>Dumps the event log and displays events in the MULTI EventAnalyzer.</p>
<p>This button is only available for some RTOSes.</p>
<p>Opens the OSA Explorer on the RTOS running on the target. For more</p>
<p>information, see âThe OSA Explorerâ on page 602.</p>
<p>This button is only available for some RTOSes.</p>
<p>Prints the tasks currently listed in the Task Manager.</p>
<p><b>Task List Pane</b></p>
<p>The area below the toolbar is the task list pane, where tasks and other kinds of</p>
<p>objects (such as CPU nodes) are listed. The columns that are displayed for each</p>
<p>task vary according to your operating system. For example, a column might be</p>
<p>labeled<b> Thread</b> or<b> Process</b> depending on the terminology used by the operating</p>
<p>system.</p>
<p>By default, tasks are listed in a hierarchical structure. The leaf nodes in the</p>
<p>hierarchies are the tasks; the non-leaf nodes represent more general concepts in the</p>
<p>corresponding RTOS (for example, CPUs and AddressSpaces on INTEGRITY).</p>
<p>Non-leaf nodes cannot be sorted. To flatten the hierarchy and list all tasks in one</p>
<p>list, choose<b> View</b> â<b> Flat View</b>. (This menu item is not available for customized</p>
<p>task groups.)</p>
<p><i>MULTI: Debugging</i></p>
<p><i>596</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Non-leaf nodes are color-coded according to MULTI's color settings. They are</p>
<p>displayed as follows:</p>
<p>â¢</p>
<p>First-level nodes (from the top of the hierarchy) are displayed in the color</p>
<p>specified for strings.</p>
<p>â¢</p>
<p>Second-level nodes are displayed in the color specified for characters.</p>
<p>â¢</p>
<p>Third-level nodes are displayed in the color specified for integers.</p>
<p>Task information is displayed in the (foreground) text color. Whenever a task is</p>
<p>displayed in a Debugger, the corresponding entry in the task list pane has the same</p>
<p>background color as the corresponding Debugger window.</p>
<p>Debugging-related statuses in the<b> Status</b> column are colored so that you can easily</p>
<p>identify them. RTOS statuses are not colored. Many of the statuses that appear in</p>
<p>the Task Manager also appear in the Debugger target list. For more information,</p>
<p>see âThe Status Columnâ on page 19.</p>
<p>Each time the Task Manager is opened, MULTI automatically displays tasks with</p>
<p>the hierarchies expanded. After that, you control how the hierarchies are displayed.</p>
<p>Whenever the Task Manager window is refreshed, MULTI automatically resizes</p>
<p>the columns so that all text is visible. However, once you manually change a</p>
<p>column's width, MULTI no longer resizes the columns when it refreshes the display.</p>
<p>MULTI maintains changes that you make to the Task Manager window (such as</p>
<p>modifications to its position) across debugging sessions.</p>
<p><b>Information Pane</b></p>
<p>The area below the task list pane is the information pane, in which the MULTI</p>
<p>command pane, target pane, I/O pane, serial terminal pane, Python pane, or traffic</p>
<p>pane can be displayed.</p>
<p>By default, the MULTI command pane is shown in the information pane area, but</p>
<p>you can switch to another pane by clicking the corresponding tab at the bottom of</p>
<p>the Task Manager window.</p>
<p><i>597</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Information Pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Tab</b></p>
<p>Shows the MULTI command pane in the information pane area. The</p>
<p>MULTI command pane located in the Task Manager supports a subset</p>
<p>of the commands that the command pane located in the Debugger does.</p>
<p>If you issue a command in the Task Manager, and the output reports</p>
<p>that it does not work in the current context, run it from the Debugger</p>
<p>instead.</p>
<p><b>Cmd</b> or<b> Cmd*</b></p>
<p>Shows the target pane in the information pane area.</p>
<p><b>Trg</b> or<b> Trg*</b></p>
<p>Shows the I/O pane in the information pane area.</p>
<p><b>I/O</b> or<b> I/O*</b></p>
<p>Shows the serial terminal pane in the information pane area.</p>
<p><b>Srl</b> or<b> Srl*</b></p>
<p>Shows the Python pane in the information pane area.</p>
<p><b>Py</b> or<b> Py*</b></p>
<p>Shows the traffic pane in the information pane area.</p>
<p><b>Tfc</b> or<b> Tfc*</b></p>
<p>As in the MULTI Debugger window, an asterisk (</p>
<p>*</p>
<p>) at the end of a tab name</p>
<p>indicates that new messages have arrived in the corresponding pane.</p>
<p>You can change the height of the information pane by dragging the bar that separates</p>
<p>it from the task list pane. To automatically resize the panes so that they share the</p>
<p>vertical window space evenly, double-click the separator bar.</p>
<p><b>The Task Manager Shortcut Menu</b></p>
<p>You can use the mouse to perform useful operations on selected objects, such as</p>
<p>expanding or contracting a node and attaching to tasks. Right-clicking in the task</p>
<p>list pane opens a shortcut menu with the following items, which perform the same</p>
<p>functions as the corresponding items in the menu and toolbar. The appearance of</p>
<p>certain menu items is dependent upon your debug server.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Specifies whether you want the target's operating system to halt each</p>
<p>task as soon as it is created by the application.</p>
<p><b>Stop on Task</b></p>
<p><b>Creation</b></p>
<p>Specifies whether you want to debug newly created tasks. If selected,</p>
<p>each newly created task is halted and displayed in a Debugger window.</p>
<p>This option is applicable only when<b> Stop on Task Creation</b> is also</p>
<p>selected.</p>
<p><b>Debug on Task</b></p>
<p><b>Creation</b></p>
<p>Specifies whether you want MULTI to automatically halt tasks when</p>
<p>you attach to them. You cannot use this option when MULTI is in</p>
<p>passive mode (see âDebugging in Passive Modeâ on page 574).</p>
<p><b>Halt on Attach</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>598</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Specifies whether you want MULTI to automatically run tasks when</p>
<p>you detach from them. You cannot use this option when MULTI is in</p>
<p>passive mode (see âDebugging in Passive Modeâ on page 574).</p>
<p><b>Run on Detach</b></p>
<p>Freezes or unfreezes the task list display. For more information, see</p>
<p>âFreezing the Task Manager's Task List Displayâ on page 584.</p>
<p><b>Freeze Task List</b></p>
<p>Changes how tasks are displayed. When<b> Flat View</b> is selected, the tasks</p>
<p>are combined together in a single list, regardless of whether they belong</p>
<p>to the same processor or high-level RTOS object. When<b> Flat View</b> is</p>
<p>cleared, tasks are organized according to processor or high-level object.</p>
<p>This menu item is not available for customized task groups.</p>
<p>For more information, see âTask List Paneâ on page 596.</p>
<p><b>Flat View</b></p>
<p>Expands the entire sub-tree for all selected entries. This has no effect</p>
<p>on the task entries because they have no sub-trees.</p>
<p><b>Expand Selected</b></p>
<p><b>Entries</b></p>
<p>Attaches to the selected tasks. This has no effect on non-task entries.</p>
<p><b>Attach to Selected</b></p>
<p><b>Tasks</b></p>
<p>Detaches from the selected tasks.</p>
<p><b>Detach from</b></p>
<p><b>Selected Tasks</b></p>
<p>Halts the selected tasks.</p>
<p><b>Halt Selected Tasks</b></p>
<p>Resumes the selected tasks.</p>
<p><b>Continue Selected</b></p>
<p><b>Tasks</b></p>
<p>Single-steps the selected tasks.</p>
<p><b>Step Selected Tasks</b></p>
<p>Detaches from all attached tasks in the current task group.</p>
<p><b>Detach from Tasks</b></p>
<p><b>in Current Group</b></p>
<p>Halts all tasks in the current task group.</p>
<p><b>Halt Tasks in</b></p>
<p><b>Current Group</b></p>
<p>Resumes all tasks in the current task group.</p>
<p><b>Continue Tasks in</b></p>
<p><b>Current Group</b></p>
<p>Single-steps through all tasks in the current task group.</p>
<p><b>Step Tasks in</b></p>
<p><b>Current Group</b></p>
<p>Halts all tasks on the target system, thereby freezing the target. This</p>
<p>option is not supported on all operating systems.</p>
<p><b>Halt System</b></p>
<p>Restores the tasks on the target to the status they held before the system</p>
<p>was halted.</p>
<p><b>Run System</b></p>
<p>Adds the selected tasks into another task group.</p>
<p><b>Add Selected Tasks</b></p>
<p><b>into Group</b></p>
<p><i>599</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Task Manager Shortcut Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Removes the selected tasks from the current task group.</p>
<p><b>Delete Selected</b></p>
<p><b>Tasks from Group</b></p>
<p>Displays Address Space IDs in the second column of the Task Manager.</p>
<p><b>Show AddressSpace</b></p>
<p><b>IDs</b></p>
<p>Displays or hides the corresponding column.</p>
<p><i><b>Other entries</b></i></p>
<p><b>Note</b></p>
<p>In the shortcut menu, the word</p>
<p>Task</p>
<p>is replaced with the corresponding</p>
<p>terminology used by the underlying RTOS (such as</p>
<p>Process</p>
<p>or</p>
<p>Thread</p>
<p>).</p>
<p><b>Task Group Configuration File</b></p>
<p>The definitions for task groups are persistent across debugging sessions. These</p>
<p>definitions are stored in a configuration file. When launching MULTI from the</p>
<p>command line, use the<b> -tv</b> option to specify which configuration file is to be used</p>
<p>in the debugging session. For example:</p>
<p>-tv mytaskview.tvc</p>
<p>If no file extension is given in the task view configuration filename,<b> .tvc</b> is appended</p>
<p>to the filename. If no configuration file is specified from the command line,</p>
<p><b>taskview.tvc</b> from your local configuration directory is used.</p>
<p>For each group, MULTI keeps a task fingerprint for each task in the group. Whenever</p>
<p>the group is to be displayed (when you select the corresponding tab in the Task</p>
<p>Manager), MULTI uses this task fingerprint to determine which tasks to display.</p>
<p>Considering different debugging environments, MULTI provides the following</p>
<p>three criteria to match a task against a task fingerprint.</p>
<p>â¢</p>
<p>Task Id + Hierarchy</p>
<p>â When a task's identifier (a number) and the</p>
<p>hierarchy path are the same as those kept in a task fingerprint of a group, the</p>
<p>task is considered to be in the group.</p>
<p>â¢</p>
<p>Task Name + Hierarchy</p>
<p>â When a task's name and the hierarchy path are</p>
<p>the same as those kept in a task fingerprint of a group, the task is considered</p>
<p>to be in the group.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>600</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Task Id or Name + Hierarchy</p>
<p>â When a task's name or identifier and</p>
<p>the hierarchy path are the same as those kept in a task fingerprint of a group,</p>
<p>the task is considered to be in the group.</p>
<p>See also the description of the<b> taskMatchCriteria</b> configuration option in âThe</p>
<p>More Debugger Options Dialogâ in Chapter 8, âConfiguration Optionsâ in the</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p>MULTI also provides a configuration option<b> deleteDeadTaskFromGroup</b> to tell</p>
<p>the Task Manager to delete<i> dead</i> task fingerprints from the task group. When you</p>
<p>display a task group by clicking the corresponding tab, if there is no live task for a</p>
<p>task fingerprint, the task fingerprint is<i> dead</i>. For example, a group created in the</p>
<p>last debugging session contains a fingerprint for</p>
<p>task1</p>
<p>, but</p>
<p>task1</p>
<p>is not on the</p>
<p>task list at present because the task has not yet been created by the program in the</p>
<p>current debugging session. If the configuration is on when you click the tab for the</p>
<p>group, the Task Manager permanently removes the fingerprint for</p>
<p>task1</p>
<p>from the</p>
<p>group. If this option is off, the fingerprint for</p>
<p>task1</p>
<p>is not removed and</p>
<p>task1</p>
<p>shows up when it is created. However, the fingerprints for zombied tasks are not</p>
<p>cleaned up from the group. (For more information about the</p>
<p><b>deleteDeadTaskFromGroup</b> option, see âThe More Debugger Options Dialogâ</p>
<p>in Chapter 8, âConfiguration Optionsâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book.)</p>
<p><b>Note</b></p>
<p>The configuration file contains the information about group definitions</p>
<p>and synchronous operations on tasks.</p>
<p><b>OS-Awareness in Run Mode</b></p>
<p>Two OS-aware tools allow you to browse OS information while debugging in run</p>
<p>mode: the<b> OSA Explorer</b> and the OSA Object Viewer. The<b> OSA Explorer</b> is useful</p>
<p>for browsing information about an entire operating system, while the OSA Object</p>
<p>Viewer is useful for browsing information about an individual INTEGRITY object.</p>
<p>The following sections briefly describe each tool.</p>
<p><i>601</i></p>
<p><i>Green Hills Software</i></p>
<p><i>OS-Awareness in Run Mode</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The OSA Explorer</b></p>
<p>The<b> OSA Explorer</b> shows INTEGRITY operating system tasks and other objects</p>
<p>on the target in run mode. You can launch an<b> OSA Explorer</b> anytime; however, if</p>
<p>the system is not halted, doing so causes MULTI to halt the system. In this case,</p>
<p>closing the<b> OSA Explorer</b> causes MULTI to resume system execution. For more</p>
<p>information about<b> System</b> halts, see âDefault Task Groupsâ on page 585.</p>
<p>To launch an<b> OSA Explorer</b> in run mode, do one of the following:</p>
<p>â¢</p>
<p>In the Task Manager or Debugger, click the<b> OSA Explorer</b> button (</p>
<p>).</p>
<p>â¢</p>
<p>In the Task Manager or Debugger, select<b> View</b> â<b> OSA Explorer</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> osaexplorer</b> command. For</p>
<p>information about this command, see âObject Structure Awareness (OSA)</p>
<p>Commandsâ in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>For more information about the<b> OSA Explorer</b>, see Chapter 26, âFreeze-Mode</p>
<p>Debugging and OS-Awarenessâ on page 605 and âObject Structure Aware</p>
<p>Debuggingâ in the<i> INTEGRITY Development Guide</i>.</p>
<p><b>The OSA Object Viewer</b></p>
<p>With the OSA Object Viewer, you can view INTEGRITY object attributes, inject</p>
<p>messages into the kernel, and navigate between objects. The OSA Object Viewer</p>
<p>also keeps a history of all the objects you have viewed. You can easily navigate</p>
<p>this history. Because the OSA Object Viewer is typically used to display small</p>
<p>chunks of information from the kernel, it is faster than the<b> OSA Explorer</b>.</p>
<p><b>Note</b></p>
<p>The OSA Object Viewer is only available if you are debugging a</p>
<p>run-mode connection and using INTEGRITY version 10 or later.</p>
<p>To open the OSA Object Viewer, do one of the following:</p>
<p>â¢</p>
<p>In the Debugger target list, select an object and click the<b> OSA Object Viewer</b></p>
<p>button (</p>
<p>).</p>
<p><i>MULTI: Debugging</i></p>
<p><i>602</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> osaview</b> command. For information</p>
<p>about the<b> osaview</b> command, see âObject Structure Awareness (OSA)</p>
<p>Commandsâ in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>In the Debugger source pane, double-click an INTEGRITY object variable</p>
<p>while the task is halted.</p>
<p>The OSA Object Viewer opens on an object summary, a list of attributes (under</p>
<p>the<b> Attributes</b> tab), and a list of operations you can perform (under the<b> Operations</b></p>
<p>tab). Objects that are underlined in the OSA Object Viewer are linked to more</p>
<p>detailed information. To view this information, click the underlined object. Similarly,</p>
<p>clicking an underlined operation performs the operation.</p>
<p>By default, the OSA Object Viewer window is reused. However, if you freeze the</p>
<p>window or click the<b> Reuse</b> button (</p>
<p>) so that it no longer appears to be pushed</p>
<p>down, a new window appears the next time you open an OSA Object Viewer or the</p>
<p>next time you click a linked (that is, underlined) object in the OSA Object Viewer.</p>
<p>For more information about the OSA Viewer, see âObject Structure Aware</p>
<p>Debuggingâ in the<i> INTEGRITY Development Guide</i>.</p>
<p><b>Profiling All Tasks in Your System</b></p>
<p>If you are using INTEGRITY version 10 or later, MULTI allows you to view</p>
<p>processor usage for all tasks in your system. The information is updated continually</p>
<p>while the target is running, and it can be obtained without instrumenting the code:</p>
<p>INTEGRITY periodically samples the program counter (PC) of running tasks, and</p>
<p>the run-mode debug server delivers the resulting PC samples to MULTI.</p>
<p>The continually updated profiling information is displayed both in the<b> Profile</b></p>
<p>window's standard calls and source reports (see âStandard Calls Reportâ on page 365</p>
<p>and âSource Reportâ on page 371) and in a target list column labeled<b> CPU %</b>. This</p>
<p>column displays the percentage of the CPU that each task and AddressSpace is</p>
<p>currently using. The AddressSpace<b> CPU %</b> is simply the sum of the CPU</p>
<p>percentages for all the tasks in that AddressSpace.</p>
<p>To begin profiling all tasks in your system, perform the following steps:</p>
<p>1.</p>
<p>In the Debugger's target list, select the run-mode connection to your target.</p>
<p><i>603</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Profiling All Tasks in Your System</i></p>
<h1 style="page-break-before:always; "></h1>
<p>2.</p>
<p>Open the<b> Profile</b> window by selecting<b> View</b> â<b> Profile</b> or by entering the</p>
<p><b>profile</b> command. For information about the<b> Profile</b> window, see âThe Profile</p>
<p>Windowâ on page 361. For information about the<b> profile</b> command, see Chapter</p>
<p>12, âProfiling Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Tip</b></p>
<p>You can use the<b> ServerPollinterval</b> configuration option to control the</p>
<p>interval between updates to displayed data. For more information about</p>
<p>this option, see âThe More Debugger Options Dialogâ in Chapter 8,</p>
<p>âConfiguration Optionsâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book.</p>
<p>To disable profiling, close the<b> Profile</b> window.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>604</i></p>
<p><i>Chapter 25. Run-Mode Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 26</b></p>
<p><b>Freeze-Mode Debugging and</b></p>
<p><b>OS-Awareness</b></p>
<p><b>Contents</b></p>
<p>Starting MULTI for Freeze-Mode Debugging and OS-Awareness . . . . . . . . .</p>
<p>607</p>
<p>The OSA Explorer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>609</p>
<p>Debugging in Freeze Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>613</p>
<p>Freeze-Mode and OSA Configuration File . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>632</p>
<h1 style="page-break-before:always; "></h1>
<p>When you debug a multitasking application, MULTI interacts with the target's</p>
<p>operating system in freeze mode, in run mode, or in both freeze and run mode</p>
<p>simultaneously. In freeze mode, the entire target system stops when a breakpoint</p>
<p>is hit or a task is halted. In run mode, the operating system kernel continues to run</p>
<p>as you halt and examine individual tasks. For information about run-mode debugging,</p>
<p>see Chapter 25, âRun-Mode Debuggingâ on page 577. For information about</p>
<p>debugging in run mode and freeze mode, see âAutomatically Establishing Run-Mode</p>
<p>Connectionsâ on page 69.</p>
<p>During freeze-mode debugging, MULTI allows you to debug individual program</p>
<p>tasks, and it provides OS-awareness for operating system objects, allowing you to</p>
<p>examine detailed information about these objects. With freeze-mode debugging,</p>
<p>you can:</p>
<p>â¢</p>
<p>Display an<b> OSA Explorer</b> showing operating system tasks and other objects</p>
<p>on the target (if any).</p>
<p>â¢</p>
<p>Display an entry in the target list for each task, even if that task is suspended</p>
<p>or otherwise not running.</p>
<p>â¢</p>
<p>Set task-specific breakpoints that will stop the running process only when the</p>
<p>chosen task is currently executing.</p>
<p>â¢</p>
<p>Display call stacks and stack (local) variables for any task that can be debugged.</p>
<p>â¢</p>
<p>Perform task-specific single-stepping.</p>
<p><b>Note</b></p>
<p>The<b> OSA Explorer</b> is also available in some run-mode debugging</p>
<p>environments. For more information, see âThe OSA Explorerâ</p>
<p>on page 602.</p>
<p>Currently, freeze-mode debugging is available for these target environments:</p>
<p>â¢</p>
<p>INTEGRITY</p>
<p>â¢</p>
<p>velOSity</p>
<p>â¢</p>
<p>u-velOSity</p>
<p>â¢</p>
<p>ThreadX</p>
<p>If your operating system is not on the list, contact your Green Hills sales</p>
<p>representative.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>606</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>In this chapter,<i> task</i> is used as a general term to describe the target</p>
<p>operating system's unit of program execution. Specific terminology varies</p>
<p>according to the target's operating system (for example, a task may also</p>
<p>be called a<i> thread</i>). When the term<i> process</i> is used in this chapter, it</p>
<p>usually refers to the master process. For more information, see âMaster</p>
<p>Debugger Modeâ on page 614.</p>
<p><b>Starting MULTI for Freeze-Mode Debugging and OS-Awareness</b></p>
<p>MULTI identifies the operating system in use on your target and then configures</p>
<p>itself to debug that operating system. INTEGRITY and velOSity are identified by</p>
<p>OSA debugging information in the operating system kernel. MULTI identifies other</p>
<p>operating systems by examining programs for the following OS-specific symbols:</p>
<p>â¢</p>
<p>u-velOSity â</p>
<p>uv_task_create</p>
<p>or</p>
<p>_uv_task_create</p>
<p>â¢</p>
<p>ThreadX â</p>
<p>_tx_thread_created_ptr</p>
<p>Under special circumstances, an OSA integration package may be provided to allow</p>
<p>freeze-mode OS-aware debugging. In that case, start MULTI with the following</p>
<p>command line option:</p>
<p><b>-osa<i> osa_name</i>[#cfg=<i>configuration_file</i>][#lib=<i>library_name</i>][#log=<i>log_file</i>]</b></p>
<p>where:</p>
<p>â¢</p>
<p><i>osa_name</i></p>
<p>is case-insensitive.</p>
<p>â¢</p>
<p><i>configuration_file</i></p>
<p>is the configuration file for freeze-mode debugging</p>
<p>and OS-awareness (see âFreeze-Mode and OSA Configuration Fileâ</p>
<p>on page 632). If you do not specify a full path to the configuration file, MULTI</p>
<p>first searches for it in:</p>
<p>â</p>
<p>Windows 7/Vista â<i><b> user_dir</i>\AppData\Roaming\GHS\os_aware</b></p>
<p>â</p>
<p>Windows XP â<i><b> user_dir</i>\Application Data\GHS\os_aware</b></p>
<p>â</p>
<p>Linux/Solaris â<i><b> user_dir</i>/.ghs/os_aware</b></p>
<p>and then looks for it in the MULTI IDE installation directory. If you do not</p>
<p>specify a configuration file,<i><b> osa_name</i>.osa</b> is used by default.</p>
<p><i>607</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Starting MULTI for Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><i>library_name</i></p>
<p>is the library containing the OSA integration package (see</p>
<p>âThe OSA Integration Module Nameâ on page 635). The library may be a DLL</p>
<p>file (Windows) or an SO shared library (Linux/Solaris). If you do not specify</p>
<p>a library,<i><b> osa_name</i>.dll</b> (Windows) or<i><b> osa_name</i>.so</b> (Linux/Solaris) is used by</p>
<p>default.</p>
<p>You can place the integration module in any location, and use an absolute or</p>
<p>relative path to locate it from the Debugger's command line or from the</p>
<p>configuration file. If the integration module is specified with only a base name,</p>
<p>MULTI first searches for it in the MULTI IDE installation directory, and then</p>
<p>in a way defined by the host machine.</p>
<p>â¢</p>
<p><i>log_file</i></p>
<p>is the name of the file in which you want to log the interaction</p>
<p>between MULTI and the OSA integration package.</p>
<p>For example, to debug a program<b> my_program</b> in freeze mode with an OSA</p>
<p>integration package</p>
<p>rtos</p>
<p>, which uses a DLL called<b> rtos.dll</b>, start MULTI with the</p>
<p>following command line option:</p>
<p>multi -osa rtos#lib=rtos_lib my_program</p>
<p>If you are debugging multiple programs and you want to use OS-aware debugging</p>
<p>features for some of the programs, but not for others, set the option</p>
<p>RequestOsaPackage</p>
<p>to</p>
<p>On</p>
<p>. With this option, you do not have to specify the<b> -osa</b></p>
<p>option on the command line. Instead, MULTI prompts you for the OS-awareness</p>
<p>package name when you are debugging in freeze mode. MULTI resolves the name</p>
<p>of the configuration file and of the library as described above. See also âThe More</p>
<p>Debugger Options Dialogâ in Chapter 8, âConfiguration Optionsâ in the<i> MULTI:</i></p>
<p><i>Managing Projects and Configuring the IDE</i> book.</p>
<p><b>Tip</b></p>
<p>You can also use the<b> osasetup</b> command to specify an OSA integration</p>
<p>package. For information about this command, see âObject Structure</p>
<p>Awareness (OSA) Commandsâ in Chapter 15, âScripting Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>608</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The OSA Explorer</b></p>
<p>The<b> OSA Explorer</b> shows operating system tasks and other objects on the target</p>
<p>(if any). The following sections explain how to display and customize the<b> OSA</b></p>
<p><b>Explorer</b> and describe the operations that can be performed in the kernel object</p>
<p>list.</p>
<p><b>Displaying an OSA Explorer</b></p>
<p>When the target is halted and you are debugging a multitasking application with</p>
<p>OS-awareness, you can launch an<b> OSA Explorer</b> by doing one of the following:</p>
<p>â¢</p>
<p>In the Debugger, select<b> View</b> â<b> OSA Explorer</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> osaexplorer</b> command. For</p>
<p>information about this command, see âObject Structure Awareness (OSA)</p>
<p>Commandsâ in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>If the<b> View</b> â<b> OSA Explorer</b> menu item is dimmed out or the<b> osaexplorer</b></p>
<p>command prints an error such as:</p>
<p>osaexplorer: not supported in the current environment</p>
<p>then MULTI does not recognize the target operating system as one for which MULTI</p>
<p>can perform freeze-mode OS-aware debugging. For more information, see âStarting</p>
<p>MULTI for Freeze-Mode Debugging and OS-Awarenessâ on page 607.</p>
<p>The following is an<b> OSA Explorer</b> showing a task list of all AddressSpaces for the</p>
<p>INTEGRITY operating system.</p>
<p><i>609</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The OSA Explorer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The following is an<b> OSA Explorer</b> showing the MemoryRegion (a type of kernel</p>
<p>object) list for the AddressSpace</p>
<p>mengineer</p>
<p>on the INTEGRITY operating system.</p>
<p>Each type of object that can be explored is represented as a tab in the<b> OSA Explorer</b>.</p>
<p>If an object type has no reference object, the<b> OSA Explorer</b> contains one object</p>
<p>list pane to show the instances of this type of object. If an object type has a reference</p>
<p>object, two object list panes are displayed:</p>
<p>â¢</p>
<p>The master pane on the left side of the<b> OSA Explorer</b>.</p>
<p>â¢</p>
<p>The reference pane on the right side of the<b> OSA Explorer</b>.</p>
<p>Whenever an object is selected in the master pane, the instances of the corresponding</p>
<p>reference object are shown in the reference pane.</p>
<p>Because the object shown in the master pane could have references to more than</p>
<p>one type of object, the drop-down list at the top of the reference pane indicates the</p>
<p><i>MULTI: Debugging</i></p>
<p><i>610</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>object type being shown in the reference pane. If you select an object type to be</p>
<p>shown in the reference pane, your change is persistent for the duration of the</p>
<p>debugging session.</p>
<p>For information about INTEGRITY objects available in the<b> OSA Explorer</b>, see</p>
<p>the<i> INTEGRITY Development Guide</i>.</p>
<p><b>The OSA Explorer GUI Reference</b></p>
<p>The following table describes the menu items and toolbar buttons available in the</p>
<p><b>OSA Explorer</b>.</p>
<p><b>Meaning</b></p>
<p><b>Button</b></p>
<p><b>Equivalent</b></p>
<p><b>Menu Item</b></p>
<p>Prints the object list(s) currently displayed in</p>
<p>the<b> OSA Explorer</b>. If two object lists (the</p>
<p>master list and the reference list) are displayed</p>
<p>in the<b> OSA Explorer</b>, the print dialog box</p>
<p>appears twice.</p>
<p><b>Options</b> â<b> Print</b></p>
<p>Displays online help information about</p>
<p>freeze-mode debugging and the<b> OSA Explorer</b>.</p>
<p>no equivalent</p>
<p>button</p>
<p><b>Options</b> â<b> Help</b></p>
<p>Closes the<b> OSA Explorer</b>. Whether this button</p>
<p>appears on your toolbar depends on the setting</p>
<p>of the option<b> Display close (x) buttons</b>. To</p>
<p>access this option, select<b> Config</b> â<b> Options</b> â</p>
<p><b>General Tab</b>.</p>
<p><b>Options</b> â<b> Close</b></p>
<p>Freezes or unfreezes the automatic refreshing</p>
<p>of the<b> OSA Explorer</b>. When the<b> OSA Explorer</b></p>
<p>is frozen, a message appears in the status bar at</p>
<p>the bottom of the window, the contents of the</p>
<p>window are preserved, and you cannot switch</p>
<p>to another tab. The window is not updated again</p>
<p>until it is unfrozen.</p>
<p><b>View</b> â<b> Freeze Object</b></p>
<p><b>List</b></p>
<p>Refreshes the<b> OSA Explorer</b> even if it is frozen.</p>
<p>This button is not available if the target is halted.</p>
<p><b>View</b> â<b> Manually</b></p>
<p><b>Refresh Object List</b></p>
<p>Runs/stops the underlying process on the target</p>
<p>if you are debugging in freeze mode, or</p>
<p>resumes/halts the underlying RTOS on the target</p>
<p>if you are debugging in run mode.</p>
<p>/</p>
<p><b>View</b> â<b> Toggle Target</b></p>
<p><b>Status</b></p>
<p><i>611</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The OSA Explorer GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Customizing the Object List</b></p>
<p>The<b> OSA Explorer</b> for each OS has a default configuration that indicates which</p>
<p>columns to display and how to display them for each type of object. The object list</p>
<p>pane behaves like other multiple-column panes in MULTI. You can customize it</p>
<p>as follows:</p>
<p>â¢</p>
<p>To sort a list based on a column's contents, click that column's header. The</p>
<p>sorting toggles between ascending and descending order.</p>
<p>â¢</p>
<p>To move a column, drag that column's header left or right.</p>
<p>â¢</p>
<p>To change the width of a column, drag the column boundary.</p>
<p>â¢</p>
<p>To show or hide a column, right-click the pane to open a shortcut menu, and</p>
<p>select or clear the corresponding menu items.</p>
<p>Changes that you make to the<b> OSA Explorer</b> itself (such as its size and position)</p>
<p>and to each object are maintained across debugging sessions.</p>
<p>Task information is displayed in the (foreground) text color. Entries in the object</p>
<p>list pane have the same background color as the corresponding Debugger window</p>
<p>(only applicable if you have opened multiple Debugger windows).</p>
<p><b>Object List Operations</b></p>
<p>When you double-click a task in the object list pane, the selected task loads in the</p>
<p>current Debugger window. When you right-click an object in the object list pane,</p>
<p>a shortcut menu appears.</p>
<p>The following table describes the menu items that may appear in the<b> OSA Explorer</b></p>
<p>shortcut menu. The actual menu contents vary depending on the RTOS and object</p>
<p>type.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Toggles between showing or hiding the indicated column.</p>
<p><i><b>Column Name</b></i></p>
<p>Freezes or unfreezes the automatic refreshing of the<b> OSA Explorer</b>.</p>
<p>When the<b> OSA Explorer</b> is frozen, a message appears in the status bar</p>
<p>at the bottom of the window, and the contents of the window are</p>
<p>preserved. The window is not updated again until it is unfrozen.</p>
<p><b>Freeze Object List</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>612</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays the selected object in a Data Explorer.</p>
<p><i><b>View Object</b></i></p>
<p><i><b>Information</b></i></p>
<p>Displays the selected task in the Debugger window. See âDebugging</p>
<p>in Freeze Modeâ on page 613 and âShortcut Menu Entry Definitionsâ</p>
<p>on page 638.</p>
<p><b>Debug Task</b></p>
<p>Injects a message to the underlying RTOS to change its behavior.</p>
<p>For example, on INTEGRITY, you can dynamically inject a message</p>
<p>into the system to:</p>
<p>â¢</p>
<p>Take a</p>
<p>Semaphore</p>
<p>object on behalf of a task</p>
<p>â¢</p>
<p>Release a</p>
<p>Semaphore</p>
<p>to break a dead lock</p>
<p>â¢</p>
<p>Send a message to a</p>
<p>Connection</p>
<p>object</p>
<p>This option is only supported on some RTOSes.</p>
<p><b>Inject Message</b></p>
<p>To print the contents of the object list pane, select<b> Options</b> â<b> Print</b>.</p>
<p><b>Debugging in Freeze Mode</b></p>
<p>The following sections explain how to debug in freeze mode:</p>
<p>â¢</p>
<p>âMaster Debugger Modeâ on page 614</p>
<p>â¢</p>
<p>âTask Debugger Modeâ on page 615</p>
<p>â¢</p>
<p>âTask-Specific Single-Steppingâ on page 616</p>
<p>â¢</p>
<p>âWorking with Freeze-Mode Breakpointsâ on page 618</p>
<p>â¢</p>
<p>âProgram I/Oâ on page 620</p>
<p>â¢</p>
<p>âMulti-Core Debuggingâ on page 620</p>
<p>If the currently executing task resides in the kernel address space, you can either</p>
<p>use Master Debugger mode or Task Debugger mode to view information specific</p>
<p>to the task. If you want to debug a task that is not currently executing or does not</p>
<p>reside in the kernel address space, you must use Task Debugger mode to view</p>
<p>task-specific information.</p>
<p><i>613</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Debugging in Freeze Mode</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>The configuration option<b> osaTaskAutoAttachLimit</b> allows you to specify</p>
<p>the maximum number of OSA tasks that are displayed in the target list</p>
<p>(the default is 32). The tasks are displayed consecutively until this limit</p>
<p>is reached. For example, if this option is set to 32 and there are 33 tasks,</p>
<p>the 33rd task is not displayed in the target list. To manually display</p>
<p>additional tasks in the target list, double-click the tasks in the<b> OSA</b></p>
<p><b>Explorer Task</b> pane. For more information about the configuration option</p>
<p><b>osaTaskAutoAttachLimit</b>, see âOther Debugger Configuration Optionsâ</p>
<p>in Chapter 8, âConfiguration Optionsâ in the<i> MULTI: Managing Projects</i></p>
<p><i>and Configuring the IDE</i> book.</p>
<p><b>Note</b></p>
<p>The configuration option<b> osaSwitchToUserTaskAutomatically</b> controls</p>
<p>whether the Debugger automatically displays the currently executing</p>
<p>user-mode task when the target is stopped while executing user-mode</p>
<p>tasks. This is in addition to automatically displaying all of the tasks in</p>
<p>the system as controlled by the<b> osaTaskAutoAttachLimit</b> configuration</p>
<p>option. For more information about these configuration options, see</p>
<p>âOther Debugger Configuration Optionsâ in Chapter 8, âConfiguration</p>
<p>Optionsâ in the<i> MULTI: Managing Projects and Configuring the IDE</i></p>
<p>book.</p>
<p>For information about debugging with TimeMachine, see âUsing TimeMachine</p>
<p>with OS Tasksâ on page 418 and âOSA Tasks and the Master Process in</p>
<p>TimeMachineâ on page 419.</p>
<p><b>Master Debugger Mode</b></p>
<p>During freeze-mode debugging, selecting the master process in the target list enables</p>
<p>Master Debugger mode for the target. The master process is displayed in the target</p>
<p>list after the CPU node of a freeze-mode connection and before the OSA address</p>
<p>spaces whose names are prefixed with<b> OSA</b>. When the master process is selected,</p>
<p>the kernel's source code is displayed in the Debugger window. Double-clicking the</p>
<p>process displays the kernel source code in a new Debugger window.</p>
<p>The status of the master process (displayed in the<b> Status</b> column) corresponds to</p>
<p>the status of a normal process or provides specific information about the mode in</p>
<p><i>MULTI: Debugging</i></p>
<p><i>614</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>which the CPU may be stopped. For example, the status may be<b> Running</b>,<b> Stopped</b>,</p>
<p><b>Stopped in Kernel Mode</b>, or<b> Stopped in User Mode</b>. All operations, such as</p>
<p>memory access, register access, etc., are performed in the target's current status. If</p>
<p>the master process is selected in the target list while the target is stopped in user</p>
<p>mode (that is, in a non-kernel task), the PC pointer becomes gray.</p>
<p>The following operations are only available in Master Debugger mode:</p>
<p>â¢</p>
<p>Reloading or restarting the program.</p>
<p>â¢</p>
<p>Killing the process or detaching from it.</p>
<p>â¢</p>
<p>Setting normal breakpoints (as opposed to task-specific and any-task</p>
<p>breakpoints). All breakpoints set in Master Debugger mode are normal</p>
<p>breakpoints.</p>
<p>â¢</p>
<p>Setting hardware breakpoints.</p>
<p>When you reload or restart the program or detach from or kill the process, MULTI</p>
<p>removes all OSA task entries from the target list and closes the<b> OSA Explorer</b> and</p>
<p>any Debugger windows that you have opened on an OSA task.</p>
<p><b>Task Debugger Mode</b></p>
<p>To view source code for a task, do one of the following:</p>
<p>â¢</p>
<p>In the<b> OSA Explorer Task</b> pane, double-click a task.</p>
<p>â¢</p>
<p>In the<b> OSA Explorer Task</b> pane, right-click a task and choose<b> Debug Task</b>.</p>
<p>â¢</p>
<p>In the Debugger's target list, select a task. Tasks are located under an address</p>
<p>space node whose name begins with<b> OSA</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the command<b> osatask</b>. For information</p>
<p>about this command, see âObject Structure Awareness (OSA) Commandsâ in</p>
<p>Chapter 15, âScripting Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>To open a separate Debugger window on a task, double-click the task in the target</p>
<p>list. MULTI does not open multiple Debugger windows for the same task.</p>
<p>The following list describes behavior that is specific to Task Debugger mode:</p>
<p>â¢</p>
<p>Call stacks, local variables, and register displays are specific to the task.</p>
<p><i>615</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Task Debugger Mode</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>The title bar displays the task ID (a number that uniquely identifies the task)</p>
<p>and the task name, if the OS maintains a name for that task (see âThe Object</p>
<p>Attribute Definitionâ on page 637).</p>
<p>â¢</p>
<p>When the RTOS's master process is halted, the target list's<b> Status</b> column</p>
<p>displays the status of tasks in the RTOS. When the RTOS's master process is</p>
<p>running, the<b> Status</b> column displays<b> &lt;OS Running&gt;</b>.</p>
<p>â¢</p>
<p>Except for the</p>
<p>and</p>
<p>buttons, buttons related to execution (such as</p>
<p>,</p>
<p>,</p>
<p>) and their corresponding commands are only available when the master</p>
<p>process is halted and the task displayed is the currently executing task.</p>
<p>â¢</p>
<p>Single-stepping and breakpoints behave in a manner that is more appropriate</p>
<p>to task-aware debugging. For more information, see âTask-Specific</p>
<p>Single-Steppingâ on page 616 and âWorking with Freeze-Mode Breakpointsâ</p>
<p>on page 618.</p>
<p>â¢</p>
<p>Some of the MULTI commands that affect the global debugging state are not</p>
<p>available in Task Debugger mode. If you try to run one of these commands,</p>
<p>MULTI displays the following error message:</p>
<p>This command cannot be run with an OSA Task selected.</p>
<p>Select the target list entry corresponding to the connection</p>
<p>or executable first.</p>
<p><b>Task-Specific Single-Stepping</b></p>
<p>When you single-step a process in Task Debugger mode, MULTI avoids stopping</p>
<p>the process when another task is running. This makes debugging shared code more</p>
<p>straightforward by allowing you to step through one task at a time.</p>
<p>MULTI generally single-steps through program source by setting temporary</p>
<p>breakpoints and running until one of those breakpoints is hit. Sometimes a context</p>
<p>switch takes place between the time the process is run and the time one of the</p>
<p>temporary breakpoints is hit. (It is possible for the temporary breakpoint to be hit</p>
<p>from another task's context.) In these cases, MULTI lets the target process run until</p>
<p>one of the following occurs.</p>
<p>â¢</p>
<p>The temporary breakpoint is hit while the original task is running.</p>
<p>â¢</p>
<p>Another breakpoint is hit.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>616</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>The running process is halted.</p>
<p>This feature operates transparently, and no special action is required, aside from</p>
<p>performing all task-specific single-steps in Task Debugger mode. In Master</p>
<p>Debugger mode, single-stepping may occasionally step over context switches.</p>
<p>The following example helps to illustrate when task-specific single-stepping can</p>
<p>be useful. This example uses u-velOSity's GH-API, but most other operating systems</p>
<p>can perform similar operations.</p>
<p>335 1</p>
<p>void shared_func(char *s) {</p>
<p>336 2</p>
<p>printf(&quot;%s called shared_func\n&quot;,s);</p>
<p>-&gt; 337 3</p>
<p>gh_task_yield();</p>
<p>338 4</p>
<p>printf(&quot;%s end of call to shared_func\n&quot;,s);</p>
<p>339 5</p>
<p>}</p>
<p>340</p>
<p>341 1</p>
<p>void task_1_entry(GH_ADDRESS input) {</p>
<p>342 2</p>
<p>for(;;)</p>
<p>343 3</p>
<p>shared_func(&quot;task_1&quot;);</p>
<p>344 4</p>
<p>}</p>
<p>345</p>
<p>346 1</p>
<p>void task_2_entry(GH_ADDRESS input) {</p>
<p>347 2</p>
<p>for(;;)</p>
<p>348 3</p>
<p>shared_func(&quot;task_2&quot;);</p>
<p>349 4</p>
<p>}</p>
<p>In this process, two tasks are running at the same priority without time slicing. Both</p>
<p>tasks loop, calling</p>
<p>shared_func()</p>
<p>. The first task,</p>
<p>task_1</p>
<p>, has</p>
<p>task_1_entry()</p>
<p>as its entry point. The second task,</p>
<p>task_2</p>
<p>, has</p>
<p>task_2_entry()</p>
<p>as its entry</p>
<p>point. Within</p>
<p>shared_func()</p>
<p>, each task calls</p>
<p>gh_task_yield()</p>
<p>, a GH-API call</p>
<p>that allows other tasks at the same priority to run. In this case,</p>
<p>task_1</p>
<p>yields to</p>
<p>task_2</p>
<p>and then</p>
<p>task_2</p>
<p>yields to</p>
<p>task_1</p>
<p>. So in the steady state, one task is</p>
<p>always suspended within a call to</p>
<p>gh_task_yield()</p>
<p>while the other task is running.</p>
<p>At the moment the process is stopped,</p>
<p>task_1</p>
<p>is the current task and is stopped on</p>
<p>line 337, where it is just about to call</p>
<p>gh_task_yield()</p>
<p>. If you now press the</p>
<p>button from within</p>
<p>task_1</p>
<p>'s Debugger window, the following happens:</p>
<p>1.</p>
<p>MULTI sets a temporary breakpoint on line 338 and restarts the process.</p>
<p>2.</p>
<p>The call to</p>
<p>gh_task_yield()</p>
<p>causes</p>
<p>task_1</p>
<p>to suspend and</p>
<p>task_2</p>
<p>to run</p>
<p>again.</p>
<p><i>617</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Task Debugger Mode</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Task_2</p>
<p>returns from its previously suspended call to</p>
<p>gh_task_yield()</p>
<p>and</p>
<p>the process hits the temporary breakpoint.</p>
<p>4.</p>
<p>MULTI notices that</p>
<p>task_1</p>
<p>is not the current task and restarts the process</p>
<p>again.</p>
<p>5.</p>
<p>Task_2</p>
<p>loops and calls</p>
<p>gh_task_yield()</p>
<p>, which causes</p>
<p>task_2</p>
<p>to suspend</p>
<p>and</p>
<p>task_1</p>
<p>to run again.</p>
<p>6.</p>
<p>Task_1</p>
<p>returns from its call to</p>
<p>gh_task_yield()</p>
<p>and the process again hits</p>
<p>the temporary breakpoint.</p>
<p>7.</p>
<p>MULTI notices that</p>
<p>task_1</p>
<p>is the current task and stops the process.</p>
<p>Task-specific single-stepping makes it easy for you to concentrate on debugging</p>
<p>the task you are interested in.</p>
<p><b>Working with Freeze-Mode Breakpoints</b></p>
<p>When performing freeze-mode debugging on multitasking applications, you can</p>
<p>set task-specific breakpoints, any-task breakpoints, and normal breakpoints. Each</p>
<p>type of breakpoint is described below:</p>
<p>â¢</p>
<p>â Indicates a task-specific breakpoint. A task-specific breakpoint can be</p>
<p>set in an OSA task and can only be hit by the task it was set on. A task-specific</p>
<p>breakpoint is implemented as a conditional breakpoint: the current task ID</p>
<p>when the breakpoint is hit must match the task ID associated with the</p>
<p>breakpoint. Otherwise, MULTI simply continues running the process.</p>
<p>If the breakpoint icon is red, the breakpoint can only be hit by the task currently</p>
<p>selected in the target list (that is, the breakpoint was set on the current task). If</p>
<p>the breakpoint icon is gray, the breakpoint can only be hit by a task other than</p>
<p>the one currently selected in the target list (that is, the breakpoint was<i> not</i> set</p>
<p>on the current task). Task-specific breakpoints in the kernel address space are</p>
<p>gray in the OSA master process.</p>
<p>In the<b> Breakpoints</b> window, task-specific breakpoints are listed with a</p>
<p>command parameter. Otherwise they are displayed like normal breakpoints.</p>
<p>â¢</p>
<p>â Indicates an any-task breakpoint. An any-task breakpoint can be set in</p>
<p>an OSA task and can be hit by any task in the same address space.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>618</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To set an any-task breakpoint, select a task in the target list and hold the<b> Shift</b></p>
<p>key as you click a breakdot (</p>
<p>) in the Debugger window. Alternatively, you</p>
<p>can use the<b> sb at</b> command.</p>
<p>For example:</p>
<p><b>sb at<i></b> function#5</i></p>
<p>sets an any-task breakpoint at line 5 of the function</p>
<p><i>function</i></p>
<p>. For information</p>
<p>about the<b> sb</b> command, see Chapter 3, âBreakpoint Command Referenceâ in</p>
<p>the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p>and all other breakpoint icons â Represent normal breakpoints. A normal</p>
<p>breakpoint can be set in the OSA master process and can be hit by OSA tasks</p>
<p>that can access the breakpoint's address.</p>
<p>These breakpoints are similar to any-task breakpoints set in OSA tasks, but</p>
<p>they are not the same. You cannot set an any-task breakpoint in the OSA master</p>
<p>process. The freeze-mode debug server has no knowledge of RTOS concepts</p>
<p>such as any-task breakpoints; it treats the program you are debugging as a</p>
<p>stand-alone program. MULTI uses the OSA package to simulate an RTOS</p>
<p>scenario (RTOS concepts are only available to MULTI). MULTI translates the</p>
<p>semantics of RTOS operations into the normal operations supported by the</p>
<p>debug server.</p>
<p>You can only set hardware breakpoints in the OSA master process. These</p>
<p>breakpoints are not RTOS aware, so they will affect all tasks.</p>
<p>For information about breakpoints set in OSA tasks or the OSA master process</p>
<p>while TimeMachine is enabled, see âOSA Breakpoints in TimeMachineâ on page 420.</p>
<p><b>Note</b></p>
<p>Only one breakpoint can be set at a particular address. For example, if a</p>
<p>task-specific breakpoint is set at the location</p>
<p>shared_func#2()</p>
<p>, the</p>
<p>breakpoint must be removed before another breakpoint (of any type) can</p>
<p>be set at the same address. If you do not remove the breakpoint, MULTI</p>
<p>does so for you. On INTEGRITY, this limitation applies to each</p>
<p>AddressSpace (that is, multiple breakpoints can be set at the same address</p>
<p>as long as each breakpoint is set in a different AddressSpace).</p>
<p><i>619</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Working with Freeze-Mode Breakpoints</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Program I/O</b></p>
<p>In a freeze-mode environment, program I/O is usually redirected to the MULTI</p>
<p>Debugger and immediately displayed in its<b> I/O</b> and<b> Cmd</b> panes. Operating systems</p>
<p>such as INTEGRITY, however, capture and independently handle program I/O. In</p>
<p>this case, I/O may not be immediately visible.</p>
<p>When an INTEGRITY program calls an I/O function such as</p>
<p>fprintf()</p>
<p>to print</p>
<p>a message, input is neither immediately sent nor output immediately received.</p>
<p>Instead, INTEGRITY translates the request into a console operation and queues it</p>
<p>in the system. Even a flush operation, such as</p>
<p>fflush()</p>
<p>, is translated and queued</p>
<p>in the same way. When the kernel is running and handling these operations, I/O is</p>
<p>printed to the console approximately every second.</p>
<p>When you single-step on a task in freeze mode, you cannot immediately see the</p>
<p>output of I/O functions because the kernel is halted. The output is displayed in the</p>
<p>console only after you start the target running and the kernel has a chance to flush</p>
<p>out queued console operations.</p>
<p><b>Multi-Core Debugging</b></p>
<p>A<i> multi-core target</i> is a target containing multiple processors, or<i> cores</i>, that can</p>
<p>each be debugged independently. This section details techniques and limitations</p>
<p>specific to debugging multi-core targets.</p>
<p><b>Multiple Cores in the Target List</b></p>
<p>When you connect to a multi-core target, MULTI displays the cores as separate</p>
<p>entries in the target list, and it assigns each core a number, beginning with zero.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>620</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Multiple Cores in the Task Manager</b></p>
<p>When you connect to a multi-core target, the Task Manager displays two separate</p>
<p>panes:</p>
<p>â¢</p>
<p>Master pane â Shows each core on the target and basic information (<b>Object</b></p>
<p><b>Id</b> and<b> Name</b>) about the tasks on each core.</p>
<p><i>621</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Multi-Core Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Reference pane â Shows more information about the object selected in the</p>
<p>master pane:</p>
<p>â</p>
<p>If a debug server is selected â Shows detailed information about the cores</p>
<p>being controlled by the debug server.</p>
<p>â</p>
<p>If a core is selected â Shows additional information about the tasks</p>
<p>running on the core.</p>
<p>â</p>
<p>If a task is selected â Shows all of the tasks belonging to the same core</p>
<p>as the selected task, and briefly highlights the selected task.</p>
<p>Cores cannot be sorted in either pane.</p>
<p>The following Task Manager shows an application that is connected via the<b> mpserv</b></p>
<p>debug server to a multi-core target running the INTEGRITY operating system on</p>
<p>each QorIQ core:</p>
<p><i>MULTI: Debugging</i></p>
<p><i>622</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Using Hook Commands in Multi-Core Setup Scripts</b></p>
<p>Before loading a program onto a hardware target, MULTI typically runs the board</p>
<p>setup script (if any) associated with the Connection Method. The board setup script</p>
<p>may set up initial register values, memory controller configurations, etc. Board</p>
<p>setup scripts for multi-core targets can take advantage of the hook commands</p>
<p>documented in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>For example, suppose you want to run several MULTI commands on core 1 after</p>
<p>resetting your target. You might add a command such as the following to your setup</p>
<p>script:</p>
<p>addhook -core 1 -after reset {<i>commands</i>}</p>
<p>If you are using the hook commands, you may want your setup script to run once</p>
<p>upon connection rather than before every download. For more information, see</p>
<p>âEarly MULTI Board Setup Scripts with Debugger Hooksâ on page 101.</p>
<p><b>Multi-Core Configuration File</b></p>
<p>The MULTI Debugger can use information you provide in a multi-core configuration</p>
<p>file (<b>*.ghsmc</b>) to automatically download programs to your multi-core target and</p>
<p>load symbol files to the Debugger. This can simplify target setup considerably.</p>
<p>To start the MULTI Debugger on a multi-core configuration file, run the following</p>
<p>command from the command line:</p>
<p>multi<i> multi-core_config_file</i>.ghsmc</p>
<p>An example configuration file for an RH850 multi-core environment follows:</p>
<p>version = 1</p>
<p>core {</p>
<p>0 {</p>
<p>download = {&quot;./core0&quot;, &quot;./shared.so&quot;}</p>
<p>}</p>
<p>1 {</p>
<p>download = {&quot;./core1&quot;}</p>
<p>symbol = {&quot;./shared.so&quot;}</p>
<p><i>623</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Multi-Core Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>}</p>
<p>2 {</p>
<p>download = {&quot;./core2&quot;}</p>
<p>symbol = {&quot;./shared.so&quot;}</p>
<p>}</p>
<p>3 {</p>
<p>download = {&quot;./core3&quot;}</p>
<p>symbol = {&quot;./shared.so&quot;}</p>
<p>}</p>
<p>}</p>
<p>Here is another example, this time for a QorIQ P4080 SMP environment:</p>
<p>version = 1</p>
<p>core {</p>
<p>0 {</p>
<p>download = {&quot;mpizza&quot;}</p>
<p>}</p>
<p>&quot;1-7&quot; {</p>
<p>symbol = {&quot;mpizza&quot;}</p>
<p>}</p>
<p>}</p>
<p>In both examples, the following elements appear:</p>
<p>â¢</p>
<p>The</p>
<p>version</p>
<p>field specifies the version of the configuration file. Only version</p>
<p>1</p>
<p>is supported at present.</p>
<p>â¢</p>
<p>Information about cores is defined in the</p>
<p>core</p>
<p>block.</p>
<p>â¢</p>
<p>The name for each block nested under</p>
<p>core</p>
<p>may be:</p>
<p>â</p>
<p>A core ID (an integer). You can find core IDs in the Debugger's target list.</p>
<p>See âMultiple Cores in the Target Listâ on page 620.</p>
<p>â</p>
<p>A quoted string with an inclusive core ID range. For example,</p>
<p>&quot;1-7&quot;</p>
<p>indicates cores with IDs 1, 2, ..., 7.</p>
<p>â¢</p>
<p>Each of the nested blocks may contain one or more fields in the format:</p>
<p>variable_name = value</p>
<p>â</p>
<p>The</p>
<p>download</p>
<p>field lists the program(s) to be loaded to the target over</p>
<p>the core; corresponding symbol information is used by the Debugger to</p>
<p>debug the program(s). Begin the list with the program that must run first</p>
<p><i>MULTI: Debugging</i></p>
<p><i>624</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>(the main program). Enclose the comma-separated list in curly braces and</p>
<p>quote each list item, as shown in the first example.</p>
<p>Note that a program may be loaded to the target over one core, but be</p>
<p>accessible to other cores.</p>
<p>â</p>
<p>The</p>
<p>symbol</p>
<p>field lists the symbol file(s) to be used on the core. Begin the</p>
<p>list with the symbol file that should run first (the main symbol file). Format</p>
<p>the list as described above.</p>
<p>Collective Treatment of Multi-Core Programs</p>
<p>Unlike an application on a single core, a multi-core application contains a set of</p>
<p>programs for a set of cores. When the following operations are applied to a program</p>
<p>on one core, the Debugger treats the programs as a single unit, automatically applying</p>
<p>the operation to the programs on all cores:</p>
<p>â¢</p>
<p>Loading a multi-core program in the Debugger</p>
<p>â¢</p>
<p>Removing a multi-core program from the Debugger</p>
<p>â¢</p>
<p>Preparing the target</p>
<p>â¢</p>
<p>Binding/unbinding a multi-core program and a connection/CPU</p>
<p>â¢</p>
<p>Detaching a multi-core program from a connection</p>
<p>â¢</p>
<p>Killing a running program</p>
<p>The following commands, some of which correspond to one of the preceding</p>
<p>operations, also affect all cores:</p>
<p>â¢</p>
<p><b>change_binding</b></p>
<p>â¢</p>
<p><b>connect</b></p>
<p>â¢</p>
<p><b>prepare_target</b></p>
<p>â¢</p>
<p><b>k</b></p>
<p>â¢</p>
<p><b>quit entry</b></p>
<p>â¢</p>
<p><b>debug</b></p>
<p>â¢</p>
<p><b>new</b></p>
<p>â¢</p>
<p><b>detach</b></p>
<p><i>625</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Multi-Core Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Corresponding toolbar buttons and menu items (including right-click menu items)</p>
<p>have the same effect as the commands.</p>
<p><b>Preparing Multiple Cores to Run a Single Executable</b></p>
<p>If multiple cores on your target share memory, or if one core controls the reset</p>
<p>and/or run-control capabilities of others, you might choose to build the code for all</p>
<p>the cores into a single executable file. Before loading this executable onto your</p>
<p>target, you must associate the executable with every core. One method for doing</p>
<p>so follows:</p>
<p>1.</p>
<p>Select the executable in the target list, and click the<b> Connect</b> button (</p>
<p>).</p>
<p>2.</p>
<p>Using the<b> Connection Chooser</b> that appears, connect to your multi-core target.</p>
<p>3.</p>
<p>In the<b> Use Which Connection/CPU?</b> dialog box that appears, select any one</p>
<p>of the cores, and click<b> OK</b>.</p>
<p>4.</p>
<p>In the Debugger command pane, issue the<b> new</b> command with no arguments.</p>
<p>For information about the<b> new</b> command, see Chapter 2, âGeneral Debugger</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>5.</p>
<p>If the<b> Use Which Connection/CPU?</b> dialog box appears again, select any</p>
<p>core. If the dialog box does not appear, MULTI automatically associated the</p>
<p>executable with the only remaining core.</p>
<p>6.</p>
<p>Repeat steps 4 and 5 until the executable has been associated with every core</p>
<p>on the target.</p>
<p>For information about the<b> Use Which Connection/CPU?</b> dialog box, see</p>
<p>âAssociating Your Executable with a Connectionâ on page 105.</p>
<p>After associating the executable with every core on the target, you can load the</p>
<p>executable onto the target:</p>
<p>1.</p>
<p>In the target list, select the executable listed after the core that is supposed to</p>
<p>run first.</p>
<p>2.</p>
<p>In the Debugger command pane, issue the<b> prepare_target -load</b> command.</p>
<p>For information about this command, see âGeneral Target Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>626</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>For each remaining core, select the executable listed after the core, and enter</p>
<p><b>prepare_target -verify=none</b> in the Debugger command pane.</p>
<p>Alternatively, you can use the<b> prepareAllCores</b> option to configure MULTI</p>
<p>to automatically and silently run<b> prepare_target -verify=none</b> on all secondary</p>
<p>cores. For more information, see the description of<b> prepareAllCores</b> in âOther</p>
<p>Debugger Configuration Optionsâ in Chapter 8, âConfiguration Optionsâ in</p>
<p>the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>Preparing Multiple Cores to Run Separate Executables</b></p>
<p>If the cores on your target do not share memory and if each can be independently</p>
<p>controlled, or if they are otherwise intended to execute programs independently,</p>
<p>you might choose to build the code for each core into its own separate executable</p>
<p>file. Before loading the executables onto your target, you must associate each</p>
<p>executable with the core that is supposed to run it. One method for doing so follows:</p>
<p>1.</p>
<p>Select one of the executables in the target list, and click the<b> Connect</b> button</p>
<p>(</p>
<p>).</p>
<p>2.</p>
<p>Using the<b> Connection Chooser</b> that appears, connect to your multi-core target.</p>
<p>3.</p>
<p>In the<b> Use Which Connection/CPU?</b> dialog box that appears, select the core</p>
<p>that you want to run the selected executable, and click<b> OK</b>.</p>
<p>4.</p>
<p>In the Debugger command pane, enter<b> new<i> program_name</b></i>, where</p>
<p><i>program_name</i></p>
<p>is the name of another executable. For information about the</p>
<p><b>new</b> command, see Chapter 2, âGeneral Debugger Command Referenceâ in</p>
<p>the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>5.</p>
<p>If the<b> Use Which Connection/CPU?</b> dialog box appears again, select the core</p>
<p>that you want to run the second executable. If the dialog box does not appear,</p>
<p>MULTI automatically associated the executable with the only remaining core.</p>
<p>6.</p>
<p>Repeat steps 4 and 5 until an executable has been associated with every core</p>
<p>on the target.</p>
<p>For information about the<b> Use Which Connection/CPU?</b> dialog box, see</p>
<p>âAssociating Your Executable with a Connectionâ on page 105.</p>
<p>After associating each executable with the core that is supposed to run it, you must</p>
<p>separately load each program onto the corresponding core:</p>
<p><i>627</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Multi-Core Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>1.</p>
<p>Select an executable in the target list.</p>
<p>2.</p>
<p>In the Debugger command pane, issue the<b> prepare_target -load</b> command.</p>
<p>For information about this command, see âGeneral Target Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p>3.</p>
<p>Select a different executable in the target list.</p>
<p>4.</p>
<p>If your board setup script only affects the current core when it is run, and if it</p>
<p>does not reinitialize any shared components on the board (such as memory)</p>
<p>â Issue the<b> prepare_target -load</b> command again.</p>
<p>If your board setup script affects multiple cores when it is run, or if it</p>
<p>reinitializes shared components on the board (such as memory) â Issue the</p>
<p><b>load -nosetup</b> command. For information about this command, see âGeneral</p>
<p>Target Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>5.</p>
<p>Repeat steps 3 and 4 for each remaining executable.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>628</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Synchronous Run Control</b></p>
<p>Some targets support (or require)<i> synchronous</i>, or simultaneous, run-control</p>
<p>operations on all cores. To initiate synchronous run-control operations, you must</p>
<p>do one of the following:</p>
<p>â¢</p>
<p>Use the options in the Task Manager's<b> Group</b> menu (for example,<b> Continue</b></p>
<p><b>Tasks in Current Group</b>).</p>
<p>â¢</p>
<p>Open the Task Manager, and then issue the<b> groupaction</b> command with</p>
<p>appropriate arguments:</p>
<p><b>groupaction</b> -r|-h|-s @All</p>
<p>where</p>
<p>-r</p>
<p>,</p>
<p>-h</p>
<p>, or</p>
<p>-s</p>
<p>specifies a run, halt, or single-step operation, respectively,</p>
<p>and</p>
<p>@All</p>
<p>indicates that the designated operation be synchronously performed</p>
<p>on all cores on the target. In a freeze-mode environment, synchronous run</p>
<p>control is not supported on groups other than</p>
<p>All</p>
<p>.</p>
<p><b>Note</b></p>
<p>In freeze mode, both of these operations operate on cores, not on the tasks</p>
<p>running on the cores.</p>
<p><b>Note</b></p>
<p>Selecting multiple tasks in the target list and then issuing a MULTI</p>
<p>command such as<b> c</b> or<b> halt</b> does<i> not</i> initiate synchronous run-control</p>
<p>operations.</p>
<p>If you are using a Green Hills Probe, see the<i> Green Hills Debug Probes User's</i></p>
<p><i>Guide</i> for any additional configuration settings that apply to your target.</p>
<p><b>Using Trace Tools on a Multi-Core Target</b></p>
<p>Some multi-core targets are capable of tracing more than one core by multiplexing</p>
<p>the trace data from many cores into a single trace stream. With supported targets,</p>
<p>MULTI can use this feature to enable TimeMachine for multiple cores.</p>
<p>Bugs involving complex interactions among multiple processors are notoriously</p>
<p>difficult to debug and are often also difficult to reproduce. With multi-core trace,</p>
<p>you only need to reproduce the problem once to obtain a complete log of every</p>
<p><i>629</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Multi-Core Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>instruction executed on all cores. You can use the TimeMachine tools to analyze</p>
<p>this data and figure out what went wrong.</p>
<p>When you trace a multi-core target, the trace controls for all of the cores are tied</p>
<p>together. However, MULTI demultiplexes the trace data and provides a separate</p>
<p>instance of each trace tool for each core. For example, you can open a separate</p>
<p>PathAnalyzer window for each core and view separate path analysis of each core,</p>
<p>but the<b> Enable Trace</b> (</p>
<p>) and<b> Retrieve Trace</b> (</p>
<p>) buttons in all the windows are</p>
<p>tied together. Clicking the<b> Enable Trace</b> button (</p>
<p>) in any of the windows enables</p>
<p>trace collection from the target and causes the<b> Enable Trace</b> button (</p>
<p>) to toggle</p>
<p>in the other windows as well.</p>
<p>By default, MULTI does not synchronize selections in the trace tools across cores.</p>
<p>To enable multi-core trace synchronization, use the<b> trace sync on</b> command (see</p>
<p>Chapter 20, âTrace Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book). If the trace data is timestamped, MULTI uses the timestamps to</p>
<p>select instructions that were executing at approximately the same time on all traced</p>
<p>cores each time an instruction is selected in a trace tool for any of the cores. If the</p>
<p>trace data does not include timestamps, multi-core trace synchronization is not</p>
<p>supported.</p>
<p>When you use TimeMachine on a multi-core trace target, the TimeMachine instances</p>
<p>are independent, but they are synchronized if multi-core trace synchronization is</p>
<p>enabled. For example, if you have a breakpoint set in the TimeMachine Debugger</p>
<p>for core 0 and you run backwards in the TimeMachine Debugger for core 1, the</p>
<p>breakpoint on core 0 is not hit. However, when the TimeMachine Debugger for</p>
<p>core 1 stops, the TimeMachine Debugger for core 0 is synchronized to approximately</p>
<p>the same point in time where core 1 stopped. It is possible to simultaneously run</p>
<p>the TimeMachine Debugger for each core, but the result is unpredictable.</p>
<p><b>Note</b></p>
<p>The compact trace encodings required to trace multiple cores in the</p>
<p>available trace bandwidth typically do not allow for timestamps on each</p>
<p>instruction. In some cases, there may be as few as one timestamp every</p>
<p>few thousand instructions. Therefore, it is not possible for MULTI to</p>
<p>pinpoint exactly which instruction was executing on each core at a specific</p>
<p>time, but its approximation is close.</p>
<p>Multi-core trace requires much more trace bandwidth than single-core trace. On</p>
<p>some targets, it is not possible to capture complete trace of multiple cores. If you</p>
<p><i>MULTI: Debugging</i></p>
<p><i>630</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>attempt to trace too many cores at once, on-chip trace buffers overflow and gaps</p>
<p>occur in the trace data (see âDealing with Incomplete Trace Dataâ on page 411). To</p>
<p>avoid this, you may want to trace a subset of cores. With most targets, you can</p>
<p>control which cores are traced via the<b> Trace Options</b> window. Click the<b> Target</b></p>
<p><b>Specific Options</b> button located on the<b> Collection</b> tab, or click the target-specific</p>
<p>tab (only one or the other will appear). For more information, see the documentation</p>
<p>about target-specific trace options in the<i> Green Hills Debug Probes User's Guide</i></p>
<p>or, if you are using a V850 target, the documentation about V850 trace options in</p>
<p>the<i> MULTI: Configuring Connections</i> book.</p>
<p>Multi-Core Trace Notes</p>
<p>â¢</p>
<p>Synchronous run control is very important when you are tracing multiple cores.</p>
<p>If one core hits a breakpoint and the other cores continue running, they quickly</p>
<p>fill up the trace buffer and push the data leading up to the breakpoint out of the</p>
<p>buffer. Therefore if you think that you may want to look at the trace data leading</p>
<p>up to a point where a core halted, you must halt all cores simultaneously or</p>
<p>nearly simultaneously.</p>
<p>â¢</p>
<p>Trace is not supported with INTEGRITY SMP.</p>
<p>â¢</p>
<p>When a program is loaded onto any core, unretrieved trace data is cleared.</p>
<p>Since the trace buffer is shared by all cores, unretrieved trace data for all cores</p>
<p>is discarded.</p>
<p><b>Limitations</b></p>
<p>â¢</p>
<p>If multiple cores on your target share memory and a single executable, then</p>
<p>breakpoints, command line procedure calls, and host I/O system calls are only</p>
<p>supported on the core that you initially loaded the program onto. Many advanced</p>
<p>debugging features such as coverage, call count, and call graph profiling make</p>
<p>use of breakpoints, command line procedure calls, and host I/O and are therefore</p>
<p>also only supported on the first core.</p>
<p>â¢</p>
<p>On targets that require synchronous run control, conditional breakpoints and</p>
<p>breakpoints that resume the target are not supported.</p>
<p>â¢</p>
<p>If one core holds another core in a reset state on your target, your debugging</p>
<p>interface (for example, Green Hills Probe) may not be able to manipulate the</p>
<p>latter core until the former brings it out of reset. In this case, the Debugger may</p>
<p><i>631</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Multi-Core Debugging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>show the core held in reset as<b> Running</b>, even though it is not actually executing</p>
<p>any code. You may not be able to halt a core that is being held in reset.</p>
<p><b>Freeze-Mode and OSA Configuration File</b></p>
<p>The configuration file for freeze-mode debugging and OS-awareness provides the</p>
<p>Debugger with information about objects to be explored. For example, the file may:</p>
<p>â¢</p>
<p>Assign identification numbers to each object and its attributes.</p>
<p>â¢</p>
<p>Specify the relationships between objects.</p>
<p>â¢</p>
<p>Define how the attributes of an object are to be displayed in the<b> OSA Explorer</b>.</p>
<p>The name of the configuration file consists of the lowercase name of the</p>
<p>corresponding operating system or of your OS-awareness package. The filename</p>
<p>ends with a<b> .osa</b> extension. It is stored in your personal configuration directory:</p>
<p>â¢</p>
<p>Windows 7/Vista â<i><b> user_dir</i>\AppData\Roaming\GHS\os_aware</b></p>
<p>â¢</p>
<p>Windows XP â<i><b> user_dir</i>\Application Data\GHS\os_aware</b></p>
<p>â¢</p>
<p>Linux/Solaris â<i><b> user_dir</i>/.ghs/os_aware</b></p>
<p>or in the MULTI IDE installation directory:</p>
<p>â¢</p>
<p>Windows â<i><b> ide_install_dir</i>\defaults\os_aware</b></p>
<p>â¢</p>
<p>Linux/Solaris â<i><b> ide_install_dir</i>/defaults/os_aware</b></p>
<p>MULTI searches for the configuration file in your personal configuration directory</p>
<p>first, and then looks for it in the MULTI IDE installation directory.</p>
<p>In order to make the configuration file more readable, comment lines are supported.</p>
<p>If the first two non-space characters are forward slashes (â//â), then the line is</p>
<p>considered to be a comment.</p>
<p><b>Note</b></p>
<p>Two consecutive forward slashes (â//â) in the middle of a line is not</p>
<p>considered to be a comment indicator as it would be in C++ code.</p>
<p>Each line in the configuration file can be a comment line, an empty line, or a line</p>
<p>representing a configuration element. A backslash ('\') at the end of a line combines</p>
<p><i>MULTI: Debugging</i></p>
<p><i>632</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>the next line with it, so multiple lines can be combined together to represent a single</p>
<p>configuration element.</p>
<p>Even though MULTI recognizes the reserved words in a case-insensitive way, we</p>
<p>recommend keeping all reserved words in uppercase for readability purposes as we</p>
<p>do in the configuration files for the built-in OS integrations.</p>
<p>All syntax elements of the configuration file are separated by a colon (':'). If a string</p>
<p>provided by the OSA integration provider contains a colon (':'), the string should</p>
<p>be enclosed in double quotes.</p>
<p>The design of MULTI's OSA integration mechanism totally separates the GUI</p>
<p>representation from program logic. Each object, attribute of an object and reference</p>
<p>of an object is assigned a unique non-negative number. Negative numbers are</p>
<p>reserved for special purposes. In the interaction between MULTI and the OSA</p>
<p>integration module, only the identifier numbers are used. This makes it very easy</p>
<p>for you to customize the strings displayed in an<b> OSA Explorer</b>, including</p>
<p>internationalization.</p>
<p>The following subsections specify the syntax of the elements in a configuration file.</p>
<p><b>General Settings</b></p>
<p><b>The OSA Integration Version</b></p>
<p>Format:</p>
<p>OSA_CONFIG</p>
<p>:</p>
<p>OSA_VERSION</p>
<p>:</p>
<p><i>version_number</i></p>
<p><i>version_number</i></p>
<p>is an integer. The current version number is</p>
<p>2</p>
<p>.</p>
<p><b>Terminology for Tasks</b></p>
<p>Format:</p>
<p>OSA_CONFIG</p>
<p>:</p>
<p>OSA_TASK_ALIAS</p>
<p>:</p>
<p><i>terminology_for_task</i></p>
<p><i>633</i></p>
<p><i>Green Hills Software</i></p>
<p><i>General Settings</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The</p>
<p><i>terminology_for_task</i></p>
<p>specified here will be used at some places in the</p>
<p><b>OSA Explorer</b>. If the setting is absent in the configuration file,</p>
<p>task</p>
<p>will be used</p>
<p>as the default.</p>
<p>When a task name needs to be used in other places of the configuration file, use</p>
<p>OSA_TASK</p>
<p>instead of</p>
<p><i>terminology_for_task</i></p>
<p>.</p>
<p><b>The OSA Explorer Title</b></p>
<p>Format:</p>
<p>OSA_CONFIG</p>
<p>:</p>
<p>OSA_EXPLORER_TITLE</p>
<p>:</p>
<p><i>osa_explorer_title</i></p>
<p>The</p>
<p><i>osa_explorer_title</i></p>
<p>argument specifies the title for the<b> OSA Explorer</b>. It</p>
<p>is a string that can contain a number replacement (for target ID used by MULTI)</p>
<p>in the syntax of</p>
<p>printf()</p>
<p>in the C library (</p>
<p>%d</p>
<p>or</p>
<p>0x%x</p>
<p>).</p>
<p><b>Initial OSA Commands</b></p>
<p>Format:</p>
<p>OSA_CONFIG</p>
<p>:</p>
<p>OSA_INIT_COMMAND</p>
<p>:</p>
<p><i>initial_osa_commands</i></p>
<p>When MULTI initializes the OSA integration module,</p>
<p><i>initial_osa_commands</i></p>
<p>are sent to it immediately.</p>
<p>Multiple initialization commands can be specified on multiple lines. When the</p>
<p>module is initialized, MULTI sends the commands to the OSA integration module</p>
<p>sequentially. If an initialization command fails, MULTI ignores the rest of the</p>
<p>initialization commands, but continues as if the OSA integration module had been</p>
<p>successfully initialized.</p>
<p><b>The Poll Interval</b></p>
<p>Format:</p>
<p>OSA_CONFIG</p>
<p>:</p>
<p>OSA_POLL_INTERVAL</p>
<p>:</p>
<p><i>interval_in_milliseconds</i></p>
<p><i>MULTI: Debugging</i></p>
<p><i>634</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The OSA integration module can provide a function to be called periodically by</p>
<p>MULTI, with an interval of</p>
<p><i>interval_in_milliseconds</i></p>
<p>. If the setting is absent,</p>
<p>the default value (200 milliseconds) will be used.</p>
<p><b>The OSA Integration Module Name</b></p>
<p>Format:</p>
<p>OSA_CONFIG</p>
<p>:</p>
<p>OSA_MODULE_NAME</p>
<p>:</p>
<p><i>osa_integration_module_name</i></p>
<p>With the exception of the built-in integrations, most of the OSA integration modules</p>
<p>are stored in a DLL file (Windows) or shared library (Linux/Solaris). This setting</p>
<p>tells MULTI the integration module's name and location. If no file extension is</p>
<p>specified in</p>
<p><i>osa_integration_module_name</i></p>
<p>, MULTI appends<b> .dll</b> (Windows)</p>
<p>or<b> .so</b> (Linux/Solaris) to it automatically.</p>
<p>If the option is absent and the OSA integration is not built into MULTI, the default</p>
<p>name (the lowercase name for the OSA integration) will be used.</p>
<p>You can set the OSA integration module's name and location with this option. If</p>
<p>the integration module is specified with only a base name, MULTI first searches</p>
<p>for it in the MULTI IDE installation directory, and then in a way defined by the</p>
<p>host machine.</p>
<p>You can override the setting here by using the<b> -osa</b> MULTI command line option</p>
<p>(see âStarting MULTI for Freeze-Mode Debugging and OS-Awarenessâ on page 607).</p>
<p>Alternatively, use the<b> osasetup</b> command (see âObject Structure Awareness (OSA)</p>
<p>Commandsâ in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>The Memory Access Block Size</b></p>
<p>Format:</p>
<p>OSA_CONFIG</p>
<p>:</p>
<p>OSA_MEMORY_ACCESS_BLOCK_SIZE</p>
<p>:</p>
<p><i>number_in_bytes</i></p>
<p>This option allows you to customize the memory access blocks size between MULTI</p>
<p>and the target to improve the performance of<b> OSA Explorer</b>.</p>
<p>The default memory access block size of MULTI is 64 bytes.</p>
<p><i>635</i></p>
<p><i>Green Hills Software</i></p>
<p><i>General Settings</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Log Interaction</b></p>
<p>Format:</p>
<p>OSA_CONFIG</p>
<p>:</p>
<p>OSA_DEBUGGING_LOGFILE</p>
<p>:</p>
<p><i>log_file</i></p>
<p>This option allows you to see the interaction between MULTI and the OSA</p>
<p>integration module. All interactions will be saved in the file</p>
<p><i>log_file</i></p>
<p>.</p>
<p>In addition to the communication between MULTI and the OSA integration module,</p>
<p>MULTI will also print some diagnostic information for the OSA integration module</p>
<p>into the log file.</p>
<p><b>The Object Type Definition</b></p>
<p>Format:</p>
<p>OSA_OBJECT_TYPE</p>
<p>:</p>
<p><i>object_name</i></p>
<p>:</p>
<p><i>unique_identifier</i></p>
<p>:</p>
<p>OSA_GLOBAL</p>
<p>|</p>
<p>OSA_NOT_GLOBAL</p>
<p>Before you specify the detailed information about an object, it must be assigned a</p>
<p>unique identifier.</p>
<p>The argument,</p>
<p><i>object_name</i></p>
<p>, is the string to be shown in the<b> OSA Explorer</b>. It</p>
<p>can be</p>
<p>OSA_TASK</p>
<p>(for the<i> task</i> object) or a string for another object. You can change</p>
<p>an object's name into any string you like.</p>
<p>An object can be either a global object (</p>
<p>OSA_GLOBAL</p>
<p>) or a local object</p>
<p>(</p>
<p>OSA_NOT_GLOBAL</p>
<p>). A global object does not require any special context for the</p>
<p>OSA integration module to access it, but a local object requires a global object as</p>
<p>context in order to access it. So, only global objects are displayed as tabs in the</p>
<p><b>OSA Explorer</b>; local objects can be used only as references to other objects.</p>
<p><b>The Object Definition</b></p>
<p>A<i> task</i> is a special type of object. If there is no definition for it in the configuration</p>
<p>file, MULTI will not be able to provide the multitasking debugging feature, but</p>
<p>OS-awareness is still available for the objects defined in the configuration file.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>636</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>An object's information contains three parts: references, attributes, and additional</p>
<p>shortcut menu entries.</p>
<p><b>The Reference Specification</b></p>
<p>Format:</p>
<p><i>master_object_name</i></p>
<p>:</p>
<p>OSA_REFERENCE_LIST</p>
<p>:</p>
<p><i>reference_object_name</i></p>
<p>:</p>
<p><i>reference_id</i></p>
<p>:</p>
<p><i>reference_name</i></p>
<p>An object (the master object) can have more than one reference object, and each</p>
<p>reference object is defined by a statement using this syntax.</p>
<p>The string</p>
<p><i>reference_id</i></p>
<p>should be unique for all references of the</p>
<p><i>master_object_name</i></p>
<p>.</p>
<p>The string</p>
<p><i>reference_name</i></p>
<p>will be displayed in the drop-down list above the</p>
<p>reference pane in the<b> OSA Explorer</b>.</p>
<p><b>The Object Attribute Definition</b></p>
<p>Each object has a set of attributes. Some attributes are universal and important to</p>
<p>objects for various OSA integrations. For example, tasks have the</p>
<p>identifier</p>
<p>,</p>
<p>name</p>
<p>,</p>
<p>status</p>
<p>, and</p>
<p>executable</p>
<p>attributes, while other objects just have the</p>
<p>identifier</p>
<p>attribute.</p>
<p>An object must have an identifier attribute. If one is not defined for an object, the</p>
<p>configuration file is invalid.</p>
<p>Each attribute of an object is defined with a statement in the following syntax.</p>
<p>Format:</p>
<p><i>object_name</i></p>
<p>:</p>
<p>OSA_ATTRIBUTE_COLUMN</p>
<p>:</p>
<p>[</p>
<p>OSA_ID</p>
<p>=|</p>
<p>OSA_NAME</p>
<p>=|</p>
<p>OSA_STATUS</p>
<p>=|</p>
<p>OSA_EXEC</p>
<p>=]</p>
<p><i>attribute_name</i></p>
<p>:</p>
<p><i>attribute_id</i></p>
<p>:</p>
<p>OSA_SHOW</p>
<p>|</p>
<p>OSA_NO_SHOW</p>
<p>:</p>
<p><i>sorting_type</i></p>
<p>OSA_ID=</p>
<p>,</p>
<p>OSA_NAME=</p>
<p>,</p>
<p>OSA_STATUS=</p>
<p>, and</p>
<p>OSA_EXEC=</p>
<p>are used to tell MULTI</p>
<p>that the defined attributes are the</p>
<p>identifier</p>
<p>,</p>
<p>name</p>
<p>,</p>
<p>status</p>
<p>, or</p>
<p>executable</p>
<p>,</p>
<p>respectively, of the corresponding object. When Task Debugger mode is enabled,</p>
<p><i>637</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Object Definition</i></p>
<h1 style="page-break-before:always; "></h1>
<p>task</p>
<p>identifier</p>
<p>and task</p>
<p>name</p>
<p>are shown in the title of the Debugger window,</p>
<p>and task</p>
<p>status</p>
<p>is shown in the target list's<b> Status</b> column. If these attributes are</p>
<p>not specified, MULTI uses default values in these places.</p>
<p>The string</p>
<p><i>attribute_id</i></p>
<p>must be unique for each attribute of an object.</p>
<p>OSA_SHOW</p>
<p>and</p>
<p>OSA_NO_SHOW</p>
<p>tell MULTI which attribute columns are to be initially</p>
<p>shown in the<b> OSA Explorer</b>.</p>
<p><i>sorting_type</i></p>
<p>tells MULTI how to sort each column when it is clicked. The</p>
<p>following are the valid sorting types:</p>
<p>â¢</p>
<p>OSA_LONG</p>
<p>â Sorts the corresponding column by long integer</p>
<p>â¢</p>
<p>OSA_STRING</p>
<p>â Sorts the corresponding column by string</p>
<p>â¢</p>
<p>OSA_DATE</p>
<p>â Sorts the corresponding column by date</p>
<p>â¢</p>
<p>OSA_FILENAME</p>
<p>â Sorts the corresponding column by filename</p>
<p>â¢</p>
<p>OSA_FLOAT</p>
<p>â Sorts the corresponding column by float value</p>
<p>â¢</p>
<p>OSA_ADDRESS</p>
<p>â Sorts the corresponding column by address (unsigned</p>
<p>integers)</p>
<p>If no sorting type is defined for an attribute, its column will be sorted by string.</p>
<p><b>Shortcut Menu Entry Definitions</b></p>
<p>You can also define additional entries of the right-click shortcut menu in the object</p>
<p>list pane of an<b> OSA Explorer</b>. Each such entry is defined by a statement in the</p>
<p>following syntax.</p>
<p>Format:</p>
<p><i>object_name</i></p>
<p>:</p>
<p>OSA_MENU</p>
<p>:</p>
<p><i>menu_entry_string</i></p>
<p>:</p>
<p><i>multi_commands</i></p>
<p>Where</p>
<p><i>menu_entry_string</i></p>
<p>is the name to be displayed on the shortcut menu,</p>
<p>and</p>
<p><i>multi_commands</i></p>
<p>is the command or commands to be executed whenever the</p>
<p>menu option is selected.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>638</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If</p>
<p><i>menu_entry_string</i></p>
<p>is</p>
<p>&quot;\x01&quot;</p>
<p>, it defines a menu separator. For example, you</p>
<p>can add a menu separator into<b> Semaphore</b> list's shortcut menu with the following</p>
<p>line:</p>
<p>Semaphore:OSA_MENU:&quot;\x01&quot;:{}</p>
<p><b>Example: Configuration File</b></p>
<p>The following is the configuration file used by INTEGRITY.</p>
<p>// OSA Integration Package Configuration File for INTEGRITY</p>
<p>// Copyright (C) 2000-Present Green Hills Software</p>
<p>OSA_CONFIG:OSA_MULTI_MENU:INTEGRITY OSA Explorer...</p>
<p>OSA_CONFIG:OSA_EXPLORER_TITLE:INTEGRITY OSA Explorer (MULTI target ID 0x%x)</p>
<p>// Uncomment the following line to customize the memory access block</p>
<p>// size(in bytes) to turn up performance for your target.</p>
<p>// OSA_CONFIG:OSA_MEMORY_ACCESS_BLOCK_SIZE:512</p>
<p>// Uncomment the following line to generate an OSA log file</p>
<p>// OSA_CONFIG:OSA_DEBUGGING_LOGFILE:&quot;integrity.log&quot;</p>
<p>// Object Type List Section</p>
<p>// ========================</p>
<p>// Define Object Type IDs and configure them for global display</p>
<p>// Format: OSA_OBJECT_TYPE:object name:object type id:global_display</p>
<p>OSA_OBJECT_TYPE:&quot;Address Space&quot;:0:OSA_GLOBAL</p>
<p>OSA_OBJECT_TYPE:OSA_TASK:1:OSA_GLOBAL</p>
<p>OSA_OBJECT_TYPE:Connection:2:OSA_GLOBAL</p>
<p>OSA_OBJECT_TYPE:Activity:3:OSA_GLOBAL</p>
<p>OSA_OBJECT_TYPE:Semaphore:4:OSA_GLOBAL</p>
<p>OSA_OBJECT_TYPE:&quot;Memory Region&quot;:5:OSA_GLOBAL</p>
<p>OSA_OBJECT_TYPE:Link:6:OSA_GLOBAL</p>
<p>OSA_OBJECT_TYPE:Clock:7:OSA_GLOBAL</p>
<p>OSA_OBJECT_TYPE:&quot;I/O Device&quot;:8:OSA_GLOBAL</p>
<p>OSA_OBJECT_TYPE:Object:9:OSA_GLOBAL</p>
<p>// Address Space Window Format Sections</p>
<p>// =============================</p>
<p>// Column Line Format:</p>
<p>//</p>
<p>type name:OSA_ATTRIBUTE_COLUMN:attribute name:attribute id:display:type</p>
<p>// List Line Format:</p>
<p>//</p>
<p>type name:OSA_REFERENCE_LIST:list type name:list id:list name</p>
<p>&quot;Address Space&quot;:OSA_REFERENCE_LIST:OSA_TASK:0:Tasks</p>
<p>&quot;Address Space&quot;:OSA_REFERENCE_LIST:Connection:1:Connection</p>
<p>&quot;Address Space&quot;:OSA_REFERENCE_LIST:Activity:2:Activity</p>
<p>&quot;Address Space&quot;:OSA_REFERENCE_LIST:Semaphore:3:Semaphore</p>
<p>&quot;Address Space&quot;:OSA_REFERENCE_LIST:&quot;Memory Region&quot;:4:&quot;Memory Region&quot;</p>
<p>&quot;Address Space&quot;:OSA_REFERENCE_LIST:Link:5:Link</p>
<p>&quot;Address Space&quot;:OSA_REFERENCE_LIST:Clock:6:Clock</p>
<p><i>639</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Example: Configuration File</i></p>
<h1 style="page-break-before:always; "></h1>
<p>&quot;Address Space&quot;:OSA_REFERENCE_LIST:&quot;I/O Device&quot;:7:&quot;I/O Device&quot;</p>
<p>&quot;Address Space&quot;:OSA_REFERENCE_LIST:Object:8:Objects</p>
<p>&quot;Address Space&quot;:OSA_ATTRIBUTE_COLUMN:OSA_ID=&quot;Domain ID&quot;:0:OSA_SHOW:OSA_ADDRESS</p>
<p>&quot;Address Space&quot;:OSA_ATTRIBUTE_COLUMN:Name:1:OSA_SHOW:OSA_STRING</p>
<p>&quot;Address Space&quot;:OSA_ATTRIBUTE_COLUMN:Virtual:2:OSA_SHOW:OSA_STRING</p>
<p>&quot;Address Space&quot;:OSA_ATTRIBUTE_COLUMN:Objects:3:OSA_SHOW:OSA_LONG</p>
<p>&quot;Address Space&quot;:OSA_MENU:&quot;View AddressSpace Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct DomainStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Domain ID is invalid.\n&quot;;}</p>
<p>// Task Space Window Format Section</p>
<p>// ==========================</p>
<p>// Column Line Format:</p>
<p>//</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:attribute name:attribute id:display:type</p>
<p>OSA_TASK:OSA_REFERENCE_LIST:Activity:0:&quot;Interrupt Stack&quot;</p>
<p>OSA_TASK:OSA_REFERENCE_LIST:Activity:1:&quot;Other Actvities&quot;</p>
<p>OSA_TASK:OSA_REFERENCE_LIST:Semaphore:2:&quot;Owned Binary Semaphores&quot;</p>
<p>OSA_TASK:OSA_REFERENCE_LIST:Semaphore:3:&quot;Owned HL Semaphores&quot;</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:OSA_NAME=Name:0:OSA_SHOW:OSA_STRING</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:OSA_ID=TaskID:1:OSA_SHOW:OSA_ADDRESS</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:OSA_STATUS=Status:2:OSA_SHOW:OSA_STRING</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:Priority:3:OSA_SHOW:OSA_LONG</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:Weight:10:OSA_SHOW:OSA_LONG</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:Stack Start:4:OSA_NO_SHOW:OSA_ADDRESS</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:Stack End:5:OSA_NO_SHOW:OSA_ADDRESS</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:Stack HWM/Size:6:OSA_SHOW:OSA_STRING</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:&quot;Address Space&quot;:7:OSA_SHOW:OSA_STRING</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:OSA_EXEC=Executable:8:OSA_NO_SHOW:OSA_STRING</p>
<p>OSA_TASK:OSA_ATTRIBUTE_COLUMN:Object Index:9:OSA_SHOW:OSA_STRING</p>
<p>//OSA_TASK:OSA_ATTRIBUTE_COLUMN:Stack HWM:10:OSA_SHOW:OSA_STRING</p>
<p>OSA_TASK:OSA_MENU:&quot;View Task Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct TaskContextStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Task ID is invalid.\n&quot;;}</p>
<p>OSA_TASK:OSA_MENU:&quot;\x01&quot;:{}</p>
<p>OSA_TASK:OSA_MENU:Debug Task:if ($_OSA_OBJ_ID) \</p>
<p>{osatask $_OSA_OBJ_ID} \</p>
<p>else {print &quot;Task ID is invalid.\n&quot;;}</p>
<p>//Clocks Window Format Section</p>
<p>Clock:OSA_ATTRIBUTE_COLUMN:OSA_ID=&quot;Clock ID&quot;:0:OSA_SHOW:OSA_ADDRESS</p>
<p>Clock:OSA_ATTRIBUTE_COLUMN:Name:1:OSA_SHOW:OSA_STRING</p>
<p>Clock:OSA_ATTRIBUTE_COLUMN:&quot;Address Space&quot;:2:OSA_SHOW:OSA_STRING</p>
<p>Clock:OSA_ATTRIBUTE_COLUMN:Object Index:3:OSA_SHOW:OSA_STRING</p>
<p>Clock:OSA_MENU:&quot;View Clock Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct ClockStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Clock ID is invalid.\n&quot;;}</p>
<p>//IODevice Window Format Section</p>
<p>&quot;I/O Device&quot;:OSA_ATTRIBUTE_COLUMN:OSA_ID=&quot;Device ID&quot;:0:OSA_SHOW:OSA_ADDRESS</p>
<p>&quot;I/O Device&quot;:OSA_ATTRIBUTE_COLUMN:Name:1:OSA_SHOW:OSA_STRING</p>
<p>&quot;I/O Device&quot;:OSA_ATTRIBUTE_COLUMN:Object Index:2:OSA_SHOW:OSA_STRING</p>
<p>&quot;I/O Device&quot;:OSA_MENU:&quot;View I/O Device Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct IODeviceStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;I/O Device ID is invalid.\n&quot;;}</p>
<p><i>MULTI: Debugging</i></p>
<p><i>640</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p>//Generic Object List format section</p>
<p>Object:OSA_REFERENCE_LIST:Link:0:&quot;Links to Object&quot;</p>
<p>Object:OSA_ATTRIBUTE_COLUMN:OSA_ID=&quot;Object ID&quot;:0:OSA_SHOW:OSA_STRING</p>
<p>Object:OSA_ATTRIBUTE_COLUMN:Type:1:OSA_SHOW:OSA_STRING</p>
<p>Object:OSA_ATTRIBUTE_COLUMN:&quot;Address Space&quot;:2:OSA_SHOW:OSA_STRING</p>
<p>Object:OSA_MENU:&quot;View Object Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct ObjectStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Object ID is invalid.\n&quot;;}</p>
<p>//Activity list format section</p>
<p>Activity:OSA_ATTRIBUTE_COLUMN:OSA_ID=&quot;Activity ID&quot;:0:OSA_SHOW:OSA_ADDRESS</p>
<p>Activity:OSA_ATTRIBUTE_COLUMN:&quot;Object Index&quot;:1:OSA_SHOW:OSA_STRING</p>
<p>Activity:OSA_ATTRIBUTE_COLUMN:Status:2:OSA_SHOW:OSA_STRING</p>
<p>Activity:OSA_ATTRIBUTE_COLUMN:Priority:3:OSA_SHOW:OSA_LONG</p>
<p>Activity:OSA_ATTRIBUTE_COLUMN:&quot;Address Space&quot;:4:OSA_SHOW:OSA_STRING</p>
<p>Activity:OSA_ATTRIBUTE_COLUMN:Task:5:OSA_SHOW:OSA_STRING</p>
<p>Activity:OSA_ATTRIBUTE_COLUMN:&quot;Waiting On&quot;:6:OSA_SHOW:OSA_STRING</p>
<p>Activity:OSA_MENU:&quot;View Activity Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct ActivityStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Activity ID is invalid.\n&quot;;}</p>
<p>//Semaphore window format section</p>
<p>Semaphore:OSA_ATTRIBUTE_COLUMN:OSA_ID=&quot;Semaphore ID&quot;:0:OSA_SHOW:OSA_ADDRESS</p>
<p>Semaphore:OSA_ATTRIBUTE_COLUMN:&quot;Object Index&quot;:1:OSA_SHOW:OSA_STRING</p>
<p>Semaphore:OSA_ATTRIBUTE_COLUMN:Type:3:OSA_SHOW:OSA_STRING</p>
<p>Semaphore:OSA_ATTRIBUTE_COLUMN:Owner:2:OSA_SHOW:OSA_STRING</p>
<p>Semaphore:OSA_ATTRIBUTE_COLUMN:Value:5:OSA_SHOW:OSA_STRING</p>
<p>Semaphore:OSA_ATTRIBUTE_COLUMN:Priority:6:OSA_SHOW:OSA_STRING</p>
<p>Semaphore:OSA_ATTRIBUTE_COLUMN:&quot;Address Space&quot;:4:OSA_SHOW:OSA_STRING</p>
<p>Semaphore:OSA_MENU:&quot;View Semaphore Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct SemaphoreStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Semaphore ID is invalid.\n&quot;;}</p>
<p>Semaphore:OSA_MENU:&quot;\x01&quot;:{}</p>
<p>Semaphore:OSA_MENU:&quot;Take Semaphore&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute dialogue TakeSemaphore %EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Semaphore ID is invalid.\n&quot;;}</p>
<p>Semaphore:OSA_MENU:&quot;Release Semaphore&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute osainject -ObjType &quot;Semaphore&quot; -ObjId %EVAL{print /x $_OSA_OBJ_ID}</p>
<p>-MsgType &quot;Release&quot;; \</p>
<p>} else {print &quot;Semaphore ID is invalid.\n&quot;;}</p>
<p>//Link list format section</p>
<p>Link:OSA_ATTRIBUTE_COLUMN:OSA_ID=&quot;Link ID&quot;:0:OSA_SHOW:OSA_ADDRESS</p>
<p>Link:OSA_ATTRIBUTE_COLUMN:&quot;Address Space&quot;:1:OSA_SHOW:OSA_STRING</p>
<p>Link:OSA_ATTRIBUTE_COLUMN:&quot;Target Type&quot;:2:OSA_SHOW:OSA_STRING</p>
<p>Link:OSA_ATTRIBUTE_COLUMN:&quot;Target ID&quot;:3:OSA_SHOW:OSA_STRING</p>
<p>Link:OSA_ATTRIBUTE_COLUMN:&quot;Object Index&quot;:4:OSA_SHOW:OSA_STRING</p>
<p>Link:OSA_ATTRIBUTE_COLUMN:&quot;Target Index&quot;:5:OSA_SHOW:OSA_STRING</p>
<p>Link:OSA_MENU:&quot;View Link Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct LinkStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Link ID is invalid.\n&quot;;}</p>
<p>//MemoryRegion list format section</p>
<p>&quot;Memory Region&quot;:OSA_ATTRIBUTE_COLUMN:OSA_ID=&quot;Memory Region ID&quot;:0:OSA_SHOW:OSA_ADDRESS</p>
<p>&quot;Memory Region&quot;:OSA_ATTRIBUTE_COLUMN:&quot;Address Space&quot;:1:OSA_SHOW:OSA_STRING</p>
<p>&quot;Memory Region&quot;:OSA_ATTRIBUTE_COLUMN:Beginning:2:OSA_SHOW:OSA_ADDRESS</p>
<p><i>641</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Example: Configuration File</i></p>
<h1 style="page-break-before:always; "></h1>
<p>&quot;Memory Region&quot;:OSA_ATTRIBUTE_COLUMN:End:3:OSA_SHOW:OSA_ADDRESS</p>
<p>&quot;Memory Region&quot;:OSA_ATTRIBUTE_COLUMN:&quot;Object Index&quot;:4:OSA_SHOW:OSA_STRING</p>
<p>&quot;Memory Region&quot;:OSA_MENU:&quot;View Memory Region Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct MemoryRegionStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Memory Region ID is invalid.\n&quot;;}</p>
<p>//Connection list format section</p>
<p>Connection:OSA_ATTRIBUTE_COLUMN:OSA_ID=&quot;Connection ID&quot;:0:OSA_SHOW:OSA_ADDRESS</p>
<p>Connection:OSA_ATTRIBUTE_COLUMN:&quot;Address Space&quot;:1:OSA_SHOW:OSA_STRING</p>
<p>Connection:OSA_ATTRIBUTE_COLUMN:&quot;Other End&quot;:2:OSA_SHOW:OSA_STRING</p>
<p>Connection:OSA_ATTRIBUTE_COLUMN:&quot;AS of Other End&quot;:3:OSA_SHOW:OSA_STRING</p>
<p>Connection:OSA_ATTRIBUTE_COLUMN:&quot;Object Index&quot;:4:OSA_SHOW:OSA_STRING</p>
<p>Connection:OSA_ATTRIBUTE_COLUMN:&quot;ObjIndex of Other End&quot;:5:OSA_SHOW:OSA_STRING</p>
<p>Connection:OSA_MENU:&quot;View Connection Internals&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute view (struct ConnectionStruct *)%EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Connection ID is invalid.\n&quot;;}</p>
<p>Connection:OSA_MENU:&quot;\x01&quot;:{}</p>
<p>Connection:OSA_MENU:&quot;Inject Message&quot;:if ($_OSA_OBJ_ID) \</p>
<p>{substitute dialogue GetMessageToConnection %EVAL{print /x $_OSA_OBJ_ID}; \</p>
<p>} else {print &quot;Connection ID is invalid.\n&quot;;}</p>
<p><i>MULTI: Debugging</i></p>
<p><i>642</i></p>
<p><i>Chapter 26. Freeze-Mode Debugging and OS-Awareness</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 27</b></p>
<p><b>Establishing Serial</b></p>
<p><b>Connections</b></p>
<p><b>Contents</b></p>
<p>Starting the Serial Terminal Emulator (MTerminal) . . . . . . . . . . . . . . . . . . . . .</p>
<p>644</p>
<p>Using Quick Connect . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>645</p>
<p>Creating and Configuring Serial Connections . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>646</p>
<p>The MTerminal Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>650</p>
<p>Running the Serial Terminal Emulator in Console Mode . . . . . . . . . . . . . . . . .</p>
<p>653</p>
<p>mterminal Syntax and Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>654</p>
<h1 style="page-break-before:always; "></h1>
<p>There are many cases in which it may be necessary or convenient to establish a</p>
<p>serial connection. You can do this easily by using MULTI's serial terminal emulator</p>
<p>(<b>MTerminal</b>), which you can access from many of the MULTI tools or run as a</p>
<p>stand-alone program. You can connect to a local serial port with<b> MTerminal's</b></p>
<p>Quick Connect, or you can configure and save multiple Serial Connection Methods,</p>
<p>which you can later use to establish serial connections. This chapter describes how</p>
<p>to use the serial terminal emulator and how to create, save, and use Serial Connection</p>
<p>Methods.</p>
<p><b>Starting the Serial Terminal Emulator (MTerminal)</b></p>
<p>The following list describes different ways you can access the<b> MTerminal</b> serial</p>
<p>terminal emulator. (The list makes frequent mention of the<b> Serial Connection</b></p>
<p><b>Chooser</b>, the<b> MTerminal</b> window, and the Debugger's<b> Srl</b> pane. For more</p>
<p>information about these interfaces, see âUsing the Serial Connection Chooserâ</p>
<p>on page 646, âThe MTerminal Windowâ on page 650, and âThe Serial Terminal</p>
<p>Paneâ on page 31.)</p>
<p>â¢</p>
<p>From the MULTI Launcher, click</p>
<p>and then select<b> Open Terminal</b> from the</p>
<p>drop-down menu that appears. Alternatively, select<b> Components</b> â<b> Open</b></p>
<p><b>Serial Terminal</b> from the menu bar. These actions start the<b> Serial Connection</b></p>
<p><b>Chooser</b>, which allows you to create or edit a Serial Connection Method and</p>
<p>then connect to the serial port.</p>
<p>â¢</p>
<p>From the MULTI Launcher, click</p>
<p>and then select the name of a previously</p>
<p>created Serial Connection Method from the drop-down menu that appears. This</p>
<p>starts the<b> MTerminal</b> window with a terminal connected to the specified serial</p>
<p>port. If the connection is unsuccessful, an error message appears.</p>
<p>â¢</p>
<p>From the command line, execute<b> mterminal</b> (for command usage, see</p>
<p>âmterminal Syntax and Argumentsâ on page 654). This opens the serial terminal</p>
<p>emulator as a stand-alone program. The emulator usually opens in GUI mode,</p>
<p>displaying either the<b> MTerminal</b> window or the<b> Serial Connection Chooser</b>,</p>
<p>depending on the arguments specified. On Linux/Solaris hosts, you can also</p>
<p>open the emulator in console mode. For more information, see âRunning the</p>
<p>Serial Terminal Emulator in Console Modeâ on page 653.</p>
<p>â¢</p>
<p>From the MULTI Debugger, select<b> Tools</b> â<b> Serial Terminal</b> â<b> Make Serial</b></p>
<p><b>Connection</b>. Alternatively, issue the<b> serialconnect</b> command with no arguments</p>
<p>in the command pane. (For information about the<b> serialconnect</b> command, see</p>
<p><i>MULTI: Debugging</i></p>
<p><i>644</i></p>
<p><i>Chapter 27. Establishing Serial Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>âSerial Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.) These</p>
<p>actions start the<b> Serial Connection Chooser</b>, which allows you to create or</p>
<p>edit a Serial Connection Method and then connect to a serial port. If the</p>
<p>connection is successful, the<b> Srl</b> tab becomes available in the bottom pane of</p>
<p>the Debugger. Selecting the<b> Srl</b> tab displays a terminal connected to the</p>
<p>specified serial port. If the serial connection is unsuccessful, an error message</p>
<p>appears and the<b> Srl</b> tab does not become available.</p>
<p>â¢</p>
<p>From the MULTI Debugger, select<b> Tools</b> â<b> Serial Terminal</b> and then select</p>
<p>the name of a previously created Serial Connection Method from the drop-down</p>
<p>list that appears. Alternatively, issue the<b> serialconnect</b> command with</p>
<p>arguments specifying the parameters for the connection in the command pane.</p>
<p>(For information about the<b> serialconnect</b> command, see âSerial Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.) If the connection is successful,</p>
<p>the<b> Srl</b> tab becomes available in the bottom pane of the Debugger. Selecting</p>
<p>the<b> Srl</b> tab displays a terminal connected to the specified serial port. If the serial</p>
<p>connection is unsuccessful, an error message appears and the<b> Srl</b> tab does not</p>
<p>become available.</p>
<p><b>Using Quick Connect</b></p>
<p>You can connect to a local serial port easily and quickly by using<b> MTerminal's</b></p>
<p>Quick Connect. With Quick Connect, you do not need to create and configure a</p>
<p>connection. To use Quick Connect, open an<b> MTerminal</b> window and perform the</p>
<p>following steps:</p>
<p>1.</p>
<p>Select an available baud rate from the<b> Baud Rate</b> drop-down list.</p>
<p>2.</p>
<p>Select one of the commonly used ports from the<b> Port</b> drop-down list, or type</p>
<p>the name of a port in the<b> Port</b> field.</p>
<p>3.</p>
<p>Click the<b> Quick Connect</b> button.</p>
<p>For information about serial connections that you can configure and save, see the</p>
<p>next section.</p>
<p><i>645</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using Quick Connect</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Creating and Configuring Serial Connections</b></p>
<p>MULTI provides two graphical tools, the<b> Serial Connection Chooser</b> and the</p>
<p><b>Serial Connection Settings</b> dialog box, that allow you to configure and save one</p>
<p>or more Serial Connection Methods and use those methods to establish serial</p>
<p>connections and open terminal emulator windows. (These tools are analogous to</p>
<p>the<b> Connection Chooser</b> and<b> Connection Editor</b>, which allow you to configure</p>
<p>and save Connection Methods for connecting to your target. See Chapter 3,</p>
<p>âConnecting to Your Targetâ on page 39.) The<b> Serial Connection Chooser</b> and</p>
<p>the<b> Serial Connection Settings</b> dialog are described in the following sections.</p>
<p><b>Using the Serial Connection Chooser</b></p>
<p>You can use the<b> Serial Connection Chooser</b> to create a new Serial Connection</p>
<p>Method, edit an existing Serial Connection Method, or establish a serial connection</p>
<p>using a saved Serial Connection Method. For information about opening the<b> Serial</b></p>
<p><b>Connection Chooser</b>, see âStarting the Serial Terminal Emulator (MTerminal)â</p>
<p>on page 644.</p>
<p>To create a new standard Serial Connection Method from the<b> Serial Connection</b></p>
<p><b>Chooser</b>, click</p>
<p>. To edit an existing Serial Connection Method, select the Method</p>
<p>from the drop-down list and click</p>
<p>. Both of these actions open a<b> Serial Connection</b></p>
<p><b>Settings</b> dialog, which allows you to configure your new or existing Serial</p>
<p>Connection Method. For more information, see âUsing the Serial Connection Settings</p>
<p>Dialogâ on page 647.</p>
<p>After you have created at least one Serial Connection Method, you can establish a</p>
<p>connection by selecting your desired method from the drop-down list and then</p>
<p>clicking<b> Connect</b>.</p>
<p>You can also create a Custom Serial Connection Method by entering a command</p>
<p>in the<b> Serial Connection Chooser</b>, rather than using the graphical<b> Serial</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>646</i></p>
<p><i>Chapter 27. Establishing Serial Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Connection Settings</b> dialog. To do this, click the<b> Custom</b> button in the<b> Serial</b></p>
<p><b>Connection Chooser</b> and use the syntax given below to describe the connection</p>
<p>in the<b> Make Serial Connection</b> text field of the Chooser.</p>
<p><b>serialconnect<i></b> port_name</i> [<i>mterminal_parameters</i>]</p>
<p>This command accepts the same arguments as the<b> mterminal</b> command, which is</p>
<p>used to launch<b> MTerminal</b> as a stand-alone application. For a description of the</p>
<p>arguments that can be used to set the parameters of your connection, see âmterminal</p>
<p>Syntax and Argumentsâ on page 654.</p>
<p>Saved serial connections are stored in:</p>
<p>â¢</p>
<p>Windows 7/Vista â<i><b> user_dir</i>\AppData\Roaming\GHS\serialconnection.odb</b></p>
<p>â¢</p>
<p>Windows XP â<i><b> user_dir</i>\Application Data\GHS\serialconnection.odb</b></p>
<p>â¢</p>
<p>Linux/Solaris â<i><b> user_dir</i>/.ghs/serialconnection.odb</b></p>
<p><b>Using the Serial Connection Settings Dialog</b></p>
<p>Like the Connection Methods described in Chapter 3, âConnecting to Your Targetâ</p>
<p>on page 39, Serial Connection Methods serve as templates that specify the settings</p>
<p>MULTI should use to establish a particular serial connection. You can use the<b> Serial</b></p>
<p><b>Connection Settings</b> dialog to configure a Serial Connection Method.</p>
<p>To create a new Serial Connection Method or change the configuration of an existing</p>
<p>Serial Connection Method:</p>
<p>1.</p>
<p>Open the<b> Serial Connection Chooser</b> (see âStarting the Serial Terminal</p>
<p>Emulator (MTerminal)â on page 644).</p>
<p>2.</p>
<p>Click</p>
<p>to create a new connection or</p>
<p>to edit an existing connection. This</p>
<p>will open a<b> Serial Connection Settings</b> dialog.</p>
<p><i>647</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the Serial Connection Settings Dialog</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Enter or change the name of your Serial Connection Method. If no name is</p>
<p>entered, the method you create will be a Temporary Serial Connection Method</p>
<p>and will exist only for the duration of the current<b> MTerminal</b> session.</p>
<p>4.</p>
<p>Enter or change the configuration settings for your Serial Connection Method.</p>
<p>For a description of the setting options, see âSerial Connection Settingsâ</p>
<p>on page 649.</p>
<p>5.</p>
<p>Click<b> Create</b> or<b> Apply</b> to save the Serial Connection Method (the button label</p>
<p>will depend on whether you are creating a new Method or editing an existing</p>
<p>one). The new (or modified) connection will be displayed in the<b> Serial</b></p>
<p><b>Connection Chooser</b> drop-down list.</p>
<p>Saved serial connections are stored in:</p>
<p>â¢</p>
<p>Windows 7/Vista â<i><b> user_dir</i>\AppData\Roaming\GHS\serialconnection.odb</b></p>
<p>â¢</p>
<p>Windows XP â<i><b> user_dir</i>\Application Data\GHS\serialconnection.odb</b></p>
<p>â¢</p>
<p>Linux/Solaris â<i><b> user_dir</i>/.ghs/serialconnection.odb</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>648</i></p>
<p><i>Chapter 27. Establishing Serial Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Serial Connection Settings</b></p>
<p>The following table describes the various settings that can be edited from the<b> Serial</b></p>
<p><b>Connection Settings</b> dialog.</p>
<p><b>Name</b></p>
<p>Specifies the name of the connection. If no name is entered, the method you create will be a</p>
<p>Temporary Serial Connection Method and will exist only for the duration of the current</p>
<p><b>MTerminal</b> session.</p>
<p><b>Log Connection to file</b></p>
<p>Logs the output from the serial port to the specified file. By default, this option is cleared (i.e.,</p>
<p>logging is disabled).</p>
<p><b>Serial Port</b></p>
<p>Identifies the name of the serial port to connect to. The default values in the list are determined</p>
<p>by the local host. If none of the values are applicable, you can type in the appropriate name.</p>
<p>(Serial port names can be prepended with<b> /dev</b>.)</p>
<p><b>Baud Rate</b></p>
<p>Specifies the baud rate for your connection. This setting defaults to<b> 9600</b>.</p>
<p><b>Data Bits</b></p>
<p>Specifies the data bits for your connection. This setting defaults to<b> 8</b>.</p>
<p><b>Parity</b></p>
<p>Specifies the parity for your connection. This setting defaults to<b> none</b>.</p>
<p><b>Stop Bits</b></p>
<p>Specifies the stop bits for your connection. This setting defaults to<b> 1</b>.</p>
<p><b>Flow Control</b></p>
<p>Specifies the flow control for your connection. This setting defaults to<b> none</b>.</p>
<p><i>649</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the Serial Connection Settings Dialog</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The MTerminal Window</b></p>
<p>The<b> MTerminal</b> window is a serial terminal window that opens when you use one</p>
<p>of the methods described in âStarting the Serial Terminal Emulator (MTerminal)â</p>
<p>on page 644.</p>
<p>You can use the main terminal window to interact with a serial port to which you</p>
<p>have connected. This window provides full<b> VT100</b> support.</p>
<p><b>The MTerminal Menu Bar</b></p>
<p>The<b> MTerminal</b> menu bar contains three menus: the<b> File</b> menu,<b> Edit</b> menu, and</p>
<p><b>Help</b> menu. The following sections describe the items available from each of these</p>
<p>menus.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>650</i></p>
<p><i>Chapter 27. Establishing Serial Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The File Menu</b></p>
<p>The table below lists the items available in the<b> File</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Opens the<b> Serial Connection Chooser</b>, which allows you to</p>
<p>create and/or edit Serial Connection Methods. For more</p>
<p>information, see âUsing the Serial Connection Chooserâ</p>
<p>on page 646.</p>
<p>This menu item is only available if the<b> MTerminal</b> window</p>
<p>is not connected to any serial port.</p>
<p><b>Connect</b></p>
<p>Closes the current serial connection. This menu item is only</p>
<p>available if the<b> MTerminal</b> window is connected to a serial</p>
<p>port.</p>
<p><b>Disconnect</b></p>
<p>Closes the<b> MTerminal</b> window.</p>
<p><b>Close MTerminal</b></p>
<p><b>The Edit Menu</b></p>
<p>The table below lists the items available in the<b> Edit</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Opens a submenu that allows you to adjust the baud rate of</p>
<p>a serial connection dynamically. The submenu items are only</p>
<p>available if a serial connection has been established.</p>
<p><b>Baud Rate</b></p>
<p>Sends a serial break to the serial port. This menu item is only</p>
<p>available if a serial connection has been established.</p>
<p><b>Send Break</b></p>
<p>Copies text selected in the terminal window.</p>
<p><b>Copy</b></p>
<p>Pastes previously copied text into the terminal window. This</p>
<p>menu item is only available if a serial connection has been</p>
<p>established.</p>
<p><b>Paste</b></p>
<p>Clears text from the terminal window.</p>
<p><b>Clear</b></p>
<p><b>The Help Menu</b></p>
<p>The table below lists the items available in the<b> Help</b> menu.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Displays online help information about<b> MTerminal</b>.</p>
<p><b>MTerminal Help</b></p>
<p><i>651</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The MTerminal Menu Bar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Shows basic information about<b> MTerminal</b>, including the</p>
<p>version number and revision date.</p>
<p><b>About</b></p>
<p><b>The MTerminal Toolbar</b></p>
<p>The<b> MTerminal</b> toolbar contains buttons and drop-down lists that allow you to</p>
<p>connect to a serial port, disconnect from a serial port, Quick Connect, and copy,</p>
<p>paste, and clear text in the terminal window. The following table describes the</p>
<p>buttons and fields available on the<b> MTerminal</b> toolbar.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Establishes a serial connection. This button is only available</p>
<p>if the<b> MTerminal</b> window is not connected to any serial port.</p>
<p>Clicking this button opens a drop-down menu that contains</p>
<p>the following selections:</p>
<p>â¢</p>
<p><b>Connect</b> â Opens the<b> Serial Connection Chooser</b>,</p>
<p>which allows you to create and/or edit Serial Connection</p>
<p>Methods. For more information, see âUsing the Serial</p>
<p>Connection Chooserâ on page 646.</p>
<p>â¢</p>
<p><i>Recently used Serial Connection Methods</i> â Attempts</p>
<p>to establish a connection to the serial port described in</p>
<p>the selected method.</p>
<p><b>Connect</b></p>
<p>Closes the current serial connection. This button is only</p>
<p>available if the<b> MTerminal</b> window is connected to a serial</p>
<p>port.</p>
<p><b>Disconnect</b></p>
<p>Allows you to adjust the baud rate of a serial connection</p>
<p>dynamically.</p>
<p><b>Baud Rate</b></p>
<p>Specifies the local serial port to use for Quick Connect.</p>
<p><b>Port</b></p>
<p>Connects to a local serial port based on the information</p>
<p>selected in the<b> Baud Rate</b> and<b> Port</b> drop-down lists.</p>
<p><b>Quick Connect</b></p>
<p>Sends a serial break to the serial port. This button is only</p>
<p>available if a serial connection has been established.</p>
<p><b>Send Break</b></p>
<p>Copies text selected in the terminal window.</p>
<p><b>Copy</b></p>
<p>Pastes previously copied text into the terminal window. This</p>
<p>button is only available if a serial connection has been</p>
<p>established.</p>
<p><b>Paste</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>652</i></p>
<p><i>Chapter 27. Establishing Serial Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Clears text from the terminal window.</p>
<p><b>Clear</b></p>
<p><b>The MTerminal Status Bar</b></p>
<p>The<b> MTerminal</b> status bar lists information about the parameters of the serial</p>
<p>connection. Status bar information, as it is displayed from left to right, follows:</p>
<p>â¢</p>
<p>The status of the connection (either<b> Connected</b> or<b> Disconnected</b>)</p>
<p>â¢</p>
<p>The name of the host on which the serial port is located (or<b> localhost</b> if the</p>
<p>port is on the local host)</p>
<p>â¢</p>
<p>The baud rate</p>
<p>â¢</p>
<p>The parity (prepended by<b> P:</b>)</p>
<p>â¢</p>
<p>The data bits (prepended by<b> DB:</b>)</p>
<p>â¢</p>
<p>The stop bits (prepended by<b> SB:</b>)</p>
<p>â¢</p>
<p>The flow control (prepended by<b> FC:</b>)</p>
<p>â¢</p>
<p>The name of the serial port</p>
<p><b>Running the Serial Terminal Emulator in Console Mode</b></p>
<p><b>MTerminal</b> can be run in a non-GUI console mode on Linux/Solaris hosts. This</p>
<p>might be useful when running validations. To run<b> MTerminal</b> in console mode,</p>
<p>launch the serial terminal emulator from the command line using the<b> -nodisplay</b></p>
<p>option. For example, to connect to the</p>
<p>ttyS0</p>
<p>port using the default parameters for</p>
<p>the serial settings, you would enter the command:</p>
<p><b>mterminal</b> ttyS0<b> -nodisplay</b></p>
<p><b>Note</b></p>
<p>Console mode does not have<b> VT100</b> support.</p>
<p><i>653</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The MTerminal Status Bar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>mterminal Syntax and Arguments</b></p>
<p>To launch<b> MTerminal</b> as a stand-alone application, run the<b> mterminal</b> command</p>
<p>from the command line. The command usage is:</p>
<p><b>mterminal<i></b> port_name</i> [<i>mterminal_parameters</i>]</p>
<p>where</p>
<p><i>port_name</i></p>
<p>specifies what serial port is being used (for example,</p>
<p>ttya</p>
<p>,</p>
<p>ttyS0</p>
<p>, or</p>
<p>COM1</p>
<p>), and</p>
<p><i>mterminal_parameters</i></p>
<p>can be one or more of the options</p>
<p>listed in the following table. (Parameters that are not specified use default values.)</p>
<p><b>Note</b></p>
<p>The following arguments can also be used with the<b> serialconnect</b></p>
<p>command, which you can enter in the<b> Make Serial Connection</b> text field</p>
<p>of the<b> Serial Connection Chooser</b>. For more information, see âUsing</p>
<p>the Serial Connection Chooserâ on page 646.</p>
<p>Specifies the baud rate, where</p>
<p><i>baudrate</i></p>
<p>can be any one of the</p>
<p>following:</p>
<p>50</p>
<p>,</p>
<p>75</p>
<p>,</p>
<p>110</p>
<p>,</p>
<p>134</p>
<p>,</p>
<p>150</p>
<p>,</p>
<p>200</p>
<p>,</p>
<p>300</p>
<p>,</p>
<p>600</p>
<p>,</p>
<p>1200</p>
<p>,</p>
<p>1800</p>
<p>,</p>
<p>2400</p>
<p>,</p>
<p>4800</p>
<p>,</p>
<p>9600</p>
<p>,</p>
<p>19200</p>
<p>,</p>
<p>38400</p>
<p>,</p>
<p>57600</p>
<p>,</p>
<p>115200</p>
<p>, or</p>
<p>230400</p>
<p>. The default</p>
<p>is</p>
<p>9600</p>
<p>.</p>
<p><b>-baud<i> baudrate</b></i></p>
<p>Specifies the data bits, where</p>
<p><i>DB</i></p>
<p>can be</p>
<p>5</p>
<p>,</p>
<p>6</p>
<p>,</p>
<p>7</p>
<p>, or</p>
<p>8</p>
<p>. The default is</p>
<p>8</p>
<p>.</p>
<p><b>-databits<i> DB</b></i></p>
<p>Specifies flow control, where</p>
<p><i>FC</i></p>
<p>can be</p>
<p>none</p>
<p>or</p>
<p>xonxoff</p>
<p>. The default</p>
<p>is</p>
<p>none</p>
<p>.</p>
<p><b>-flowcontrol<i> FC</b></i></p>
<p>Prints help information. This option is only valid in console mode and</p>
<p>does not work on Windows hosts.</p>
<p><b>-help</b></p>
<p>Enables logging and specifies the name of the file to which data is</p>
<p>written. By default, logging is disabled.</p>
<p><b>-log_file<i> filename</b></i></p>
<p>Runs<b> mterminal</b> in console mode. This option causes all output to be</p>
<p>printed to standard output and all input to be received from standard</p>
<p>input. In console mode, no graphical windows appear and the serial</p>
<p>port must be specified. This option does not work on Windows hosts.</p>
<p><b>-nodisplay</b></p>
<p>Specifies parity, where</p>
<p><i>P</i></p>
<p>can be</p>
<p>none</p>
<p>,</p>
<p>even</p>
<p>, or</p>
<p>odd</p>
<p>. The default is</p>
<p>none</p>
<p>.</p>
<p><b>-parity<i> P</b></i></p>
<p>Specifies stop bits, where</p>
<p><i>SB</i></p>
<p>can be either</p>
<p>1</p>
<p>or</p>
<p>2</p>
<p>. The default is</p>
<p>1</p>
<p>.</p>
<p><b>-stopbits<i> SB</b></i></p>
<p><i>MULTI: Debugging</i></p>
<p><i>654</i></p>
<p><i>Chapter 27. Establishing Serial Connections</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The following example starts the GUI version of<b> MTerminal</b> on the serial port</p>
<p>ttyS0</p>
<p>. The baud rate is</p>
<p>38400</p>
<p>.</p>
<p>mterminal ttyS0 -baud 38400</p>
<p><i>655</i></p>
<p><i>Green Hills Software</i></p>
<p><i>mterminal Syntax and Arguments</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Part VI</b></p>
<p><b>Appendices</b></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Appendix A</b></p>
<p><b>Debugger GUI Reference</b></p>
<p><b>Contents</b></p>
<p>Debugger Window Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>660</p>
<p>The Debugger Window Toolbar . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>691</p>
<p>The Target List Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>702</p>
<p>Source Pane Shortcut Menus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>704</p>
<p>The Command Pane Shortcut Menu . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>712</p>
<p>The Source Pane Search Dialog Box . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>712</p>
<p>The File Chooser Dialog Box (Linux/Solaris) . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>713</p>
<h1 style="page-break-before:always; "></h1>
<p>This appendix contains detailed descriptions of the menus and toolbar buttons</p>
<p>available in the main Debugger window, as well as descriptions of some of the</p>
<p>dialog boxes you can open via these menus and buttons. Most of these items are</p>
<p>mentioned in the main text of this book in the context in which they are used. They</p>
<p>are listed here together to provide a comprehensive reference.</p>
<p>For information about other GUI elements of the Debugger window, including</p>
<p>descriptions of the target list, source pane, navigation bar, and information panes,</p>
<p>see Chapter 2, âThe Main Debugger Windowâ on page 11.</p>
<p><b>Note</b></p>
<p>Some menu items, shortcuts, commands, and dialog box buttons open a</p>
<p>file chooser that allows you to browse to and specify a file for a particular</p>
<p>operation. For information about how to use a Windows file chooser, see</p>
<p>your Windows documentation. For information about the Linux/Solaris</p>
<p>file chooser, see âThe File Chooser Dialog Box (Linux/Solaris)â</p>
<p>on page 713.</p>
<p><b>Debugger Window Menus</b></p>
<p>The sections below describe the menu items that are accessible from the Debugger</p>
<p>window's menu bar.</p>
<p>Context-sensitive menu items are dimmed if they are unavailable in your current</p>
<p>environment. For example, if you are debugging a running process, the<b> Go on</b></p>
<p><b>Selected Items</b> item in the<b> Debug</b> menu is dimmed.</p>
<p>The menus on the main Debugger window, from left to right, are:</p>
<p>â¢</p>
<p>The<b> File</b> menu (see âThe File Menuâ on page 661)</p>
<p>â¢</p>
<p>The<b> Debug</b> menu (see âThe Debug Menuâ on page 665)</p>
<p>â¢</p>
<p>The<b> View</b> menu (see âThe View Menuâ on page 673)</p>
<p>â¢</p>
<p>The<b> Browse</b> menu (see âThe Browse Menuâ on page 679)</p>
<p>â¢</p>
<p>The<b> Target</b> menu (see âThe Target Menuâ on page 680)</p>
<p>â¢</p>
<p>The<b> TimeMachine</b> menu (see âThe TimeMachine Menuâ on page 683)</p>
<p>â¢</p>
<p>The<b> Tools</b> menu (see âThe Tools Menuâ on page 685)</p>
<p><i>MULTI: Debugging</i></p>
<p><i>660</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>The<b> Config</b> menu (see âThe Config Menuâ on page 687)</p>
<p>â¢</p>
<p>The<b> Windows</b> menu (see âThe Windows Menuâ on page 690)</p>
<p>â¢</p>
<p>The<b> Help</b> menu (see âThe Help Menuâ on page 691)</p>
<p><b>The File Menu</b></p>
<p>The following table describes the selections available from the<b> File</b> menu in the</p>
<p>main Debugger window.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a file chooser from which you can select a program to debug.</p>
<p>MULTI adds the program to the target list and loads it in the Debugger</p>
<p>window. The script file (if any) of the new program being debugged is</p>
<p>executed and the final debugging environment is shared by the active</p>
<p>Debugger window and secondary Debugger windows (if any).</p>
<p>Corresponds to: the<b> dbnew</b> command (see Chapter 2, âGeneral Debugger</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Debug Program as</b></p>
<p><b>New Entry</b></p>
<p>Similar to<b> Debug Program as New Entry</b>, except that the previously</p>
<p>debugged program is removed from the target list and terminated or</p>
<p>detached. The script file (if any) of the new program being debugged is</p>
<p>executed to establish the final debugging environment. Any configuration</p>
<p>changes made during the debugging session of the previous program</p>
<p>remain in effect unless overridden.</p>
<p>Corresponds to: the<b> debug</b> command (see Chapter 2, âGeneral Debugger</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Debug Program</b></p>
<p>Opens the<b> Print</b> (Windows) or<b> Print Setup</b> (Linux/Solaris) dialog box.</p>
<p>The dialog box allows you to print the current source file, including</p>
<p>interlaced assembly code if it is the current display mode, but not</p>
<p>including non-ASCII characters. If no high-level source file is available</p>
<p>(that is, there is only assembly code), this option is unavailable.</p>
<p>For details, see âThe Print Setup Dialog Boxâ on page 663.</p>
<p><b>Print</b></p>
<p>Opens the<b> Print</b> (Windows) or<b> Print Setup</b> (Linux/Solaris) dialog box</p>
<p>to print the visible, ASCII contents of the source pane.</p>
<p>For details, see âThe Print Setup Dialog Boxâ on page 663.</p>
<p><b>Print Window</b></p>
<p><i>661</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The File Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a file chooser for you to specify a file to save to. You can save</p>
<p>the source file, including interlaced assembly code if it is the current</p>
<p>display mode, but you cannot save non-ASCII characters. If no high-level</p>
<p>source file is available (that is, there is only assembly code), only the</p>
<p>contents of the source pane are saved.</p>
<p>Click<b> Save</b> in the file chooser to perform the save.</p>
<p><b>Write to File</b></p>
<p>Opens a dialog box for you to specify the ID of a running task. This</p>
<p>menu option only works with a multitasking target. Clicking<b> OK</b> in the</p>
<p>dialog box adds a new target list entry for the selected process and loads</p>
<p>the task in the Debugger window.</p>
<p>Corresponds to: the<b> attach</b> command (see Chapter 2, âGeneral Debugger</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Attach to Process</b></p>
<p>In run mode, detaches the Debugger from the current process, and selects</p>
<p>the next program in the target list. If you are not debugging in run mode,</p>
<p>the entry for the current process is removed from the target list, but the</p>
<p>debug server remains connected. All breakpoints are removed before</p>
<p>detaching.</p>
<p>Corresponds to: the<b> detach</b> command (see Chapter 2, âGeneral Debugger</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Detach from</b></p>
<p><b>Process</b></p>
<p>Lists the most recent programs opened in the Debugger. To debug one</p>
<p>of these in the current Debugger window, select it.</p>
<p><b>1<i> pathname</b></i></p>
<p><b>2<i> pathname</b></i></p>
<p><b>3<i> pathname</b></i></p>
<p><b>4<i> pathname</b></i></p>
<p>Removes the currently selected entry from the target list. If the entry is</p>
<p>a connection, selecting this option disconnects from it. In run mode,</p>
<p>MULTI detaches from a selected process. If you are not debugging in</p>
<p>run mode, MULTI terminates a selected process. If the entry is the only</p>
<p>remaining entry in the target list, all Debugger windows close and the</p>
<p>Debugger exits.</p>
<p>Corresponds to:<b> Ctrl</b>+<b>W</b> and the<b> quit entry</b> command (see Chapter 2,</p>
<p>âGeneral Debugger Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Close Entry</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>662</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Closes the current Debugger window, but does not detach from or</p>
<p>terminate any process unless the current Debugger window is the only</p>
<p>one remaining. If the current Debugger window is the only one</p>
<p>remaining, MULTI detaches from run-mode processes and terminates</p>
<p>non-run-mode processes when it closes the window.</p>
<p>Corresponds to:</p>
<p>,<b> Ctrl</b>+<b>Q</b>, and the<b> quit window</b> command (see Chapter</p>
<p>2, âGeneral Debugger Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Close Debugger</b></p>
<p><b>Window</b></p>
<p>Closes all MULTI IDE windows and exits.</p>
<p>Corresponds to: the<b> quitall</b> command (see Chapter 2, âGeneral Debugger</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Exit All</b></p>
<p><b>The Print Setup Dialog Box</b></p>
<p>On Windows, selecting a printing operation from the<b> File</b> menu opens a standard</p>
<p><b>Print</b> dialog box with settings and options appropriate for your version of Windows</p>
<p>and your printer and printer driver. See your Windows and printer documentation</p>
<p>for details about the settings on this dialog.</p>
<p>On Linux/Solaris systems, selecting a printing operation from the<b> File</b> menu opens</p>
<p>the following<b> Print Setup</b> dialog box.</p>
<p>The settings of the<b> Print Setup</b> dialog box are described in the following table.</p>
<p><i>663</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The File Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Specifies where to send the print output. Select either<b> Printer</b> (the</p>
<p>default) or<b> File</b> (to write to a postscript file).</p>
<p><b>Print To</b></p>
<p>Specifies the print command that will be run when you click<b> Print</b>. Enter</p>
<p>the appropriate command and options for printing a file on your specific</p>
<p>system (for example,<b> lpr</b> on Linux/Solaris).</p>
<p>You can also set the print command with the<b> configure printCommand</b></p>
<p>command. For information about the<b> configure</b> command, see âUsing</p>
<p>the configure Commandâ in Chapter 7, âConfiguring and Customizing</p>
<p>MULTIâ in the<i> MULTI: Managing Projects and Configuring the IDE</i></p>
<p>book.</p>
<p>This field is only available if you have chosen the<b> Printer</b> radio button</p>
<p>above.</p>
<p><b>Print Command</b></p>
<p>Specifies the output post-script file for print to file operations. This field</p>
<p>is only available if you have selected the<b> File</b> radio button above. Enter</p>
<p>the file to write to, or click<b> Browse</b> to open a chooser and navigate to</p>
<p>an existing file. (See âThe File Chooser Dialog Box (Linux/Solaris)â</p>
<p>on page 713 for a description of the chooser.)</p>
<p><b>Filename</b></p>
<p>Specifies the font for your printing operations. Select your desired font</p>
<p>from the drop-down list, which contains a list of available fonts on your</p>
<p>system. You can also type a font name into this field if it is not in the</p>
<p>list.</p>
<p><b>Font Name</b></p>
<p>Specifies the font size used for printing. Select your desired size from</p>
<p>the drop-down list. The default font size is 8 point.</p>
<p><b>Font Size</b></p>
<p>Specifies your paper size. Select<b> Letter</b>,<b> Legal</b>,<b> Executive</b>, or<b> A4</b>. The</p>
<p>default setting is<b> Letter</b>.</p>
<p><b>Paper Size</b></p>
<p>Specifies the layout for your printed document. Select<b> Portrait</b> or</p>
<p><b>Landscape</b>. The default setting is<b> Portrait</b>.</p>
<p><b>Orientation</b></p>
<p>Specifies whether to print the output in one or two columns. The default</p>
<p>setting is<b> 1</b>.</p>
<p><b>Columns</b></p>
<p>Executes the print request.</p>
<p><b>Print</b></p>
<p>Cancels the print request and discards any settings you have changed.</p>
<p><b>Cancel</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>664</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Debug Menu</b></p>
<p>The following table describes the selections available from the<b> Debug</b> menu in the</p>
<p>main Debugger window.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a dialog box where you can specify the arguments for the current</p>
<p>program. (Program arguments can only be passed to stand-alone</p>
<p>applications that are started from MULTI.) The dialog box also allows</p>
<p>you to control input and output redirection for the current process. See</p>
<p>âThe Arguments Dialog Boxâ on page 668.</p>
<p>Corresponds to: the<b> setargs</b> command and the<b> r</b> command (see âGeneral</p>
<p>Program Execution Commandsâ in Chapter 13, âProgram Execution</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Set Program</b></p>
<p><b>Arguments</b></p>
<p>Starts or resumes items selected in the target list. This menu item cannot</p>
<p>be used to start tasks on VxWorks systems. For information about starting</p>
<p>tasks on these systems, see the<b> runtask</b> command in âRun Commandsâ</p>
<p>in Chapter 13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>Corresponds to:</p>
<p>,<b> F5</b>, and the<b> c</b> command (see âContinue Commandsâ</p>
<p>in Chapter 13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Go on Selected</b></p>
<p><b>Items</b></p>
<p>Starts or restarts the current program being debugged, with preset</p>
<p>arguments (if any).</p>
<p>If you select this menu item while debugging a Dynamic Download</p>
<p>INTEGRITY application, MULTI attempts to (re)load the application.</p>
<p>This menu item may not be available for relocatable modules.</p>
<p>Corresponds to:</p>
<p>,<b> Ctrl</b>+<b>Shift</b>+<b>F5</b>, and the<b> restart</b> command (see âRun</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Restart</b></p>
<p>Halts the items selected in the target list.</p>
<p>Corresponds to:</p>
<p>and the<b> halt</b> command (see âHalt Commandsâ in</p>
<p>Chapter 13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Halt on Selected</b></p>
<p><b>Items</b></p>
<p>Kills the items selected in the target list.</p>
<p>Corresponds to:<b> Shift</b>+<b>F5</b> and the<b> k</b> command (see âHalt Commandsâ</p>
<p>in Chapter 13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Kill Selected Items</b></p>
<p><i>665</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Debug Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Executes single statements, stepping into procedure calls of items that</p>
<p>are selected in the target list.</p>
<p>Corresponds to:</p>
<p>,<b> F11</b>, and the<b> s</b> command (see âSingle-Stepping</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Step (into</b></p>
<p><b>Functions) on</b></p>
<p><b>Selected Items</b></p>
<p>Executes single statements, stepping over procedure calls of items that</p>
<p>are selected in the target list.</p>
<p>Corresponds to:</p>
<p>,<b> F10</b>, and the<b> n</b> command (see âSingle-Stepping</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Next (over</b></p>
<p><b>Functions) on</b></p>
<p><b>Selected Items</b></p>
<p>For items that are selected in the target list, continues execution to the</p>
<p>end of the current subroutine and stops in the calling routine after</p>
<p>returning to it.</p>
<p>Corresponds to:</p>
<p>,<b> F9</b>, and the<b> cU</b> command (see âContinue Commandsâ</p>
<p>in Chapter 13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Return on Selected</b></p>
<p><b>Items</b></p>
<p>Continues execution to the location of the current line pointer.</p>
<p>Corresponds to:<b> Ctrl</b>+<b>F10</b></p>
<p><b>Run to Cursor</b></p>
<p>Halts all tasks on the target system, thereby freezing the target. This</p>
<p>menu item is not supported on all operating systems and only appears</p>
<p>if a run-mode connection is selected in the target list.</p>
<p>Corresponds to: the<b> groupaction -h @system</b> command (see Chapter</p>
<p>19, âTask Group Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Halt System</b></p>
<p>Restores the tasks on the target to the status they held before the system</p>
<p>was halted. This menu item only appears if a run-mode connection is</p>
<p>selected in the target list.</p>
<p>Corresponds to: the<b> groupaction -r @system</b> command (see Chapter</p>
<p>19, âTask Group Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Run System</b></p>
<p>Opens a dialog box that specifies the signal name and then sends a signal</p>
<p>to the current process. To list signal names, enter the<b> l z</b> (lowercase L</p>
<p>lowercase Z) command. See the<b> l</b> command in Chapter 8, âDisplay and</p>
<p>Print Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Send Signal</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>666</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a dialog box that creates a watchpoint.</p>
<p>Corresponds to: the<b> watchpoint</b> command (see Chapter 3, âBreakpoint</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Set Watchpoint</b></p>
<p>Deletes software breakpoints:</p>
<p>â¢</p>
<p>If the OSA master process is selected in the target list â Deletes</p>
<p>all normal software breakpoints (except group breakpoints) in the</p>
<p>master process. For more information, see âWorking with</p>
<p>Freeze-Mode Breakpointsâ on page 618.</p>
<p>â¢</p>
<p>If a run-mode AddressSpace is selected in the target list and you</p>
<p>are using INTEGRITY 10 or later â Deletes all any-task</p>
<p>breakpoints in the AddressSpace.</p>
<p>â¢</p>
<p>If a task is selected in the target list â Deletes all task-specific</p>
<p>software breakpoints in the task.</p>
<p>Corresponds to: the<b> D</b> command (see Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Remove All</b></p>
<p><b>Breakpoints</b></p>
<p>Toggles the active state of all software breakpoints of the current program</p>
<p>(i.e. all currently enabled breakpoints will be disabled, and all currently</p>
<p>disabled breakpoints will be enabled).</p>
<p>Corresponds to: the<b> Tog</b> command (see Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Toggle All</b></p>
<p><b>Breakpoints</b></p>
<p>Opens the<b> Prepare Target</b> dialog box, which you can use to select a</p>
<p>method for setting up your target. You can download your program to</p>
<p>RAM, flash it to ROM, or verify that it is already on the target. This</p>
<p>menu item opens the<b> Prepare Target</b> dialog box even if you saved an</p>
<p>action for the selected program by clicking<b> Automatically use these</b></p>
<p><b>settings for this program next time</b> in the dialog box the last time you</p>
<p>prepared the target. For more information, see âPreparing Your Targetâ</p>
<p>on page 108.</p>
<p>This menu item may not be available for relocatable modules.</p>
<p>Corresponds to:</p>
<p>and the<b> prepare_target</b> command (see âGeneral</p>
<p>Target Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Prepare Target</b></p>
<p>Opens the<b> Use Connection</b> submenu. See âThe Use Connection</p>
<p>Submenuâ on page 670.</p>
<p><b>Use Connection</b></p>
<p><i>667</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Debug Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the<b> Debug Settings</b> submenu. See âThe Debug Settings Submenuâ</p>
<p>on page 670.</p>
<p><b>Debug Settings</b></p>
<p>Opens the<b> Target Settings</b> submenu. See âThe Target Settings Submenuâ</p>
<p>on page 672.</p>
<p><b>Target Settings</b></p>
<p><b>The Arguments Dialog Box</b></p>
<p>The<b> Arguments</b> dialog box opens when you select<b> Debug</b> â<b> Set Program</b></p>
<p><b>Arguments</b>. When the dialog box first appears, it may be displayed in a contracted</p>
<p>form:</p>
<p>To expand the dialog box to see the I/O setting fields, click the small plus sign icon</p>
<p>(</p>
<p>)on the bottom right corner of the contracted dialog box. The expanded dialog</p>
<p>box is shown next.</p>
<p>To hide the three I/O fields, click the minus sign (</p>
<p>) to the right of the line dividing</p>
<p>the top and bottom sections of the dialog box.</p>
<p>The following table describes the items in the expanded<b> Arguments</b> dialog box.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>668</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Specifies the arguments to be passed to the current program the next</p>
<p>time you run it without specifying any arguments (for example, by</p>
<p>clicking</p>
<p>or</p>
<p>, or by executing the<b> r</b> command, etc.). Program</p>
<p>arguments can only be passed to stand-alone applications that are started</p>
<p>from MULTI. If you specify any arguments in the next execution (with</p>
<p>the<b> r</b> command, for example) the existing arguments in the<b> Arguments</b></p>
<p>field are replaced by the ones specified. These new arguments are</p>
<p>displayed the next time the<b> Arguments</b> dialog box is opened.</p>
<p><b>Arguments</b></p>
<p>Runs the program with the arguments specified in the<b> Arguments</b> text</p>
<p>field.</p>
<p>The</p>
<p>button</p>
<p>Restarts the process with the arguments specified in the<b> Arguments</b> text</p>
<p>field.</p>
<p>The</p>
<p>button</p>
<p>Closes the<b> Arguments</b> dialog box.</p>
<p>Whether this button appears on your toolbar depends on the setting of</p>
<p>the option<b> Display close (x) buttons</b>. To access this option, select<b> Config</b></p>
<p>â<b> Options</b> â<b> General Tab</b>.</p>
<p>The</p>
<p>button</p>
<p>Specifies a file on the host system that will be used as input to your</p>
<p>process. Enter a filename, or click</p>
<p>to open a file chooser to browse</p>
<p>to an existing file. If this field is not specified, the input comes from</p>
<p>standard input.</p>
<p><b>stdin (&lt;)</b></p>
<p>Specifies a file on the host system that will capture output from your</p>
<p>process. Enter a filename, or click</p>
<p>to open a file chooser to browse</p>
<p>to an existing file. If this field is not specified, the output goes to standard</p>
<p>output.</p>
<p><b>stdout (&gt;)</b></p>
<p>Specifies the directory in which the process runs or, for embedded</p>
<p>processes that use host I/O, specifies the directory that MULTI uses to</p>
<p>perform host I/O operations.</p>
<p>Enter a directory, or click</p>
<p>to open a directory chooser to browse to</p>
<p>an existing directory.</p>
<p>For information about the command equivalent of this field, see the</p>
<p><b>rundir</b> command in âRun Commandsâ in Chapter 13, âProgram</p>
<p>Execution Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Start in</b></p>
<p><i>669</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Debug Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Use Connection Submenu</b></p>
<p>The following table describes the selections available from the<b> Debug</b> â<b> Use</b></p>
<p><b>Connection</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Associates the current executable with the specified connection. Only</p>
<p>compatible, currently active connections are listed. If a connection</p>
<p>appears dimmed, the current executable cannot be associated with that</p>
<p>connection, or it is already associated with that connection.<i><b> Status</b></i> is</p>
<p>listed either as:<b> Available</b> (the connection can accept more executables),</p>
<p><b>Current</b> (the connection is associated with the current executable), or</p>
<p><b>Full</b> (using the connection will cause another executable to stop using</p>
<p>it). For more information, see âAssociating Your Executable with a</p>
<p>Connectionâ on page 105.</p>
<p><b>[<i>Status</i>]</b></p>
<p><i><b>Connection_Name</b></i></p>
<p>Disassociates the selected executable from the connection it is currently</p>
<p>associated with. Selecting this menu item does not disconnect from the</p>
<p>target debug server. For more information, see âAssociating Your</p>
<p>Executable with a Connectionâ on page 105.</p>
<p>Corresponds to: the<b> change_binding unbind</b> command (see âGeneral</p>
<p>Target Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Stop Using Current</b></p>
<p><b>Connection</b></p>
<p>Opens the<b> Connection Chooser</b>, which you can use to establish a</p>
<p>connection. For more information, see âCreating a Standard Connection</p>
<p>Using the Connection Chooserâ on page 43.</p>
<p><b>Create New</b></p>
<p><b>Connection</b></p>
<p><b>The Debug Settings Submenu</b></p>
<p>The following table describes the selections available from the<b> Debug</b> â<b> Debug</b></p>
<p><b>Settings</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Toggles the option to attach to child processes spawned by calls to</p>
<p>fork()</p>
<p>. This option is only supported on native targets.</p>
<p>Corresponds to: the<b> P c</b> command (see Chapter 2, âGeneral Debugger</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Attach on</b></p>
<p><b>Fork/Thread</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>670</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Controls whether the Debugger attempts to limit memory reads from</p>
<p>the target. See âMemory Sensitive Modeâ on page 115.</p>
<p>Corresponds to: the</p>
<p>_VOLATILE</p>
<p>system variable.</p>
<p><b>Memory Sensitive</b></p>
<p>Controls whether the Debugger uses a cache to read memory more</p>
<p>efficiently. When enabled, the Debugger reads memory in blocks, which</p>
<p>are stored in a cache. This reduces the number of memory accesses</p>
<p>required. For example, with the cache active, printing a structure with</p>
<p>ten members would require only one memory read as opposed to ten</p>
<p>memory reads. However, this could cause problems when accessing</p>
<p>volatile memory.</p>
<p>Corresponds to: the</p>
<p>_CACHE</p>
<p>system variable (see âSystem Variablesâ</p>
<p>on page 310).</p>
<p><b>Cache Memory</b></p>
<p><b>Reads</b></p>
<p>Controls whether the Debugger displays disassembly for programs based</p>
<p>on the code in the executable file, as opposed to the contents of memory.</p>
<p>When enabled, the Debugger disassembles instructions found in the</p>
<p>executable file. This has the advantage of not requiring any memory</p>
<p>reads from the target. When disabled, the Debugger reads instructions</p>
<p>from target memory when disassembling.</p>
<p>Corresponds to: the</p>
<p>_ASMCACHE</p>
<p>system variable (see âSystem Variablesâ</p>
<p>on page 310).</p>
<p><b>Disassemble From</b></p>
<p><b>Host</b></p>
<p>Controls whether the Debugger is allowed to access the stack for stack</p>
<p>trace information. When the setting is enabled, stack traces are</p>
<p>disallowed. This can be useful if you know that the stack does not contain</p>
<p>a valid stack trace, and you want to prevent the Debugger from attempting</p>
<p>to trace into invalid memory. See âNo Stack Trace Modeâ on page 116.</p>
<p>Corresponds to: the</p>
<p>_NOSTACKTRACE</p>
<p>system variable.</p>
<p><b>No Stack Trace</b></p>
<p>Controls whether the Debugger checks coherency automatically. When</p>
<p>automatic coherency checking is enabled, MULTI checks the coherency</p>
<p>of the specified number of addresses at every stop (see<b> Number of</b></p>
<p><b>Addresses to Check</b> below). If it finds discrepancies between the</p>
<p>contents of memory and what you loaded onto your target, it highlights</p>
<p>the differing lines in the source pane. See âChecking Coherency</p>
<p>Automaticallyâ on page 537.</p>
<p>Corresponds to: the</p>
<p>_AUTO_CHECK_COHERENCY</p>
<p>system variable (see</p>
<p>âSystem Variablesâ on page 310).</p>
<p><b>Auto Check</b></p>
<p><b>Coherency</b></p>
<p><i>671</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Debug Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a dialog box where you can enter the number of addresses you</p>
<p>want checked for coherency on each stop. By default, MULTI checks</p>
<p>either 16 addresses or the number of addresses lasting the length of 4</p>
<p>instructions (whichever is fewer). MULTI attempts to check an equal</p>
<p>number of addresses before and after the current program counter;</p>
<p>however, it does not cross procedure boundaries. For more information,</p>
<p>see âChecking Coherency Automaticallyâ on page 537.</p>
<p>See also<b> Auto Check Coherency</b> above.</p>
<p>Corresponds to: the</p>
<p>_AUTO_CHECK_NUM_ADDRS</p>
<p>system variable (see</p>
<p>âSystem Variablesâ on page 310).</p>
<p><b>Number of</b></p>
<p><b>Addresses to Check</b></p>
<p>Controls whether the Debugger attempts to speed up stepping through</p>
<p>source code. When enabled, on each source step, the Debugger analyzes</p>
<p>the code, sets temporary breakpoints on all possible step destinations,</p>
<p>and allows the process to run until one of the breakpoints is hit. This</p>
<p>allows the process to run at nearly full speed during the source step.</p>
<p>When disabled, the Debugger usually steps one machine instruction at</p>
<p>a time until it reaches the next source line. However, even when disabled,</p>
<p>the Debugger sets temporary breakpoints and runs to step over function</p>
<p>calls. This method is generally much slower.</p>
<p>Corresponds to: the</p>
<p>FASTSTEP</p>
<p>system variable (see âSystem Variablesâ</p>
<p>on page 310).</p>
<p><b>Fast Source Step</b></p>
<p><b>The Target Settings Submenu</b></p>
<p>The following table describes the selections available from the<b> Debug</b> â<b> Target</b></p>
<p><b>Settings</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Specifies whether you want the target's operating system to halt each</p>
<p>task as soon as it is created by the application.</p>
<p><b>Stop on Task</b></p>
<p><b>Creation</b></p>
<p>Specifies whether you want to debug the newly created task. If enabled,</p>
<p>each newly created task is halted and opened in the Debugger window.</p>
<p>This option is applicable only when the<b> Stop on Task Creation</b> menu</p>
<p>item is selected.</p>
<p><b>Attach on Task</b></p>
<p><b>Creation</b></p>
<p>Specifies whether you want MULTI to automatically halt tasks when</p>
<p>you attach to them. You cannot use this option when MULTI is in passive</p>
<p>mode (see âDebugging in Passive Modeâ on page 574).</p>
<p><b>Halt on Attach</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>672</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Specifies whether you want MULTI to automatically run tasks when</p>
<p>you detach from them. You cannot use this option when MULTI is in</p>
<p>passive mode (see âDebugging in Passive Modeâ on page 574).</p>
<p><b>Run on Detach</b></p>
<p><b>The View Menu</b></p>
<p>The following table describes the selections available from the<b> View</b> menu in the</p>
<p>main Debugger window.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the<b> Navigation</b> submenu. See âThe Navigation Submenuâ</p>
<p>on page 676.</p>
<p><b>Navigation</b></p>
<p>Opens the<b> Display Mode</b> submenu. See âThe Display Mode Submenuâ</p>
<p>on page 677.</p>
<p><b>Display Mode</b></p>
<p>Opens the<b> Breakpoints</b> window. See âThe Breakpoints Windowâ</p>
<p>on page 146.</p>
<p>Corresponds to:</p>
<p>and the<b> breakpoints</b> command (see Chapter 3,</p>
<p>âBreakpoint Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>Breakpoints</b></p>
<p>Opens a<b> Call Stack</b> window. See âViewing Call Stacksâ on page 388.</p>
<p>Corresponds to:</p>
<p>and the<b> callsview</b> command (see Chapter 5, âCall</p>
<p>Stack Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>Call Stack</b></p>
<p>Opens a Data Explorer displaying all local variables. If the current</p>
<p>function is a C++ instance method, the Data Explorer also shows</p>
<p>information about the</p>
<p>this</p>
<p>pointer. See Chapter 11, âViewing and</p>
<p>Modifying Variables with the Data Explorerâ on page 183.</p>
<p>Corresponds to:</p>
<p>, the<b> view $locals$</b> command, and the<b> localsview</b></p>
<p>command (see âGeneral View Commandsâ in Chapter 22, âView</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Local Variables</b></p>
<p>Opens a<b> Register View</b> window. See âThe Register View Windowâ</p>
<p>on page 254.</p>
<p>Corresponds to:</p>
<p>and the<b> regview</b> command (see âRegister Commandsâ</p>
<p>in Chapter 14, âRegister Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Registers</b></p>
<p><i>673</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The View Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens an empty<b> Memory View</b> window. See Chapter 15, âUsing the</p>
<p>Memory View Windowâ on page 323.</p>
<p>Corresponds to:</p>
<p>and the<b> memview</b> command (see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Memory</b></p>
<p>Opens the<b> Memory Allocations</b> window. See âUsing the Memory</p>
<p>Allocations Windowâ on page 340.</p>
<p>Corresponds to: the<b> heapview</b> command (see âGeneral View Commandsâ</p>
<p>in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Memory</b></p>
<p><b>Allocations</b></p>
<p>Opens the<b> Profile</b> window. See âThe Profile Windowâ on page 361.</p>
<p>Corresponds to: the<b> profile</b> command (see Chapter 12, âProfiling</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Profile</b></p>
<p>Opens a Task Manager window if you are debugging in a run-mode</p>
<p>environment. Otherwise it opens a Process Viewer. See âThe Task</p>
<p>Managerâ on page 580 and âViewing Native Processesâ on page 390.</p>
<p>If you are debugging in run mode, corresponds to: the<b> taskwindow</b></p>
<p>command (see âObject Structure Awareness (OSA) Commandsâ in</p>
<p>Chapter 15, âScripting Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p>If you are debugging in a native environment, corresponds to: the<b> top</b></p>
<p>command (see âGeneral View Commandsâ in Chapter 22, âView</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Task Manager</b></p>
<p>Opens an<b> OSA Explorer</b> on the current process in a freeze-mode</p>
<p>debugging environment or on the current debug server in a run-mode</p>
<p>debugging environment, or opens the<b> Linux Threads</b> window in Linux.</p>
<p>The<b> OSA Explorer</b> shows information for objects recognized by the</p>
<p>OSA integration module. For information about the<b> OSA Explorer</b>, see</p>
<p>âThe OSA Explorerâ on page 609.</p>
<p>Corresponds to: the<b> osaexplorer</b> command (see âObject Structure</p>
<p>Awareness (OSA) Commandsâ in Chapter 15, âScripting Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>OSA Explorer</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>674</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a<b> Note Browser</b>, which allows you to browse your Debugger</p>
<p>Notes. See âViewing Debugger Notesâ on page 177.</p>
<p>Corresponds to: the<b> noteview</b> command (see Chapter 7, âDebugger Note</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Debugger Notes</b></p>
<p>Opens the<b> Cache View</b> window. See âThe Cache View Windowâ</p>
<p>on page 392.</p>
<p>Corresponds to: the<b> cacheview</b> command (see âCache View Commandsâ</p>
<p>in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Caches</b></p>
<p>Opens the<b> Cache Find</b> window. See âThe Cache Find Windowâ</p>
<p>on page 396.</p>
<p>Corresponds to: the<b> cachefind</b> command (see âCache View Commandsâ</p>
<p>in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Find Address in</b></p>
<p><b>Cache</b></p>
<p>Opens a dialog box for you to specify an expression to be printed.</p>
<p>Corresponds to: the<b> print</b> command (see Chapter 8, âDisplay and Print</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Print Expression</b></p>
<p>Opens a dialog box for you to enter an expression to view in a Data</p>
<p>Explorer.</p>
<p>Corresponds to:<b> Shift</b>+<b>F9</b> and the<b> view</b> command (see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>View Expression</b></p>
<p>Opens the<b> List</b> submenu. See âThe List Submenuâ on page 678.</p>
<p><b>List</b></p>
<p>Opens the<b> Source Path</b> window, which allows you to change the</p>
<p>directories that are searched for source files.</p>
<p>Corresponds to: the<b> source</b> command (see âGeneral Configuration</p>
<p>Commandsâ in Chapter 6, âConfiguration Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Source Path</b></p>
<p>Refreshes all Data Explorers,<b> Register View</b> windows,<b> Memory View</b></p>
<p>windows,<b> Call Stack</b> windows, etc. Frozen Data Explorer variables and</p>
<p>frozen<b> Register View</b>,<b> Memory View</b>, and<b> Call Stack</b> windows are not</p>
<p>updated.</p>
<p>Corresponds to: the<b> update</b> command (see âGeneral View Commandsâ</p>
<p>in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Refresh Views</b></p>
<p><i>675</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The View Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Toggles whether the Debugger automatically updates all Data Explorers,</p>
<p><b>Register View</b> windows,<b> Memory View</b> windows,<b> Call Stack</b> windows,</p>
<p>etc. (If a Data Explorer variable is frozen, this menu item does not update</p>
<p>that variable.) The default update interval time is 1 second. To change</p>
<p>the interval time, enter the<b> update</b> command followed by an interval</p>
<p>number in seconds. For more information about the<b> update</b> command,</p>
<p>see âGeneral View Commandsâ in Chapter 22, âView Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Auto Update Views</b></p>
<p>Closes all Data Explorers, Browse windows,<b> Register View</b> windows,</p>
<p><b>Memory View</b> windows,<b> Call Stack</b> windows, and<b> Breakpoints</b></p>
<p>windows.</p>
<p>Corresponds to: the<b> viewdel</b> command (see âGeneral View Commandsâ</p>
<p>in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Close All Views</b></p>
<p><b>The Navigation Submenu</b></p>
<p>The following table describes the selections available from the<b> View</b> â<b> Navigation</b></p>
<p>submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Views the procedure one higher on the call stack.</p>
<p>Corresponds to:</p>
<p>,<b> Ctrl</b>+<b>+</b>, and the<b> E +</b> command (see Chapter 8,</p>
<p>âDisplay and Print Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>UpStack</b></p>
<p>Views the procedure one lower on the call stack.</p>
<p>Corresponds to:</p>
<p>,<b> Ctrl</b>+<b>-</b>, and the<b> E -</b> command (see Chapter 8,</p>
<p>âDisplay and Print Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>DownStack</b></p>
<p>Views the procedure where the process is currently stopped.</p>
<p>Corresponds to:</p>
<p>and the<b> E</b> command (see Chapter 8, âDisplay and</p>
<p>Print Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>Current PC</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>676</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Views the first procedure higher on the call stack that has source code.</p>
<p>You can use this feature if you are stopped inside a library function with</p>
<p>no source code (such as</p>
<p>printf()</p>
<p>), and you want to return to viewing</p>
<p>your program.</p>
<p>Corresponds to: the<b> uptosource</b> command (see Chapter 11, âNavigation</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>UpStack To Source</b></p>
<p>Opens a dialog box in which you can specify a procedure or an address,</p>
<p>and displays the program at the specified location in the source pane.</p>
<p>Corresponds to: the<b> e</b> command (see Chapter 11, âNavigation Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Goto Location</b></p>
<p><b>The Display Mode Submenu</b></p>
<p>The following table describes the selections available from the<b> View</b> â<b> Display</b></p>
<p><b>Mode</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays only source code in the source pane.</p>
<p>Corresponds to:</p>
<p>(not selected) and the<b> assem off</b> command (see</p>
<p>Chapter 8, âDisplay and Print Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Source Only</b></p>
<p>Displays source code and the corresponding assembly instructions for</p>
<p>each source code line in the source pane.</p>
<p>Corresponds to:</p>
<p>(selected) and the<b> assem on</b> command (see Chapter</p>
<p>8, âDisplay and Print Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Interlaced</b></p>
<p><b>Assembly</b></p>
<p>Displays only assembly instructions in the source pane.</p>
<p>Corresponds to: the<b> assem nosource</b> command (see Chapter 8, âDisplay</p>
<p>and Print Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>Assembly Only</b></p>
<p><i>677</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The View Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The List Submenu</b></p>
<p>The following table describes the selections available from the<b> View</b> â<b> List</b></p>
<p>submenu.</p>
<p>See also the<b> l</b> (lowercase L) command in Chapter 8, âDisplay and Print Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Lists all the filenames in the program.</p>
<p><b>Files</b></p>
<p>Lists the names and addresses of all procedures.</p>
<p><b>Procedures</b></p>
<p>Lists the mangled names and addresses of all procedures.</p>
<p><b>Mangled</b></p>
<p><b>Procedures</b></p>
<p>Lists the names and addresses of all global variables.</p>
<p><b>Globals</b></p>
<p>Lists the names and addresses of all static variables.</p>
<p><b>Statics</b></p>
<p>Lists the names and values of all local variables for the procedure you</p>
<p>are viewing (that is, the procedure at the current line pointer) if the</p>
<p>procedure is on the stack. If the procedure is a C++ instance method,</p>
<p>this menu item lists information about the</p>
<p>this</p>
<p>pointer as well.</p>
<p><b>Locals</b></p>
<p>Lists the names and addresses of the local variables specified above.</p>
<p><b>Local Addresses</b></p>
<p>Lists the names and values of all registers.</p>
<p><b>Registers</b></p>
<p>Lists the register synonyms.</p>
<p><b>Register Synonyms</b></p>
<p>Lists all the parameters and local variables of the specified procedure if</p>
<p>it is on the stack.</p>
<p><b>Variables In</b></p>
<p><b>Procedure</b></p>
<p>Lists all the defined macros.</p>
<p><b>Defines</b></p>
<p>Lists the values of all MULTI special variables.</p>
<p><b>MULTI Variables</b></p>
<p>Lists the processes that the MULTI Debugger is currently attached to.</p>
<p><b>Processes</b></p>
<p>Lists the names and configuration settings of all signals.</p>
<p><b>Signals</b></p>
<p>Lists all software breakpoints.</p>
<p><b>Breakpoints</b></p>
<p>Lists all loaded dialog boxes.</p>
<p><b>Dialog Boxes</b></p>
<p>Lists the directories where MULTI looks for source files and scripts.</p>
<p><b>Source Paths</b></p>
<p>Lists the source files included by the current file.</p>
<p><b>Included Files</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>678</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Browse Menu</b></p>
<p>The following table describes the selections available from the<b> Browse</b> menu in</p>
<p>the main Debugger window.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a Browse window displaying all procedures in the program being</p>
<p>debugged. See âBrowsing Proceduresâ on page 220.</p>
<p><b>Procedures</b></p>
<p>Opens a Browse window displaying all global variables in the program</p>
<p>being debugged. See âBrowsing Global Variablesâ on page 228.</p>
<p><b>Globals</b></p>
<p>Opens a Browse window displaying the name and location of all of the</p>
<p>source files containing procedures used in the program being debugged.</p>
<p>See âBrowsing Source Filesâ on page 230.</p>
<p><b>Files</b></p>
<p>Opens a Browse window displaying all data types used in the program</p>
<p>being debugged. See âBrowsing Data Typesâ on page 233.</p>
<p><b>All Types</b></p>
<p>Opens a Tree Browser displaying the class hierarchy of the program</p>
<p>being debugged. See âBrowsing Classesâ on page 243.</p>
<p><b>Classes</b></p>
<p>Opens a Tree Browser displaying the static calling relationships of the</p>
<p>current procedure (i.e., which functions are called by and which functions</p>
<p>call the procedure at the current line pointer in the Debugger). See</p>
<p>âBrowsing Static Calls By Functionâ on page 244.</p>
<p><b>Static Calls</b></p>
<p>Opens a Tree Browser displaying which functions were actually called</p>
<p>during run time. See âBrowsing Dynamic Calls by Functionâ on page 246.</p>
<p><b>Dynamic Calls</b></p>
<p>Opens a Tree Browser displaying static calls by file. This view shows</p>
<p>source files whose functions are called from other source files. See</p>
<p>âBrowsing Static Calls By Fileâ on page 245.</p>
<p><b>File Calls</b></p>
<p>Opens a Graph View window displaying the include file hierarchy. See</p>
<p>âBrowsing Includesâ on page 247.</p>
<p><b>Includes</b></p>
<p>Opens a dialog box that allows you to specify a source file, then opens</p>
<p>a Browse window displaying all the procedures in the file you specified.</p>
<p>See âBrowsing Proceduresâ on page 220.</p>
<p><b>Procedures In File</b></p>
<p>Opens a dialog box that allows you to specify a type name, then opens</p>
<p>a Data Explorer displaying the structure of the type you specified. See</p>
<p>Chapter 11, âViewing and Modifying Variables with the Data Explorerâ</p>
<p>on page 183.</p>
<p><b>Type</b></p>
<p><i>679</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Browse Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Target Menu</b></p>
<p>The following table describes the selections available from the<b> Target</b> menu in the</p>
<p>main Debugger window.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the<b> Connection Chooser</b>, which allows you to create, edit, or</p>
<p>invoke a Connection Method to connect to your target. See âStandard</p>
<p>Connection Methodsâ on page 42.</p>
<p>Corresponds to:</p>
<p>,<b> F4</b>, and the<b> connect</b> command (see âGeneral Target</p>
<p>Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Connect</b></p>
<p>Opens the<b> Connection Organizer</b>, which configures how you connect</p>
<p>to target hardware or simulators. For more information about the</p>
<p><b>Connection Organizer</b>, see âUsing the Connection Organizerâ</p>
<p>on page 50.</p>
<p>Corresponds to: the<b> connectionview</b> command (see âGeneral Target</p>
<p>Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Show Connection</b></p>
<p><b>Organizer</b></p>
<p>Disconnects from the current target debug server.</p>
<p>Corresponds to:</p>
<p>and the<b> disconnect</b> command (see âGeneral Target</p>
<p>Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Disconnect from</b></p>
<p><b>Target</b></p>
<p>Opens the<b> Set Run-Mode Partner</b> dialog box, in which you can select</p>
<p>a run-mode connection that the Debugger automatically attempts to</p>
<p>establish when you boot an INTEGRITY kernel via the current</p>
<p>freeze-mode connection. The dialog box also allows you to disable this</p>
<p>behavior. For more information, see âThe Set Run-Mode Partner Dialog</p>
<p>Boxâ on page 71.</p>
<p><b>Set Run-Mode</b></p>
<p><b>Partner</b></p>
<p>Opens a submenu that allows you to load a module into the target</p>
<p>system's memory.</p>
<p>This menu item is only available if the target supports and was</p>
<p>configured with a dynamic loader (for example, the LoaderTask on</p>
<p>INTEGRITY).</p>
<p><b>Load Module</b></p>
<p>Opens a submenu that allows you to unload a module.</p>
<p><b>Unload Module</b></p>
<p>Lists the most recently connected debug servers. To connect to one of</p>
<p>them, select it.</p>
<p><b>1<i> connection</b></i></p>
<p><b>2<i> connection</b></i></p>
<p><b>3<i> connection</b></i></p>
<p><b>4<i> connection</b></i></p>
<p><i>MULTI: Debugging</i></p>
<p><i>680</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Toggles buffering for the I/O pane.</p>
<p>Corresponds to: the<b> iobuffer</b> command (see âGeneral Target Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>IO Buffering</b></p>
<p>Opens the<b> Memory Manipulation</b> submenu. See âThe Memory</p>
<p>Manipulation Submenuâ on page 681.</p>
<p><b>Memory</b></p>
<p><b>Manipulation</b></p>
<p>Opens the<b> Memory Test Wizard</b>. See âQuick Memory Testing: Using</p>
<p>the Memory Test Wizardâ on page 512.</p>
<p><b>Memory Test</b></p>
<p>Opens the<b> MULTI Fast Flash Programmer</b>, which allows you to enter</p>
<p>parameters to transfer a file from the host to flash memory on the target.</p>
<p>See Chapter 22, âProgramming Flash Memoryâ on page 539.</p>
<p>Corresponds to: the<b> flash gui</b> command (see âGeneral Memory</p>
<p>Commandsâ in Chapter 10, âMemory Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Flash</b></p>
<p><b>The Memory Manipulation Submenu</b></p>
<p>The following table describes the selections available from the<b> Target</b> â<b> Memory</b></p>
<p><b>Manipulation</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the<b> Copy a Region of Memory</b> dialog box, which allows you to</p>
<p>copy memory contents from the<b> From address</b> to the<b> Destination</b></p>
<p><b>address</b> in memory. The copying continues for the specified<b> Number</b></p>
<p><b>of blocks</b> of memory, and you can specify the size of each memory block</p>
<p>in bytes.</p>
<p>Corresponds to: the<b> copy</b> command (see âGeneral Memory Commandsâ</p>
<p>in Chapter 10, âMemory Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Copy</b></p>
<p>Opens the<b> Fill a Region of Memory</b> dialog box, which allows you to</p>
<p>fill memory starting from the<b> Starting at address</b> location with the given</p>
<p>value<b> Fill value</b>. The filling continues for the specified<b> Number of</b></p>
<p><b>blocks</b> of memory, and you can specify the size of each memory block</p>
<p>in bytes.</p>
<p>Corresponds to: the<b> fill</b> command (see âGeneral Memory Commandsâ</p>
<p>in Chapter 10, âMemory Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Fill</b></p>
<p><i>681</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Target Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the<b> Find a Region of Memory</b> dialog box, which allows you to</p>
<p>find a value in memory. The search begins at the<b> Starting at address</b></p>
<p>location and continues for<b> Number of blocks</b> of memory. You can</p>
<p>specify the size of each memory block in bytes. For each memory</p>
<p>location, MULTI performs a bitwise</p>
<p>AND</p>
<p>operation using the memory</p>
<p>value and the mask as the operands, then compares the results with the</p>
<p><b>Value to find</b>.</p>
<p>Corresponds to: the<b> find</b> command (see âGeneral Memory Commandsâ</p>
<p>in Chapter 10, âMemory Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Find</b></p>
<p>Opens the<b> Compare Memory Regions</b> dialog box, which allows you</p>
<p>to compare memory contents. You specify the two starting memory</p>
<p>locations to compare (<b>Address 1</b> and<b> Address 2</b>) and the<b> Number of</b></p>
<p><b>blocks</b> of memory to compare. You can specify the size of each memory</p>
<p>block in bytes. You can also specify the<b> Comparison operation</b>:</p>
<p>==</p>
<p>(equal),</p>
<p>&gt;</p>
<p>(greater than),</p>
<p>&gt;=</p>
<p>(greater than or equal),</p>
<p>&lt;</p>
<p>(less than),</p>
<p>&lt;=</p>
<p>(less than or equal),</p>
<p>!=</p>
<p>(not equal).</p>
<p>Corresponds to: the<b> compare</b> command (see âGeneral Memory</p>
<p>Commandsâ in Chapter 10, âMemory Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Compare</b></p>
<p>Opens the<b> Load Memory into Target</b> dialog box, which allows you to</p>
<p>copy a section of memory from the specified file (<b>Load memory from</b></p>
<p><b>file</b>).</p>
<p>Corresponds to: the<b> memload</b> command (see âGeneral Memory</p>
<p>Commandsâ in Chapter 10, âMemory Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Memory Load</b></p>
<p>Opens the<b> Dump Memory into File</b> dialog box, which allows you to</p>
<p>copy a section of memory to the specified file (<b>Dump memory to file</b>),</p>
<p>starting at the<b> Start Address</b> and continuing for<b> Length</b> bytes.</p>
<p>Corresponds to: the<b> memdump</b> command (see âGeneral Memory</p>
<p>Commandsâ in Chapter 10, âMemory Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Memory Dump</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>682</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The TimeMachine Menu</b></p>
<p>The following table describes the selections available from the<b> TimeMachine</b> menu</p>
<p>in the main Debugger window. For information about the commands listed in the</p>
<p>table, see Chapter 20, âTrace Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Loads a previously saved trace session.</p>
<p>Corresponds to: the<b> traceload</b> command.</p>
<p><b>Load Trace Session</b></p>
<p>Saves the trace session.</p>
<p>Corresponds to: the<b> tracesave</b> command.</p>
<p><b>Save Trace Session</b></p>
<p>Starts trace collection and clears any previously collected data on the</p>
<p>target. Data that has already been retrieved is not cleared, but if trace</p>
<p>retrieval is currently in progress, it is aborted.</p>
<p>Corresponds to: the<b> trace enable</b> command.</p>
<p><b>Enable Trace</b></p>
<p>Stops trace collection and retrieves trace data. For more information,</p>
<p>see âEnabling and Disabling Trace Collectionâ on page 405.</p>
<p>Corresponds to: the<b> trace disable</b> command.</p>
<p><b>Disable Trace</b></p>
<p>Retrieves trace data from the trace probe or target.</p>
<p>With SuperTrace Probe v3 targets, this either retrieves the amount of</p>
<p>data set by the<b> Target buffer size</b> option (see âThe Collection Tabâ</p>
<p>on page 481), or it retrieves twice as much data as has already been</p>
<p>retrieved. In the latter case, all previously retrieved trace data is retrieved</p>
<p>again.</p>
<p>With all other targets, all trace data is always retrieved.</p>
<p>Corresponds to: the<b> trace retrieve</b> command.</p>
<p><b>Retrieve Trace</b></p>
<p>Aborts the retrieval of trace data.</p>
<p>Corresponds to: the<b> trace abort</b> command.</p>
<p><b>Abort Trace</b></p>
<p><b>Retrieval</b></p>
<p>Clears all current trace data on the host, trace probe, and target.</p>
<p>Corresponds to: the<b> trace clear</b> command.</p>
<p><b>Clear Data</b></p>
<p>Opens the<b> Set Triggers</b> window, which allows you to configure trace</p>
<p>collection by setting triggers and other target-specific events. See âThe</p>
<p>Set Triggers Windowâ on page 493.</p>
<p>Corresponds to: the<b> trace triggers</b> command.</p>
<p><b>Set Triggers</b></p>
<p><i>683</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The TimeMachine Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the<b> Trace Options</b> window, which allows you to configure trace</p>
<p>options related to trace collection and display. See âThe Trace Options</p>
<p>Windowâ on page 480.</p>
<p>Corresponds to: the<b> trace options</b> command.</p>
<p><b>Trace Options</b></p>
<p>Enables/disables TimeMachine mode for the currently selected item.</p>
<p>In addition to the normal Debugger run-control operations, the</p>
<p>TimeMachine Debugger allows you to step backwards in time. This</p>
<p>option is only available if you have collected trace data. For more</p>
<p>information, see âThe TimeMachine Debuggerâ on page 413.</p>
<p>Corresponds to:</p>
<p>and the<b> timemachine</b> command.</p>
<p><b>TimeMachine</b></p>
<p><b>Debugger</b></p>
<p>Generates path analysis information from the current trace data and</p>
<p>displays it in a PathAnalyzer. This option is available only if trace data</p>
<p>is available. See âThe PathAnalyzerâ on page 424.</p>
<p>Corresponds to: the<b> tracepath</b> command.</p>
<p><b>PathAnalyzer</b></p>
<p>Opens the<b> Trace Statistics</b> window, which shows statistical information</p>
<p>about the current trace data. This option is available only if trace data</p>
<p>exists. For more information, see âViewing Trace Statisticsâ on page 460.</p>
<p>Corresponds to: the<b> trace stats</b> command.</p>
<p><b>Trace Statistics</b></p>
<p>Generates profiling data from the current trace data and displays it in</p>
<p>the<b> Profile</b> window. This option is available only if trace data is</p>
<p>available. See âUsing Trace Data to Profile Your Targetâ on page 475.</p>
<p>Corresponds to: the<b> tracepro</b> command.</p>
<p><b>Profile</b></p>
<p>Opens the Trace List, which allows you to view and explore trace data</p>
<p>at the assembly level. This window also provides access to advanced</p>
<p>trace analysis tools. For more information, see âViewing Trace Data</p>
<p>in the Trace Listâ on page 434.</p>
<p>Corresponds to: the<b> trace list</b> command.</p>
<p><b>Trace List</b></p>
<p>Generates an EventAnalyzer log from the current trace data and displays</p>
<p>it in the MULTI EventAnalyzer. This option is available only if trace</p>
<p>data is available. See âViewing Trace Events in the EventAnalyzerâ</p>
<p>on page 474.</p>
<p>Corresponds to: the<b> tracemevsys</b> command.</p>
<p><b>EventAnalyzer</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>684</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Tools Menu</b></p>
<p>The following table describes the selections available from the<b> Tools</b> menu in the</p>
<p>main Debugger window.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the MULTI<b> EventAnalyzer</b>. This menu item is only available</p>
<p>for some RTOSes.</p>
<p>Corresponds to:</p>
<p><b>MULTI</b></p>
<p><b>EventAnalyzer</b></p>
<p>Opens the MULTI<b> ResourceAnalyzer</b>. This menu item is only available</p>
<p>if you are using INTEGRITY.</p>
<p>Corresponds to:</p>
<p><b>MULTI</b></p>
<p><b>ResourceAnalyzer</b></p>
<p>Opens the MULTI Launcher.</p>
<p>Corresponds to: the<b> multibar</b> command (see Chapter 2, âGeneral</p>
<p>Debugger Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>Launcher</b></p>
<p>Opens the Project Manager on the project for the current program. If</p>
<p>MULTI cannot find a project for the current program, it will ask which</p>
<p>project to open.</p>
<p>Corresponds to: the<b> builder</b> command (see Chapter 4, âBuilding</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Project Manager</b></p>
<p>Rebuilds the current program if the project for the program can be</p>
<p>located.</p>
<p>Corresponds to: the<b> build</b> command (see Chapter 4, âBuilding Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Rebuild</b></p>
<p>Opens an<b> Edit File</b> dialog box, which allows you to select a file to open</p>
<p>in an Editor window.</p>
<p>Corresponds to:</p>
<p>and the<b> edit</b> command (see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Editor</b></p>
<p>Opens the<b> Utility Program Launcher</b>, which provides a graphical</p>
<p>interface to the Green Hills utility programs.</p>
<p>Corresponds to: the<b> wgutils</b> command (see Chapter 4, âBuilding</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Launch Utility</b></p>
<p><b>Programs</b></p>
<p>Opens the<b> Serial Terminal</b> submenu. See âThe Serial Terminal</p>
<p>Submenuâ on page 686.</p>
<p><b>Serial Terminal</b></p>
<p><i>685</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Tools Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens MULTI's search dialog box. See âThe Source Pane Search Dialog</p>
<p>Boxâ on page 712.</p>
<p>Corresponds to: the<b> dialogsearch</b> command (see Chapter 16, âSearch</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Search</b></p>
<p>Opens the<b> Search in Files</b> dialog box, which searches the source files</p>
<p>of the program being debugged and any other open files for the specified</p>
<p>string, using the<b> grep</b> utility. See âSearching in Filesâ on page 159.</p>
<p>Corresponds to: the<b> grep</b> command (see Chapter 16, âSearch Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Search in Files</b></p>
<p><b>The Serial Terminal Submenu</b></p>
<p>The following table describes the selections available from the<b> Tools</b> â<b> Serial</b></p>
<p><b>Terminal</b> submenu. For more information, see Chapter 27, âEstablishing Serial</p>
<p>Connectionsâ on page 643.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the<b> Serial Connection Chooser</b>, which allows you to create, edit,</p>
<p>or invoke a Serial Connection Method.</p>
<p>Corresponds to: the<b> serialconnect</b> command (see âSerial Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Make Serial</b></p>
<p><b>Connection</b></p>
<p>Closes the current serial connection.</p>
<p>Corresponds to: the<b> serialdisconnect</b> command (see âSerial Connection</p>
<p>Commandsâ in Chapter 18, âTarget Connection Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Disconnect from</b></p>
<p><b>Serial</b></p>
<p>Lists the four most recently used serial connections. To invoke one of</p>
<p>these, select it.</p>
<p><b>1<i> connection</b></i></p>
<p><b>2<i> connection</b></i></p>
<p><b>3<i> connection</b></i></p>
<p><b>4<i> connection</b></i></p>
<p><i>MULTI: Debugging</i></p>
<p><i>686</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Config Menu</b></p>
<p>The following table describes the selections available from the<b> Config</b> menu in the</p>
<p>main Debugger window.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens the<b> Options</b> dialog box, which allows you to configure the</p>
<p>appearance and behaviors of the Debugger and other MULTI tools. For</p>
<p>a description of all the options in this window, see Chapter 8,</p>
<p>âConfiguration Optionsâ in the<i> MULTI: Managing Projects and</i></p>
<p><i>Configuring the IDE</i> book.</p>
<p>Corresponds to: the<b> configoptions</b> command (see âGeneral Configuration</p>
<p>Commandsâ in Chapter 6, âConfiguration Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Options</b></p>
<p>Opens the<b> Customize Menus</b> window, which allows you to configure</p>
<p>the menus in a number of MULTI tools. For more information, see</p>
<p>Chapter 7, âConfiguring and Customizing MULTIâ in the<i> MULTI:</i></p>
<p><i>Managing Projects and Configuring the IDE</i> book.</p>
<p>Corresponds to: the<b> customizemenus</b> command (see âButton, Menu,</p>
<p>and Mouse Commandsâ in Chapter 6, âConfiguration Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Customize Menus</b></p>
<p>Opens the<b> Customize Toolbar</b> window, which allows you to configure</p>
<p>the Debugger toolbar. For more information, see âConfiguring the</p>
<p>Debugger Toolbarâ on page 698.</p>
<p>Corresponds to: the<b> customizetoolbar</b> command (see âButton, Menu,</p>
<p>and Mouse Commandsâ in Chapter 6, âConfiguration Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Customize Toolbar</b></p>
<p>Saves the current configuration into the default user configuration file,</p>
<p>so that it will be automatically loaded when MULTI starts. For more</p>
<p>information, see âSaving Configuration Settingsâ in Chapter 7,</p>
<p>âConfiguring and Customizing MULTIâ in the<i> MULTI: Managing</i></p>
<p><i>Projects and Configuring the IDE</i> book.</p>
<p>Corresponds to: the<b> saveconfig</b> command (see âGeneral Configuration</p>
<p>Commandsâ in Chapter 6, âConfiguration Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Save Configuration</b></p>
<p><b>as User Default</b></p>
<p>Deletes the default user configuration file and restores the default system</p>
<p>configuration.</p>
<p>Corresponds to: the<b> clearconfig</b> command (see âGeneral Configuration</p>
<p>Commandsâ in Chapter 6, âConfiguration Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Clear User Default</b></p>
<p><b>Configuration</b></p>
<p><i>687</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Config Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a file chooser in which you can choose the file where you want</p>
<p>to save the current configuration. For more information, see âSaving</p>
<p>Configuration Settingsâ in Chapter 7, âConfiguring and Customizing</p>
<p>MULTIâ in the<i> MULTI: Managing Projects and Configuring the IDE</i></p>
<p>book.</p>
<p>Corresponds to: the<b> saveconfigtofile</b> command (see âGeneral</p>
<p>Configuration Commandsâ in Chapter 6, âConfiguration Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Save Configuration</b></p>
<p><b>As</b></p>
<p>Opens a file chooser from which you can choose the file whose</p>
<p>configuration you want to load.</p>
<p>Corresponds to: the<b> loadconfigfromfile</b> command (see âGeneral</p>
<p>Configuration Commandsâ in Chapter 6, âConfiguration Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Load Configuration</b></p>
<p>Opens the<b> Default INTEGRITY Distribution</b> dialog box in which you</p>
<p>can provide MULTI with the location of the installed INTEGRITY</p>
<p>distribution. This information is used to add INTEGRITY documentation</p>
<p>to MULTI's<b> Help</b> menu and to determine the default INTEGRITY</p>
<p>distribution for use with the<b> Project Wizard</b>. For more information, see</p>
<p>âConfiguring MULTI for Use with INTEGRITY or u-velOSityâ in</p>
<p>Chapter 2, âMULTI Tutorialâ in the<i> MULTI: Getting Started</i> book.</p>
<p>Corresponds to: the<b> setintegritydir</b> command (see âGeneral</p>
<p>Configuration Commandsâ in Chapter 6, âConfiguration Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Set INTEGRITY</b></p>
<p><b>Distribution</b></p>
<p>Opens the<b> Default u-velOSity Distribution</b> dialog box in which you</p>
<p>can provide MULTI with the location of the installed u-velOSity</p>
<p>distribution. This information is used to add u-velOSity documentation</p>
<p>to MULTI's<b> Help</b> menu and to determine the default u-velOSity</p>
<p>distribution for use with the<b> Project Wizard</b>. For more information, see</p>
<p>âConfiguring MULTI for Use with INTEGRITY or u-velOSityâ in</p>
<p>Chapter 2, âMULTI Tutorialâ in the<i> MULTI: Getting Started</i> book.</p>
<p>Corresponds to: the<b> setuvelositydir</b> command (see âGeneral</p>
<p>Configuration Commandsâ in Chapter 6, âConfiguration Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>Set u-velOSity</b></p>
<p><b>Distribution</b></p>
<p>Opens the<b> State</b> submenu. See âThe State Submenuâ on page 689.</p>
<p><b>State</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>688</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The State Submenu</b></p>
<p>The following table describes the selections available from the<b> Config</b> â<b> State</b></p>
<p>submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Prints the command history. Each Debugger window keeps a history of</p>
<p>all the Debugger commands entered in that window. You can use the<b> !</b></p>
<p>command to execute a command from the history (see âHistory</p>
<p>Commandsâ in Chapter 15, âScripting Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book). You can also use the</p>
<p><b>UpArrow</b> and<b> DownArrow</b> keys to navigate through the history and</p>
<p>choose a command for execution.</p>
<p>Corresponds to: the<b> h</b> command (see âHistory Commandsâ in Chapter</p>
<p>15, âScripting Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book).</p>
<p><b>Show Command</b></p>
<p><b>History</b></p>
<p>Saves the state of the Debugger to the specified file. The saved</p>
<p>information includes target connection and status, breakpoints, and the</p>
<p>source directories list. (Note that the Debugger may not be able to restore</p>
<p>saved group breakpoints.)</p>
<p>Corresponds to: the<b> save</b> command (see Chapter 2, âGeneral Debugger</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Save State</b></p>
<p>Restores the state of the Debugger from the specified file. (Note that the</p>
<p>Debugger may not be able to restore group breakpoints.)</p>
<p>Corresponds to: the<b> restore</b> command (see Chapter 2, âGeneral Debugger</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book).</p>
<p><b>Restore State</b></p>
<p>Records commands into the specified file.</p>
<p>Corresponds to: the<b> &gt;</b> command (see âRecord and Playback Commandsâ</p>
<p>in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Record Commands</b></p>
<p>Records commands and their output to the specified file.</p>
<p>Corresponds to: the<b> &gt;&gt;</b> command (see âRecord and Playback Commandsâ</p>
<p>in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Record Commands</b></p>
<p><b>+ Output</b></p>
<p><i>689</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Config Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Stops recording commands. Use this item to stop recording if it has been</p>
<p>started by<b> Record Commands</b>.</p>
<p>Corresponds to: the<b> &gt;c</b> command (see âRecord and Playback Commandsâ</p>
<p>in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Stop Recording</b></p>
<p><b>Commands</b></p>
<p>Stops recording commands and their output. Use this item to stop</p>
<p>recording if it has been started by<b> Record Commands + Output</b>.</p>
<p>Corresponds to: the<b> &gt;&gt;c</b> command (see âRecord and Playback</p>
<p>Commandsâ in Chapter 15, âScripting Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Stop Recording</b></p>
<p><b>Commands +</b></p>
<p><b>Output</b></p>
<p>Plays back commands recorded in the selected file.</p>
<p>Corresponds to: the<b> &lt;</b> command (see âRecord and Playback Commandsâ</p>
<p>in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>Playback</b></p>
<p><b>Commands</b></p>
<p><b>The Windows Menu</b></p>
<p>The<b> Windows</b> menu is used to jump between all of the windows created by MULTI.</p>
<p>If you choose an entry in the<b> Windows</b> menu, the corresponding window is brought</p>
<p>to the front.</p>
<p>The following are menu items that may appear in the<b> Windows</b> menu:</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Gives focus to a debugging-related window that has been launched from</p>
<p>the local executable.</p>
<p><i><b>debug window</b></i></p>
<p>Gives focus to the main Debugger window for the local<i> application</i>.</p>
<p><i><b>application name</b></i></p>
<p>Opens a submenu that lists windows corresponding to the<i> IDE_tool</i>. The</p>
<p>windows listed in this submenu might be created from the local execution</p>
<p>or from other executions.</p>
<p>If only one MULTI Launcher is open, that tool does not have a submenu;</p>
<p>it has a menu entry instead.</p>
<p><i><b>IDE tool</b></i></p>
<p>Opens a submenu listing other window types that do not fall into any of</p>
<p>the above categories.</p>
<p><b>Misc</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>690</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Help Menu</b></p>
<p>The table below describes the selections available from the<b> Help</b> menu in the main</p>
<p>Debugger window.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens online help for the Debugger. You may also press<b> F1</b> to access</p>
<p>the online help.</p>
<p><b>Debugger Help</b></p>
<p>Opens the<b> Manuals</b> submenu, which displays a list of all manuals</p>
<p>included in your MULTI installation. Choose a manual to open its online</p>
<p>help.</p>
<p><b>Manuals</b></p>
<p>Opens the<b> Bookmarks</b> submenu, which displays all the Help Viewer</p>
<p>bookmarks you have created. Bookmarks function across manuals and</p>
<p>MULTI sessions.</p>
<p>Select a bookmark to display the bookmarked page in online help. Select</p>
<p><b>Manage Bookmarks</b> to open a window that allows you to modify your</p>
<p>bookmarks.</p>
<p><b>Bookmarks</b></p>
<p>Opens the<b> About the MULTI Debugger</b> dialog box, which contains</p>
<p>basic information about MULTI, such as its version and copyright</p>
<p>information.</p>
<p>Corresponds to: the<b> about</b> command (see Chapter 9, âHelp and</p>
<p>Information Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>About MULTI</b></p>
<p>Opens the<b> Active Licenses</b> dialog box, which displays the licenses in</p>
<p>use.</p>
<p>Corresponds to: the<b> aboutlic</b> command (see Chapter 9, âHelp and</p>
<p>Information Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>License Info</b></p>
<p><b>The Debugger Window Toolbar</b></p>
<p>The Debugger toolbar contains buttons that allow you to access the most commonly</p>
<p>used features of the Debugger. Placing the mouse pointer over a button on the</p>
<p>toolbar displays a tooltip with a description of the button's function. The following</p>
<p>table gives a full description of each button and its command equivalent. For</p>
<p>instructions about how to add or remove buttons from the toolbar, see âAdding,</p>
<p>Removing, and Rearranging Toolbar Buttonsâ on page 698.</p>
<p><i>691</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Help Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Runs backward to the previous breakpoint or, if no previous</p>
<p>breakpoint exists, to the first instruction in the trace data.</p>
<p>Corresponds to:<b> Alt</b>+<b>F5</b> and the<b> bc</b> command. For information</p>
<p>about this command, see âRun Commandsâ in Chapter 13, âProgram</p>
<p>Execution Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Go Back</b></p>
<p>Steps back up to the caller of the current function.</p>
<p>Corresponds to:<b> Alt</b>+<b>F9</b> and the<b> bcU</b> command. For information</p>
<p>about this command, see âSingle-Stepping Commandsâ in Chapter</p>
<p>13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Step Up</b></p>
<p>Steps back one line. If the TimeMachine Debugger is in source</p>
<p>display mode, clicking this button causes the TimeMachine</p>
<p>Debugger to step back a single source line. If the TimeMachine</p>
<p>Debugger is in an assembly mode, it steps back a single machine</p>
<p>instruction. For more information about display modes, see âSource</p>
<p>Pane Display Modesâ on page 23.</p>
<p>Corresponds to:<b> Alt</b>+<b>F10</b> and the<b> bprev</b> command. For information</p>
<p>about this command, see âSingle-Stepping Commandsâ in Chapter</p>
<p>13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Previous</b></p>
<p>Steps back one line, stepping into a function if the previous line is</p>
<p>in a different function.</p>
<p>Corresponds to:<b> Alt</b>+<b>F11</b> and the<b> bs</b> command. For information</p>
<p>about this command, see âSingle-Stepping Commandsâ in Chapter</p>
<p>13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Step Back</b></p>
<p>For items selected in the target list, executes one statement. If the</p>
<p>statement is a function call, it steps into the called function. When</p>
<p>in interlaced source/assembly mode, a machine instruction is</p>
<p>executed instead of a source statement.</p>
<p>Corresponds to:<b> Debug</b> â<b> Step (into Functions) on Selected</b></p>
<p><b>Items</b>,<b> F11</b>, and the<b> s</b> command. For information about this</p>
<p>command, see âSingle-Stepping Commandsâ in Chapter 13,</p>
<p>âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Step (into Functions)</b></p>
<p><b>on Selected Items</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>692</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>For items selected in the target list, executes until the next statement</p>
<p>of the current function (that is, steps over function calls). When in</p>
<p>interlaced source/assembly mode, executes until the next machine</p>
<p>instruction of the current function.</p>
<p>Corresponds to:<b> Debug</b> â<b> Next (over Functions) on Selected</b></p>
<p><b>Items</b>,<b> F10</b>, and the<b> n</b> command. For information about this</p>
<p>command, see âSingle-Stepping Commandsâ in Chapter 13,</p>
<p>âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Next (over Functions)</b></p>
<p><b>on Selected Items</b></p>
<p>For items selected in the target list, continues to the end of the</p>
<p>current function, and stops in the calling function after returning to</p>
<p>it.</p>
<p>Corresponds to:<b> Debug</b> â<b> Return on Selected Items</b>,<b> F9</b>, and the</p>
<p><b>cU</b> command. For information about this command, see âContinue</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Return on Selected</b></p>
<p><b>Items</b></p>
<p>For items selected in the target list, begins execution of the program.</p>
<p>If the process is stopped, this button continues execution.</p>
<p>Corresponds to:<b> Debug</b> â<b> Go on Selected Items</b>,<b> F5</b>, and the<b> c</b></p>
<p>command. For information about this command, see âContinue</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Go on Selected Items</b></p>
<p>For items selected in the target list, halts program execution.</p>
<p>Corresponds to:<b> Debug</b> â<b> Halt on Selected Items</b> and the<b> halt</b></p>
<p>command. For information about this command, see âHalt</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Halt on Selected</b></p>
<p><b>Items</b></p>
<p>Restarts the process with the same arguments as before.</p>
<p>If you click this button while debugging a Dynamic Download</p>
<p>INTEGRITY application, MULTI attempts to (re)load the</p>
<p>application. This button may not be available for relocatable</p>
<p>modules.</p>
<p>Corresponds to:<b> Debug</b> â<b> Restart</b>,<b> Ctrl</b>+<b>Shift</b>+<b>F5</b>, and the<b> restart</b></p>
<p>command. For information about this command, see âRun</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Restart</b></p>
<p><i>693</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Debugger Window Toolbar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Automatically prepares your target or opens the<b> Prepare Target</b></p>
<p>dialog box, which allows you to download your program, flash your</p>
<p>program, or verify that your program is present on the target. For</p>
<p>more information, see âPreparing Your Targetâ on page 108.</p>
<p>This button may not be available for relocatable modules.</p>
<p>Corresponds to:<b> Debug</b> â<b> Prepare Target</b> and the<b> prepare_target</b></p>
<p>command. For information about this command, see âGeneral Target</p>
<p>Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Prepare Target</b></p>
<p>Resets the target board. This button is only available when you are</p>
<p>connected to a target that supports the<b> reset</b> command.</p>
<p>Corresponds to: the<b> reset</b> command. For information about this</p>
<p>command, see âGeneral Target Connection Commandsâ in Chapter</p>
<p>18, âTarget Connection Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Reset</b></p>
<p>Reloads the current executable.</p>
<p>Corresponds to: the<b> debug</b> command. For information about this</p>
<p>command, see Chapter 2, âGeneral Debugger Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Reload Symbols</b></p>
<p>Toggles between displaying source code only and source interlaced</p>
<p>with assembly code. This button appears to be pushed down if any</p>
<p>assembly instructions are displayed.</p>
<p>Corresponds to:<b> View</b> â<b> Display Mode</b> â<b> Source Only</b>,<b> View</b> â</p>
<p><b>Display Mode</b> â<b> Interlaced Assembly</b>, and the<b> assem</b> command.</p>
<p>For information about this command, see Chapter 8, âDisplay and</p>
<p>Print Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Assembly</b></p>
<p>Displays the current program counter (PC) in the source pane.</p>
<p>Corresponds to:<b> View</b> â<b> Navigation</b> â<b> Current PC</b> and the<b> E</b></p>
<p>command. For information about this command, see Chapter 8,</p>
<p>âDisplay and Print Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Program Counter</b></p>
<p>Displays the function up one stack frame. Hold this button down</p>
<p>to view a menu showing the entire call stack.</p>
<p>Corresponds to:<b> View</b> â<b> Navigation</b> â<b> UpStack</b>,<b> Ctrl</b>+<b>+</b>, and the</p>
<p><b>E+</b> command. For information about this command, see Chapter</p>
<p>8, âDisplay and Print Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Upstack</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>694</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Displays the function down one stack frame. Hold this button down</p>
<p>to view a menu showing the entire call stack.</p>
<p>Corresponds to:<b> View</b> â<b> Navigation</b> â<b> DownStack</b>,<b> Ctrl</b>+<b>â</b>, and</p>
<p>the<b> E-</b> command. For information about this command, see Chapter</p>
<p>8, âDisplay and Print Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Downstack</b></p>
<p>Displays the call stack in the<b> Call Stack</b> window. See also âViewing</p>
<p>Call Stacksâ on page 388.</p>
<p>Corresponds to:<b> View</b> â<b> Call Stack</b> and the<b> callsview</b> command.</p>
<p>For information about this command, see Chapter 5, âCall Stack</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Call Stack</b></p>
<p>Opens a<b> Breakpoints</b> window in which you can add and edit</p>
<p>breakpoints. See âViewing Breakpoint and Tracepoint Informationâ</p>
<p>on page 128.</p>
<p>Corresponds to:<b> View</b> â<b> Breakpoints</b> and the<b> breakpoints</b></p>
<p>command. For information about this command, see Chapter 3,</p>
<p>âBreakpoint Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Breakpoints</b></p>
<p>Opens a<b> Memory View</b> window. See Chapter 15, âUsing the</p>
<p>Memory View Windowâ on page 323.</p>
<p>Corresponds to:<b> View</b> â<b> Memory</b> and the<b> memview</b> command.</p>
<p>For information about this command, see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Memory</b></p>
<p>Opens a<b> Register View</b> window displaying machine registers. See</p>
<p>Chapter 13, âUsing the Register Explorerâ on page 253.</p>
<p>Corresponds to:<b> View</b> â<b> Registers</b> and the<b> regview</b> command. For</p>
<p>information about this command, see âRegister Commandsâ in</p>
<p>Chapter 14, âRegister Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Registers</b></p>
<p>Opens a Data Explorer displaying local variables. If the current</p>
<p>function is a C++ instance method, the Data Explorer displays the</p>
<p>this</p>
<p>pointer as well.</p>
<p>Corresponds to:<b> View</b> â<b> Local Variables</b>, the<b> view $locals$</b></p>
<p>command, and the<b> localsview</b> command. For information about</p>
<p>these commands, see âGeneral View Commandsâ in Chapter 22,</p>
<p>âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Locals</b></p>
<p><i>695</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Debugger Window Toolbar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Connects to a target.</p>
<p>If the Debugger is not connected, pressing this button opens the</p>
<p><b>Connection Chooser</b> dialog box, which allows you to connect to</p>
<p>a target board or simulator.</p>
<p>Corresponds to:<b> Target</b> â<b> Connect</b>,<b> F4</b>, and the<b> connect</b> command.</p>
<p>For information about this command, see âGeneral Target</p>
<p>Connection Commandsâ in Chapter 18, âTarget Connection</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>Connect</b></p>
<p>Disconnects from a target board or simulator.</p>
<p>Corresponds to:<b> Target</b> â<b> Disconnect from Target</b> and the</p>
<p><b>disconnect</b> command. For information about this command, see</p>
<p>âGeneral Target Connection Commandsâ in Chapter 18, âTarget</p>
<p>Connection Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Disconnect</b></p>
<p>Opens an Editor window at the currently viewed location in the</p>
<p>source pane.</p>
<p>Corresponds to:<b> Tools</b> â<b> Editor</b> and the<b> edit</b> command. For</p>
<p>information about this command, see âGeneral View Commandsâ</p>
<p>in Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Edit</b></p>
<p>Enables/disables TimeMachine mode for the currently selected</p>
<p>item. This button is only available if you have collected trace data.</p>
<p>See Chapter 19, âAnalyzing Trace Data with the TimeMachine</p>
<p>Tool Suiteâ on page 401.</p>
<p>Corresponds to:<b> TimeMachine</b> â<b> TimeMachine Debugger</b> and</p>
<p>the<b> timemachine</b> command. For information about this command,</p>
<p>see Chapter 20, âTrace Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>TimeMachine</b></p>
<p><b>Debugger</b></p>
<p>Opens the<b> OSA Explorer</b> on the RTOS running on the target. This</p>
<p>button is only available for some RTOSes.</p>
<p>Corresponds to:<b> View</b> â<b> OSA Explorer</b> and the<b> osaexplorer</b></p>
<p>command. For information about this command, see âObject</p>
<p>Structure Awareness (OSA) Commandsâ in Chapter 15, âScripting</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>OSA Explorer</b></p>
<p>Dumps the event log and displays events in the MULTI</p>
<p>EventAnalyzer. This button is only available for some RTOSes.</p>
<p><b>Dump and Show</b></p>
<p><b>Events</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>696</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Launches the MULTI EventAnalyzer. This button is only available</p>
<p>for some RTOSes.</p>
<p>Corresponds to:<b> Tools</b> â<b> MULTI EventAnalyzer</b></p>
<p><b>MULTI</b></p>
<p><b>EventAnalyzer</b></p>
<p>Launches the MULTI ResourceAnalyzer. This button is only</p>
<p>available if you are using INTEGRITY.</p>
<p>Corresponds to:<b> Tools</b> â<b> MULTI ResourceAnalyzer</b></p>
<p><b>MULTI</b></p>
<p><b>ResourceAnalyzer</b></p>
<p>Launches the OSA Object Viewer on the object currently selected</p>
<p>in the target list. If multiple items are selected in the target list, the</p>
<p>OSA Object Viewer displays information for the entire INTEGRITY</p>
<p>target. This button is visible only if you are debugging a run-mode</p>
<p>connection and using INTEGRITY version 10 or later.</p>
<p>Corresponds to: the<b> osaview -context</b> command if one item is</p>
<p>selected in the target list.</p>
<p>Corresponds to: the<b> osaview</b> command if multiple items are selected</p>
<p>in the target list.</p>
<p>For information about this command, see âObject Structure</p>
<p>Awareness (OSA) Commandsâ in Chapter 15, âScripting Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>INTEGRITY OSA</b></p>
<p><b>Object Viewer</b></p>
<p>Quits the MULTI Debugger. If you are debugging a process, MULTI</p>
<p>gives you the choice to<b> Quit and kill process</b> or<b> Detach from</b></p>
<p><b>process</b>.</p>
<p>Whether this button appears on your toolbar depends on the setting</p>
<p>of the option<b> Display close (x) buttons</b>. To access this option, select</p>
<p><b>Config</b> â<b> Options</b> â<b> General Tab</b>.</p>
<p>Corresponds to:<b> File</b> â<b> Close Debugger Window</b>,<b> Ctrl</b>+<b>Q</b>, and</p>
<p>the<b> quit window</b> command. For information about this command,</p>
<p>see Chapter 2, âGeneral Debugger Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Close Debugger</b></p>
<p>For information about the buttons that appear to the right of the<b> Status</b> column, see</p>
<p>âRepositioning and Hiding the Target Listâ on page 15.</p>
<p><i>697</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Debugger Window Toolbar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Configuring the Debugger Toolbar</b></p>
<p>The toolbar appears just below the menu bar in the main Debugger window and</p>
<p>displays the default buttons (documented in the previous section) with icon labels.</p>
<p>As described next, you can add or remove toolbar buttons and modify the placement</p>
<p>of buttons.</p>
<p><b>Adding, Removing, and Rearranging Toolbar Buttons</b></p>
<p>You can use the<b> Customize Toolbar</b> window to rearrange the order of buttons on</p>
<p>the Debugger toolbar, add pre-defined and custom buttons, and delete buttons.</p>
<p>To open the<b> Customize Toolbar</b> window, do one of the following:</p>
<p>â¢</p>
<p>Select<b> Config</b> â<b> Customize Toolbar</b>.</p>
<p>â¢</p>
<p>In the Debugger command pane, enter the<b> customizetoolbar</b> command. For</p>
<p>information about this command, see âButton, Menu, and Mouse Commandsâ</p>
<p>in Chapter 6, âConfiguration Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p>The pane on the left side of the windowâ<b>Debugger Toolbar</b>âdisplays all the</p>
<p>buttons that may currently appear on your toolbar. If your toolbar does not contain</p>
<p>all the buttons located in the<b> Debugger Toolbar</b> pane, your current debugging</p>
<p>environment does not support them. For information about these buttons, see âThe</p>
<p>Debugger Window Toolbarâ on page 691. The pane on the right side of the</p>
<p>windowâ<b>Available Buttons</b>âdisplays a comprehensive set of pre-defined buttons</p>
<p><i>MULTI: Debugging</i></p>
<p><i>698</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>that you can add to your toolbar. For a description of these buttons, see the next</p>
<p>section.</p>
<p>The following list provides instructions for using the<b> Customize Toolbar</b> window.</p>
<p>â¢</p>
<p>To rearrange the order of buttons on the toolbar â In the<b> Debugger Toolbar</b></p>
<p>pane, drag a button to its new position.</p>
<p>â¢</p>
<p>To delete a button from your toolbar â Drag the button from the left side of</p>
<p>the window (<b>Debugger Toolbar</b>) to the right (<b>Available Buttons</b>), or select</p>
<p>the button in the<b> Debugger Toolbar</b> pane and click<b> Remove button</b> (</p>
<p>).</p>
<p>â¢</p>
<p>To add a pre-defined button to your toolbar â Drag the button from the right</p>
<p>side of the window (<b>Available Buttons</b>) to the left (<b>Debugger Toolbar</b>), or</p>
<p>select the button in the right side of the window and click<b> Add new button</b></p>
<p>(</p>
<p>). (You can add back deleted buttons in this way.)</p>
<p>â¢</p>
<p>To add a custom button to your toolbar:</p>
<p>1. Click<b> Add Custom Button</b> (</p>
<p>).</p>
<p>2. In the dialog box that appears, select a button icon from the<b> Icon</b> pane. Fill</p>
<p>in the<b> Button Name</b> text field with the text you want to appear in a tooltip</p>
<p>when the cursor moves over the button, the<b> Command</b> text field with the</p>
<p>command you want to execute when you click the button, and the<b> Help String</b></p>
<p>text field with the text you want to appear at the bottom of the Debugger window</p>
<p>when the cursor moves over the button.</p>
<p>3. Click<b> OK</b>.</p>
<p>4. Your new button appears in the<b> Available Buttons</b> pane. Drag it to the</p>
<p>desired location in the<b> Debugger Toolbar</b> pane.</p>
<p>5. Click<b> OK</b>.</p>
<p>â¢</p>
<p>To edit a custom button:</p>
<p>1. Drag the button to the<b> Available Buttons</b> pane if it is not already there.</p>
<p>2. Click<b> Edit Custom Button</b> (</p>
<p>), and make the desired changes.</p>
<p>3. Click<b> OK</b>.</p>
<p><i>699</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Configuring the Debugger Toolbar</i></p>
<h1 style="page-break-before:always; "></h1>
<p>4. To add the button to the toolbar, drag it to the desired location in the</p>
<p><b>Debugger Toolbar</b> pane.</p>
<p>5. Click<b> OK</b>.</p>
<p>Modifications that you make to the toolbar through the<b> Customize Toolbar</b> window</p>
<p>are saved by default.</p>
<p>You can edit the<b> button.odb</b> configuration file to make the same toolbar changes</p>
<p>that are detailed above. The<b> button.odb</b> file is located in:</p>
<p>â¢</p>
<p>Windows 7/Vista â<i><b> user_dir</i>\AppData\Roaming\GHS\v6</b></p>
<p>â¢</p>
<p>Windows XP â<i><b> user_dir</i>\Application Data\GHS\v6</b></p>
<p>â¢</p>
<p>Linux/Solaris â<i><b> user_dir</i>/.ghs/v6</b></p>
<p>Within the current MULTI session, you can reprogram any of the pre-defined</p>
<p>Debugger toolbar buttons except the<b> Close Debugger</b> button (</p>
<p>). You can define</p>
<p>a button's name, command string, corresponding icon (optional), etc. by entering</p>
<p>the<b> debugbutton</b> command with appropriate arguments. For more information</p>
<p>about this command, see Chapter 7, âConfiguring and Customizing MULTIâ in the</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p>Pre-Defined Buttons</p>
<p>There are a number of pre-defined buttons that you can add to the Debugger toolbar</p>
<p>via the<b> Customize Toolbar</b> window (see âAdding, Removing, and Rearranging</p>
<p>Toolbar Buttonsâ on page 698). The following table contains descriptions of these</p>
<p>buttons.</p>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Adds a vertical bar between adjacent icons on the toolbar.</p>
<p><b>Separator</b></p>
<p>Closes all Data Explorers and<b> Register View</b>,<b> Call Stack</b>,</p>
<p><b>Breakpoints</b>,<b> Memory View</b>, and Browse windows.</p>
<p>Corresponds to:<b> View</b> â<b> Close All Views</b> and the<b> viewdel</b></p>
<p>command. For information about this command, see âGeneral View</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Delete all view</b></p>
<p><b>windows</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>700</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Button</b></p>
<p>Loads the current program into the target system's memory if the</p>
<p>target supports and was configured with a dynamic loader (for</p>
<p>example, the LoaderTask on INTEGRITY).</p>
<p>Corresponds to: the<b> load -setup</b> command. For information about</p>
<p>this command, see âGeneral Target Connection Commandsâ in</p>
<p>Chapter 18, âTarget Connection Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book.</p>
<p><b>Download Program</b></p>
<p>Returns to the next location in the trace navigation history. This</p>
<p>button is only available if you have previously clicked the<b> Go to</b></p>
<p><b>previous selected location in trace data</b> button (described next).</p>
<p>Corresponds to: the<b> trace history +</b> command. For information</p>
<p>about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Go to next selected</b></p>
<p><b>location in trace data</b></p>
<p>Returns to the previous location in the trace navigation history. This</p>
<p>can be useful if you want to undo an action (such as running or</p>
<p>stepping backwards in the TimeMachine Debugger) that brought</p>
<p>you to an unexpected location in your source code.</p>
<p>Corresponds to: the<b> trace history -</b> command. For information</p>
<p>about this command, see Chapter 20, âTrace Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Go to previous</b></p>
<p><b>selected location in trace</b></p>
<p><b>data</b></p>
<p>Opens a Project Manager on the current project.</p>
<p>Corresponds to:<b> Tools</b> â<b> Project Manager</b> and the<b> builder</b></p>
<p>command. For information about this command, see Chapter 4,</p>
<p>âBuilding Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Open project</b></p>
<p><b>manager for current</b></p>
<p><b>project</b></p>
<p>Toggles collection of trace data. The button appears to be pushed</p>
<p>down while trace data is being collected.</p>
<p>Corresponds to:<b> TimeMachine</b> â<b> Enable/Disable Trace</b> and<b> trace</b></p>
<p><b>toggle</b> command. For information about this command, see Chapter</p>
<p>20, âTrace Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Start collecting trace</b></p>
<p><b>data</b></p>
<p><i>701</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Configuring the Debugger Toolbar</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Target List Shortcut Menu</b></p>
<p>The following table describes the menu items that are available in the target list</p>
<p>right-click menu. These menu items are context sensitive; they may not all appear</p>
<p>every time you open this menu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a new Debugger window on the selected item. See also âOpening</p>
<p>Multiple Debugger Windowsâ on page 14.</p>
<p><b>Open in New</b></p>
<p><b>Window</b></p>
<p>Opens the<b> Prepare Target</b> dialog box from which you can choose to</p>
<p>download the selected program, flash it, or verify its presence on the</p>
<p>target. This menu item opens the<b> Prepare Target</b> dialog box even if</p>
<p>you saved an action for the selected program by clicking<b> Automatically</b></p>
<p><b>use these settings for this program next time</b> in the dialog box the last</p>
<p>time you prepared the target. For more information, see âPreparing Your</p>
<p>Targetâ on page 108.</p>
<p><b>Prepare Target</b></p>
<p>Opens a submenu with the following entries:</p>
<p>â¢</p>
<p><b>[<i>Status</i>]<i> Connection_Name</b></i> â Associates the current executable</p>
<p>with the specified connection. Only compatible, currently active</p>
<p>connections are listed.<i><b> Status</b></i> is one of:<b> Available</b> (the current</p>
<p>executable can use this connection),<b> Current</b> (the current executable</p>
<p>is using this connection), or<b> Full</b> (another executable is using this</p>
<p>connection exclusively).</p>
<p>â¢</p>
<p><b>Stop Using Current Connection</b> â Disassociates the selected</p>
<p>executable from the connection it is currently associated with.</p>
<p>Selecting this menu item does not disconnect from the target debug</p>
<p>server.</p>
<p>â¢</p>
<p><b>Create New Connection</b> â Opens the<b> Connection Chooser</b> and</p>
<p>attempts to use the connection selected.</p>
<p>For more information, see âAssociating Your Executable with a</p>
<p>Connectionâ on page 105.</p>
<p><b>Use Connection</b></p>
<p>Removes the currently selected executable from the target list and</p>
<p>terminates the process. If the executable is part of the last remaining</p>
<p>group of related items, the main Debugger window and its child windows</p>
<p>close.</p>
<p><b>Remove</b></p>
<p>Disconnects from the target debug server.</p>
<p><b>Disconnect from</b></p>
<p><b>Target</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>702</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a file chooser from which you can select a module to load on the</p>
<p>target. This option is only available if you are connected to INTEGRITY</p>
<p>in run mode and if the target supports and was configured with the</p>
<p>dynamic loader (the LoaderTask).</p>
<p><b>Load New Module</b></p>
<p>Loads the selected module on the target. This option is only available if</p>
<p>you are connected to INTEGRITY in run mode and if the target supports</p>
<p>and was configured with the dynamic loader (the LoaderTask).</p>
<p><b>Load Module</b></p>
<p>Unloads the selected module from the target. This option is only available</p>
<p>if you are connected to INTEGRITY in run mode. It may not be available</p>
<p>on<b> rtserv</b> connections (INTEGRITY version 5 and earlier) if all the tasks</p>
<p>in the module have exited.</p>
<p><b>Unload Module</b></p>
<p>Unloads, then loads the selected module. This option is only available</p>
<p>if you are connected to INTEGRITY in run mode. It may not be available</p>
<p>on<b> rtserv</b> connections (INTEGRITY version 5 and earlier) if all the tasks</p>
<p>in the module have exited.</p>
<p><b>Reload Module</b></p>
<p>Toggles trace collection for the AddressSpace in which the selected task</p>
<p>resides. This option is only available when you connect to INTEGRITY</p>
<p>in run-mode. For more information, see âCollecting Operating System</p>
<p>Trace Dataâ on page 406.</p>
<p><b>Trace</b></p>
<p>Starts or continues execution of the selected executable.</p>
<p><b>Resume</b></p>
<p>Halts the selected process.</p>
<p><b>Halt</b></p>
<p>Kills the selected process. If you are debugging a stand-alone program</p>
<p>on a hardware target (i.e. not a simulated target), you cannot kill a running</p>
<p>process. When the program reaches its exit point, the process terminates</p>
<p>and the program is left halted at the exit system call.</p>
<p><b>Kill</b></p>
<p>Attaches the Debugger to the currently selected executable. This option</p>
<p>is only available on some run-mode targets.</p>
<p><b>Attach</b></p>
<p><i>703</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Target List Shortcut Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Source Pane Shortcut Menus</b></p>
<p>When you right-click in the source pane, a shortcut menu appears.</p>
<p><b>Note</b></p>
<p>This is the default behavior. If you have configured a right-click to</p>
<p>perform other functions, the shortcut menu will not appear.</p>
<p>This menu is context sensitive and depends on the object (such as a procedure, type,</p>
<p>or variable) you right-click. Some menu items may appear dimmed, indicating that</p>
<p>they are unavailable in the current context.</p>
<p>In the following shortcut menu discussion, the term âright-clicked lineâ refers to</p>
<p>the source line where the right-click occurred.</p>
<p><b>Common Shortcut Menu Options</b></p>
<p>The following items appear in most shortcut menus available from the Debugger</p>
<p>source pane.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a<b> Graph View</b> window (see âThe Graph View Windowâ</p>
<p>on page 247) displaying a graph with one tab for each defined custom</p>
<p><i>view description</i>. This is equivalent to the<b> dataview</b> command. For more</p>
<p>information about how to define and load<i> view descriptions</i>, see</p>
<p>Appendix E, âCreating Custom Data Visualizationsâ on page 741. For</p>
<p>information about the<b> dataview</b> command, see âData Visualization</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>Display Program</b></p>
<p><b>Visualizations</b></p>
<p>Opens an editor window with the cursor on the right-clicked line of the</p>
<p>current source file.</p>
<p><b>Edit File</b></p>
<p>Searches for the selected text in open files and in the source code of your</p>
<p>current executable. Results appear in a new<b> Search in Files Results</b></p>
<p>window.</p>
<p><b>Search for Selected</b></p>
<p><b>Text</b></p>
<p>Opens a dialog box displaying basic information about the current source</p>
<p>line (for example, the filename, language, and line number), the current</p>
<p>target connection, and also basic information about the right-clicked</p>
<p>object, if available (for example, its size, address, and whether its scope</p>
<p>is static or global).</p>
<p><b>Properties</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>704</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Source Line Shortcut Menu</b></p>
<p>In addition to the menu options listed in âCommon Shortcut Menu Optionsâ</p>
<p>on page 704, the following menu options are available in the shortcut menu that</p>
<p>appears when you right-click a blank part of a source line or an unknown object.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Sets a temporary breakpoint on the line and then runs the program to it.</p>
<p>The process stops on the line only if it attempts to execute that line. This</p>
<p>menu item is only available if the right-clicked line contains executable</p>
<p>code.</p>
<p><b>Run To This Line</b></p>
<p>Changes the program counter to the first executable instruction of the</p>
<p>line. This menu item is only available if the right-clicked line contains</p>
<p>executable code and the process is stopped within the procedure</p>
<p>containing the right-clicked line.</p>
<p><b>Change PC To This</b></p>
<p><b>Line</b></p>
<p>Opens a submenu containing trace options. For a description of this</p>
<p>submenu, see later in this section. This menu item is only available if</p>
<p>you are connected to a trace-enabled target.</p>
<p><b>Trace</b></p>
<p>Opens a submenu that allows you to set various types of breakpoints on</p>
<p>the line. For a description of this submenu, see later in this section. This</p>
<p>menu item is only available if the right-clicked line contains executable</p>
<p>code and does not already have a breakpoint set on it.</p>
<p><b>Set Breakpoint</b></p>
<p>Opens the<b> Software Breakpoint Editor</b>, which allows you to edit the</p>
<p>software breakpoint set on the line. This menu item is only available if</p>
<p>a software breakpoint is set on the right-clicked line.</p>
<p><b>Edit Breakpoint</b></p>
<p>Removes the software breakpoint from the line. This menu item is only</p>
<p>available if the right-clicked line contains executable code and a</p>
<p>breakpoint has already been set on it.</p>
<p><b>Remove Breakpoint</b></p>
<p>Toggles (enables or disables) the software breakpoint located on the line.</p>
<p>This menu item is only available if a breakpoint is set on the right-clicked</p>
<p>line.</p>
<p><b>Enable/Disable</b></p>
<p><b>Breakpoint</b></p>
<p>Allows you to move the software breakpoint located on the line to another</p>
<p>line in the same function. This menu item is only available if one software</p>
<p>breakpoint is set on the right-clicked line. For more information, see</p>
<p>âMoving Software Breakpointsâ on page 132.</p>
<p><b>Move Breakpoint</b></p>
<p>Allows you to add a Debugger Note at the line's location. For more</p>
<p>information, see Chapter 10, âUsing Debugger Notesâ on page 173.</p>
<p><b>Create Note</b></p>
<p>Allows you to edit the Debugger Note set at the line's location. For more</p>
<p>information, see Chapter 10, âUsing Debugger Notesâ on page 173.</p>
<p><b>Edit Note</b></p>
<p><i>705</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Source Line Shortcut Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Removes the Debugger Note from the line. For more information, see</p>
<p>Chapter 10, âUsing Debugger Notesâ on page 173.</p>
<p><b>Remove Note</b></p>
<p>Opens a Browse window displaying those files that include the current</p>
<p>file. For more information, see âBrowsing Source Files General</p>
<p>Informationâ on page 231.</p>
<p><b>Browse Includers</b></p>
<p><b>Of This File</b></p>
<p>Opens a Browse window displaying those files that are included by the</p>
<p>current file. For more information, see âBrowsing Source Files General</p>
<p>Informationâ on page 231 .</p>
<p><b>Browse Files</b></p>
<p><b>Included By This</b></p>
<p><b>File</b></p>
<p>Toggles the display between source-only mode and interlaced assembly</p>
<p>mode.</p>
<p><b>Display Interlaced</b></p>
<p><b>Assembly/Source</b></p>
<p><b>Only</b></p>
<p>The following table describes the selections available from the<b> Trace</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Sets the trigger event to be any execution of the selected line and enables</p>
<p>trace. See âConfiguring Trace Directly from MULTIâ on page 491.</p>
<p><b>Trace Around This</b></p>
<p><b>Line</b></p>
<p>After collecting trace data, displays a list showing each time the selected</p>
<p>source line was executed and stored in trace data. See âThe Trace</p>
<p>Instruction Browserâ on page 456.</p>
<p><b>Browse Traced</b></p>
<p><b>Executions</b></p>
<p>The following table describes the selections available from the<b> Set Breakpoint</b></p>
<p>submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Sets a software breakpoint.</p>
<p>See also the<b> b</b> command in Chapter 3, âBreakpoint Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book</p>
<p><b>Set Breakpoint</b></p>
<p>Opens the<b> Software Breakpoint Editor</b> window, which allows you to</p>
<p>specify and set a software breakpoint. See the<b> editswbp</b> command in</p>
<p>Chapter 3, âBreakpoint Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Set And Edit</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>706</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Queries for a location to jump to when the breakpoint is hit and sets a</p>
<p>jump breakpoint. A jump breakpoint executes the<b> g<i> location</b></i>;<b>resume</b>;</p>
<p>commands when it is reached. For information about the<b> g</b> command,</p>
<p>see âGeneral Program Execution Commandsâ in Chapter 13, âProgram</p>
<p>Execution Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book. For information about the<b> resume</b> command, see</p>
<p>Chapter 3, âBreakpoint Command Referenceâ in the<i> MULTI: Debugging</i></p>
<p><i>Command Reference</i> book.</p>
<p><b>Set Jump</b></p>
<p><b>Breakpoint</b></p>
<p>Sets a software breakpoint which can be hit by any task. This option is</p>
<p>available only when connected to a target which supports this type of</p>
<p>breakpoint. See the<b> sb</b> command in Chapter 3, âBreakpoint Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Set Any Task</b></p>
<p><b>Breakpoint</b></p>
<p><b>The Breakdot Shortcut Menu</b></p>
<p>In addition to certain menu options listed in âThe Source Line Shortcut Menuâ</p>
<p>on page 705, the following menu options are available in the shortcut menu that</p>
<p>appears when you right-click a breakdot. Tracepoint menu options appear if your</p>
<p>connection supports tracepoints.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Sets a hardware breakpoint on the line. This menu item is only available</p>
<p>if the right-clicked line contains executable code and does not already</p>
<p>have a breakpoint set on it.</p>
<p><b>Set Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Opens the<b> Hardware Breakpoint Editor</b>, which allows you to edit the</p>
<p>hardware breakpoint set on the line. This menu item is only available if</p>
<p>a hardware breakpoint is set on the right-clicked line.</p>
<p><b>Edit Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Removes the hardware breakpoint from the line. This menu item is only</p>
<p>available if the right-clicked line contains executable code and a hardware</p>
<p>breakpoint has already been set on it.</p>
<p><b>Remove Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Toggles (enables and disables) the hardware breakpoint located on the</p>
<p>line. This menu item is only available if a hardware breakpoint is set on</p>
<p>the right-clicked line.</p>
<p><b>Enable/Disable</b></p>
<p><b>Hardware</b></p>
<p><b>Breakpoint</b></p>
<p>Opens the<b> Tracepoint Editor</b>, which allows you to set a tracepoint on</p>
<p>the line.</p>
<p><b>Set Tracepoint</b></p>
<p>Opens the<b> Tracepoint Editor</b>, which allows you to edit the tracepoint</p>
<p>set on the line. This menu item is only available if a tracepoint is set on</p>
<p>the right-clicked line.</p>
<p><b>Edit Tracepoint</b></p>
<p><i>707</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Breakdot Shortcut Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Removes the tracepoint from the line. This menu item is only available</p>
<p>if a tracepoint is set on the right-clicked line.</p>
<p><b>Remove Tracepoint</b></p>
<p>Toggles (enables and disables) the tracepoint located on the line. This</p>
<p>menu item is only available if a tracepoint is set on the right-clicked line.</p>
<p><b>Enable/Disable</b></p>
<p><b>Tracepoint</b></p>
<p><b>The Procedure Shortcut Menu</b></p>
<p>In addition to the menu options listed in âCommon Shortcut Menu Optionsâ</p>
<p>on page 704, the following menu options are available in the shortcut menu that</p>
<p>appears when you right-click a procedure.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays the source code, if available, for the procedure's definition in</p>
<p>the source pane.</p>
<p><b>Go To Definition</b></p>
<p>Displays the source code, if available, for the procedure's declaration in</p>
<p>the source pane.</p>
<p><b>Go To Declaration</b></p>
<p>Shows the procedure's cross references in a Browse window. For more</p>
<p>information, see âBrowsing Cross Referencesâ on page 236.</p>
<p><b>Browse References</b></p>
<p>For a description of this submenu, see later in this section.</p>
<p><b>Browse Other</b></p>
<p>This is available only if connected to a trace-enabled target. For a</p>
<p>description of this submenu, see later in this section.</p>
<p><b>Trace</b></p>
<p>Attempts to step through the next source line, halting if execution enters</p>
<p>the selected procedure. This is available only when right-clicking</p>
<p>procedure calls on the currently executing line.</p>
<p><b>Step Into This</b></p>
<p><b>Function</b></p>
<p>Opens an editor window centered on the procedure's definition, if the</p>
<p>appropriate source debugging information is available.</p>
<p><b>Edit Definition</b></p>
<p>The following table lists the entries in the<b> Browse Other</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Opens a Browse window displaying the callers of the procedure.</p>
<p><b>Browse Callers</b></p>
<p>Opens a Browse window displaying the callees of the procedure.</p>
<p><b>Browse Callees</b></p>
<p>Opens a<b> Tree Browser</b> window displaying the static call graph of the</p>
<p>procedure (which shows its callers and callees and their callers and</p>
<p>callees). See âThe Tree Browser Windowâ on page 239.</p>
<p><b>Browse Static Calls</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>708</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The following table lists the entries in the<b> Trace</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Enables trace only when executing the selected function. Tracing will</p>
<p>not occur when executing subfunctions.</p>
<p><b>Trace This</b></p>
<p><b>Function</b></p>
<p>Allows you to create conditions that enable and disable trace based on</p>
<p>executions in specific functions. See âSpecifying a Trace Function</p>
<p>Intervalâ on page 492 for more information.</p>
<p><b>Trace Function</b></p>
<p><b>Interval</b></p>
<p>After you have collected trace data, displays a list of each call to this</p>
<p>function in the trace data. See âThe Trace Call Browserâ on page 457.</p>
<p><b>Browse Traced</b></p>
<p><b>Calls</b></p>
<p>For more information about collecting trace data, see âEnabling and Disabling Trace</p>
<p>Collectionâ on page 405.</p>
<p><b>The Variable Shortcut Menu</b></p>
<p>In addition to the menu options listed in âCommon Shortcut Menu Optionsâ</p>
<p>on page 704, the following menu options are available in the shortcut menu that</p>
<p>appears when you right-click a variable (local, parameter, global, or static). If you</p>
<p>can set a hardware breakpoint on the variable, the hardware breakpoint menu options</p>
<p>listed in âThe Breakdot Shortcut Menuâ on page 707 appear as well.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays the source code, if available, for the variable's definition in the</p>
<p>source pane.</p>
<p><b>Go To Definition</b></p>
<p>Displays the source code, if available, for the variable's declaration in</p>
<p>the source pane. This is available only for global and static variables.</p>
<p><b>Go To Declaration</b></p>
<p>Shows the variable's cross references in a Browse window. See</p>
<p>âBrowsing Cross Referencesâ on page 236 for more information.</p>
<p><b>Browse References</b></p>
<p>This is available only if you are connected to a trace-enabled target. For</p>
<p>a description of this submenu, see later in this section.</p>
<p><b>Trace</b></p>
<p>Opens a Data Explorer displaying the value of the variable.</p>
<p><b>View Value</b></p>
<p>If the variable matches a custom data description of the data type</p>
<p>graph</p>
<p>,</p>
<p>opens a<b> Graph View</b> window displaying a graph of objects based on</p>
<p>the data description. See Appendix E, âCreating Custom Data</p>
<p>Visualizationsâ on page 741 and âThe Graph View Windowâ on page 247.</p>
<p><b>Graph Data</b></p>
<p>Opens an editor window centered on the variable's definition, if the</p>
<p>appropriate source debugging information is available.</p>
<p><b>Edit Definition</b></p>
<p><i>709</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Variable Shortcut Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The following table lists the entries in the<b> Trace</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Sets the trigger event to be any access of the selected global variable.</p>
<p>This option is available only when connected to a trace-enabled target.</p>
<p>For more information, see Chapter 20, âAdvanced Trace Configurationâ</p>
<p>on page 479.</p>
<p><b>Trace Around Data</b></p>
<p><b>Access</b></p>
<p>After you have collected trace data, displays a list of each access to this</p>
<p>global or static variable in the trace data. Note that this only displays</p>
<p>accesses of the first address of the variable. If the variable is a struct or</p>
<p>class with multiple member variables, only accesses of the first member</p>
<p>variable are displayed. For more information, see âThe Trace Memory</p>
<p>Browserâ on page 452.</p>
<p><b>Browse Traced</b></p>
<p><b>Accesses</b></p>
<p><b>The Type Shortcut Menu</b></p>
<p>In addition to the menu options listed in âCommon Shortcut Menu Optionsâ</p>
<p>on page 704, the following menu options are available in the shortcut menu that</p>
<p>appears when you right-click a type.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays the source code, if available, for the type's definition in the</p>
<p>source pane.</p>
<p><b>Go To Definition</b></p>
<p>Shows the type's cross references in a Browse window. See âBrowsing</p>
<p>Cross Referencesâ on page 236 for more information.</p>
<p><b>Browse References</b></p>
<p>For a description of this submenu, see later in this section. This is</p>
<p>available only if the type is a C++ class.</p>
<p><b>Browse Other</b></p>
<p>Opens a Data Explorer displaying the type's definition.</p>
<p><b>View Type</b></p>
<p>Opens an editor window centered on the type's definition, if the</p>
<p>appropriate source debugging information is available.</p>
<p><b>Edit Definition</b></p>
<p>The following table lists the entries in the<b> Browse Other</b> submenu.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Shows the type's super-classes in a Browse window.</p>
<p><b>Browse</b></p>
<p><b>Superclasses</b></p>
<p>Shows the type's sub-classes in a Browse window.</p>
<p><b>Browse Subclasses</b></p>
<p>Opens a tree browser window to show class hierarchy information. See</p>
<p>âThe Tree Browser Windowâ on page 239.</p>
<p><b>Browse Class</b></p>
<p><b>Hierarchy</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>710</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Type Member Shortcut Menu</b></p>
<p>In addition to the menu options listed in âCommon Shortcut Menu Optionsâ</p>
<p>on page 704, the following menu options are available in the shortcut menu that</p>
<p>appears when you right-click a type's member (such as the member reference of a</p>
<p>struct variable, an enumeration member, or a member name in a class declaration).</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays the source code, if available, for the member's definition in the</p>
<p>source pane.</p>
<p><b>Go To Definition</b></p>
<p>Shows the member's cross references in a Browse window. See</p>
<p>âBrowsing Cross Referencesâ on page 236 for more information.</p>
<p><b>Browse Member</b></p>
<p><b>References</b></p>
<p>Opens a Data Explorer displaying the value of the member.</p>
<p><b>View Value</b></p>
<p>If the member variable matches a custom data description of the data</p>
<p>type</p>
<p>graph</p>
<p>, opens a<b> Graph View</b> window displaying a graph of objects</p>
<p>based on the data description. See Appendix E, âCreating Custom Data</p>
<p>Visualizationsâ on page 741 and âThe Graph View Windowâ on page 247.</p>
<p><b>Graph Data</b></p>
<p>Opens an editor window centered on the member's definition, if the</p>
<p>appropriate source debugging information is available.</p>
<p><b>Edit Definition</b></p>
<p><b>The C/C++ Macro Shortcut Menu</b></p>
<p>In addition to the menu options listed in âCommon Shortcut Menu Optionsâ</p>
<p>on page 704, the following menu options are available in the shortcut menu that</p>
<p>appears when you right-click a C or C++ macro.</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Displays the source code, if available, for the macro's definition in the</p>
<p>source pane.</p>
<p><b>Go To Definition</b></p>
<p><i>711</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Type Member Shortcut Menu</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Command Pane Shortcut Menu</b></p>
<p>The following items appear in the shortcut menu when you right-click in the</p>
<p>Debugger command pane (or the target pane, I/O pane, serial terminal pane, Python</p>
<p>pane, or traffic pane).</p>
<p><b>Meaning</b></p>
<p><b>Menu Item</b></p>
<p>Cuts the current selection to the clipboard. Note that only the current</p>
<p>input line may be cut.</p>
<p><b>Cut</b></p>
<p>Copies the current selection to the clipboard.</p>
<p><b>Copy</b></p>
<p>Pastes text from the clipboard into the current pane. The text will be</p>
<p>treated as input.</p>
<p><b>Paste</b></p>
<p>Switches to the command pane.</p>
<p><b>Command Pane</b></p>
<p>Switches to the target pane.</p>
<p><b>Target Pane</b></p>
<p>Switches to the I/O pane.</p>
<p><b>IO Pane</b></p>
<p>Switches to the serial terminal pane.</p>
<p><b>Serial Pane</b></p>
<p>Switches to the Python pane.</p>
<p><b>Python Pane</b></p>
<p>Switches to the traffic pane.</p>
<p><b>Traffic Pane</b></p>
<p>When selected, output from each pane is displayed in the command pane</p>
<p>in addition to its own pane.</p>
<p><b>Interleaved Output</b></p>
<p>Clears all text from the current pane.</p>
<p><b>Clear Pane</b></p>
<p>Opens the Python pane as a separate window.</p>
<p><b>Show Separate Py</b></p>
<p><b>Window</b></p>
<p>Opens a file chooser in which you can choose the file where you want</p>
<p>to save the contents of the current pane.</p>
<p><b>Save As</b></p>
<p><b>The Source Pane Search Dialog Box</b></p>
<p>To control searches in the source pane, open the<b> Source Pane Search</b> dialog box</p>
<p>in one of the following ways:</p>
<p>â¢</p>
<p>Select<b> Tools</b> â<b> Search</b>.</p>
<p>â¢</p>
<p>In the command pane, enter the<b> dialogsearch</b> command. For information about</p>
<p>this command, see Chapter 16, âSearch Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>712</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For example, to search for a string such as</p>
<p>tree</p>
<p>:</p>
<p>1.</p>
<p>Type</p>
<p>tree</p>
<p>in the search text field.</p>
<p>2.</p>
<p>Click<b> Find</b> to search for the next occurrence of the string.</p>
<p>The toggle buttons in this window are the same as those in the Editor's search dialog</p>
<p>box.</p>
<p>To initiate or repeat searches without the search dialog box, you can also use the</p>
<p><b>Ctrl</b>+<b>F</b> or<b> Ctrl</b>+<b>B</b> key sequences in the command pane.</p>
<p><b>The File Chooser Dialog Box (Linux/Solaris)</b></p>
<p>A file chooser dialog box opens if you initiate an action (using a menu, button,</p>
<p>command, or shortcut) for which a file must be specified, but you have not yet</p>
<p>specified a file. A chooser also opens if you click a<b> Browse</b> or</p>
<p>button on a dialog</p>
<p>box. A sample Linux/Solaris file chooser follows. (For information about Windows</p>
<p>file choosers, see your Windows documentation.)</p>
<p>The title bar of the file chooser will vary depending on the action you are performing.</p>
<p>The following table describes the main elements of the file chooser.</p>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>Displays the directory whose contents are shown in the<b> File List</b>. Type</p>
<p>in a new directory name and press<b> Enter</b> to display a different directory.</p>
<p><b>Directory</b></p>
<p><i>713</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The File Chooser Dialog Box (Linux/Solaris)</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Meaning</b></p>
<p><b>Item</b></p>
<p>With this set of buttons, you can quickly go to different important</p>
<p>directories. The buttons that appear are:</p>
<p>â<b> Up One Directory</b> from the current directory.</p>
<p>â Jumps to the current<b> Working Directory</b>.</p>
<p>â Jumps to the<b> IDE Installation Directory</b>.</p>
<p>â Jumps to the<b> User Home Directory</b>.</p>
<p><b>Directory Buttons</b></p>
<p>Below the directory text field is the file list. To enter a directory,</p>
<p>double-click the directory. To choose a file, single-click the filename.</p>
<p>You can click any column header to sort the list in ascending or</p>
<p>descending order.</p>
<p>If multiple files are allowed for the present operation (for example,<b> Open</b></p>
<p>is selected in the editor menu), use the<b> Shift</b> key to select a consecutive</p>
<p>list of files; use the<b> Ctrl</b> key to select non-consecutive files.</p>
<p><b>File List</b></p>
<p>Type a filename or directory name into this text field. As you type in</p>
<p>this field, the selection in the file list will change to reflect the closest</p>
<p>match. If you type a directory name and press<b> Enter</b>, or follow the</p>
<p>directory name by a slash (</p>
<p>/</p>
<p>), the file list will change to the specified</p>
<p>directory.</p>
<p><b>Filename</b></p>
<p>If you select a file type, the<b> File List</b> will only display files with suffixes</p>
<p>that match the selected file type.</p>
<p><b>File type</b></p>
<p>There are two buttons in the lower right corner of the file chooser</p>
<p>window. The upper button displays the action that will occur, such as</p>
<p><b>Edit</b> (in the example above),<b> OK</b>, or<b> Open</b>. The lower button is the</p>
<p><b>Cancel</b> button, which closes the window without taking any action.</p>
<p><b>Action buttons</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>714</i></p>
<p><i>Appendix A. Debugger GUI Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Appendix B</b></p>
<p><b>Keyboard Shortcut Reference</b></p>
<p><b>Contents</b></p>
<p>Main Debugger Window Shortcuts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>716</p>
<p>Source Pane Shortcuts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>717</p>
<p>Command Pane Shortcuts . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>718</p>
<h1 style="page-break-before:always; "></h1>
<p>This appendix contains descriptions of the Debugger's default keyboard shortcuts.</p>
<p><b>Main Debugger Window Shortcuts</b></p>
<p>The following shortcuts are available from the Debugger window.</p>
<p><b>Note</b></p>
<p>If you have clicked in the source pane or command pane, these shortcuts</p>
<p>may have different effects. See âSource Pane Shortcutsâ on page 717 and</p>
<p>âCommand Pane Shortcutsâ on page 718.</p>
<p><b>Effect</b></p>
<p><b>Shortcut</b></p>
<p>Displays help about the current window.</p>
<p>Corresponds to: the<b> help</b> command (see Chapter 9, âHelp and</p>
<p>Information Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>F1</b></p>
<p>Connects to a target.</p>
<p>If the Debugger is not connected, pressing this button opens the</p>
<p><b>Connection Chooser</b> dialog box, which allows you to connect to a</p>
<p>target board or simulator.</p>
<p>Corresponds to:</p>
<p>and the<b> connect</b> command (see âGeneral Target</p>
<p>Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>F4</b></p>
<p>Begins execution of the program. If the process is stopped, it continues</p>
<p>execution.</p>
<p>Corresponds to:</p>
<p>and the<b> c</b> command (see âContinue Commandsâ in</p>
<p>Chapter 13, âProgram Execution Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book).</p>
<p><b>F5</b></p>
<p>Restarts the process with the same arguments as before.</p>
<p>If you use this shortcut while debugging a Dynamic Download</p>
<p>INTEGRITY application, MULTI attempts to (re)load the application.</p>
<p>This shortcut may not be available for use with relocatable modules.</p>
<p>Corresponds to:</p>
<p>and the<b> restart</b> command (see âRun Commandsâ</p>
<p>in Chapter 13, âProgram Execution Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>Ctrl</b>+<b>Shift</b>+<b>F5</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>716</i></p>
<p><i>Appendix B. Keyboard Shortcut Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Shortcut</b></p>
<p>Continues to the end of the current procedure, and stops in the calling</p>
<p>procedure after returning to it.</p>
<p>Corresponds to:</p>
<p>and the<b> cU</b> command (see âContinue Commandsâ</p>
<p>in Chapter 13, âProgram Execution Command Referenceâ in the</p>
<p><i>MULTI: Debugging Command Reference</i> book).</p>
<p><b>F9</b></p>
<p>Executes until the next statement of the current procedure (that is, steps</p>
<p>over procedure calls). When in interlaced source/assembly mode, a</p>
<p>machine instruction is executed instead of a source statement.</p>
<p>Corresponds to:</p>
<p>and the<b> n</b> command (see âSingle-Stepping</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>F10</b></p>
<p>Executes one statement. If the statement is a procedure call, it is stepped</p>
<p>into. When in interlaced source/assembly mode, a machine instruction</p>
<p>is executed instead of a source statement.</p>
<p>Corresponds to:</p>
<p>and the<b> s</b> command (see âSingle-Stepping</p>
<p>Commandsâ in Chapter 13, âProgram Execution Command Referenceâ</p>
<p>in the<i> MULTI: Debugging Command Reference</i> book).</p>
<p><b>F11</b></p>
<p>Displays the procedure up one stack frame.</p>
<p>Corresponds to:</p>
<p>and the<b> E +</b> command (see Chapter 8, âDisplay and</p>
<p>Print Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>Ctrl</b>+<b>+</b></p>
<p>Displays the procedure down one stack frame.</p>
<p>Corresponds to:</p>
<p>and the<b> E -</b> command (see Chapter 8, âDisplay and</p>
<p>Print Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book).</p>
<p><b>Ctrl</b>+<b>â</b></p>
<p><b>Source Pane Shortcuts</b></p>
<p>The following shortcuts are available from the Debugger window's source pane.</p>
<p><b>Effect</b></p>
<p><b>Shortcut</b></p>
<p>Scroll the source pane up by one page.</p>
<p><b>PageUp</b></p>
<p>Scroll the source pane down by one page.</p>
<p><b>PageDown</b></p>
<p>Scroll the source pane up by one line.</p>
<p><b>Shift</b>+<b>UpArrow</b></p>
<p>Scroll the source pane down by one line.</p>
<p><b>Shift</b>+<b>DownArrow</b></p>
<p>Search forward in the source pane.</p>
<p><b>Ctrl</b>+<b>F</b></p>
<p><i>717</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Source Pane Shortcuts</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Shortcut</b></p>
<p>Search backward in the source pane.</p>
<p><b>Ctrl</b>+<b>B</b></p>
<p>Abort current operation or halt process.</p>
<p><b>Esc</b></p>
<p><b>Command Pane Shortcuts</b></p>
<p>The following shortcuts are available from the Debugger window's command pane.</p>
<p><b>Effect</b></p>
<p><b>Shortcut</b></p>
<p>If nothing is entered on the command line, retrieves the previous</p>
<p>command from the command history, moving back in the list. Press</p>
<p>repeatedly to retrieve older commands.</p>
<p>If you have already begun typing, MULTI attempts to auto-complete</p>
<p>the current string, working backwards through commands that have</p>
<p>been entered.</p>
<p><b>UpArrow</b></p>
<p>If nothing is entered on the command line, retrieves the next</p>
<p>command from the command history, moving forward in the list.</p>
<p>Press repeatedly to retrieve more recent commands.</p>
<p>If you have already begun typing, MULTI attempts to auto-complete</p>
<p>the current string, working forwards through commands that have</p>
<p>been entered.</p>
<p><b>DownArrow</b></p>
<p>Scrolls up four lines.</p>
<p><b>Ctrl</b>+<b>UpArrow</b></p>
<p>Scrolls down four lines.</p>
<p><b>Ctrl</b>+<b>DownArrow</b></p>
<p>Cuts to the beginning of the current line or the selection.</p>
<p><b>Ctrl</b>+<b>U</b></p>
<p>Accepts auto-completion of the current word.</p>
<p><b>Tab</b></p>
<p>Attempts to auto-complete the current string, working backwards</p>
<p>through the command history for commands beginning with the</p>
<p>typed characters.</p>
<p><b>Ctrl</b>+<b>P</b></p>
<p>Attempts to auto-complete the current string, working forwards</p>
<p>through the command history for commands beginning with the</p>
<p>typed characters.</p>
<p><b>Ctrl</b>+<b>N</b></p>
<p>Displays a list of possible completions for the current word.</p>
<p><b>Ctrl</b>+<b>D</b></p>
<p><i>MULTI: Debugging</i></p>
<p><i>718</i></p>
<p><i>Appendix B. Keyboard Shortcut Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Effect</b></p>
<p><b>Shortcut</b></p>
<p>Cycles between the available panes in the command pane area. For</p>
<p>more information, see âThe Cmd, Trg, I/O, Srl, Py, and Tfc Panesâ</p>
<p>on page 26.</p>
<p>Cycles between the command, I/O, target, and serial terminal panes.</p>
<p>For more information, see âThe Cmd, Trg, I/O, Srl, Py, and Tfc</p>
<p>Panesâ on page 26 .</p>
<p><b>F6</b></p>
<p>Displays a pop-up menu showing all Debugger Notes set in the</p>
<p>program.</p>
<p><b>F12</b></p>
<p>Opens a shortcut menu for the command pane. For a full description</p>
<p>of the shortcut menu, see âThe Command Pane Shortcut Menuâ</p>
<p>on page 712.</p>
<p>Click with the right</p>
<p>mouse button</p>
<p><i>719</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Command Pane Shortcuts</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Appendix C</b></p>
<p><b>Command Line Reference</b></p>
<p><b>Contents</b></p>
<p>Using a Specification File . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>727</p>
<h1 style="page-break-before:always; "></h1>
<p>The following command line options can be used when starting MULTI from the</p>
<p>command line, as described in âStarting the Debugger in GUI Modeâ on page 6.</p>
<p><b>--<i> args</b></i></p>
<p>Passes all the arguments that follow the double dash to the program being debugged as though</p>
<p>the arguments were set with the<b> setargs</b> command.</p>
<p>For more information, see the<b> setargs</b> command in âGeneral Program Execution Commandsâ</p>
<p>in Chapter 13, âProgram Execution Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book.</p>
<p><b>-build<i> file</b></i></p>
<p>Opens the Project Manager on<b> default.gpj</b> in your current working directory and starts building</p>
<p><i>file</i></p>
<p>, which may be anything you can build within<b> default.gpj</b>.</p>
<p>The Debugger does not open when you use this option, so you should not specify a program to</p>
<p>debug.</p>
<p><b>-c<i> file</b></i></p>
<p><b>-config<i> file</b></i></p>
<p><b>-configure<i> file</b></i></p>
<p>Configures MULTI using the information in the configuration file</p>
<p><i>file</i></p>
<p>.</p>
<p>For more information, see âCreating and Editing Configuration Filesâ in Chapter 7, âConfiguring</p>
<p>and Customizing MULTIâ in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>-C<i> core_file</b></i></p>
<p><b>Linux/Solaris only</b></p>
<p>Specifies the core file, where</p>
<p><i>core_file</i></p>
<p>is a Linux/Solaris core image of the program to be</p>
<p>debugged. For more information, see âCore File Debugging (Linux/Solaris only)â on page 117.</p>
<p><b>-cmd<i> commands</b></i></p>
<p>Runs the specified commands when the Debugger is up.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>722</i></p>
<p><i>Appendix C. Command Line Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>-connect[=<i>target</i> | =<i>connection_method_name</i>]</b></p>
<p>Connects to the target debug server specified by</p>
<p><i>target</i></p>
<p>; connects using the specified Connection</p>
<p>Method; or, if neither a target nor a Connection Method is specified, opens the<b> Connection</b></p>
<p><b>Chooser</b>.</p>
<p>For more information about connecting to targets, see Chapter 3, âConnecting to Your Targetâ</p>
<p>on page 39. For information about the<b> connect</b> command, which corresponds to this option,</p>
<p>see âGeneral Target Connection Commandsâ in Chapter 18, âTarget Connection Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>Note</b>: The Debugger ignores the deprecated</p>
<p>mode</p>
<p>argument in Connection Methods that specify</p>
<p>it. To remove the</p>
<p>mode</p>
<p>argument from a MULTI 4 Connection Method, edit and save the</p>
<p>Connection Method in MULTI 6. For more information, see the<b> connect</b> command in âGeneral</p>
<p>Target Connection Commandsâ in Chapter 18, âTarget Connection Command Referenceâ in</p>
<p>the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>-connectfile<i> file</b></i></p>
<p>Specifies that connections should be loaded from the file</p>
<p><i>file</i></p>
<p>.</p>
<p>For more information, see âCreating and Managing Connection Filesâ on page 52.</p>
<p><b>-D</b></p>
<p>Ignores all currently specified alternative directories.</p>
<p>See also the<b> -I</b> command line option later in this table and the<b> source</b> command in âGeneral</p>
<p>Configuration Commandsâ in Chapter 6, âConfiguration Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>-data<i> offset</b></i></p>
<p>Sets the default offset for all data addresses to</p>
<p><i>offset</i></p>
<p>, which is assumed to be in decimal unless</p>
<p>preceded by</p>
<p>0x</p>
<p>. Do not set</p>
<p><i>offset</i></p>
<p>to</p>
<p>-1</p>
<p>. This option is only useful when debugging programs</p>
<p>built with position-independent data; it should not be used in other kinds of programs.</p>
<p><b>-display<i> disp</b></i></p>
<p><b>Linux/Solaris only</b></p>
<p>Specifies that the Debugger will open in the alternative display</p>
<p><i>disp</i></p>
<p>.</p>
<p><b>-e<i> entry</b></i></p>
<p>Specifies the entry label. The default is</p>
<p>main</p>
<p>. In C++ programs, only non-mangled names such</p>
<p>as those declared with</p>
<p>extern &quot;C&quot;</p>
<p>may be specified for</p>
<p><i>entry</i></p>
<p>.</p>
<p><i>723</i></p>
<p><i>Green Hills Software</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>-E<i> file</b></i></p>
<p>Opens the Debugger on multiple files. Use this option for each file after the first that you want</p>
<p>to debug. For example, if you want to debug<b> foo</b>,<b> bar</b>, and<b> baz</b>, use the command:</p>
<p>multi foo -E bar -E baz</p>
<p>This opens a single Debugger window and lists<b> foo</b>,<b> bar</b>, and<b> baz</b> in the target list of that window.</p>
<p>The maximum number of files you can specify is 256. The first file you specify, which is not</p>
<p>preceded by<b> -E</b>, is included in this maximum number.</p>
<p><b>-h</b></p>
<p>Displays a concise description of all command line options. This is equivalent to the<b> -usage</b></p>
<p>option (below).</p>
<p><b>-H</b></p>
<p><b>-help</b></p>
<p>Opens the MULTI Help Viewer on the<i> MULTI: Debugging</i> book.</p>
<p><b>-I<i> directory</b></i></p>
<p>(This option is a capital letter âi.â)</p>
<p>Names an alternative directory for the Debugger to search for files in. You can specify multiple</p>
<p>alternative directories by using multiple<b> -I<i> directory</b></i> arguments. The Debugger searches</p>
<p>alternative directories in the order given. If it does not find a file in the specified alternative</p>
<p>directory or directories, it also searches the current directory.</p>
<p>See also the<b> -D</b> command line option earlier in this table and the<b> source</b> command in âGeneral</p>
<p>Configuration Commandsâ in Chapter 6, âConfiguration Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p><b>-m<i> file</b></i></p>
<p>Sets</p>
<p><i>file</i></p>
<p>as the default specification file.</p>
<p>For more information, see âUsing a Specification Fileâ on page 727.</p>
<p><b>-nocfg</b></p>
<p>Causes MULTI to ignore all<b> .cfg</b> files on startup.</p>
<p><b>-nodisplay</b></p>
<p><b>Linux/Solaris only</b></p>
<p>Specifies that the Debugger will open in non-GUI mode.</p>
<p>For more information, see âStarting the Debugger in Non-GUI Mode (Linux/Solaris only)â</p>
<p>on page 8.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>724</i></p>
<p><i>Appendix C. Command Line Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>-norc</b></p>
<p>Causes MULTI to ignore all<b> .rc</b> script files upon startup except for those specified with<b> -rc</b></p>
<p>(below).</p>
<p>For more information, see âUsing Script Filesâ in Chapter 7, âConfiguring and Customizing</p>
<p>MULTIâ in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>-noshared</b></p>
<p>Indicates that MULTI should not debug shared libraries. This option is relevant only for targets</p>
<p>that support shared libraries.</p>
<p>See also the</p>
<p>DEBUGSHARED</p>
<p>system variable in âSystem Variablesâ on page 310.</p>
<p><b>-nosplash</b></p>
<p>Prevents MULTI from displaying the startup banner.</p>
<p><b>-osa<i> osa_name</i>[#cfg=<i>configuration_file</i>][#lib=<i>library_name</i>][#log=<i>log_file</i>]</b></p>
<p>Starts MULTI with freeze-mode debugging and OS-awareness enabled.</p>
<p><i>osa_name</i></p>
<p>specifies</p>
<p>an object structure-aware debug package.</p>
<p><i>configuration_file</i></p>
<p>specifies the configuration</p>
<p>file for freeze-mode debugging and OS-awareness,</p>
<p><i>library_name</i></p>
<p>specifies the library</p>
<p>containing the OSA integration package, and</p>
<p><i>log_file</i></p>
<p>specifies a file in which to log the</p>
<p>interaction between MULTI and the OSA integration package.</p>
<p>For more information, see âStarting MULTI for Freeze-Mode Debugging and OS-Awarenessâ</p>
<p>on page 607.</p>
<p><b>-p<i> file</b></i></p>
<p>Runs the commands in the playback file</p>
<p><i>file</i></p>
<p>on startup.</p>
<p>For more information, see âRecord and Playback Commandsâ in Chapter 15, âScripting</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>-P<i> pid</b></i></p>
<p><b>Native targets only</b></p>
<p>Attaches to the process with the process identification number</p>
<p><i>pid</i></p>
<p>. The maximum number of</p>
<p>processes you can specify is 256.</p>
<p><b>-preload<i> module</b></i></p>
<p>Downloads</p>
<p><i>module</i></p>
<p>after connecting to an operating system target, which must be specified</p>
<p>elsewhere on the command line.</p>
<p>This option is only valid for certain operating system targets. Additionally, the target must</p>
<p>support and be configured with a dynamic loader (for example, the LoaderTask on INTEGRITY).</p>
<p><b>-r<i> file</b></i></p>
<p>Records commands to the playback file</p>
<p><i>file</i></p>
<p>.</p>
<p>For more information, see âRecord and Playback Commandsâ in Chapter 15, âScripting</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>725</i></p>
<p><i>Green Hills Software</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>-R<i> file</b></i></p>
<p>Records commands and output to the playback file</p>
<p><i>file</i></p>
<p>.</p>
<p>For more information, see âRecord and Playback Commandsâ in Chapter 15, âScripting</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>-rc<i> file</b></i></p>
<p>Reads the command script</p>
<p><i>file</i></p>
<p>when the first Debugger window appears. The file is read after</p>
<p>the global and user script files.</p>
<p>For more information, see âUsing Script Filesâ in Chapter 7, âConfiguring and Customizing</p>
<p>MULTIâ in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.</p>
<p><b>-RO<i> file</b></i></p>
<p>Records output to the playback file</p>
<p><i>file</i></p>
<p>. (Commands are not recorded.)</p>
<p>For more information, see âRecord and Playback Commandsâ in Chapter 15, âScripting</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>-run<i> debug_server</i> [-timeout=<i>num</i>] --</b></p>
<p>Connects to</p>
<p><i>debug_server</i></p>
<p>, runs</p>
<p><i>program</i></p>
<p>in the Debugger (see âStarting the Debugger in</p>
<p>GUI Modeâ on page 6), runs any commands specified on the command line or in any relevant</p>
<p><b>.rc</b> scripts, and then exits.</p>
<p>-timeout</p>
<p>specifies the number of seconds until the operation times out. On Windows and</p>
<p>Linux, the default is</p>
<p>600</p>
<p>; on Solaris, the default is</p>
<p>2400</p>
<p>. The maximum value of</p>
<p><i>num</i></p>
<p>is 2</p>
<p>31</p>
<p>/1000.</p>
<p>If</p>
<p><i>num</i></p>
<p>is</p>
<p>-1</p>
<p>, the operation never times out.</p>
<p>This option should be specified after other options and before</p>
<p><i>program</i></p>
<p>(see âStarting the</p>
<p>Debugger in GUI Modeâ on page 6).</p>
<p><b>-servertimeout<i> time</b></i></p>
<p>Sets the default debug server timeout to</p>
<p><i>time</i></p>
<p>seconds.</p>
<p><b>-socket<i> port</b></i></p>
<p>Creates a socket connection on the port</p>
<p><i>port</i></p>
<p>. This socket connection can be used to send</p>
<p>Debugger commands and receive Debugger output.</p>
<p>For more details, see the<b> socket</b> command in Chapter 2, âGeneral Debugger Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><b>-text<i> offset</b></i></p>
<p>Sets the default offset for all text addresses to</p>
<p><i>offset</i></p>
<p>, which is assumed to be in decimal unless</p>
<p>preceded by</p>
<p>0x</p>
<p>. Do not set</p>
<p><i>offset</i></p>
<p>to</p>
<p>-1</p>
<p>. This option is only useful when debugging programs</p>
<p>built with position-independent code; it should not be used with other kinds of programs.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>726</i></p>
<p><i>Appendix C. Command Line Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>-top</b></p>
<p><b>Native targets only</b></p>
<p>Opens the Process Viewer, which displays a snapshot of the processes running on your native</p>
<p>target and allows you to attach to native processes. For more information, see âViewing Native</p>
<p>Processesâ on page 390.</p>
<p><b>-tv<i> file</b></i></p>
<p>Specifies the task view configuration file for run-mode debugging.</p>
<p>For more information about task view configuration files, see âTask Group Configuration Fileâ</p>
<p>on page 600.</p>
<p><b>-usage</b></p>
<p>Displays a concise description of all command line options. This is equivalent to the<b> -h</b> option</p>
<p>(above).</p>
<p><b>-V</b></p>
<p>Prints Debugger version information.</p>
<p><b>Using a Specification File</b></p>
<p>You can use a specification file to set up a default set of command line arguments,</p>
<p>which are used when you open the Debugger on a specified executable. You can</p>
<p>create default command line options for more than one executable in the same</p>
<p>specification file.</p>
<p>Your specification file should have an<b> .mc</b> extension. To indicate the command line</p>
<p>arguments associated with an executable, type the name of the executable followed</p>
<p>by a space and the list of command line arguments, all on a single line. If you need</p>
<p>to continue a list of arguments on a second line, the second line must begin with a</p>
<p>tab. To create a list of commands for another executable, begin a new line and enter</p>
<p>the executable name followed by a space and the list of command line options. For</p>
<p>example, a specification file that uses separate command line arguments when</p>
<p>debugging<b> foo</b> and when debugging<b> bar</b> might contain the following lines.</p>
<p>Windows:</p>
<p>â¢</p>
<p>foo -I C:\usr\joebob -I C:\usr\foodir</p>
<p>â¢</p>
<p>bar -text 10000 -data 40000</p>
<p><i>727</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using a Specification File</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Linux/Solaris:</p>
<p>â¢</p>
<p>foo -I /usr/joebob -I /usr/foodir</p>
<p>â¢</p>
<p>bar -text 10000 -data 40000</p>
<p>To use a specification file, pass the<b> -m<i> file</b></i> option and launch the MULTI Debugger</p>
<p>from the command line. This results in MULTI searching the specified file for a</p>
<p>line that begins with the name of the executable on which you are opening the</p>
<p>Debugger. If it finds a line that begins with the executable name, the Debugger uses</p>
<p>the specified command line options on that line when it opens on the program. For</p>
<p>example, if the specification file<b> albatross.mc</b> contains the lines given above,</p>
<p>entering the command:</p>
<p>multi -m albatross.mc foo</p>
<p>has the same effect on your operating system as entering one of the following</p>
<p>commands.</p>
<p>â¢</p>
<p>Windows â</p>
<p>multi foo -I C:\usr\</p>
<p>joebob -I C:\usr\foodir</p>
<p>â¢</p>
<p>Linux/Solaris â</p>
<p>multi foo -I /usr/joebob -I /usr/foodir</p>
<p><i>MULTI: Debugging</i></p>
<p><i>728</i></p>
<p><i>Appendix C. Command Line Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Appendix D</b></p>
<p><b>Using Third-Party Tools with</b></p>
<p><b>the MULTI Debugger</b></p>
<p><b>Contents</b></p>
<p>Using the Debugger with Third-Party Compilers . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>730</p>
<p>Running Third-Party Tools from the Debugger . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>731</p>
<p>Using MULTI with Rhapsody . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>732</p>
<h1 style="page-break-before:always; "></h1>
<p>This appendix describes how to use various third-party tools with the MULTI</p>
<p>Debugger.</p>
<p><b>Using the Debugger with Third-Party Compilers</b></p>
<p>Green Hills provides Debug Translators that allow you to use the MULTI Debugger</p>
<p>to debug applications compiled with third-party compilers. The MULTI Debugger</p>
<p>provides superior debugging capabilities by using special debugging information</p>
<p>files generated by Green Hills Compilers. If you do not compile with Green Hills</p>
<p>Compilers, the Green Hills Debug Translators allow you to convert DWARF or</p>
<p>Stabs debugging information generated by third-party compilers into the format</p>
<p>required by the MULTI Debugger.</p>
<p>If you have licensed one of the Green Hills Debug Translators, you can configure</p>
<p>MULTI to automatically convert DWARF or Stabs debugging information when</p>
<p>an executable compiled entirely by a third-party compiler that generates that type</p>
<p>of information is loaded into the Debugger. To enable automatic conversion:</p>
<p>1.</p>
<p>Select<b> Config</b> â<b> Options</b> from the Debugger.</p>
<p>2.</p>
<p>Select the Debugger tab, and then click<b> More Debugger Options</b>.</p>
<p>3.</p>
<p>Select either<b> Translate DWARF debugging information</b> or<b> Translate stabs</b></p>
<p><b>debugging information</b>, as desired. (For more information about these options,</p>
<p>see âThe More Debugger Options Dialogâ in Chapter 8, âConfiguration</p>
<p>Optionsâ in the<i> MULTI: Managing Projects and Configuring the IDE</i> book.)</p>
<p>4.</p>
<p>Click<b> OK</b>.</p>
<p>For more information, including instructions about what to do if you compiled some</p>
<p>of the object files of your executable with a third-party compiler and others with a</p>
<p>Green Hills Software compiler, see the documentation about generating debugging</p>
<p>information for applications compiled with third-party compilers in the<i> MULTI:</i></p>
<p><i>Building Applications</i> book.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>730</i></p>
<p><i>Appendix D. Using Third-Party Tools with the MULTI Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Running Third-Party Tools from the Debugger</b></p>
<p>By using the Debugger's<b> shell</b> command, you can configure menus and buttons to</p>
<p>run arbitrary external commands from within the Debugger. For information about</p>
<p>the<b> shell</b> command, see âCommand Manipulation and Macro Commandsâ in Chapter</p>
<p>15, âScripting Command Referenceâ in the<i> MULTI: Debugging Command Reference</i></p>
<p>book. For information about defining your own menu items and toolbar buttons to</p>
<p>invoke commands, see âCustomizing the GUIâ in Chapter 7, âConfiguring and</p>
<p>Customizing MULTIâ in the<i> MULTI: Managing Projects and Configuring the IDE</i></p>
<p>book.</p>
<p>You can dynamically construct command line arguments by using the</p>
<p>%EVAL{<i>multi_commands</i>}</p>
<p>escape sequence of the<b> shell</b> command. Useful</p>
<p><i>multi_commands</i></p>
<p>include:</p>
<p>â¢</p>
<p>System variables such as</p>
<p>_SELECTION</p>
<p>, which obtains the current selection in</p>
<p>the Debugger source pane</p>
<p>â¢</p>
<p>Commands such as<b> dialog</b> that prompt you for information (see âDialog</p>
<p>Commandsâ in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book)</p>
<p>To display the contents of output files produced by third-party tools, issue the<b> cat</b></p>
<p><i><b>file</b></i> command. The Debugger displays the contents of</p>
<p><i>file</i></p>
<p>in the command pane.</p>
<p>For information about the<b> cat</b> command, see Chapter 8, âDisplay and Print Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p>If you have the<b> make</b> utility installed on your system, you can use it to build</p>
<p>programs from within the MULTI Debugger by issuing the Debugger's<b> make</b></p>
<p>command. For information about the<b> make</b> command, see âExternal Tool</p>
<p>Commandsâ in Chapter 15, âScripting Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>You can configure the MULTI IDE to invoke the editor of your choice instead of</p>
<p>the MULTI Editor. For more information, see âThird-Party Editor Configuration</p>
<p>Optionsâ in Chapter 8, âConfiguration Optionsâ in the<i> MULTI: Managing Projects</i></p>
<p><i>and Configuring the IDE</i> book.</p>
<p><i>731</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Running Third-Party Tools from the Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Using MULTI with Rhapsody</b></p>
<p>Rhapsody and MULTI are integrated to provide a complete Model Driven</p>
<p>Development (MDD) solution for a number of target environments.</p>
<p>Rhapsody provides a UML-based development environment that can generate source</p>
<p>files and has many other capabilities not listed here. In contrast, MULTI provides</p>
<p>the capabilities to compile that code, download and run it on a target, and debug it</p>
<p>at the source level.</p>
<p>Ultimately, the integration between these two tools provides automation and a</p>
<p>seamless path from phases such as requirements analysis, UML design, and</p>
<p>model-driven development through to code generation, compilation, loading,</p>
<p>running, debugging, validation, and testing.</p>
<p><b>Supported Environments</b></p>
<p>At the time of writing, supported versions of Rhapsody are:</p>
<p>â¢</p>
<p>7.5.1</p>
<p>â¢</p>
<p>7.5.3</p>
<p>The supported host is Windows.</p>
<p>Supported target environments include:</p>
<p>â¢</p>
<p>INTEGRITY 10 and 5</p>
<p>â</p>
<p>Power Architecture, ColdFire, ARM, MIPS, x86</p>
<p><b>Note</b></p>
<p>While INTEGRITY 10 is supported, the Rhapsody GUIs only refer</p>
<p>to INTEGRITY 5.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>732</i></p>
<p><i>Appendix D. Using Third-Party Tools with the MULTI Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Integration Description</b></p>
<p>The three significant points of integration between Rhapsody and MULTI can be</p>
<p>summarized as follows:</p>
<p>â¢</p>
<p>Build â Rhapsody can generate source files and the necessary MULTI project</p>
<p>files (<b>.gpj</b> files) and invoke the build processes automatically.</p>
<p>â¢</p>
<p>Target â The Rhapsody<i> Adapters</i> (framework libraries) provide the adaptation</p>
<p>layer between the generated model and the underlying OS, such as INTEGRITY.</p>
<p>The Adapters take into account the Green Hills Compiler and are customized</p>
<p>for the underlying OS.</p>
<p>â¢</p>
<p>Debug â Rhapsody provides model-level debugging called<i> Animation</i>, whereas</p>
<p>MULTI provides source-level debugging. While these debugging methods can</p>
<p>be used independently and effectively, the integration provides the additional</p>
<p>capability to synchronize them.</p>
<p><b>Installation and Configuration</b></p>
<p>For information about installing Rhapsody, please refer to Rhapsody's installation</p>
<p>guide from IBM Rational. There are no special installation requirements or</p>
<p>configuration instructions for MULTI or INTEGRITY.</p>
<p>Rhapsody must be configured to use a particular compiler (such as a Green Hills</p>
<p>Compiler) and a particular OS (such as INTEGRITY). During the Rhapsody</p>
<p>installation process, you should supply the path to the Compiler directory when</p>
<p>prompted for the location of<b> GHS MULTI 4.x for PPC</b>. You may supply the path</p>
<p>to an INTEGRITY 10 installation when you are prompted for the location of<b> GHS</b></p>
<p><b>INTEGRITY 5.x</b>.</p>
<p>The Rhapsody installer records the location of the Compiler and/or INTEGRITY</p>
<p>directories in one or more<b> .bat</b> files located in the<b> Rhapsody\Share\etc</b> directory</p>
<p>(depending upon your target environment and versions of tools). They include</p>
<p><b>Integrity5Make.bat</b> and<b> Integrity5MakefileGenerator.bat</b>. If you enter the wrong</p>
<p>directory during installation, or if the Compiler or INTEGRITY directories are</p>
<p>subsequently moved, you may manually correct these files.</p>
<p><i>733</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Integration Description</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The Rhapsody build system for INTEGRITY requires the following system</p>
<p>environment variables to be set when you run Rhapsody:</p>
<p>â¢</p>
<p>INTEGRITY_ROOT</p>
<p>â The INTEGRITY installation directory</p>
<p>â¢</p>
<p>MULTI_ROOT</p>
<p>â The Compiler installation directory</p>
<p>For further information about configuring Rhapsody to use MULTI and</p>
<p>INTEGRITY, please refer to Rhapsody's installation guide from IBM Rational.</p>
<p><b>Licensing</b></p>
<p>Standard MULTI and Compiler licenses are required for MULTI and the Green</p>
<p>Hills Compilers, respectively. To enable the synchronous debugging functionality,</p>
<p>MULTI requires the additional âRhapsody Integration License.â If you do not</p>
<p>already have these licenses, contact your Green Hills sales representative to obtain</p>
<p>them.</p>
<p><b>Additional Notes</b></p>
<p>Much of the information in the following sections is covered by Rhapsody</p>
<p>documentation, but some highlights are presented here.</p>
<p><b>Building Framework Libraries for INTEGRITY</b></p>
<p>To build the framework libraries for a particular INTEGRITY target, invoke</p>
<p><b>IntegrityBuild.bat</b> from the command line in the appropriate Rhapsody language</p>
<p>directory and with pointers to the Compiler directory, the INTEGRITY directory,</p>
<p>and the target BSP. For example:</p>
<p>&gt; cd Rhapsody\Share\LangC</p>
<p>&gt; IntegrityBuild C:\GHS\int<i>xxxx</i> sim800 C:\ghs\comp_<i>xxxxxx</i> -trg ppc_integrity.tgt</p>
<p>&gt; cd Rhapsody\Share\LangCpp</p>
<p>&gt; IntegrityBuild C:\GHS\int<i>xxxx</i> sim800 C:\ghs\comp_<i>xxxxxx</i> -trg ppc_integrity.tgt</p>
<p>The resulting Adapter libraries are linked into your models when you build them.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>734</i></p>
<p><i>Appendix D. Using Third-Party Tools with the MULTI Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Configuring a Model for INTEGRITY</b></p>
<p>A few options need to be configured for a model before you can build the model</p>
<p>for an INTEGRITY target. Double-click the configuration you want to build for</p>
<p>INTEGRITY (configurations are located at<i><b> Project Name</b></i> â<b> Components</b> â</p>
<p><i><b>Component Name</b></i> â<b> Configurations</b> â<i><b> Configuration Name</b></i>), and set the</p>
<p>appropriate optionsâor ensure that they are setâas follows.</p>
<p>Under the<b> General</b> tab:</p>
<p>â¢</p>
<p>The<b> Executable</b> radio button should be selected if you want to generate an</p>
<p>INTEGRITY Dynamic Download with a single AddressSpace that contains a</p>
<p>Rhapsody component.</p>
<p>â¢</p>
<p>The<b> Library</b> radio button should be selected if you want to generate a basic</p>
<p>library that can then be linked to some other executable.</p>
<p>Under the<b> Settings</b> tab:</p>
<p>â¢</p>
<p><b>Instrumentation Mode</b> should be set to<b> Animation</b> to enable model-level</p>
<p>debugging.</p>
<p>â¢</p>
<p><b>Time Model</b> may optionally be set to<b> Simulated</b>. When you are building a</p>
<p>model for ISIM, it is often useful to set this option. For example, because a</p>
<p>one-second timeout is calculated by a simulated processor, the actual wall-clock</p>
<p>time could be noticeably longer.</p>
<p>â¢</p>
<p><b>Environment</b> should be set to<b> INTEGRITY5</b>. (Note that this is the case even</p>
<p>if you are using INTEGRITY 10.)</p>
<p>â¢</p>
<p><b>Build Set</b> should be set to<b> Debug</b> to enable source-level debugging.</p>
<p>Under the<b> Properties</b> tab:</p>
<p>â¢</p>
<p><b>C_CG</b> (or<b> CPP_CG</b>, etc.) â<b> INTEGRITY5</b> â<b> BLDtarget</b> should be set to</p>
<p>your desired BSP (sim800, for example).</p>
<p>â¢</p>
<p><b>C_CG</b> (or<b> CPP_CG</b>, etc.) â<b> INTEGRITY</b> â<b> IDEInterfaceDLL</b> should be</p>
<p>set to MULTI's DLL (<b>C:\ghs\multi_<i>xxx</i>\rhapsody_multi_ide.dll</b>, for example)</p>
<p>to enable synchronous debugging. This must include a full path.</p>
<p>â¢</p>
<p><b>C_CG</b> (or<b> CPP_CG</b>, etc.) â<b> INTEGRITY5</b> â<b> PrimaryTarget</b> should be</p>
<p>set to an INTEGRITY<b> .tgt</b> file (<b>ppc_integrity.tgt</b>, for example).</p>
<p><i>735</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Additional Notes</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Animated, Source, and Synchronous Debugging</b></p>
<p>Model-level debugging (known as<i> Animation</i>) is covered by the Rhapsody</p>
<p>documentation. By default, it depends upon TCP/IP, and thus requires a TCP/IP</p>
<p>stack on an INTEGRITY target.</p>
<p>Source-level debugging is covered in this book and is a standard capability of the</p>
<p>MULTI environment.</p>
<p>Model-level and source-level debugging can be done independently, and even at</p>
<p>the same time, with only the following constraints on how the image is loaded onto</p>
<p>the target. These constraints apply to synchronized model-level and source-level</p>
<p>debugging only:</p>
<p>â¢</p>
<p>Components must be loaded onto an INTEGRITY target via the<b> Code</b> â</p>
<p><b>Target</b> menu in Rhapsody (for Rhapsody 6.x, see<b> Code</b> â<b> IDE</b>). This allows</p>
<p>Rhapsody to load the image via MULTI and to maintain synchronization of</p>
<p>the two debug environments.</p>
<p>â¢</p>
<p>If you want to reload an image while a model-level session is running, you</p>
<p>must select<b> Code</b> â<b> Stop Execution</b> before reloading or unloading the image;</p>
<p>otherwise the model-level session cannot be run after the reload.</p>
<p><b>Example: Using MULTI 6, INTEGRITY 10, and Rhapsody 7</b></p>
<p>A number of example models are provided with Rhapsody. The following numbered</p>
<p>list illustrates how to configure and build the pingpong example model with MULTI</p>
<p>for an INTEGRITY ISIM ARM target. For more details about how to configure</p>
<p>and use Rhapsody in general, please refer to Rhapsody's user manual.</p>
<p>1.</p>
<p>Build the OXF framework libraries:</p>
<p>From the command line, build the OXF framework libraries for an ISIM ARM</p>
<p>target. Using your particular Compiler and INTEGRITY directories, enter:</p>
<p>&gt; cd Rhapsody\Share\LangCpp</p>
<p>&gt; IntegrityBuild C:\GHS\int<i>xxxx</i> simarm C:\ghs\comp_<i>xxxxxx</i> âtrg arm_integrity.tgt</p>
<p><i>MULTI: Debugging</i></p>
<p><i>736</i></p>
<p><i>Appendix D. Using Third-Party Tools with the MULTI Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>2.</p>
<p>Open the example:</p>
<p>Open the<b> pingpong.rpy</b> model in the</p>
<p><b>Rhapsody\Samples\CppSamples\PingPong</b> directory. Right-click the</p>
<p><b>AnimConfig</b> configuration and select<b> Features</b>.</p>
<p><i>737</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Example: Using MULTI 6, INTEGRITY 10, and Rhapsody 7</i></p>
<h1 style="page-break-before:always; "></h1>
<p>3.</p>
<p>Configure for INTEGRITY:</p>
<p>a.</p>
<p>Under the<b> Settings</b> tab:</p>
<p>i.</p>
<p>Ensure<b> Instrumentation Mode</b> is set to<b> Animation</b>.</p>
<p>ii.</p>
<p>To make timeouts run faster in ISIM, you may select<b> Simulated</b> as</p>
<p>the<b> Time Model</b>.</p>
<p>iii. Set the<b> Environment</b> to<b> INTEGRITY5</b>. (Note that this is the case</p>
<p>even if you are using INTEGRITY 10.)</p>
<p>iv. Ensure<b> Build Set</b> is set to<b> Debug</b>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>738</i></p>
<p><i>Appendix D. Using Third-Party Tools with the MULTI Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p>b.</p>
<p>Under the<b> Properties</b> tab:</p>
<p>i.</p>
<p>Select<b> View All</b>.</p>
<p>ii.</p>
<p>Set<b> CPP_CG</b> â<b> INTEGRITY5</b> â<b> BLDTarget</b> to<b> simarm</b>.</p>
<p>iii. Set<b> CPP_CG</b> â<b> INTEGRITY5</b> â<b> IDEInterfaceDLL</b> to</p>
<p><b>C:\ghs\multi_<i>xxx</i>\rhapsody_multi_ide.dll</b> (specify a full path).</p>
<p>iv. Set<b> CPP_CG</b> â<b> INTEGRITY5</b> â<b> PrimaryTarget</b> to</p>
<p><b>arm_integrity.tgt</b>.</p>
<p>4.</p>
<p>Build the model:</p>
<p>a.</p>
<p>To generate the source code and MULTI build files and to build it, select</p>
<p><b>Code</b> â<b> Generate/Make</b>.</p>
<p>b.</p>
<p>By default, this creates an INTEGRITY Dynamic Download with a single</p>
<p>AddressSpace that encapsulates the pingpong model.</p>
<p>5.</p>
<p>Run the model:</p>
<p>a.</p>
<p>The Dynamic Download can be loaded onto an INTEGRITY target (ISIM)</p>
<p>via MULTI using a standard<b> rtserv2</b> connection. This provides</p>
<p>source-level debugging. If the model is run, it communicates with</p>
<p><i>739</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Example: Using MULTI 6, INTEGRITY 10, and Rhapsody 7</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Rhapsody via TCP/IP. Rhapsody then provides model-level debugging.</p>
<p>Each debugging method is independent and can coexist with the other.</p>
<p>b.</p>
<p>Or, to synchronize the debugging activity, select<b> Code</b> â<b> Target</b> â</p>
<p><b>Connect</b> (then<b> Load</b>, then<b> Run</b>). This allows Rhapsody and MULTI to</p>
<p>coordinate activities. Select the first task listed as<b> no-name</b> in the target</p>
<p>list. This task represents the running model. When attached to it, clicking</p>
<p>the<b> Go</b>/<b>Halt</b> buttons in either environment runs/halts the program at the</p>
<p>source level and at the model level. When a breakpoint in the model is</p>
<p>hit, MULTI navigates to the corresponding source code in the Debugger</p>
<p>window.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>740</i></p>
<p><i>Appendix D. Using Third-Party Tools with the MULTI Debugger</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Appendix E</b></p>
<p><b>Creating Custom Data</b></p>
<p><b>Visualizations</b></p>
<p><b>Contents</b></p>
<p>Using MULTI Data Visualization (.mdv) Files . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>743</p>
<p>Invoking Customized Data Visualizations . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>746</p>
<p>MULTI Data Visualization (.mdv) File Format . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>747</p>
<h1 style="page-break-before:always; "></h1>
<p><i>MULTI data visualization</i> (<b>.mdv</b>) files can be used to create customized views</p>
<p>which display certain types of variables according to your specifications. Depending</p>
<p>upon the types of data you want to display, and your specific settings, these custom</p>
<p>views will be shown in the Data Explorer or<b> Graph View</b> windows. The following</p>
<p>two examples use custom visualizations to define the way data types are displayed.</p>
<p>A linked list using the following structure definition in your source code:</p>
<p>struct ListType {</p>
<p>int value;</p>
<p>struct ListType* next;</p>
<p>}</p>
<p>could be shown in a Data Explorer as:</p>
<p><i>MULTI: Debugging</i></p>
<p><i>742</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>A binary tree using the following structure definition in your source code:</p>
<p>struct TreeNode {</p>
<p>int value;</p>
<p>struct TreeNode *left, *right;</p>
<p>}</p>
<p>could be shown in a<b> Graph View</b> window as:</p>
<p><b>Using MULTI Data Visualization (.mdv) Files</b></p>
<p>You can define a custom data visualization for any data type. (MULTI has built-in</p>
<p>support for certain types of data structures. For information about using MULTI's</p>
<p>built-in visualizations, see âDisplaying Linked Listsâ on page 191.) To use</p>
<p>customized data visualizations, you must first create one or more MULTI data</p>
<p>visualization (<b>.mdv</b>) files and then load them during your debugging session. These</p>
<p>files can contain three kinds of descriptions that are used to create custom data</p>
<p>visualizations:</p>
<p>â¢</p>
<p><i>Data descriptions</i> are the basic building blocks of custom data visualizations.</p>
<p>They describe how MULTI should display variables of a particular type.</p>
<p><i>743</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using MULTI Data Visualization (.mdv) Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><i>Profile descriptions</i> contain a collection of data descriptions, as well as some</p>
<p>basic information about hierarchical relationships and the layout of the</p>
<p>visualization(s) for the variables specified in the data descriptions.</p>
<p>You can create multiple profiles, but only one profile can be<i> active</i> at a time.</p>
<p>Custom visualizations are only available for the variables described in the</p>
<p>active profile or in no profile. (Data descriptions that are not included in a</p>
<p>profile are considered to be part of a global profile that is always accessible.)</p>
<p>You can change profiles easily by using the<b> dvprofile<i> prof_name</b></i> command.</p>
<p>For information about the<b> dvprofile</b> command, see âData Visualization</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI:</i></p>
<p><i>Debugging Command Reference</i> book.</p>
<p>â¢</p>
<p><i>View descriptions</i> specify a configuration of profiles to use for displaying</p>
<p>variables in a<b> Graph View</b> window. These allow you to specify a profile to be</p>
<p>active during evaluation of the view. They also allow you to create a âdual</p>
<p>paneâ display, where selecting an object in the first pane causes a new graph</p>
<p>rooted on that object to be displayed in the second pane, using a different profile</p>
<p>and therefore potentially providing a different view of the data.</p>
<p>Each of these potential components of<b> .mdv</b> files is described in more detail in</p>
<p>âMULTI Data Visualization (.mdv) File Formatâ on page 747, but the following</p>
<p>outline of the basic syntax will provide a context for understanding the descriptions.</p>
<p>(Lines enclosed in square brackets in the following template are optional; the square</p>
<p>brackets are not part of the syntax. The curly brackets, however, are part of the</p>
<p>syntax.)</p>
<p><i>unique_prof_id</i> {</p>
<p>profile_name =<i> prof_name</i></p>
<p>[parent_profile =<i> parent_prof_name</i>]</p>
<p>[default_root =<i> def_root_prof</i>]</p>
<p>[vertical_layout =<i> bool_expr</i>]</p>
<p>[add_siblings_of_root =<i> bool_expr</i>]</p>
<p>data_descriptions {</p>
<p><i>data_desc_name_1</i> {</p>
<p>signature = {&quot;<i>sig1</i>&quot;, &quot;<i>sig2</i>&quot;, ... }</p>
<p>[required_fields = {&quot;<i>field1</i>&quot;, &quot;<i>field2</i>&quot;, ... }]</p>
<p>type = &quot;<i>data_desc_type</i>&quot;</p>
<p>[predicate = &quot;<i>pred</i>&quot;]</p>
<p>[<i>required and optional fields depending on type</i>]...</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>}</p>
<p><i>MULTI: Debugging</i></p>
<p><i>744</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p><i>unique_view_id</i> {</p>
<p>initial_pane = &quot;<i>pane_name</i>&quot;</p>
<p>default_root = &quot;<i>def_root_view</i>&quot;</p>
<p>[tab_name = &quot;<i>tab</i>&quot;]</p>
<p>panes {</p>
<p><i>pane_name1</i> {</p>
<p>profile_name = &quot;<i>prof_name1</i>&quot;</p>
<p>[child_pane = &quot;<i>child_pane_name1</i>&quot;]</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>}</p>
<p>For an example<b> .mdv</b> file, see â.mdv File Examplesâ on page 770.</p>
<p><b>Loading and Clearing MULTI Data Visualization (.mdv) Files</b></p>
<p>To make the data descriptions, profiles, and views that you have defined available</p>
<p>in the Debugger, you must load your<b> .mdv</b> file(s) by entering the following command</p>
<p>in the Debugger command pane:</p>
<p><b>dvload<i></b> filename</i></p>
<p>where</p>
<p><i>filename</i></p>
<p>is the name of a custom MULTI data visualization (<b>.mdv</b>) file.</p>
<p>You can load multiple<b> .mdv</b> files by issuing this command repeatedly, once for</p>
<p>each file you want to load. If the file is specified with a relative path, MULTI</p>
<p>searches for it in the user configuration directory, then in the Compiler installation's</p>
<p>configuration directory, and finally in the IDE installation's configuration directory.</p>
<p>All of the data descriptions, profile descriptions, and view descriptions included in</p>
<p>all loaded<b> .mdv</b> files will be available during your MULTI session, but will not</p>
<p>persist across re-launches. However, only those data descriptions contained in the</p>
<p>active profile or in no profile will be accessible for viewing, and only one profile</p>
<p>can be active at a time. These are the data descriptions that MULTI will match your</p>
<p>program data against when selecting data to be displayed in your custom view.</p>
<p>(You can change the active profile to any profile in a loaded<b> .mdv</b> file by issuing</p>
<p>the<b> dvprofile<i> prof_name</b></i> command. See âProfile Descriptionsâ on page 766.)</p>
<p>To clear MULTI data visualization files you have loaded, use the following</p>
<p>command:</p>
<p><b>dvclear</b></p>
<p><i>745</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Loading and Clearing MULTI Data Visualization (.mdv) Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>This command clears all loaded data descriptions.</p>
<p><b>Invoking Customized Data Visualizations</b></p>
<p>Most types of data descriptions are used to describe how a type should be displayed</p>
<p>in Data Explorers and by the<b> print</b> command (see Chapter 8, âDisplay and Print</p>
<p>Command Referenceâ in the<i> MULTI: Debugging Command Reference</i> book). These</p>
<p>data descriptions are used automatically when a variable matching the data</p>
<p>description is viewed in a Data Explorer, or printed in the Debugger command pane.</p>
<p>The</p>
<p>graph</p>
<p>data description type, on the other hand, describes how to display a</p>
<p>graphical representation of the variable in a<b> Graph View</b> window (see âThe Graph</p>
<p>View Windowâ on page 247). Data descriptions with the</p>
<p>use_for_print_and_view</p>
<p>field set to</p>
<p>false</p>
<p>are also not used when viewing a</p>
<p>variable in a Data Explorer or printing to the Debugger command pane. They are</p>
<p>typically used to define containers that are used in</p>
<p>graph</p>
<p>data description types.</p>
<p>For example, the children of a node can be specified in a container, which would</p>
<p>need a corresponding data description.</p>
<p>For information about how MULTI matches a data description to a variable, see</p>
<p>âData Descriptionsâ on page 747.</p>
<p>To view the graphical representation of data for which you have</p>
<p>graph</p>
<p>data</p>
<p>descriptions, use one of the following methods:</p>
<p>â¢</p>
<p>Right-click a variable and select<b> Graph Data</b> from the shortcut menu that</p>
<p>appears. If you have right-clicked a variable matching a</p>
<p>graph</p>
<p>data description,</p>
<p>MULTI will create a graph of objects based on the data description, and display</p>
<p>it in a<b> Graph View</b> window. The graph will be rooted on the clicked variable.</p>
<p>If no data description is found for the variable's type, the text of the node will</p>
<p>be the output of<b> print<i> variable</b></i>.</p>
<p>â¢</p>
<p>Right-click in the Debugger source pane and select<b> Display Program</b></p>
<p><b>Visualizations</b> or enter the command<b> dataview</b> in the Debugger command</p>
<p>pane (see âData Visualization Commandsâ in Chapter 22, âView Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book). This will</p>
<p>display a graph with one tab for each defined custom<i> view description</i>, using</p>
<p>the default root and profile specified for each view.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>746</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Enter the following command in the Debugger command pane:</p>
<p><b>dataview<i></b> prof_name</i> |<i> view_name</i></p>
<p>This will open a graph displaying the specified profile (</p>
<p><i>prof_name</i></p>
<p>) or view</p>
<p>(</p>
<p><i>view_name</i></p>
<p>). The graph will use the default root (</p>
<p><i>def_root_prof</i></p>
<p>or</p>
<p><i>def_root_view</i></p>
<p>) specified in the profile or view description.</p>
<p><b>MULTI Data Visualization (.mdv) File Format</b></p>
<p>A MULTI data visualization (<b>.mdv</b>) file can contain data descriptions, profile</p>
<p>descriptions, and/or view descriptions. MULTI uses the information in these</p>
<p>descriptions to filter which data to display and to format custom visualizations of</p>
<p>the filtered data according to your specifications. The sections below give the exact</p>
<p>syntax for each of these types of descriptions.</p>
<p><b>Note</b></p>
<p>Many of the fields used to describe data types, profiles, and views in</p>
<p><b>.mdv</b> files take expressions. See âUsing Expressions in MULTI Data</p>
<p>Visualization (.mdv) Filesâ on page 770 for information about valid</p>
<p>expressions.</p>
<p><b>Data Descriptions</b></p>
<p>Data descriptions describe how data is accessed for a particular type. A data</p>
<p>description has the following format (lines enclosed in square brackets are optional;</p>
<p>the square brackets are not part of the syntax, but the curly brackets are):</p>
<p><i>data_desc_name</i> {</p>
<p>signature = {&quot;<i>sig1</i>&quot;, &quot;<i>sig2</i>&quot;, ... }</p>
<p>[required_fields = {&quot;<i>field1</i>&quot;, &quot;<i>field2</i>&quot;, ... }]</p>
<p>type = &quot;<i>data_desc_type</i>&quot;</p>
<p>[predicate = &quot;<i>pred</i>&quot;]</p>
<p>[<i>required and optional fields depending on type</i>]</p>
<p>}</p>
<p>The meaning of the elements in this format are described in the following table.</p>
<p><i>747</i></p>
<p><i>Green Hills Software</i></p>
<p><i>MULTI Data Visualization (.mdv) File Format</i></p>
<h1 style="page-break-before:always; "></h1>
<p><i>data_desc_name</i></p>
<p>Uniquely identifies the data description. Data descriptions with the same name will overwrite</p>
<p>each other.</p>
<p>signature = {&quot;<i>sig1</i>&quot;, &quot;<i>sig2</i>&quot;, ... }</p>
<p>Specifies the signature or signatures (</p>
<p><i>sig1</i></p>
<p>,</p>
<p><i>sig2</i></p>
<p>, etc.) of the data type being described in the</p>
<p>data description. The signature is used to match against the type of a variable, to determine</p>
<p>whether the data description should be used for the variable. Wildcards can be used when</p>
<p>matching. For example, to match an STL list, use the format:</p>
<p>signature = {&quot;std::list&lt;*&gt;&quot;}</p>
<p>To match objects or pointers of either type</p>
<p>DeviceType1</p>
<p>or</p>
<p>DeviceType2</p>
<p>, use the format:</p>
<p>signature = {&quot;DeviceType1&quot;, &quot;DeviceType2&quot;}</p>
<p>Variables are always cast to derived types and dereferenced before being used in a data</p>
<p>description.</p>
<p>This field is required.</p>
<p>required_fields = {&quot;<i>field1</i>&quot;, &quot;<i>field2</i>&quot;, ... }</p>
<p>Specifies a list of fields (</p>
<p><i>field1</i></p>
<p>,</p>
<p><i>field2</i></p>
<p>, etc.) that must be present in the type to match this</p>
<p>data description. This line is not required, but specifying required fields can be useful for sanity</p>
<p>checking.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>748</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>type = &quot;<i>data_desc_type</i>&quot;</p>
<p>Specifies what type of data description is being defined, where</p>
<p><i>data_desc_type</i></p>
<p>is one of the</p>
<p>following:</p>
<p>â¢</p>
<p>container</p>
<p>â¢</p>
<p>list</p>
<p>â¢</p>
<p>null_terminated_list</p>
<p>â¢</p>
<p>circular_list</p>
<p>â¢</p>
<p>binary_tree</p>
<p>â¢</p>
<p>structure</p>
<p>â¢</p>
<p>alias</p>
<p>â¢</p>
<p>singleton</p>
<p>â¢</p>
<p>function_definer</p>
<p>â¢</p>
<p>graph</p>
<p>See âData Description Types and Their Type-Specific Fieldsâ on page 750 for more information</p>
<p>about each data type.</p>
<p>This field is required.</p>
<p>predicate = &quot;<i>pred</i>&quot;</p>
<p>Specifies a predicate expression to determine whether the data description should be used. For</p>
<p>example, if this data description should only be used when the</p>
<p>value</p>
<p>field of the struct is 0,</p>
<p>the predicate line of the description would be:</p>
<p>predicate = &quot;return self.value == 0&quot;</p>
<p>Specifying a predicate is optional.</p>
<p><i>required and optional fields depending on type</i></p>
<p>Specifies required and optional fields according to the type of data description. See the following</p>
<p>sections for a description of the required and optional fields for each data type.</p>
<p>When checking whether a data description matches the variable, MULTI first casts</p>
<p>the variable to its derived type. Then MULTI compares the type name to the</p>
<p>signature</p>
<p>entries in the data description. If the type name matches, MULTI checks</p>
<p>that all fields listed in</p>
<p>required_fields</p>
<p>are present in the structure, and then</p>
<p>evaluates the</p>
<p>predicate</p>
<p>expression, if any. If the type matches the</p>
<p>signature</p>
<p>,</p>
<p>required_fields</p>
<p>, and the</p>
<p>predicate</p>
<p>expression returns</p>
<p>true</p>
<p>, the data</p>
<p>description is used to display that type.</p>
<p><i>749</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Data Description Types and Their Type-Specific Fields</b></p>
<p>The available data types are described in the sections below, along with the required</p>
<p>and optional data description fields for each.</p>
<p>The container Data Type</p>
<p>The</p>
<p>container</p>
<p>type is used to describe a type which is a container of elements,</p>
<p>such as a list, vector, or map. A data description for a container includes information</p>
<p>about how to create an<i> iterator</i> for the container, how to walk the iterator through</p>
<p>the container, and how to retrieve a value from the iterator at each step. An iterator</p>
<p>is a value that represents a position in the container. For example, for a linked list,</p>
<p>the iterator might be the address of a node.</p>
<p><b>Tip</b></p>
<p>If extra information about the parent structure is needed by an iterator,</p>
<p>set a MULTI special variable to contain this information in the</p>
<p>begin_iter</p>
<p>expression (see below).</p>
<p>An example of a</p>
<p>container</p>
<p>data description for an STL list is shown below.</p>
<p>list {</p>
<p>signature = {&quot;list&lt;*&gt;&quot;, &quot;std::list&lt;*&gt;&quot;}</p>
<p>required_fields = {&quot;_Mysize&quot;, &quot;_Myhead&quot;}</p>
<p>type = &quot;container&quot;</p>
<p>size = &quot;return self._Mysize;&quot;</p>
<p>begin_iter = &quot;return self._Myhead._Next;&quot;</p>
<p>next_iter = &quot;return self._Next;&quot;</p>
<p>value_from_iter = &quot;return self._Myval;&quot;</p>
<p>}</p>
<p>The type-specific fields for the</p>
<p>container</p>
<p>data description type are described in</p>
<p>the following table.</p>
<p>size = &quot;<i>size_expr</i>&quot;</p>
<p>Specifies an expression,</p>
<p><i>size_expr</i></p>
<p>, that returns an integer value that equals the number of</p>
<p>elements in the container.</p>
<p>This field is required.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>750</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>begin_iter = &quot;<i>begin_iter_expr</i>&quot;</p>
<p>Specifies an expression,</p>
<p><i>begin_iter_expr</i></p>
<p>, that returns some representation of a beginning</p>
<p>iterator over the container. For example, a list data description might return a pointer to the first</p>
<p>list node. A vector might return an index to the first element.</p>
<p>This field is required.</p>
<p>next_iter = &quot;<i>next_iter_expr</i>&quot;</p>
<p>Specifies an expression,</p>
<p><i>next_iter_expr</i></p>
<p>, that is used to retrieve the next iterator from the</p>
<p>current iterator. In this expression, the</p>
<p>self</p>
<p>variable refers to the current iterator, not to the</p>
<p>original structure.</p>
<p>For example, for a list, this line might be:</p>
<p>next_iter = &quot;return self.next&quot;</p>
<p>This field is required.</p>
<p>value_from_iter = &quot;<i>value_from_iter_expr</i>&quot;</p>
<p>Specifies an expression,</p>
<p><i>value_from_iter_expr</i></p>
<p>, that is used to retrieve the element value</p>
<p>from the current iterator. In this expression, the</p>
<p>self</p>
<p>variable refers to the current iterator, not</p>
<p>the original structure.</p>
<p>For example, for a list, this line might be:</p>
<p>value_from_iter = &quot;return self.value&quot;</p>
<p>This field is required.</p>
<p>use_for_print_and_view =<i> bool_expr</i></p>
<p>Specifies whether the data description should be used for displaying the type in Data Explorers</p>
<p>and when printing, where</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>Defining this field is optional. It defaults to</p>
<p>true</p>
<p>, which causes the graph description to be used</p>
<p>for graph views and print views. In most situations, this setting should not be changed; however,</p>
<p>there may be times when you need to set up a container data description to support another data</p>
<p>description (particularly in</p>
<p>graph</p>
<p>data descriptions), but do not want the container to display</p>
<p>in a Data Explorer.</p>
<p>The list Data Type</p>
<p>The</p>
<p>list</p>
<p>type is a specialized type of container used to describe C-style lists. The</p>
<p>list is made up of structures that are both list nodes and elements, each connected</p>
<p>to its successor by a<i> next</i> pointer. This type of data description is useful for lists</p>
<p>that rely on a termination condition, rather than a size parameter.</p>
<p><i>751</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For example, consider code using the following structure definition:</p>
<p>struct ListType {</p>
<p>int value;</p>
<p>struct ListType *next;</p>
<p>};</p>
<p>struct ListType EndOfListNode;</p>
<p>To view a</p>
<p>ListType</p>
<p>variable as a list instead of simply a structure with a</p>
<p>next</p>
<p>pointer, you could use the following data description:</p>
<p>ListTypeDataDescription {</p>
<p>signature = {&quot;ListType&quot;}</p>
<p>required_fields = {&quot;value&quot;, &quot;next&quot;}</p>
<p>type = &quot;list&quot;</p>
<p>next = &quot;next&quot;</p>
<p>termination_condition = &quot;return &amp;self == &amp;EndOfListNode&quot;</p>
<p>}</p>
<p>The type-specific fields for data descriptions for lists are described in the table</p>
<p>below.</p>
<p>next = &quot;<i>next_field_name</i>&quot;</p>
<p>Specifies</p>
<p><i>next_field_name</i></p>
<p>as the field within the type that points to the next element in the</p>
<p>list.</p>
<p>This line is required.</p>
<p>termination_condition = &quot;<i>term_condition_expr</i>&quot;</p>
<p>Specifies the expression</p>
<p><i>term_condition_expr</i></p>
<p>as the condition that ends the list.</p>
<p>This field is required.</p>
<p>use_for_print_and_view =<i> bool_expr</i></p>
<p>Specifies whether the data description should be used for displaying the type in Data Explorers</p>
<p>and when printing, where</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>Defining this field is optional. It defaults to</p>
<p>true</p>
<p>, which causes the graph description to be used</p>
<p>for graph views and print views. In most situations, this setting should not be changed; however,</p>
<p>there may be times when you need to set up a container data description to support another data</p>
<p>description (particularly in</p>
<p>graph</p>
<p>data descriptions), but do not want the container to display</p>
<p>in a Data Explorer.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>752</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The null_terminated_list Data Type</p>
<p>The</p>
<p>null_terminated_list</p>
<p>type is a specialized type of list used to describe</p>
<p>standard C-style null-terminated lists.</p>
<p>For example, consider code using the following structure definition:</p>
<p>struct NullTerminatedListType {</p>
<p>int value;</p>
<p>struct NullTerminatedListType *next;</p>
<p>};</p>
<p>To view a</p>
<p>NullTerminatedListType</p>
<p>variable as a list instead of simply a structure</p>
<p>with a</p>
<p>next</p>
<p>pointer, you could use the following data description:</p>
<p>NullTerminatedListTypeDataDescription {</p>
<p>signature = {&quot;NullTerminatedListType&quot;}</p>
<p>required_fields = {&quot;value&quot;, &quot;next&quot;}</p>
<p>type = &quot;null_terminated_list&quot;</p>
<p>next = &quot;next&quot;</p>
<p>}</p>
<p>The type-specific fields for data descriptions for null-terminated lists are described</p>
<p>in the table below.</p>
<p>next = &quot;<i>next_field_name</i>&quot;</p>
<p>Specifies</p>
<p><i>next_field_name</i></p>
<p>as the field within the type that points to the next element in the</p>
<p>list.</p>
<p>This line is required.</p>
<p>use_for_print_and_view =<i> bool_expr</i></p>
<p>Specifies whether the data description should be used for displaying the type in Data Explorers</p>
<p>and when printing, where</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>Defining this field is optional. It defaults to</p>
<p>true</p>
<p>, which causes the graph description to be used</p>
<p>for graph views and print views. In most situations, this setting should not be changed; however,</p>
<p>there may be times when you need to set up a container data description to support another data</p>
<p>description (particularly in</p>
<p>graph</p>
<p>data descriptions), but do not want the container to display</p>
<p>in a Data Explorer.</p>
<p><i>753</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The circular_list Data Type</p>
<p>The</p>
<p>circular_list</p>
<p>type is a specialized type of list used to describe C-style</p>
<p>circular lists (i.e., lists in which the end is discovered by returning to an element</p>
<p>that has already been seen).</p>
<p>For example, consider code using the following structure definition:</p>
<p>struct CircularListType {</p>
<p>int value;</p>
<p>struct ListType *next;</p>
<p>};</p>
<p>To view a</p>
<p>CircularListType</p>
<p>variable as a list instead of simply a structure with</p>
<p>a</p>
<p>next</p>
<p>pointer, you could use the following data description:</p>
<p>CircularListTypeDataDescription {</p>
<p>signature = {&quot;CircularListType&quot;}</p>
<p>required_fields = {&quot;value&quot;, &quot;next&quot;}</p>
<p>type = &quot;circular_list&quot;</p>
<p>next = &quot;next&quot;</p>
<p>}</p>
<p>The type-specific fields for data descriptions for circular lists are described in the</p>
<p>table below.</p>
<p>next = &quot;<i>next_field_name</i>&quot;</p>
<p>Specifies</p>
<p><i>next_field_name</i></p>
<p>as the field within the type that points to the next element in the</p>
<p>list.</p>
<p>This line is required.</p>
<p>use_for_print_and_view =<i> bool_expr</i></p>
<p>Specifies whether the data description should be used for displaying the type in Data Explorers</p>
<p>and when printing, where</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>Defining this field is optional. It defaults to</p>
<p>true</p>
<p>, which causes the graph description to be used</p>
<p>for graph views and print views. In most situations, this setting should not be changed; however,</p>
<p>there may be times when you need to set up a container data description to support another data</p>
<p>description (particularly in</p>
<p>graph</p>
<p>data descriptions), but do not want the container to display</p>
<p>in a Data Explorer.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>754</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The binary_tree Data Type</p>
<p>The</p>
<p>binary_tree</p>
<p>type is used to describe a type of container used to describe a</p>
<p>binary tree structure. The tree is traversed in order â first the</p>
<p>left</p>
<p>subtree is</p>
<p>traversed, then the value of the node is displayed, then finally the</p>
<p>right</p>
<p>subtree is</p>
<p>traversed.</p>
<p>For example, consider code using the following structure definition:</p>
<p>struct TreeNode {</p>
<p>int value;</p>
<p>struct TreeNode *left, *right;</p>
<p>}</p>
<p>To view a</p>
<p>TreeNode</p>
<p>variable as an in-order list of elements rather than simply as</p>
<p>a structure, you could use the following data description:</p>
<p>TreeNodeDataDescription {</p>
<p>signature = {&quot;TreeNode&quot;}</p>
<p>required_fields = {&quot;value&quot;, &quot;left&quot;, &quot;right&quot;}</p>
<p>type = &quot;binary_tree&quot;</p>
<p>left = &quot;left&quot;</p>
<p>right = &quot;right&quot;</p>
<p>}</p>
<p>The type-specific fields for data descriptions for binary trees are described in the</p>
<p>following table.</p>
<p>left = &quot;<i>left_field_name</i>&quot;</p>
<p>Specifies</p>
<p><i>left_field_name</i></p>
<p>as the field representing the left child pointer.</p>
<p>This field is required.</p>
<p>right = &quot;<i>right_field_name</i>&quot;</p>
<p>Specifies</p>
<p><i>right_field_name</i></p>
<p>as the field representing the right child pointer.</p>
<p>This field is required.</p>
<p><i>755</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>use_for_print_and_view =<i> bool_expr</i></p>
<p>Specifies whether the data description should be used for displaying the type in Data Explorers</p>
<p>and when printing, where</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>Defining this field is optional. It defaults to</p>
<p>true</p>
<p>, which causes the graph description to be used</p>
<p>for graph views and print views. In most situations, this setting should not be changed; however,</p>
<p>there may be times when you need to set up a container data description to support another data</p>
<p>description (particularly in</p>
<p>graph</p>
<p>data descriptions), but do not want the container to display</p>
<p>in a Data Explorer.</p>
<p>The structure Data Type</p>
<p>The</p>
<p>structure</p>
<p>type is used to describe a list of artificial fields that can be viewed</p>
<p>for the data type. The data type is seen as a structure containing the fields defined</p>
<p>in the</p>
<p>structure</p>
<p>data description.</p>
<p>The syntax for the</p>
<p>structure</p>
<p>type data description follows (lines enclosed in</p>
<p>square brackets are optional; the square brackets are not part of the syntax, but the</p>
<p>curly brackets are):</p>
<p><i>data_desc_name</i> {</p>
<p>signature = {&quot;<i>sig1</i>&quot;, &quot;<i>sig2</i>&quot;, ... }</p>
<p>[required_fields = {&quot;<i>field1</i>&quot;, &quot;<i>field2</i>&quot;, ... }]</p>
<p>type = &quot;<i>structure</i>&quot;</p>
<p>[predicate = &quot;<i>pred</i>&quot;]</p>
<p>fields {</p>
<p>field1{</p>
<p>name =<i> name_string</i></p>
<p>value = &quot;<i>value_expr</i>&quot;</p>
<p>mutable =<i> bool_expr</i></p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>}</p>
<p>An example of a</p>
<p>structure</p>
<p>data description for an STL list iterator is shown</p>
<p>below.</p>
<p>list_iterator {</p>
<p>signature = {&quot;list&lt;*&gt;::*iterator&quot;}</p>
<p>required_fields = {&quot;_Ptr&quot;}</p>
<p><i>MULTI: Debugging</i></p>
<p><i>756</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>type = &quot;structure&quot;</p>
<p>predicate = &quot;return self._Ptr != 0&quot;</p>
<p>fields {</p>
<p>next {</p>
<p>name = &quot;_Next&quot;</p>
<p>value = &quot;return self._Ptr-&gt;_Next&quot;</p>
<p>}</p>
<p>prev {</p>
<p>name = &quot;_Prev&quot;</p>
<p>value = &quot;return self._Ptr-&gt;_Prev&quot;</p>
<p>}</p>
<p>value {</p>
<p>name = &quot;_Myval&quot;</p>
<p>value = &quot;return self._Ptr-&gt;_Myval&quot;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The type-specific fields for data descriptions for structures are described in the table</p>
<p>below.</p>
<p>field1</p>
<p>A unique identifier for the field description.</p>
<p>name = &quot;<i>name_string</i>&quot;</p>
<p>Specifies</p>
<p><i>name_string</i></p>
<p>as the name of the artificial field you are creating. This name must not</p>
<p>contain any whitespace.</p>
<p>This field is required.</p>
<p>value = &quot;<i>value_expr</i>&quot;</p>
<p>Specifies the expression,</p>
<p><i>value_expr</i></p>
<p>, as the value to be displayed for the field.</p>
<p>This field is required.</p>
<p>mutable =<i> bool_expr</i></p>
<p>Specifies whether the value can be edited in Data Explorer windows, where</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>Defining this field is optional. It defaults to</p>
<p>true</p>
<p>, which allows the values to be edited.</p>
<p><i>757</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The alias Data Type</p>
<p>The</p>
<p>alias</p>
<p>type is used to specify that one type should be viewed as if it were a</p>
<p>different type.</p>
<p>An example of an</p>
<p>alias</p>
<p>data description for an STL string is shown next. This</p>
<p>data description causes an STL string to be displayed as its underlying C-style string.</p>
<p>string {</p>
<p>signature = {&quot;basic_string&lt;*&gt;&quot;}</p>
<p>required_fields = {&quot;_Bx&quot;, &quot;_Myres&quot;}</p>
<p>type = &quot;alias&quot;</p>
<p>value</p>
<p>= &quot;if (_BUF_SIZE &lt;= self._Myres) {&quot;</p>
<p>value += &quot;</p>
<p>return self._Bx._Ptr;&quot;</p>
<p>value += &quot;} else {&quot;</p>
<p>value += &quot;</p>
<p>return self._Bx._Buf;&quot;</p>
<p>value += &quot;}&quot;</p>
<p>mutable = false;</p>
<p>}</p>
<p>The type-specific fields for data descriptions for aliases are described in the table</p>
<p>below.</p>
<p>value = &quot;<i>val_expr</i>&quot;</p>
<p>Specifies that the result of the expression</p>
<p><i>val_expr</i></p>
<p>will be displayed in place of the actual</p>
<p>value of the item matching this data description.</p>
<p>This field is required.</p>
<p>mutable =<i> bool_expr</i></p>
<p>Specifies whether the value can be edited in Data Explorer windows, where</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>Defining this field is optional. It defaults to</p>
<p>true</p>
<p>, which allows the value to be edited.</p>
<p>replace_self =<i> bool_expr</i></p>
<p>Specifies whether the variable being viewed is replaced with the result of the expression specified</p>
<p>by the line</p>
<p>value = &quot;<i>val_expr</i>&quot;</p>
<p>. The argument</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>. If</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>true</p>
<p>, the variable being viewed is replaced with the result of</p>
<p><i>val_expr</i></p>
<p>. If</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>false</p>
<p>, the result of</p>
<p><i>val_expr</i></p>
<p>is used as the value of the variable, but the original</p>
<p>variable's type is still displayed.</p>
<p>Defining this field is optional. It defaults to</p>
<p>false</p>
<p>.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>758</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The singleton Data Type</p>
<p>The</p>
<p>singleton</p>
<p>type is used to specify a data type that should be viewed as a</p>
<p>singleton type. Since the data type is a singleton, only one instance of it is ever</p>
<p>created. Specifying a data description for the singleton allows you to view the</p>
<p>instance of the data type by viewing the type.</p>
<p>For example, a</p>
<p>singleton</p>
<p>data description for the following type:</p>
<p>class SingletonClass {</p>
<p>private:</p>
<p>SingletonClass();</p>
<p>static SingletonClass* instance;</p>
<p>public:</p>
<p>static SingletonClass* getInstance() {</p>
<p>if (!instance)</p>
<p>instance = new SingletonClass;</p>
<p>return instance;</p>
<p>}</p>
<p>};</p>
<p>would be:</p>
<p>singleton_class {</p>
<p>signature = {&quot;SingletonClass&quot;}</p>
<p>type = &quot;singleton&quot;</p>
<p>instance = &quot;SingletonClass::instance&quot;</p>
<p>}</p>
<p>This data description would allow you to see the singleton instance of the class by</p>
<p>viewing the class type. There is only one type-specific field for data descriptions</p>
<p>for singletons, which is described in the table below.</p>
<p>instance = &quot;<i>variable_name</i>&quot;</p>
<p>Specifies</p>
<p><i>variable_name</i></p>
<p>as the instance variable of the type. This must be a valid variable</p>
<p>identifier.</p>
<p>This field is required.</p>
<p><i>759</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The function_definer Data Type</p>
<p>The</p>
<p>function_definer</p>
<p>type is used to define macros that can be called from the</p>
<p>Debugger command line as if they were member functions of the data type.</p>
<p>The syntax for the</p>
<p>function_definer</p>
<p>data description follows (lines enclosed</p>
<p>in square brackets are optional; the square brackets are not part of the syntax, but</p>
<p>the curly brackets are):</p>
<p><i>data_desc_name</i> {</p>
<p>signature = {&quot;<i>sig1</i>&quot;, &quot;<i>sig2</i>&quot;, ... }</p>
<p>[required_fields = {&quot;<i>field1</i>&quot;, &quot;<i>field2</i>&quot;, ... }]</p>
<p>type = &quot;<i>function_definer</i>&quot;</p>
<p>[predicate = &quot;<i>pred</i>&quot;]</p>
<p>functions {</p>
<p><i>unique_name</i> {</p>
<p>name = &quot;<i>name_string</i>&quot;</p>
<p>[arguments = {&quot;<i>arg_string1</i>&quot;, &quot;<i>arg_string2</i>&quot;, ...}]</p>
<p>body = &quot;<i>body_expr</i>&quot;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><b>Note</b></p>
<p>The</p>
<p>functions</p>
<p>block shown above can also be added to any of the other</p>
<p>data description types (except</p>
<p>graph</p>
<p>), rather than being placed in a</p>
<p>function_definer</p>
<p>type.</p>
<p>A sample</p>
<p>function_definer</p>
<p>data description for an STL list is shown next.</p>
<p>list_funcs {</p>
<p>signature = {&quot;list&lt;*&gt;&quot;}</p>
<p>required_fields = {&quot;_Mysize&quot;, &quot;_Myhead&quot;}</p>
<p>type = &quot;function_definer&quot;</p>
<p>functions {</p>
<p>size {</p>
<p>name = &quot;size&quot;</p>
<p>body = &quot;return self._Mysize&quot;</p>
<p>}</p>
<p><i>MULTI: Debugging</i></p>
<p><i>760</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>front {</p>
<p>name = &quot;front&quot;</p>
<p>body = &quot;return self._Myhead-&gt;_Next-&gt;_Myval&quot;</p>
<p>}</p>
<p>back {</p>
<p>name = &quot;back&quot;</p>
<p>body = &quot;return self._Myhead-&gt;_Prev-&gt;_Myval&quot;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The type-specific fields for data descriptions for function definers are described in</p>
<p>the table below.</p>
<p><i>unique_name</i></p>
<p>A unique name for the function entry.</p>
<p>name = &quot;<i>name_string</i>&quot;</p>
<p>Specifies the string</p>
<p><i>name_string</i></p>
<p>as the name of the function. For example, if the name is</p>
<p>size</p>
<p>, then the function can be called by</p>
<p>obj.size()</p>
<p>.</p>
<p>This field is required.</p>
<p>arguments = {&quot;<i>arg_string1</i>&quot;, &quot;<i>arg_string2</i>&quot;, ...}</p>
<p>Specifies additional arguments (</p>
<p><i>arg_string1</i>,<i> arg_string2</i>, ...</p>
<p>) to the function. Like</p>
<p>C++ class member functions, there is always one implicit argument to the</p>
<p>functionâ</p>
<p>self</p>
<p>âwhich contains a pointer to the object being referenced (taking the place of</p>
<p>the</p>
<p>this</p>
<p>parameter in C++).</p>
<p>This line is optional.</p>
<p>body = &quot;<i>body_expr</i>&quot;</p>
<p>Specifies an expression,</p>
<p><i>body_expr</i></p>
<p>, that is evaluated when the function is called.</p>
<p>This field is required.</p>
<p>The graph Data Type</p>
<p>The</p>
<p>graph</p>
<p>type is used to describe a data type that should be displayed graphically</p>
<p>in a<b> Graph View</b> window. The data description defines how a data type will be</p>
<p>represented in nodes in a graph, and contains information about the text that should</p>
<p>appear in the nodes, the children of the nodes, and the parents of the nodes.</p>
<p><i>761</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Consider the following type:</p>
<p>class Device {</p>
<p>public:</p>
<p>const char* deviceName;</p>
<p>int deviceId;</p>
<p>Device(const char *name, const int id);</p>
<p>void addInputBus(Bus* input);</p>
<p>void addOutputBus(Bus* output);</p>
<p>protected:</p>
<p>std::list&lt;Bus*&gt; inputs;</p>
<p>std::list&lt;Bus*&gt; outputs;</p>
<p>};</p>
<p>This type might have the following data description:</p>
<p>device {</p>
<p>signature = {&quot;Device&quot;}</p>
<p>type = &quot;graph&quot;</p>
<p>node_text = &quot;mprintf(\&quot;%s\nDevice ID: %d\&quot;, self.deviceName, self.deviceId)&quot;</p>
<p>children {</p>
<p>outputs {</p>
<p>value = &quot;return self.outputs&quot;</p>
<p>is_container = true</p>
<p>}</p>
<p>}</p>
<p>parents {</p>
<p>inputs {</p>
<p>value = &quot;return self.inputs&quot;</p>
<p>is_container = true</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>See â.mdv File Examplesâ on page 770 for a complete example of the</p>
<p>graph</p>
<p>data</p>
<p>description.</p>
<p>The type-specific fields for data descriptions for graphs are described in the following</p>
<p>table.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>762</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>replace_with = &quot;<i>repl_node_expr</i>&quot;</p>
<p>Specifies a value,</p>
<p><i>repl_node_expr</i></p>
<p>, to replace (in<b> Graph View</b>) the node being defined. If</p>
<p>this line is present, all other fields in the data description are ignored. The node being defined</p>
<p>will not show up in the graph, but will instead be replaced by a node representing the value</p>
<p>returned by the expression</p>
<p><i>repl_node_expr</i></p>
<p>.</p>
<p>To make a node not show up at all, use the line:</p>
<p>replace_with = &quot;return (void*) 0&quot;</p>
<p>This field is optional.</p>
<p>node_text = &quot;<i>commands</i>&quot;</p>
<p>Specifies one or more MULTI commands, separated by semicolons, that generate output which</p>
<p>will appear on the node being defined. Commands that can be used for output include<b> echo</b>,</p>
<p><b>print</b>, and<b> mprintf</b>. Any textual output from these commands will be captured and displayed</p>
<p>in the node.</p>
<p>This field is required.</p>
<p>vertical_layout =<i> bool_expr</i></p>
<p>Specifies whether the graph should use a vertically-oriented layout or a horizontally-oriented</p>
<p>layout, where</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>. If</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>true</p>
<p>, the graph will use a</p>
<p>vertically-oriented layout.</p>
<p>This field is optional and defaults to</p>
<p>false</p>
<p>. This field can be set on a profile-by-profile basis</p>
<p>(see âProfile Descriptionsâ on page 766).</p>
<p>children {</p>
<p><i>child_name</i> {</p>
<p>value = &quot;<i>child_val_expr</i>&quot;</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>Specifies information about the node's children. Each child must have a unique name,</p>
<p><i>child_name</i></p>
<p>, but the number of children is unlimited.</p>
<p>For more information about the syntax and fields for describing children, see the next section.</p>
<p>Specifying children is optional.</p>
<p><i>763</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>parents {</p>
<p><i>parent_name</i> {</p>
<p>value = &quot;<i>parent_val_expr</i>&quot;</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>Specifies information about the node's parents. Each parent must have a unique name,</p>
<p><i>parent_name</i></p>
<p>.</p>
<p>If an edge is specified by both the parent and the child, it will only appear once. This provides</p>
<p>an easy mechanism for describing complex graphs without having to worry about duplication.</p>
<p>For more information about the syntax and fields for describing parents, see the next section.</p>
<p>Specifying parents is optional.</p>
<p>next_sibling = &quot;<i>sibl_expr</i>&quot;</p>
<p>Specifies information about the node's siblings, where</p>
<p><i>sibl_expr</i></p>
<p>is an expression.</p>
<p>Siblings are laid out orthogonally to the primary layout orientation. If the graph is horizontally</p>
<p>oriented, siblings will be connected vertically. This provides a convenient way to display data</p>
<p>in a list of trees. There can be at most one sibling edge entering a node, and one sibling edge</p>
<p>leaving a node.</p>
<p>Specifying siblings is optional.</p>
<p>max_display_size =<i> int</i></p>
<p>Specifies the maximum number,</p>
<p><i>int</i></p>
<p>, of siblings displayed in a chain.</p>
<p>This field is optional and defaults to 20, meaning that if you have a list being displayed as</p>
<p>siblings, it will get cut off after the twentieth element.</p>
<p>Describing Parents and Children of the Node</p>
<p>The core functionality of the</p>
<p>graph</p>
<p>type is describing children and parents of a</p>
<p>node. The</p>
<p>children</p>
<p>of a node may be significant pointers contained in the structure,</p>
<p>entries from a lookup table, or any other value that can be calculated given the</p>
<p>structure as a starting point.</p>
<p>The syntax for defining a child follows (lines enclosed in square brackets are</p>
<p>optional; the square brackets are not part of the syntax, but the curly brackets are):</p>
<p>children {</p>
<p><i>child_name</i> {</p>
<p>value = &quot;<i>child_val_expr</i>&quot;</p>
<p>[is_container =<i> bool_expr</i>]</p>
<p><i>MULTI: Debugging</i></p>
<p><i>764</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>[is_array =<i> bool_expr</i>]</p>
<p>[array_len = &quot;<i>length_expr</i>&quot;]</p>
<p>[invisible_edge =<i> bool_expr</i>]</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>The lines in this syntax are described in the following table.</p>
<p>value = &quot;<i>child_val_expr</i>&quot;</p>
<p>Specifies the value of the child, where</p>
<p><i>child_val_expr</i></p>
<p>is an expression.</p>
<p>For example, in a binary tree you might define one child with:</p>
<p>value = &quot;return self.left&quot;</p>
<p>and another with:</p>
<p>value = &quot;return self.right&quot;</p>
<p>You must specify a value for every child.</p>
<p>is_container =<i> bool_expr</i></p>
<p>Specifies whether this child should be treated as a container of children, where</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>If</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>true</p>
<p>, the child is treated as a container â MULTI looks up a data description</p>
<p>for that type and adds each element of the container as a child. STL container descriptions have</p>
<p>been provided, so any time you have a structure with a list, vector, or map of children, you can</p>
<p>simply set this value to</p>
<p>true</p>
<p>and each element will be added as a child.</p>
<p>This field is optional and defaults to</p>
<p>false</p>
<p>. This field is mutually exclusive with</p>
<p>is_array</p>
<p>;</p>
<p>only one of</p>
<p>is_array</p>
<p>and</p>
<p>is_container</p>
<p>can be</p>
<p>true</p>
<p>.</p>
<p>is_array =<i> bool_expr</i></p>
<p>Specifies whether the child should be treated as an array of children, where</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>This field is optional and defaults to</p>
<p>false</p>
<p>. This field is mutually exclusive with</p>
<p>is_container</p>
<p>;</p>
<p>only one of</p>
<p>is_array</p>
<p>and</p>
<p>is_container</p>
<p>can be</p>
<p>true</p>
<p>.</p>
<p><i>765</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Data Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>array_len = &quot;<i>length_expr</i>&quot;</p>
<p>Specifies an expression,</p>
<p><i>length_expr</i></p>
<p>, to be used to calculate the length of the array. An</p>
<p>example child using arrays might be:</p>
<p>value = &quot;return self.myChildArray&quot;</p>
<p>is_array = true</p>
<p>array_len = &quot;return self.myChildArrayLen&quot;</p>
<p>This field is required if</p>
<p>is_array = true</p>
<p>.</p>
<p>invisible_edge =<i> bool_expr</i></p>
<p>Specifies whether the edge defined by this parent or child relationship will be displayed, where</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>.</p>
<p>This field gives you greater control over the layout of a graph. If</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>true</p>
<p>, the edge</p>
<p>will not be displayed, but will still restrain the layout of the graph, allowing you to, for example,</p>
<p>enforce an ordering on nodes without having visible edges connecting them.</p>
<p>This field is optional and defaults to</p>
<p>false</p>
<p>.</p>
<p>Parents can be described in the same way as children by using the</p>
<p>parents</p>
<p>keyword</p>
<p>in place of the</p>
<p>children</p>
<p>keyword. A single data description can contain both</p>
<p>parents</p>
<p>and</p>
<p>children</p>
<p>blocks.</p>
<p><b>Profile Descriptions</b></p>
<p>A data visualization profile is a collection of data descriptions. You can create</p>
<p>several profiles, but only one is<i> active</i> at a given time. Only the active profile is</p>
<p>used when searching for data descriptions. Using profiles allows you to have multiple</p>
<p>data descriptions for the same type, which you use in different circumstances. You</p>
<p>can change which profile is active by using the command:</p>
<p><b>dvprofile<i> prof_name</b></i></p>
<p>where</p>
<p><i>prof_name</i></p>
<p>is the name of the profile to be made active.</p>
<p>Any data description not in a profile is placed in a global profile, and is always</p>
<p>accessible.</p>
<p>Profiles are defined in profile descriptions in<b> .mdv</b> files. A profile description has</p>
<p>the following form. (Lines enclosed in square brackets are optional; the square</p>
<p>brackets are not part of the syntax, but the curly brackets are part of the syntax.)</p>
<p><i>MULTI: Debugging</i></p>
<p><i>766</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p><i>unique_prof_id</i> {</p>
<p>profile_name = &quot;<i>prof_name</i>&quot;</p>
<p>[parent_profile = &quot;<i>parent_prof_name</i>&quot;]</p>
<p>[default_root = &quot;<i>def_root_prof</i>&quot;]</p>
<p>[vertical_layout =<i> bool_expr</i>]</p>
<p>[add_siblings_of_root =<i> bool_expr</i>]</p>
<p>data_descriptions {</p>
<p>[<i>series_of_data_descriptions</i>]</p>
<p>}</p>
<p>}</p>
<p>The lines in this syntax are described in the table below.</p>
<p><i>unique_prof_id</i></p>
<p>Specifies a unique identifier,</p>
<p><i>unique_prof_id</i></p>
<p>, for the profile. Reading in a new profile with</p>
<p>the same identifier will overwrite the original.</p>
<p>This field is required.</p>
<p>profile_name = &quot;<i>prof_name</i>&quot;</p>
<p>Specifies</p>
<p><i>prof_name</i></p>
<p>as the string used to refer to the profile when you are using the<b> dvprofile</b></p>
<p>command or working with different views. See the<b> dvprofile</b> command in âData Visualization</p>
<p>Commandsâ in Chapter 22, âView Command Referenceâ in the<i> MULTI: Debugging Command</i></p>
<p><i>Reference</i> book, and see âView Descriptionsâ on page 768.</p>
<p>This field is required.</p>
<p>parent_profile = &quot;<i>parent_prof_name</i>&quot;</p>
<p>Specifies that the profile with the name</p>
<p><i>parent_prof_name</i></p>
<p>is the parent of the profile. A</p>
<p>profile can have at most one parent. When searching for a data description, MULTI starts at the</p>
<p>active profile and then searches its parent, then the parent of that parent, and so on. If no parent</p>
<p>is specified, the parent is set to the global profile by default.</p>
<p>This field is optional.</p>
<p>default_root =<i> def_root_prof</i></p>
<p>Specifies a variable identifier</p>
<p><i>def_root_prof</i></p>
<p>as the default root variable for graphs using this</p>
<p>profile. This line is optional, but is used by the<b> dataview</b> command. For information about the</p>
<p><b>dataview</b> command, see âData Visualization Commandsâ in Chapter 22, âView Command</p>
<p>Referenceâ in the<i> MULTI: Debugging Command Reference</i> book.</p>
<p><i>767</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Profile Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>vertical_layout =<i> bool_expr</i></p>
<p>Specifies whether the graph should use a vertically oriented layout or a horizontally oriented</p>
<p>layout, where</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>. If</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>true</p>
<p>, the graph will use</p>
<p>a vertically oriented layout.</p>
<p>This field is optional and defaults to</p>
<p>false</p>
<p>.</p>
<p>add_siblings_of_root =<i> bool_expr</i></p>
<p>Specifies whether the siblings of the root node for the graph of this profile should be added,</p>
<p>where</p>
<p><i>bool_expr</i></p>
<p>is either</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>. If</p>
<p><i>bool_expr</i></p>
<p>is</p>
<p>true</p>
<p>, siblings will be added.</p>
<p>This field is optional and defaults to</p>
<p>true</p>
<p>.</p>
<p><b>View Descriptions</b></p>
<p>Views are high-level visualizations in graph form. You can create views for elements</p>
<p>of the</p>
<p>graph</p>
<p>data type by including<i> view descriptions</i> in your loaded<b> .mdv</b> file(s).</p>
<p>When you select<b> Display Program Visualizations</b> from a right-click shortcut menu</p>
<p>in the Debugger source pane, a graph will be displayed for each view that is defined</p>
<p>in your loaded<b> .mdv</b> files. These individual graphs will appear on separate tabs of</p>
<p>a single window.</p>
<p>Every view starts at a default root and contains one or two panes. A single pane</p>
<p>view displays the data specified by a single profile. A dual-pane view displays a</p>
<p>profile in the initial, or primary, pane. When a node in this primary pane is clicked,</p>
<p>that node is used as the root variable for a graph that is then displayed in the second</p>
<p>pane, using a different profile.</p>
<p>A view description contains specifications about the contents and layout of a single</p>
<p>view. The syntax for defining views has the following form. (Lines enclosed in</p>
<p>square brackets are optional; the square brackets are not part of the syntax, but the</p>
<p>curly brackets are part of the syntax.)</p>
<p><i>view_unique_name</i> {</p>
<p>initial_pane = &quot;<i>pane_name</i>&quot;</p>
<p>default_root = &quot;<i>def_root_view</i>&quot;</p>
<p>[tab_name = &quot;<i>tab</i>&quot;]</p>
<p><i>MULTI: Debugging</i></p>
<p><i>768</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>panes {</p>
<p><i>pane_name1</i> {</p>
<p>profile_name = &quot;<i>prof_name</i>&quot;</p>
<p>[child_pane = &quot;<i>child_pane_name</i>&quot;]</p>
<p>}</p>
<p>[<i>pane_name2</i> {</p>
<p>profile_name = &quot;<i>prof_name2</i>&quot;</p>
<p>}]</p>
<p>}</p>
<p>}</p>
<p>The fields in this syntax are described in the table below.</p>
<p><i>view_unique_name</i></p>
<p>Specifies a unique identifier,</p>
<p><i>view_unique_name</i></p>
<p>, for the view. This name can be used with</p>
<p>the<b> dataview</b> command to open a<b> Graph View</b> window on this view (see âInvoking Customized</p>
<p>Data Visualizationsâ on page 746).</p>
<p>This field is required.</p>
<p>initial_pane = &quot;<i>pane_name</i>&quot;</p>
<p>Specifies which pane is the primary pane for this view. In single pane views, this will be the</p>
<p>name of the only pane. In dual pane views, this will be the name of the pane on the left. In dual</p>
<p>pane views, clicking a node in the primary pane will cause the child pane to display a new graph</p>
<p>with the selected object as its root.</p>
<p>This field is required.</p>
<p>default_root = &quot;<i>def_root_view</i>&quot;</p>
<p>Specifies</p>
<p><i>def_root_view</i></p>
<p>as the root variable for the view.</p>
<p>This field is required.</p>
<p>tab_name = &quot;<i>tab</i>&quot;</p>
<p>Specifies the string to be displayed on the tab that displays this view.</p>
<p>This field is optional.</p>
<p><i>pane_name</i></p>
<p>Specifies the name (</p>
<p><i>pane_name1</i></p>
<p>,</p>
<p><i>pane_name2</i></p>
<p>) of the pane(s). This is used to refer to the pane</p>
<p>within this view.</p>
<p>This field is required for each pane in the view.</p>
<p><i>769</i></p>
<p><i>Green Hills Software</i></p>
<p><i>View Descriptions</i></p>
<h1 style="page-break-before:always; "></h1>
<p>profile_name = &quot;<i>prof_name</i>&quot;</p>
<p>Specifies</p>
<p><i>prof_name</i></p>
<p>as the profile to use as the active profile when displaying this pane. (See</p>
<p>âProfile Descriptionsâ on page 766.)</p>
<p>This field is required for each pane in the view.</p>
<p>child_pane = &quot;<i>child_pane_name</i>&quot;</p>
<p>Specifies</p>
<p><i>child_pane_name</i></p>
<p>as the child pane. When a node is selected in the pane being</p>
<p>defined, the selected node will be displayed in this child pane.</p>
<p>This field is required if the pane has a child pane.</p>
<p><b>Using Expressions in MULTI Data Visualization (.mdv) Files</b></p>
<p>Many of the fields defined in<b> .mdv</b> files take an expression as their value. An</p>
<p>expression is specified in quotation marks and can contain any statement or series</p>
<p>of statements that can be evaluated from the MULTI command pane. The value of</p>
<p>the expression is whatever value is found in the</p>
<p>return</p>
<p>statement. If no</p>
<p>return</p>
<p>statement is specified, the expression returns</p>
<p>void</p>
<p>and is probably incorrect.</p>
<p>Expressions can contain loops, MULTI special variables, and command line</p>
<p>procedure calls. Expressions can also refer to program variables and return pointers,</p>
<p>but they cannot return objects.</p>
<p>Expressions access the<i> current</i> structure through the</p>
<p>self</p>
<p>keyword. The current</p>
<p>structure is usually the structure that the data description's signature matches. (There</p>
<p>are some exceptions, such as when the current structure is the iterator while walking</p>
<p>through a container.)</p>
<p><b>.mdv File Examples</b></p>
<p>Consider the following data types:</p>
<p>class Device {</p>
<p>public:</p>
<p>Device(const char *name, const int id);</p>
<p>void addInputBus(Bus* input);</p>
<p>void addOutputBus(Bus* output);</p>
<p><i>MULTI: Debugging</i></p>
<p><i>770</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p>protected:</p>
<p>const char* deviceName;</p>
<p>int deviceId;</p>
<p>std::list&lt;Bus*&gt; inputs;</p>
<p>std::list&lt;Bus*&gt; outputs;</p>
<p>};</p>
<p>class Bus {</p>
<p>public:</p>
<p>Bus(const char* name, const int id);</p>
<p>void addInputDevice(Device* input);</p>
<p>void addOutputDevice(Device* output);</p>
<p>protected:</p>
<p>const char* busName;</p>
<p>int busId;</p>
<p>std::list&lt;Device*&gt; inputs;</p>
<p>std::list&lt;Device*&gt; outputs;</p>
<p>};</p>
<p>A sample<b> .mdv</b> file used to display the preceding types is listed below.</p>
<p>demo_profile {</p>
<p>profile_name = &quot;Device_Bus_Profile&quot;</p>
<p>data_descriptions {</p>
<p>device {</p>
<p>signature = {&quot;Device&quot;}</p>
<p>type = &quot;graph&quot;</p>
<p>node_text = &quot;mprintf(\&quot;%s\nDevice ID: %d\&quot;, self.deviceName, self.deviceId)&quot;</p>
<p>children {</p>
<p>outputs {</p>
<p>value = &quot;return self.outputs&quot;</p>
<p>is_container = true;</p>
<p>}</p>
<p>}</p>
<p>parents {</p>
<p>inputs {</p>
<p>value = &quot;return self.inputs&quot;</p>
<p>is_container = true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p><i>771</i></p>
<p><i>Green Hills Software</i></p>
<p><i>.mdv File Examples</i></p>
<h1 style="page-break-before:always; "></h1>
<p>bus {</p>
<p>signature = {&quot;Bus&quot;}</p>
<p>type = &quot;graph&quot;</p>
<p>node_text = &quot;mprintf(\&quot;%s\nBus ID: %d\nInputs: %d\nOutputs: %d\&quot;,&quot;</p>
<p>node_text+= &quot;self.busName, self.busId, self.inputs.size(), self.outputs.size())&quot;</p>
<p>children {</p>
<p>outputs {</p>
<p>value = &quot;return self.outputs&quot;</p>
<p>is_container = true;</p>
<p>}</p>
<p>}</p>
<p>parents {</p>
<p>inputs {</p>
<p>value = &quot;return self.inputs&quot;</p>
<p>is_container = true;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>my_list {</p>
<p>signature = {&quot;std::list&lt;*&gt;&quot;}</p>
<p>type = &quot;container&quot;</p>
<p>size = &quot;return self._Mysize;&quot;</p>
<p>begin_iter = &quot;return self._Myhead._Next;&quot;</p>
<p>next_iter = &quot;return self._Next;&quot;</p>
<p>value_from_iter = &quot;return self._Myval;&quot;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>demo_view {</p>
<p>initial_pane = &quot;only_pane&quot;</p>
<p>default_root = &quot;deviceA&quot;</p>
<p>tab_name = &quot;Device Graph&quot;</p>
<p>panes {</p>
<p>only_pane {</p>
<p>profile_name = &quot;Device_Bus_Profile&quot;</p>
<p>}</p>
<p>}</p>
<p>}</p>
<p>The preceding<b> .mdv</b> file might yield a<b> Graph View</b> like the following.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>772</i></p>
<p><i>Appendix E. Creating Custom Data Visualizations</i></p>
<h1 style="page-break-before:always; "></h1>
<p><i>773</i></p>
<p><i>Green Hills Software</i></p>
<p><i>.mdv File Examples</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Appendix F</b></p>
<p><b>Register Definition and</b></p>
<p><b>Configuration Reference</b></p>
<p><b>Contents</b></p>
<p>The GRD Register Definition Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>776</p>
<h1 style="page-break-before:always; "></h1>
<p>This appendix describes the GRD register definition format.</p>
<p><b>The GRD Register Definition Format</b></p>
<p>A target's register information is defined in a GRD file, which will contain some</p>
<p>or all of the following sections:</p>
<p>â¢</p>
<p>The</p>
<p>general</p>
<p>section</p>
<p>â¢</p>
<p>The</p>
<p>enum</p>
<p>section</p>
<p>â¢</p>
<p>The</p>
<p>structure</p>
<p>section</p>
<p>â¢</p>
<p>The</p>
<p>bitfield</p>
<p>section</p>
<p>â¢</p>
<p>The</p>
<p>register</p>
<p>section</p>
<p>â¢</p>
<p>The</p>
<p>group</p>
<p>section</p>
<p>Each section is enclosed in a block (delimited by</p>
<p>{}</p>
<p>) with a tag name identifying</p>
<p>the section. The definition for each section can be separated into multiple parts. For</p>
<p>example, you can define one</p>
<p>register</p>
<p>section for all special purpose registers,</p>
<p>then a</p>
<p>group</p>
<p>section for the special purpose registers, and then another</p>
<p>register</p>
<p>section.</p>
<p>Preprocessor directives can be used in GRD files. The syntax and usage of the GRD</p>
<p>file preprocessor is the same as in C++ except that the initial character is</p>
<p>%</p>
<p>instead</p>
<p>of</p>
<p>#</p>
<p>(an initial</p>
<p>#</p>
<p>indicates a comment line in GRD format).</p>
<p>A preprocessor symbol can be substituted in a string with syntax</p>
<p>${DefinedSymbol}</p>
<p>. For example:</p>
<p>%define PPC400_DCR_BASE</p>
<p>5000</p>
<p>CPC0_SR {address=&quot;${PPC400_DCR_BASE}+0x000000b0&quot;}</p>
<p>In the value of</p>
<p>CPC0_SR</p>
<p>'s</p>
<p>address</p>
<p>attribute, the Debugger substitutes</p>
<p>5000</p>
<p>for</p>
<p>${PPC400_DCR_BASE}</p>
<p>and then evaluates the resulting expression</p>
<p>5000+0x000000b0</p>
<p>.</p>
<p>Pre-defined preprocessor symbols for the debugging environment are available for</p>
<p>use in GRD files. For more information, see the comment at the top of the file</p>
<p><i>MULTI: Debugging</i></p>
<p><i>776</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>os_constants_internal.grd</b>, which is located at</p>
<p><i><b>compiler_install_dir</i>/defaults/registers</b>.</p>
<p>Blocks can be represented in two formats:</p>
<p>â¢</p>
<p>Delimited by curly braces (</p>
<p>{}</p>
<p>). For example:</p>
<p>general {</p>
<p>register_offset = &quot;16&quot;;</p>
<p>}</p>
<p>â¢</p>
<p>Delimited with a period (</p>
<p>.</p>
<p>). For example:</p>
<p>general.register_offset = &quot;16&quot;;</p>
<p>or</p>
<p>&quot;general&quot;.&quot;register_offset&quot; = &quot;16&quot;;</p>
<p>The following sections describe each element's syntax.</p>
<p><b>The general Section</b></p>
<p>The</p>
<p>general</p>
<p>section defines the following settings for the target:</p>
<p>general {</p>
<p>version =<i> number</i></p>
<p>pad_bitfield =<i> bool</i></p>
<p>register_width =<i> int</i></p>
<p>register_offset =<i> string</i></p>
<p>byte_endian =<i> string</i></p>
<p>bit_0_is_msb =<i> bool</i></p>
<p>memory_space =<i> number</i></p>
<p>pvr_address[<i>index</i>] =<i> identifier</i></p>
<p>pvr_info[<i>index</i>] {<i>register definition block</i>}</p>
<p>pvr_mask[<i>index</i>] =<i> mask</i></p>
<p>bcr_address[<i>index</i>] =<i> identifier</i></p>
<p>bcr_info[<i>index</i>] {<i>register definition block</i>}</p>
<p>bcr_mask[<i>index</i>] =<i> mask</i></p>
<p>multi_command =<i> commands</i></p>
<p>}</p>
<p><i>777</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The general Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>The only required attribute is</p>
<p>version</p>
<p>. All other attributes are optional.</p>
<p>version =<i> number</i></p>
<p>Defines the version number of the Green Hills Software Register Definition language used in</p>
<p>the GRD file. The version number should be</p>
<p>3</p>
<p>.</p>
<p>Example:</p>
<p>version = 3</p>
<p>pad_bitfield =<i> bool</i></p>
<p>Where</p>
<p><i>bool</i></p>
<p>can be:</p>
<p>â¢</p>
<p>true</p>
<p>or</p>
<p>false</p>
<p>â¢</p>
<p>An integer (where</p>
<p>0</p>
<p>means false, and a non-zero integer means true)</p>
<p>â¢</p>
<p>A string expression starting with</p>
<p>%EVAL</p>
<p>that can be dynamically evaluated and result in a</p>
<p>Boolean value</p>
<p>When a register with bitfields is defined, some bits or bit ranges may be omitted. This option</p>
<p>tells the Debugger whether to automatically generate fields for the omitted bits or bit ranges</p>
<p>when creating symbol information for the bitfield. If this attribute is true, when a register with</p>
<p>the corresponding bitfield is displayed, the automatically generated padding fields will be</p>
<p>displayed.</p>
<p>The default value for this attribute is</p>
<p>true</p>
<p>.</p>
<p>Example:</p>
<p>pad_bitfield = true</p>
<p>register_width =<i> int</i></p>
<p>Where</p>
<p><i>int</i></p>
<p>defines the default register width in bits. It can be an integer or a string expression</p>
<p>starting with</p>
<p>%EVAL</p>
<p>. The expression enclosed in</p>
<p>%EVAL {}</p>
<p>, will be dynamically evaluated into</p>
<p>an integer.</p>
<p>The default value for this attribute is 32.</p>
<p>The default register width will be applied to all registers except those registers whose definitions</p>
<p>override the default width by using the</p>
<p>width</p>
<p>setting.</p>
<p>Example:</p>
<p>register_width = 16</p>
<p>register_offset =<i> string</i></p>
<p>Each register has an identifier in the Debugger, but it can have a different identifier (register</p>
<p>offset) in the communication message between the Debugger and the debug server. This setting</p>
<p>defines the default register offset that will be applied to all registers. A register definition can</p>
<p>override the default offset expression by using the</p>
<p>offset</p>
<p>setting.</p>
<p>Example:</p>
<p>register_offset = &quot;return 2*__regadr&quot;</p>
<p>__regadr</p>
<p>is a reserved symbol whose value is the register's identifier in the Debugger.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>778</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>byte_endian = string</p>
<p>This setting defines the default byte order for a register. A register definition can override the</p>
<p>default byte order by using the</p>
<p>byte_endian</p>
<p>setting.</p>
<p>Here are the supported values:</p>
<p>â¢</p>
<p>default</p>
<p>â Always the same as the target (this is the default)</p>
<p>â¢</p>
<p>big</p>
<p>â Always big endian</p>
<p>â¢</p>
<p>little</p>
<p>â Always little endian</p>
<p>In big endian registers, the most significant byte is at the lowest address. In little endian registers,</p>
<p>the least significant byte is at the lowest address.</p>
<p>Example:</p>
<p>byte_endian = &quot;big&quot;</p>
<p>bit_0_is_msb =<i> bool</i></p>
<p>This setting defines the default bit order for a register. A register definition can override the</p>
<p>default bit order by using the</p>
<p>bit_0_is_msb</p>
<p>setting.</p>
<p>This setting indicates how a register's bit numbers are ordered. If the value for</p>
<p>bit_0_is_msb</p>
<p>is true, bit 0 will refer to the register's most significant bit (msb), and the largest bit number will</p>
<p>refer to the register's least significant bit (lsb). Otherwise, bit 0 will refer to the register's least</p>
<p>significant bit (lsb), and the largest bit number will refer to the register's most significant bit</p>
<p>(msb).</p>
<p>The default value for the attribute is</p>
<p>false</p>
<p>.</p>
<p>Example:</p>
<p>bit_0_is_msb = true</p>
<p>memory_space =<i> number</i></p>
<p>This setting defines the default memory space for memory-mapped registers.</p>
<p>When defining a custom memory space, you should use a value larger than 65536. The Debugger</p>
<p>reserves values less than 65536 for its own use.</p>
<p>The Debugger also supports the following memory spaces, which are defined in the</p>
<p><b>os_constants_internal.grd</b> file located at<i><b> compiler_install_dir</i>/defaults/registers</b>.</p>
<p>â¢</p>
<p>MSPACE_TEXT_PHYSICAL</p>
<p>â The physical memory space for text.</p>
<p>â¢</p>
<p>MSPACE_DATA_PHYSICAL</p>
<p>â [default] The physical memory space for data.</p>
<p>â¢</p>
<p>MSPACE_TEXT_DEFAULT</p>
<p>â The default memory space (recognized by the debug server)</p>
<p>for text.</p>
<p>â¢</p>
<p>MSPACE_DATA_DEFAULT</p>
<p>â The default memory space (recognized by the debug server)</p>
<p>for data.</p>
<p>See also the</p>
<p>memory_space</p>
<p>attribute in âThe register Sectionâ on page 791.</p>
<p>Example:</p>
<p>memory_space = 95</p>
<p><i>779</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The general Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p>pvr_address[<i>index</i>] =<i> identifier</i></p>
<p>If a processor has more than one processor version register (PVR),</p>
<p><i>index</i></p>
<p>can be appended to</p>
<p>pvr_address</p>
<p>. The two settings</p>
<p>pvr_address</p>
<p>and</p>
<p>pvr_address0</p>
<p>represent the same processor</p>
<p>version register.</p>
<p><i>identifier</i></p>
<p>can be an integer or a string expression starting with</p>
<p>%EVAL</p>
<p>that will evaluate to</p>
<p>an integer.</p>
<p>See also âProcessor Version Register Informationâ on page 783.</p>
<p>Example:</p>
<p>pvr_address10 = 1061</p>
<p>pvr_info[<i>index</i>] {<i>register definition block</i>}</p>
<p>This setting defines a memory-mapped processor version register (PVR). To support</p>
<p>memory-mapped PVRs, the syntax for the PVR definition is extended to support attributes from</p>
<p>the register definition block. For information about the register definition block, see âThe register</p>
<p>Sectionâ on page 791.</p>
<p>The</p>
<p>access</p>
<p>string must be a</p>
<p>regular</p>
<p>,</p>
<p>special</p>
<p>,</p>
<p>io</p>
<p>, or</p>
<p>memory-mapped</p>
<p>string, or it must</p>
<p>be a string expression that can be resolved into such a string. For more information, see the</p>
<p>access</p>
<p>attribute in âThe register Sectionâ on page 791.</p>
<p>See also âProcessor Version Register Informationâ on page 783.</p>
<p>When this PVR specification is used, the version number should be</p>
<p>2</p>
<p>or higher. See the</p>
<p>version</p>
<p>description earlier in this table.</p>
<p>Example:</p>
<p>pvr_info1 {</p>
<p>access = &quot;memorymapped&quot;;</p>
<p>address = 0x123456;</p>
<p>width = 16;</p>
<p>read_length = 16;</p>
<p>byte_endian=&quot;little&quot;;</p>
<p>}</p>
<p>pvr_mask[<i>index</i>] =<i> mask</i></p>
<p><i>index</i></p>
<p>has the same meaning as in the processor version register address.</p>
<p><i>mask</i></p>
<p>can be an integer or a string expression starting with</p>
<p>%EVAL</p>
<p>that will evaluate to an integer.</p>
<p>See also âProcessor Version Register Informationâ on page 783.</p>
<p>Example:</p>
<p>pvr_mask10 = 0xffff0000</p>
<p><i>MULTI: Debugging</i></p>
<p><i>780</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>bcr_address[<i>index</i>] =<i> identifier</i></p>
<p>If a target has more than one board configuration register (BCR),</p>
<p><i>index</i></p>
<p>can be appended to</p>
<p>bcr_address</p>
<p>. The two settings</p>
<p>bcr_address</p>
<p>and</p>
<p>bcr_address0</p>
<p>represent the same BCR.</p>
<p>See also âBoard Configuration Register Informationâ on page 783.</p>
<p>Example:</p>
<p>bcr_address10 = 258</p>
<p>bcr_info[<i>index</i>] {<i>register definition block</i>}</p>
<p>This setting defines a memory-mapped board configuration register (BCR). To support</p>
<p>memory-mapped BCRs, the syntax for the BCR definition is extended to support attributes from</p>
<p>the register definition block. For information about the register definition block, see âThe register</p>
<p>Sectionâ on page 791.</p>
<p>The</p>
<p>access</p>
<p>string must be a</p>
<p>regular</p>
<p>,</p>
<p>special</p>
<p>,</p>
<p>io</p>
<p>, or</p>
<p>memory-mapped</p>
<p>string, or it must</p>
<p>be an expression that can be resolved into such a string. For more information, see the</p>
<p>access</p>
<p>attribute in âThe register Sectionâ on page 791.</p>
<p>See also âBoard Configuration Register Informationâ on page 783.</p>
<p>When this BCR specification is used, the version number should be</p>
<p>2</p>
<p>or higher. See the</p>
<p>version</p>
<p>description earlier in this table.</p>
<p>Example:</p>
<p>bcr_info1 {</p>
<p>access = &quot;memorymapped&quot;;</p>
<p>address = 0x123456;</p>
<p>width = 16;</p>
<p>read_length = 16;</p>
<p>byte_endian=&quot;little&quot;;</p>
<p>}</p>
<p>bcr_mask[<i>index</i>] =<i> mask</i></p>
<p><i>index</i></p>
<p>has the same meaning as in the board configuration register address.</p>
<p><i>mask</i></p>
<p>can be an integer or a string expression starting with</p>
<p>%EVAL</p>
<p>that will evaluate to an integer.</p>
<p>See also âBoard Configuration Register Informationâ on page 783.</p>
<p>Example:</p>
<p>bcr_mask10 = 0xffff0000</p>
<p><i>781</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The general Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p>multi_command =<i> multi_commands</i></p>
<p>multi_command +=<i> multi_commands</i></p>
<p>This setting defines Debugger commands in a string that will be executed when the register</p>
<p>definition is constructed inside the Debugger.</p>
<p>This setting is especially useful to support memory-mapped registers whose addresses are not</p>
<p>based on another register's value but which could depend on other factors, such as the following:</p>
<p>â¢</p>
<p>A debug server could move a register base around when it connects to the target (via its</p>
<p>setup script, for example).</p>
<p>â¢</p>
<p>A program such as the INTEGRITY kernel could move a register base when it runs.</p>
<p>â¢</p>
<p>A program's build process might move a register base.</p>
<p>You can define the address of these registers with an expression using one or more Debugger</p>
<p>local variables. For example, on a PowerPC target supporting QUICC, a Debugger variable is</p>
<p>defined for the base of the QUICC registers:</p>
<p>$MULTI_PPC_QUICC_SIU_IMMR_BASE</p>
<p>which can be used to define the addresses of QUICC registers as described below:</p>
<p>bcr_address = &quot;$MULTI_PPC_QUICC_SIU_IMMR_BASE + 0x10024&quot;</p>
<p>The special variable can be initialized to the default base with a Debugger command:</p>
<p>multi_command +=</p>
<p>&quot; if (!$MULTI_PPC_QUICC_SIU_IMMR_BASE_IS_SET)</p>
<p>{eval $MULTI_PPC_QUICC_SIU_IMMR_BASE = 0x0f000000;}&quot;</p>
<p>where</p>
<p>eval</p>
<p>is used to prevent the Debugger from printing the new value of</p>
<p>$MULTI_PPC_QUICC_SIU_IMMR_BASE</p>
<p>after the assignment.</p>
<p>The default GRD files for some targets already use this mechanism. If the default IMMR base</p>
<p>does not match your target setting, you can either change the GRD file directly or add statements</p>
<p>such as the following into your program resource file (<b>.rc</b>) or target setup script (<b>.mbs</b>) to set</p>
<p>the correct IMMR base and disable the default setting:</p>
<p>eval $MULTI_PPC_QUICC_SIU_IMMR_BASE_IS_SET = 1</p>
<p>eval $MULTI_PPC_QUICC_SIU_IMMR_BASE = 0xfc000000</p>
<p><i>MULTI: Debugging</i></p>
<p><i>782</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Processor Version Register Information</b></p>
<p>Some targets have a processor version register or registers that can be used to identify</p>
<p>target processors and their variants. If such information about the processor version</p>
<p>is defined, the value can be used in GRD file preprocessor expressions with the</p>
<p>following syntax:</p>
<p>pvr_value[<i>index</i>]</p>
<p>where</p>
<p><i>index</i></p>
<p>is the index (starting from 0) for the processor version register. A</p>
<p>processor version register's basic information contains:</p>
<p>â¢</p>
<p>An identifier, which is used by the Debugger to communicate with the</p>
<p>underlying debug server</p>
<p>â¢</p>
<p>A value mask</p>
<p><b>Board Configuration Register Information</b></p>
<p>As with processor version registers, a mechanism is provided for users to define</p>
<p>board configuration register(s). If such information for the board configuration</p>
<p>registers is defined, the value can be used in GRD file preprocessor expressions</p>
<p>with the following syntax:</p>
<p>bcr_value[<i>index</i>]</p>
<p>where</p>
<p><i>index</i></p>
<p>is the index (starting from 0) for the board configuration register.</p>
<p>A board configuration register's basic information contains:</p>
<p>â¢</p>
<p>An identifier, which is used by the Debugger to communicate with the</p>
<p>underlying debug server</p>
<p>â¢</p>
<p>A value mask</p>
<p><i>783</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The general Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The enum Section</b></p>
<p>An enumeration definition must be in an enumeration section, and must be defined</p>
<p>before it is referenced. An enumeration can have the following attributes:</p>
<p>enum {</p>
<p><i>enum_name</i> {</p>
<p>description =<i> string</i></p>
<p>help_key =<i> string</i></p>
<p>auto_value_desc =<i> bool</i></p>
<p><i>enum_entry_name</i> {</p>
<p>description =<i> string</i></p>
<p>help_key =<i> string</i></p>
<p>long_name =<i> string</i></p>
<p>value =<i> int</i></p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>}</p>
<p><b>Note</b></p>
<p>All attributes are optional.</p>
<p>description =<i> string</i></p>
<p>description +=<i> string</i></p>
<p>desc =<i> string</i></p>
<p>desc +=<i> string</i></p>
<p>The description string can be an expression starting with</p>
<p>%EVAL</p>
<p>, which will be dynamically</p>
<p>evaluated.</p>
<p>An enumeration can have a long description combined from multiple description settings (with</p>
<p>+=</p>
<p>). Newline characters (</p>
<p>\n</p>
<p>) must be specified if you want a newline displayed in the Register</p>
<p>Information window's help pane.</p>
<p>Example:</p>
<p>desc = &quot;Indicates whether interrupts are enabled:\n&quot;;</p>
<p>desc += &quot;</p>
<p>0 - disabled\n&quot;;</p>
<p><i>MULTI: Debugging</i></p>
<p><i>784</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>help_key =<i> string</i></p>
<p>hk =<i> string</i></p>
<p>The help key string can be an expression starting with</p>
<p>%EVAL</p>
<p>, which will be dynamically</p>
<p>evaluated.</p>
<p>Example:</p>
<p>hk = &quot;register.msr&quot;</p>
<p>auto_value_desc =<i> bool</i></p>
<p>The default setting for this option is</p>
<p>true</p>
<p>.</p>
<p>When this option is set to</p>
<p>false</p>
<p>, the Debugger will not automatically generate the specification</p>
<p>for the enumeration's values in the help pane of the Register Information window for those</p>
<p>bitfields whose type is the enumeration.</p>
<p>If you include a detailed list of enumeration values in the enumeration description, set this option</p>
<p>to</p>
<p>false</p>
<p>to avoid duplicating the list of enumeration values in the help pane.</p>
<p>Example:</p>
<p>auto_value_desc = false</p>
<p>An enumeration must have at least one value entry, which can have the following</p>
<p>attributes. If none of the attributes are specified, the braces should still be present.</p>
<p>description =<i> string</i></p>
<p>description +=<i> string</i></p>
<p>desc =<i> string</i></p>
<p>desc +=<i> string</i></p>
<p>The description string can be an expression starting with</p>
<p>%EVAL</p>
<p>, which will be dynamically</p>
<p>evaluated.</p>
<p>help_key =<i> string</i></p>
<p>hk =<i> string</i></p>
<p>The help key will be used to show online help. The help key string can be an expression starting</p>
<p>with</p>
<p>%EVAL</p>
<p>, which will be dynamically evaluated.</p>
<p>long_name =<i> string</i></p>
<p>ln =<i> string</i></p>
<p>The long name string can be an expression starting with</p>
<p>%EVAL</p>
<p>, which will be dynamically</p>
<p>evaluated.</p>
<p><i>785</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The enum Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p>value =<i> int</i></p>
<p>value = {<i>int1</i>, ...,<i> intn</i>}</p>
<p>The enumeration entry will have the value or values specified. If an enumeration entry does not</p>
<p>have a value explicitly specified, its value is assigned as follows:</p>
<p>â¢</p>
<p>If no previous enumeration entry exists, the enumeration entry will be assigned the value</p>
<p>0.</p>
<p>â¢</p>
<p>If a previous enumeration entry exists, the enumeration entry will be assigned a value one</p>
<p>greater than that of that previous enumeration entry.</p>
<p>â¢</p>
<p>If a previous enumeration entry contains a list of values, the enumeration entry will be</p>
<p>assigned a value one greater than maximum value in the previous enumeration entry.</p>
<p><b>The structure Section</b></p>
<p>Any structure definition must be in a structure section, and it must be defined before</p>
<p>it is referenced. Structure definitions are rarely used in register definition files. A</p>
<p>structure can have the following components:</p>
<p>structure {</p>
<p><i>structure_name</i> {</p>
<p>description =<i> string</i></p>
<p>help_key =<i> string</i></p>
<p><i>field_name</i> {</p>
<p>description =<i> string</i></p>
<p>help_key =<i> string</i></p>
<p>long_name =<i> string</i></p>
<p>type =<i> string</i></p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>}</p>
<p><b>Note</b></p>
<p>All attributes are optional.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>786</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>description =<i> string</i></p>
<p>desc =<i> string</i></p>
<p>This is the structure's description. MULTI 6 does not use this value, which is currently being</p>
<p>reserved for a future release.</p>
<p>help_key =<i> string</i></p>
<p>hk =<i> string</i></p>
<p>This is the structure's help key. MULTI 6 does not use this value, which is currently being</p>
<p>reserved for a future release.</p>
<p>A structure's field can have the following attributes:</p>
<p>description =<i> string</i></p>
<p>desc =<i> string</i></p>
<p>This is the structure field's description. MULTI 6 does not use this value, which is currently</p>
<p>being reserved for a future release.</p>
<p>help_key =<i> string</i></p>
<p>hk =<i> string</i></p>
<p>This is the structure field's help key. MULTI 6 does not use this value, which is currently being</p>
<p>reserved for a future release.</p>
<p>long_name =<i> string</i></p>
<p>ln =<i> string</i></p>
<p>This is the structure field's long name. MULTI 6 does not use this value, which is currently</p>
<p>being reserved for a future release.</p>
<p><i>787</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The structure Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p>type =<i> string</i></p>
<p>The type string must be one of the following:</p>
<p>â¢</p>
<p>A basic data type, including</p>
<p>â</p>
<p>int</p>
<p>â</p>
<p>unsigned int</p>
<p>â</p>
<p>char</p>
<p>â</p>
<p>unsigned char</p>
<p>â</p>
<p>short</p>
<p>â</p>
<p>unsigned short</p>
<p>â</p>
<p>long</p>
<p>â</p>
<p>unsigned long</p>
<p>â</p>
<p>long long</p>
<p>â</p>
<p>unsigned long long</p>
<p>â</p>
<p>float</p>
<p>â</p>
<p>double</p>
<p>â</p>
<p>code</p>
<p>â¢</p>
<p>A pointer to one of the above basic data types (for example,</p>
<p>int *</p>
<p>)</p>
<p><b>The bitfield Section</b></p>
<p>Any bitfield definition must be in a bitfield section, and must be defined before it</p>
<p>is referenced.</p>
<p>A bitfield can have the following attributes:</p>
<p>bitfield {</p>
<p><i>bitfield_name</i> {</p>
<p>description =<i> string</i></p>
<p>help_key =<i> string</i></p>
<p><i>field_name</i> {</p>
<p>description =<i> string</i></p>
<p>help_key =<i> string</i></p>
<p>short_name =<i> string</i></p>
<p>long_name =<i> string</i></p>
<p>auto_value_desc =<i> bool</i></p>
<p><i>MULTI: Debugging</i></p>
<p><i>788</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>loc = &quot;<i>begin_bit...end_bit</i>&quot;</p>
<p>type =<i> string</i></p>
<p>}</p>
<p>...</p>
<p>}</p>
<p>}</p>
<p><b>Note</b></p>
<p>The only required attribute is</p>
<p>loc</p>
<p>. All other attributes are optional.</p>
<p>description =<i> string</i></p>
<p>desc =<i> string</i></p>
<p>The bitfield description is displayed in the Register Information window's help pane.</p>
<p>help_key =<i> string</i></p>
<p>hk =<i> string</i></p>
<p>This is the bitfield's help key. MULTI 6 does not use this value, which is currently being reserved</p>
<p>for a future release.</p>
<p>Every field in a bitfield must have a unique</p>
<p><i>field_name</i></p>
<p>.</p>
<p>description =<i> string</i></p>
<p>description +=<i> string</i></p>
<p>desc =<i> string</i></p>
<p>desc +=<i> string</i></p>
<p>A long description can be defined with multiple</p>
<p>+=</p>
<p>statements.</p>
<p>The field description is displayed in the Register Information window's help pane.</p>
<p>help_key =<i> string</i></p>
<p>hk =<i> string</i></p>
<p>This is the field's help key. MULTI 6 does not use this value, which is currently being reserved</p>
<p>for a future release.</p>
<p>short_name =<i> string</i></p>
<p>sn =<i> string</i></p>
<p>This is the field's GUI name shown in<b> Register View</b> window and Register Information window.</p>
<p>Multiple fields can have the same GUI name, like</p>
<p>Reserved</p>
<p>for those reserved fields. But each</p>
<p>field's tag name must be unique in a bitfield.</p>
<p>If the attribute is absent, the field's tag name will be used as GUI name.</p>
<p><i>789</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The bitfield Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p>long_name =<i> string</i></p>
<p>ln =<i> string</i></p>
<p>This is the field's long name. It is displayed in the following places in the Register Information</p>
<p>window:</p>
<p>â¢</p>
<p>A tooltip in the concise display pane</p>
<p>â¢</p>
<p>The<b> Description</b> in the detailed display pane</p>
<p>â¢</p>
<p>The help pane</p>
<p>auto_value_desc =<i> bool</i></p>
<p>This option is only relevant for fields with an enumeration type. The default setting for this</p>
<p>option is</p>
<p>true</p>
<p>.</p>
<p>When this option is set to</p>
<p>false</p>
<p>, the Debugger will not automatically generate the specification</p>
<p>for the field's values in the help pane of the Register Information window.</p>
<p>If you include a detailed list of enumeration values in the field description, set this option to</p>
<p>false</p>
<p>to avoid duplicating the list of enumeration values in the help pane.</p>
<p>loc = &quot;<i>begin_bit</i>..<i>end_bit</i>&quot;</p>
<p>loc = &quot;<i>bit_index</i>&quot;</p>
<p>The second form of this setting is for a field with only one bit.</p>
<p>type =<i> type_string</i></p>
<p>The type must be one of the following basic types:</p>
<p>â¢</p>
<p>hex</p>
<p>â¢</p>
<p>binary</p>
<p>â¢</p>
<p>unsigned</p>
<p>â¢</p>
<p>signed</p>
<p>â¢</p>
<p>A defined enumeration type</p>
<p><i>MULTI: Debugging</i></p>
<p><i>790</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The register Section</b></p>
<p>A register definition must be in a register section. A register definition can have the</p>
<p>following elements:</p>
<p>register {</p>
<p><i>register_name</i> {</p>
<p>description =<i> string</i></p>
<p>help_key =<i> string</i></p>
<p>short_name =<i> string</i></p>
<p>alias = {<i>string_list</i>}</p>
<p>long_name =<i> string</i></p>
<p>gui_tab =<i> string</i></p>
<p>cache_value =<i> bool</i></p>
<p>access =<i> string</i></p>
<p>address =<i> number_or_string</i></p>
<p>offset =<i> string</i></p>
<p>address_port =<i> string</i></p>
<p>address_mask =<i> number_or_string</i></p>
<p>data_port =<i> string</i></p>
<p>width =<i> number_or_string</i></p>
<p>byte_endian =<i> string</i></p>
<p>bit_0_is_msb =<i> bool</i></p>
<p>permission =<i> string</i></p>
<p>type =<i> string</i></p>
<p>read_length =<i> number_or_string</i></p>
<p>write_length =<i> number_or_string</i></p>
<p>hide =<i> bool_or_string</i></p>
<p>memory_space =<i> number</i></p>
<p>}</p>
<p>}</p>
<p><b>Note</b></p>
<p>The</p>
<p>address</p>
<p>attribute is always required. Other attributes may be</p>
<p>required depending on the</p>
<p>access</p>
<p>type.</p>
<p>In the Debugger, each register has an identifier, which is usually defined</p>
<p>by the</p>
<p>address</p>
<p>attribute. When the Debugger communicates with a</p>
<p>debug server, a different register identifier may be used to refer to the</p>
<p>register, in which case, the identifier is defined by the</p>
<p>offset</p>
<p>setting.</p>
<p><i>791</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The register Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Some register attributes only apply to certain register types, as described</p>
<p>in the following table.</p>
<p>description =<i> string</i></p>
<p>description +=<i> string</i></p>
<p>desc =<i> string</i></p>
<p>desc +=<i> string</i></p>
<p>This is the register's description. It is displayed in Register Information window.</p>
<p>help_key =<i> string</i></p>
<p>hk =<i> string</i></p>
<p>This is the register's help key. MULTI 6 does not use this value, which is currently being reserved</p>
<p>for a future release.</p>
<p>short_name =<i> string</i></p>
<p>sn =<i> string</i></p>
<p>If a register's short name is defined, the short name instead of the tag name will be displayed in</p>
<p>Register Explorer windows.</p>
<p>alias = {<i>string_list</i>}</p>
<p>A register's aliases. They will be displayed in the<b> Register View</b> window, the Register</p>
<p>Information window, and the Register Search window.</p>
<p>long_name =<i> string</i></p>
<p>ln =<i> string</i></p>
<p>This is the register's long name. It is displayed in the following places:</p>
<p>â¢</p>
<p>As a tooltip in the<b> Register View</b> window</p>
<p>â¢</p>
<p>In the help pane of the Register Information window</p>
<p>gui_tab =<i> string</i></p>
<p>This setting allows a register to be associated with a<b> Register View</b> window tab. The Debugger</p>
<p>will create the specified tab and display the register in the tab.</p>
<p>cache_value =<i> bool</i></p>
<p>This setting indicates whether the Debugger can cache a register's value to improve performance</p>
<p>while the target is halted.</p>
<p>The default value is</p>
<p>true</p>
<p>, which is okay for most registers. For some special registers, such as</p>
<p>the timer, the setting should be defined as</p>
<p>false</p>
<p>so that when you manually refresh values</p>
<p>from the<b> Register View</b> window or print values in the Debugger window, the values can be</p>
<p>fetched from the target even though the corresponding process is stopped on the target.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>792</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>access =<i> string</i></p>
<p>The string must be one of the following strings or an expression that can be resolved into one</p>
<p>of the following strings:</p>
<p>â¢</p>
<p>regular</p>
<p>â [default] A physical register that is accessed through the debug server. The</p>
<p>address</p>
<p>syntax is</p>
<p><i>num</i>|<i>expr</i></p>
<p>, which resolves to the register number.</p>
<p>â¢</p>
<p>fpu</p>
<p>â A floating point register that is accessed through the debug server. The</p>
<p>address</p>
<p>syntax is</p>
<p><i>num</i>|<i>expr</i></p>
<p>, which resolves to the register number.</p>
<p>â¢</p>
<p>special</p>
<p>â A special coprocessor register that is accessed through the debug server. The</p>
<p>address</p>
<p>syntax is</p>
<p><i>num</i>|<i>expr</i></p>
<p>, which resolves to the register number.</p>
<p>â¢</p>
<p>io</p>
<p>â An input/output register that is accessed through the debug server. The</p>
<p>address</p>
<p>syntax is</p>
<p><i>num</i>|<i>expr</i></p>
<p>, which resolves to the register number.</p>
<p>â¢</p>
<p>synonym</p>
<p>â A synonym for another defined register. The</p>
<p>address</p>
<p>syntax is</p>
<p><i>name</i>|<i>expr</i></p>
<p>and resolves to the name of the register for which this register is a synonym.</p>
<p>â¢</p>
<p>memorymapped</p>
<p>â The contents of the register correspond to a location in memory. The</p>
<p>address</p>
<p>syntax is</p>
<p><i>num</i>|<i>name</i>|<i>expr</i></p>
<p>.</p>
<p>If the</p>
<p>address</p>
<p>field is a number, it indicates the address in memory of the start of the</p>
<p>register's contents.</p>
<p>If the</p>
<p>address</p>
<p>field is not a number, then it is assumed to be string containing a Debugger</p>
<p>expression that will evaluate to an address. This expression is evaluated dynamically each</p>
<p>time the register is accessed to produce an address, and may depend on other registers.</p>
<p>This expression is<i> not</i> surrounded by</p>
<p>%EVAL{}</p>
<p>.</p>
<p>An expression value surrounded by</p>
<p>%EVAL{}</p>
<p>is evaluated when the file is loaded, producing</p>
<p>either a numerical address or a string that contains a Debugger command to be evaluated</p>
<p>at run time to produce an address.</p>
<p>â¢</p>
<p>dynamic</p>
<p>â The contents of the register are obtained by evaluating a Debugger expression.</p>
<p>The</p>
<p>address</p>
<p>syntax is</p>
<p><i>name</i>|<i>expr</i></p>
<p>.</p>
<p>The value is a string that contains an expression in the language being debugged and which</p>
<p>is evaluated to produce the register's value each time the register is accessed. This expression</p>
<p>is<i> not</i> surrounded by</p>
<p>%EVAL{}</p>
<p>.</p>
<p>An expression value surrounded by</p>
<p>%EVAL{}</p>
<p>is evaluated when the file is loaded, producing</p>
<p>a string that contains a Debugger command to be evaluated at run time to produce a value.</p>
<p>â¢</p>
<p>indirect</p>
<p>â The register's value is obtained by writing its address into an address port</p>
<p>and reading its value from a data port. The</p>
<p>address</p>
<p>syntax is</p>
<p><i>num</i>|<i>expr</i></p>
<p>and resolves to</p>
<p>the control value to be written to the address port so the register value will be made available</p>
<p>on the data port.</p>
<p><i>793</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The register Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p>address =<i> number_or_string</i></p>
<p>For a register of type</p>
<p>regular</p>
<p>,</p>
<p>special</p>
<p>,</p>
<p>io</p>
<p>, or</p>
<p>fpu</p>
<p>, the address must be a number, or a string</p>
<p>that can be immediately resolved into a number.</p>
<p>For a</p>
<p>synonym</p>
<p>register, the address should be another register name or a string that can be</p>
<p>immediately resolved into another register name. The register name used here should not contain</p>
<p>the</p>
<p>$</p>
<p>prefix.</p>
<p>For a</p>
<p>memorymapped</p>
<p>register, the address must be a number, or an expression that can be</p>
<p>resolved into an address immediately or at the time it is accessed.</p>
<p>For a</p>
<p>dynamic</p>
<p>register, the address should be an expression that can be resolved into a number</p>
<p>immediately or at the time it is accessed.</p>
<p>For an</p>
<p>indirect</p>
<p>register, the address can be a number or an expression that can be resolved</p>
<p>into a number immediately or at the time it is accessed.</p>
<p>offset =<i> string</i></p>
<p>The value must be a string or an expression that can be resolved into a number when the register</p>
<p>is accessed.</p>
<p>The resolved number is the register's ID used by the Debugger to communicate with the debug</p>
<p>server.</p>
<p>If the setting is absent and</p>
<p>register_offset</p>
<p>is defined in the</p>
<p>general</p>
<p>section, then the</p>
<p>string value of</p>
<p>register_offset</p>
<p>from the</p>
<p>general</p>
<p>section will be used as the register's</p>
<p>offset.</p>
<p>address_port =<i> number_or_string</i></p>
<p>This setting defines an indirect register's address port.</p>
<p>The address port value must be a number, a register name or an expression that can be resolved</p>
<p>into a number or register name. If it is an expression that can be resolved into a register name,</p>
<p>it should be resolvable immediately.</p>
<p>address_mask =<i> number_or_string</i></p>
<p>This setting defines the mask for the control value to be written to an indirect register's address</p>
<p>port.</p>
<p>Its value must be a number or an expression that can be resolved into a number immediately.</p>
<p>data_port =<i> number_or_string</i></p>
<p>This setting defines an indirect register's data port, from which the indirect register's value is</p>
<p>read.</p>
<p>The data port value must be a number, a register name or an expression that can be resolved</p>
<p>into a register name or a number. If it is an expression that can be resolved into a register name,</p>
<p>it should be resolvable immediately.</p>
<p>An indirect register's data port and address port must both be register names or both be addresses.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>794</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>width =<i> number_or_string</i></p>
<p>This setting specifies a register's width in bits. If the attribute is not explicitly specified, the</p>
<p>default register width will be used.</p>
<p>The value must be a number or a string expression that can be immediately resolved into a</p>
<p>number.</p>
<p>byte_endian =<i> string</i></p>
<p>This setting defines a register's byte order, and overrides the byte order defined in the</p>
<p>general</p>
<p>section. For the available values and other details, see</p>
<p>byte_endian</p>
<p>attribute in âThe general</p>
<p>Sectionâ on page 777.</p>
<p>If the setting is absent, the byte order defined in the</p>
<p>general</p>
<p>section will be used for the register.</p>
<p>bit_0_is_msb =<i> bool</i></p>
<p>This setting defines a register's bit order.</p>
<p>If the value for</p>
<p>bit_0_is_msb</p>
<p>is true, bit 0 will refer to the register's most significant bit (msb),</p>
<p>and the largest bit number will refer to the register's least significant bit (lsb). Otherwise, bit 0</p>
<p>will refer to the register's least significant bit (lsb), and the largest bit number will refer to the</p>
<p>register's most significant bit (msb).</p>
<p>If the attribute is not explicitly specified, the default bit order defined in the</p>
<p>general</p>
<p>section</p>
<p>will be applied.</p>
<p><i>795</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The register Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p>permission =<i> string</i></p>
<p>The value must be a string in the syntax specified below or an expression which can be resolved</p>
<p>into such a string immediately:</p>
<p><i>action</i>/<i>permission</i>[/<i>user_mode</i>][;<i>action</i>/<i>permission</i>[/<i>user_mode</i>]]</p>
<p>where:</p>
<p>â¢</p>
<p><i>action</i></p>
<p>can be one of the following values:</p>
<p>â</p>
<p>read</p>
<p>â</p>
<p>write</p>
<p>â</p>
<p>both</p>
<p>[default]</p>
<p>â¢</p>
<p><i>permission</i></p>
<p>can be one of the following values:</p>
<p>â</p>
<p>none</p>
<p>â</p>
<p>once</p>
<p>â</p>
<p>full</p>
<p>[default]</p>
<p>â¢</p>
<p><i>user_mode</i></p>
<p>can be one of the following values:</p>
<p>â</p>
<p>user</p>
<p>â</p>
<p>supervisor</p>
<p>â</p>
<p>both</p>
<p>[default]</p>
<p>type =<i> string</i></p>
<p>The value must be one of the following strings or an expression that can be immediately resolved</p>
<p>into one of the strings:</p>
<p>â¢</p>
<p>unsigned</p>
<p>â¢</p>
<p>signed</p>
<p>â¢</p>
<p>A defined bitfield name</p>
<p>â¢</p>
<p>A defined enumeration name</p>
<p>â¢</p>
<p>A defined structure name</p>
<p>â¢</p>
<p>A pointer to one of the above types or a pointer to</p>
<p>void</p>
<p>, such as</p>
<p>unsigned *</p>
<p>or</p>
<p>void</p>
<p>*</p>
<p>read_length =<i> number_or_string</i></p>
<p>The value must be a number or an expression that can be resolved into a number immediately.</p>
<p>The attribute is only valid for</p>
<p>memorymapped</p>
<p>registers or</p>
<p>indirect</p>
<p>registers located in memory.</p>
<p>If no read length is specified for such registers, the default read block length is the length of the</p>
<p>whole register.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>796</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>write_length =<i> number_or_string</i></p>
<p>The value must be a number or an expression that can be resolved into a number immediately.</p>
<p>The attribute is only valid for</p>
<p>memorymapped</p>
<p>registers or</p>
<p>indirect</p>
<p>registers located in memory.</p>
<p>If no write length is specified for such registers, the default write block length is the length of</p>
<p>the whole register.</p>
<p>hide =<i> bool_or_string</i></p>
<p>The value must be a Boolean value or a string expression that can be resolved into a Boolean</p>
<p>immediately.</p>
<p>This setting indicates whether a register should be hidden or displayed.</p>
<p>memory_space =<i> number</i></p>
<p>This setting defines the memory space for memory-mapped registers.</p>
<p>For more information, see the</p>
<p>memory_space</p>
<p>attribute in âThe general Sectionâ on page 777.</p>
<p><b>The group Section</b></p>
<p>Registers appear in groups. A register must be included in at least one group, but</p>
<p>a register can appear in multiple groups, if desired. If a register is not explicitly</p>
<p>included by any group, it will be included in a default group named</p>
<p>Ungrouped</p>
<p>.</p>
<p>A group can contain other groups as well as registers. A group can be included by</p>
<p>at most one other group. If a group is not included by any other group, it is a top-level</p>
<p>group. A group must contain at least one register or group; otherwise, it will be</p>
<p>automatically hidden.</p>
<p>Groups and registers compose the hierarchy in the Debugger's<b> Register View</b></p>
<p>window.</p>
<p><i>797</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The group Section</i></p>
<h1 style="page-break-before:always; "></h1>
<p>A group definition can have the following elements:</p>
<p>group {</p>
<p><i>group_name</i> {</p>
<p>description =<i> string</i></p>
<p>help_key =<i> string</i></p>
<p>short_name =<i> string</i></p>
<p>long_name =<i> string</i></p>
<p>top_level_index =<i> number_or_string</i></p>
<p>collapse =<i> bool_or_string</i></p>
<p>register = {<i>registers</i>}</p>
<p>group = {<i>groups</i>}</p>
<p>}</p>
<p>...</p>
<p>}</p>
<p><b>Note</b></p>
<p>All attributes are optional.</p>
<p>description =<i> string</i></p>
<p>description +=<i> string</i></p>
<p>desc =<i> string</i></p>
<p>desc +=<i> string</i></p>
<p>This is the group's description. MULTI 6 does not use this value, which is currently being</p>
<p>reserved for a future release.</p>
<p>help_key =<i> string</i></p>
<p>hk =<i> string</i></p>
<p>This is the group's help key. MULTI 6 does not use this value, which is currently being reserved</p>
<p>for a future release.</p>
<p>short_name =<i> string</i></p>
<p>sn =<i> string</i></p>
<p>The value must be a string or an expression that can be immediately resolved into a string.</p>
<p>If group's short name is defined, it will be used to represent the group in the Debugger's<b> Register</b></p>
<p><b>View</b> window, otherwise, the group's tag name is used.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>798</i></p>
<p><i>Appendix F. Register Definition and Configuration Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>long_name =<i> string</i></p>
<p>ln =<i> string</i></p>
<p>The value must be a string or an expression that can be immediately resolved into a string.</p>
<p>A group's long name is displayed in a tooltip in the<b> Register View</b> window.</p>
<p>top_level_index =<i> number_or_string</i></p>
<p>The value must be a number or a string expression that can be immediately resolved into a</p>
<p>number.</p>
<p>The attribute will be used to determine the group's position at top level if it is a top-level group,</p>
<p>or inside a group if it is included by another group.</p>
<p>collapse =<i> bool_or_string</i></p>
<p>The value must be a Boolean or a string expression that can be immediately resolved into a</p>
<p>Boolean.</p>
<p>If this attribute is</p>
<p>true</p>
<p>, the Debugger collapses the group. If</p>
<p>false</p>
<p>, the Debugger expands the</p>
<p>group. The default value for groups created on the fly is</p>
<p>false</p>
<p>. Otherwise, the default value is</p>
<p>true</p>
<p>.</p>
<p><b>Note</b>: In GRD files with a</p>
<p>version</p>
<p>of</p>
<p>1</p>
<p>or</p>
<p>2</p>
<p>, the Debugger initially collapses all nested groups</p>
<p>and expands all top-level groups, regardless of the specification in the GRD file. In GRD files</p>
<p>with a</p>
<p>version</p>
<p>of</p>
<p>3</p>
<p>, the Debugger follows the specification in the GRD file.</p>
<p><b>Note</b>: The<b> Register View</b> window remembers the value of this attribute across debugging</p>
<p>sessions for targets of the same type. This information overrides the specification in the GRD</p>
<p>file.</p>
<p>register = {<i>registers</i>}</p>
<p>register += {<i>registers</i>}</p>
<p>The strings used in the value to represent registers must be register tag names. The registers</p>
<p>listed in the value must be defined.</p>
<p>group = {<i>groups</i>}</p>
<p>group += {<i>groups</i>}</p>
<p>The strings used in the value to represent groups must be group tag names. The groups listed</p>
<p>in the value must be defined.</p>
<p><i>799</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The group Section</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Appendix G</b></p>
<p><b>Integrate Views</b></p>
<p><b>Contents</b></p>
<p>Integrate Security View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>802</p>
<p>Integrate Relationship View . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>802</p>
<h1 style="page-break-before:always; "></h1>
<p>The Integrate GUI provides an easy way to create a customized configuration file</p>
<p>based on the specific requirements of your INTEGRITY application. In MULTI 6,</p>
<p>the stand-alone Integrate application adds two new views and the ability to group</p>
<p>objects into collections. This appendix briefly describes each of these views and</p>
<p>explains collections. Note that the lightweight version of the Integrate utility that</p>
<p>appears in the<b> Integrate</b> tab of the MULTI Project Manager does not enable these</p>
<p>new features.</p>
<p><b>Integrate Security View</b></p>
<p>Security view displays relationships between AddressSpaces and AddressSpace</p>
<p>collections defined in the Integrate file, thereby helping you to find unintended</p>
<p>avenues of communication between AddressSpaces. An example is shown next.</p>
<p>Lines between AddressSpaces or AddressSpace collections indicate a relationship.</p>
<p>A double-sided arrow is displayed between any two AddressSpaces or collections</p>
<p>that contain underlying linked objects. Linked objects include connection pairs,</p>
<p>links to objects, and mapped MemoryRegions.</p>
<p><b>Integrate Relationship View</b></p>
<p>Relationship view displays relationships between a central AddressSpace or</p>
<p>AddressSpace collection and other AddressSpaces or AddressSpace collections.</p>
<p>This view allows you to edit individual AddressSpaces, collections, and underlying</p>
<p>objects while minimizing the number of lines drawn on the screen. An example is</p>
<p>shown next.</p>
<p><i>MULTI: Debugging</i></p>
<p><i>802</i></p>
<p><i>Appendix G. Integrate Views</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Collections of AddressSpaces may be featured in both security view and in</p>
<p>relationship view, but in relationship view, other objects are also automatically</p>
<p>grouped by type into collections. A collection is a GUI-only, hierarchical grouping</p>
<p>of objects that are defined in your Integrate file. You can also create your own</p>
<p>collection of objects within an AddressSpace.</p>
<p>Collections ease viewing by giving you the ability to contract everything but the</p>
<p>one or two objects that require closer examination. This is especially helpful when</p>
<p>your file contains many objects. To expand or contract a hierarchy, click the<b> +</b>/<b>-</b></p>
<p>box.</p>
<p><i>803</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Integrate Relationship View</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Index</b></p>
<p><b>Symbols</b></p>
<p>&gt; (greater than sign)</p>
<p>in C++ classes, 195</p>
<p># (number sign) variable search designator, 293, 298</p>
<p>$ (dollar sign) variable search designator, 298</p>
<p>* (asterisk) wildcard character, 303</p>
<p>-- (minus sign-double) command line option, 722</p>
<p>-&gt;* (minus sign, right angle bracket, asterisk) operator, 296</p>
<p>. (period) variable search designator, 299</p>
<p>.* (period, asterisk) operator, 296</p>
<p>/* */ (slash, asterisk-double, slash) comments, 295</p>
<p>// (slash-double) comments, 295</p>
<p>: (colon) variable search designator, 298</p>
<p>:: (colon-double) variable search designator, 298</p>
<p>&lt; (left angle bracket) command</p>
<p>menu equivalent, 690</p>
<p>= (equal sign) operator, 294</p>
<p>== (equal sign-double) operator, 294</p>
<p>&gt; (right angle bracket) command</p>
<p>menu equivalent, 689, 690</p>
<p>&gt;&gt; (right angle bracket-double) command</p>
<p>menu equivalent, 689, 690</p>
<p>? (question mark)</p>
<p>wildcard character, 303</p>
<p>@ (at sign) wildcard character, 303</p>
<p><b>A</b></p>
<p>Abort Trace Retrieval menu item, 683</p>
<p>About banner</p>
<p>disabling with -nosplash, 725</p>
<p>About dialog box, 691</p>
<p>About MULTI menu item, 691</p>
<p>active group, 177, 180</p>
<p>addhook command, 94</p>
<p>address bus walking test, 525</p>
<p>addresses</p>
<p>source, expressing in Debugger, 293</p>
<p>viewing program at, 163, 677</p>
<p>AddressSpaces</p>
<p>freeze-mode (OSA), 16</p>
<p>profiling, 355, 359</p>
<p>run-mode, 581</p>
<p>in Trace List, 436</p>
<p>viewing individually in PathAnalyzer, 434</p>
<p>Advanced Event Editor</p>
<p>complex events, specifying, 443, 497, 504</p>
<p>count expressions, creating, 505</p>
<p>event type descriptions, 501</p>
<p>exception type descriptions, 502</p>
<p>resources, creating, 498, 499</p>
<p>state machine expressions, inserting, 506</p>
<p>state machine resources, creating, 502</p>
<p>All Types menu item, 679</p>
<p>alternate directories</p>
<p>ignoring with -D, 723</p>
<p>specifying for search with -I, 724</p>
<p>annotations (see Debugger Notes)</p>
<p>ANSICMODE system variable, 310</p>
<p>any-task breakpoints</p>
<p>freeze-mode, 420, 618</p>
<p>run-mode, setting, 587</p>
<p>arguments</p>
<p>passing with -- (minus sign-double), 722</p>
<p>Arguments dialog box, 668</p>
<p>arrays in Data Explorer, 193</p>
<p>arrows in source pane, 22, 123</p>
<p>_ASMCACHE system variable, 312</p>
<p>assem command, 677</p>
<p>Assembly button, 694</p>
<p>assembly code</p>
<p>infinite scrolling, 156</p>
<p>interlaced with source code, 23</p>
<p>viewing in Debugger, 23</p>
<p>Assembly Only menu item, 677</p>
<p>associating executable and connection</p>
<p>methods for, 105</p>
<p>on multi-core system, 626, 627</p>
<p>asterisk (*) wildcard character, 303</p>
<p>at sign (@) wildcard character, 303</p>
<p>Attach on Fork/Thread menu item, 670</p>
<p>Attach on Task Creation menu item, 672</p>
<p>Attach to Process menu item, 662</p>
<p>attaching to a process, 662</p>
<p>with -P, 725</p>
<p>attaching to a task, 582</p>
<p>Auto Check Coherency menu item, 671</p>
<p>Auto Update Views menu item, 676</p>
<p>_AUTO_CHECK_COHERENCY system variable, 312</p>
<p>_AUTO_CHECK_NUM_ADDRS system variable, 312</p>
<h1 style="page-break-before:always; "></h1>
<p><b>B</b></p>
<p>bc command, 416</p>
<p>bcU command, 416</p>
<p>beeping</p>
<p>in incremental Debugger search, 157</p>
<p>bitfield definitions</p>
<p>changing, 276</p>
<p>block detailed profiling report, 370</p>
<p>board setup scripts</p>
<p>commands for, 94</p>
<p>created by Project Wizard, 90</p>
<p>creating custom, 90</p>
<p>early, 101</p>
<p>editing, 91</p>
<p>example, 96</p>
<p>MULTI (.mbs) vs. legacy (.dbs), 91, 98</p>
<p>multi-core system, 623</p>
<p>need for, 90</p>
<p>running manually, 101</p>
<p>running on connection, 99, 100</p>
<p>testing, 94</p>
<p>bookmarking trace data, 432, 444, 445, 446, 448</p>
<p>Bookmarks menu item, 691</p>
<p>$bp_adr() special operator, 318</p>
<p>bprev command, 416</p>
<p>bpview command, 128</p>
<p>_BREAK system variable, 314</p>
<p>breakdots, 22, 125</p>
<p>shortcut menu for, 707</p>
<p>breakpoints, 124</p>
<p>(see also Breakpoints window)</p>
<p>any-task, freeze-mode, 420, 618</p>
<p>any-task, run-mode, 587</p>
<p>deleting, 129</p>
<p>disabling, 127</p>
<p>enabling, 127</p>
<p>freeze-mode, 420, 618</p>
<p>hardware, 133</p>
<p>(see also hardware breakpoints)</p>
<p>information about, 128</p>
<p>jump, 707</p>
<p>listing, 678</p>
<p>markers, 22, 125</p>
<p>moving (see software breakpoints)</p>
<p>overview, 124</p>
<p>restoring deleted, 137</p>
<p>run-mode, 587</p>
<p>run-mode, group, 588, 589</p>
<p>Separate Session TimeMachine, 422</p>
<p>setting basic, 22, 129</p>
<p>shared between TimeMachine and live target, 417</p>
<p>shared object, 136</p>
<p>software, 128</p>
<p>(see also software breakpoints)</p>
<p>task groups, using when setting, 589</p>
<p>task-specific, 420, 587, 618</p>
<p>toggling status of, 127</p>
<p>Breakpoints button, 128, 695</p>
<p>Breakpoints menu item</p>
<p>in View menu, 128, 673</p>
<p>in ViewList submenu, 678</p>
<p>Breakpoints Restore window, 152</p>
<p>Breakpoints window, 128</p>
<p>(see also breakpoints)</p>
<p>hardware breakpoints, 133, 135, 146, 148, 149, 150</p>
<p>opening, 128, 673</p>
<p>shared object breakpoints, 136, 146, 148, 149, 150</p>
<p>shortcut menus, 150</p>
<p>software breakpoints, 131, 146, 148, 149, 150</p>
<p>tracepoints, 571, 572, 573</p>
<p>browse command, 377</p>
<p>Browse menu, 679</p>
<p>Browse window</p>
<p>cross references, browsing, 236, 238</p>
<p>data types, browsing, 233, 234, 235</p>
<p>filtering content in, 216, 217, 218, 219</p>
<p>global variables, browsing, 228, 230</p>
<p>headings, 220, 227, 233, 235</p>
<p>menus, 215</p>
<p>overview, 214</p>
<p>procedure ambiguities, 227</p>
<p>procedures, browsing, 166, 220, 222, 224, 227</p>
<p>source files, browsing, 165, 230, 231, 232, 233</p>
<p>browsing</p>
<p>calls, classes (see Tree Browser)</p>
<p>classes, includes (see Graph View window)</p>
<p>cross references, data types, global variables, procedures,</p>
<p>source files (see Browse window)</p>
<p>trace data, 431, 451, 452, 454, 456, 457</p>
<p>bs command, 417</p>
<p>-build command line option, 722</p>
<p>buttons, 691</p>
<p>(see also toolbar)</p>
<p>adding to toolbar, 698</p>
<p>commands for, 716</p>
<p>configuring, 698</p>
<p>in Debugger, 692</p>
<p>removing from toolbar, 698</p>
<p>reprogramming, 700</p>
<p><i>MULTI: Debugging</i></p>
<p><i>806</i></p>
<p><i>bc command</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>C</b></p>
<p>c command, 94</p>
<p>-c command line option, 722</p>
<p>-C command line option, 722</p>
<p>C++</p>
<p>application, TimeMachine API, 473</p>
<p>classes in Data Explorer, 195, 196</p>
<p>command line procedure calls, caveats for, 306</p>
<p>expressions and language dependencies, viewing, 303</p>
<p>expressions, caveats for, 296</p>
<p>unsupported operators, casts, destructors in expressions,</p>
<p>296, 306</p>
<p>Cache Find window, 396</p>
<p>Cache Memory Reads menu item, 671</p>
<p>_CACHE system variable, 313</p>
<p>Cache View window, 392</p>
<p>caches</p>
<p>searching, 392, 396</p>
<p>viewing, 392, 396</p>
<p>Caches menu item, 675</p>
<p>call count profiling data, 354, 355, 360, 475</p>
<p>call graph</p>
<p>profiling data, 354, 355, 475</p>
<p>profiling report, 367</p>
<p>Call Stack button, 695</p>
<p>Call Stack menu item, 673</p>
<p>Call Stack window</p>
<p>buttons, 388</p>
<p>call stack pane, 389</p>
<p>call stack, viewing, 388</p>
<p>command line procedure calls, 389</p>
<p>functions, listing, 695</p>
<p>interrupt/exception handlers, 390</p>
<p>opening, 388, 673</p>
<p>procedure prologues and epilogues, 390</p>
<p>calls</p>
<p>browsing, 213, 244, 245, 246</p>
<p>casts, in C++</p>
<p>not supported in expressions, 296</p>
<p>caveats</p>
<p>for command line procedure calls, 306</p>
<p>for expressions, 294</p>
<p>for profiling, 360</p>
<p>.cfg files, ignoring with -nocfg, 724</p>
<p>classes</p>
<p>browsing, 213, 243</p>
<p>Classes menu item, 679</p>
<p>Clear Data menu item, 683</p>
<p>Clear User Default Configuration menu item, 687</p>
<p>clearhooks command, 94</p>
<p>clearing</p>
<p>profiling data, 384</p>
<p>trace, 410</p>
<p>Close All Views menu item, 676</p>
<p>Close Debugger button, 697</p>
<p>Close Debugger Window menu item, 663</p>
<p>Close Entry menu item, 662</p>
<p>closing multiple windows, 676</p>
<p>-cmd command line option, 722</p>
<p>Cmd pane, 28</p>
<p>coherency checking, 536</p>
<p>collecting</p>
<p>OS trace data, 406</p>
<p>profiling data, 356, 357, 358, 359</p>
<p>trace, 405</p>
<p>collections, Integrate, 803</p>
<p>colon (:) variable search designator, 298</p>
<p>colon-double (::) variable search designator, 298</p>
<p>command groups</p>
<p>register commands, 282</p>
<p>command line</p>
<p>starting MULTI from, 6, 722</p>
<p>command line options</p>
<p>-- (minus sign-double), 722</p>
<p>-build, 722</p>
<p>-c, 722</p>
<p>-C, 722</p>
<p>-cmd, 722</p>
<p>-config, 722</p>
<p>-configure, 722</p>
<p>-connect, 7, 723</p>
<p>-connectfile, 723</p>
<p>-D, 723</p>
<p>-data, 723</p>
<p>-display, 7, 723</p>
<p>-e, 723</p>
<p>-E, 724</p>
<p>-h, 7, 724</p>
<p>-H, 7, 724</p>
<p>-help, 7, 724</p>
<p>-I, 724</p>
<p>listing with -h, 7, 724</p>
<p>-m, 724, 728</p>
<p>minus sign-double (--), 722</p>
<p>-nocfg, 724</p>
<p>-nodisplay, 724</p>
<p>-norc, 7, 725</p>
<p>-noshared, 725</p>
<p>-nosplash, 725</p>
<p>-osa, 607, 725</p>
<p>-p, 7, 725</p>
<p><i>807</i></p>
<p><i>Green Hills Software</i></p>
<p><i>c command</i></p>
<h1 style="page-break-before:always; "></h1>
<p>-P, 725</p>
<p>passing in a specification file, 727</p>
<p>(see also -m command line option)</p>
<p>-preload, 725</p>
<p>-r, 725</p>
<p>-R, 726</p>
<p>-rc, 726</p>
<p>-RO, 726</p>
<p>-run, 726</p>
<p>-servertimeout, 726</p>
<p>-socket, 726</p>
<p>-text, 726</p>
<p>-top, 727</p>
<p>-tv, 727</p>
<p>-usage, 727</p>
<p>-V, 727</p>
<p>command line procedure calls</p>
<p>call stack for, 389</p>
<p>caveats for, 306</p>
<p>in Debugger, 304</p>
<p>unsupported class members, operators in C++, 306</p>
<p>command pane</p>
<p>Debugger, 28, 172</p>
<p>shortcut menus, 712</p>
<p>shortcuts, 29, 718</p>
<p>command script, reading on startup, 726</p>
<p>commands</p>
<p>&lt; (left angle bracket)</p>
<p>menu equivalent, 690</p>
<p>&gt; (right angle bracket)</p>
<p>menu equivalent, 689, 690</p>
<p>&gt;&gt; (right angle bracket-double)</p>
<p>menu equivalent, 689, 690</p>
<p>addhook, 94</p>
<p>assem, 677</p>
<p>b, 130</p>
<p>bc, 416</p>
<p>bcU, 416</p>
<p>board setup script, 94</p>
<p>bprev, 416</p>
<p>bpview, 128</p>
<p>browse, 377</p>
<p>bs, 417</p>
<p>c, 94</p>
<p>clearhooks, 94</p>
<p>connect -restart_runmode, 71</p>
<p>dataview, 746, 747, 767</p>
<p>Debugger button equivalents, 716</p>
<p>dialogsearch, 712</p>
<p>dvclear, 745</p>
<p>dvload, 745</p>
<p>dvprofile, 744, 766</p>
<p>e, 163</p>
<p>edithwbp, 134</p>
<p>editswbp, 130</p>
<p>eval, 94</p>
<p>flash gui, 541</p>
<p>h, 689</p>
<p>halt, 95</p>
<p>hook, 101, 623</p>
<p>left angle bracket (&lt;)</p>
<p>menu equivalent, 690</p>
<p>legacy debug scripts, 91</p>
<p>memread, 95</p>
<p>memtest, 535</p>
<p>memwrite, 95</p>
<p>passive, 574, 575</p>
<p>profdump, 377, 382</p>
<p>profile, 357, 359</p>
<p>profilemode, 373, 374, 375, 376, 377, 378, 381, 382, 383, </p>
<p>384</p>
<p>profilereport, 363, 364, 372</p>
<p>recording to playback files, 725, 726</p>
<p>reset, 95</p>
<p>restore, 689</p>
<p>right angle bracket (&gt;)</p>
<p>menu equivalent, 689, 690</p>
<p>right angle bracket-double (&gt;&gt;)</p>
<p>menu equivalent, 689, 690</p>
<p>save, 689</p>
<p>sb, 587, 619</p>
<p>serialconnect, 686</p>
<p>serialdisconnect, 686</p>
<p>set_runmode_partner, 71</p>
<p>target, 95</p>
<p>TimeMachine run-control, 416</p>
<p>timemachine, 414, 415, 418, 422</p>
<p>tpdel, 564</p>
<p>tpenable, 565</p>
<p>tplist, 564</p>
<p>tpprint, 566</p>
<p>tppurge, 567</p>
<p>tpreset, 565</p>
<p>tpset, 562, 568, 570, 571</p>
<p>trace abort, 408</p>
<p>trace clear, 411</p>
<p>trace disable, 406</p>
<p>trace enable, 406</p>
<p>trace retrieve, 408</p>
<p>traceload, 450</p>
<p>tracemevsys, 475</p>
<p>tracepro, 358</p>
<p><i>MULTI: Debugging</i></p>
<p><i>808</i></p>
<p><i>command line options (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>tracesave, 449</p>
<p>update, 189</p>
<p>view, 184</p>
<p>viewdel, 185</p>
<p>viewlist, 192</p>
<p>wait, 95</p>
<p>comments</p>
<p>in expressions, 295</p>
<p>Compare menu item, 682</p>
<p>compare test, CRC, 533</p>
<p>compilers</p>
<p>generating debugging information, 5</p>
<p>complex events, specifying with Advanced Event Editor,</p>
<p>443, 497, 504</p>
<p>compressed target list display, 17</p>
<p>compute test, CRC, 532</p>
<p>concise display pane in Register Information window, 272</p>
<p>conditionally not-executed instructions, 123</p>
<p>-config command line option, 722</p>
<p>Config menu, 687</p>
<p>configuration file, 722</p>
<p>configuration options</p>
<p>Initial Position (XxY), 200</p>
<p>Maximum initial size (WxH), 200</p>
<p>Minimum initial size (WxH), 200</p>
<p>osaSwitchToUserTaskAutomatically, 614</p>
<p>osaTaskAutoAttachLimit, 614</p>
<p>ProcRelativeLines, 24</p>
<p>-configure command line option, 722</p>
<p>Configure Trace Interval window, 492</p>
<p>configuring</p>
<p>buttons, 698</p>
<p>line numbers in source pane, 24</p>
<p>MULTI with -c, 722</p>
<p>toolbar, 698</p>
<p>connect -restart_runmode command, 71</p>
<p>-connect command line option, 7, 723</p>
<p>Connect menu item, 680</p>
<p>connected targets</p>
<p>managing from Connection Organizer, 54</p>
<p>-connectfile command line option, 723</p>
<p>connecting</p>
<p>from Connection Organizer, 54</p>
<p>to debug server with -connect, 7, 723</p>
<p>to hardware (freeze mode) and OS (run mode), 69</p>
<p>troubleshooting, 73</p>
<p>to OS (run mode), 578</p>
<p>to process with -P, 725</p>
<p>to serial port (see serial connections)</p>
<p>to simulator, 41</p>
<p>to target</p>
<p>Custom Connection Method, 47</p>
<p>Standard Connection Method, 45</p>
<p>Temporary Connection Method, 49</p>
<p>connecting MULTI to your target</p>
<p>through a terminal server, 68</p>
<p>Connection Chooser</p>
<p>creating Custom Connection Method, 47</p>
<p>creating Standard Connection Method, 43</p>
<p>opening, 43</p>
<p>Connection Editor</p>
<p>configuring Standard Connection Method, 44</p>
<p>INDRT (rtserv), 80, 81, 82, 83</p>
<p>INDRT2 (rtserv2), 62, 63, 64</p>
<p>opening, 44</p>
<p>Connection Files, 52</p>
<p>Connection Methods</p>
<p>connecting with, 45, 54</p>
<p>creating, 52</p>
<p>Custom, 42, 47</p>
<p>custom</p>
<p>INDRT (rtserv), 86</p>
<p>INDRT2 (rtserv2), 66, 67, 68</p>
<p>editing, 44, 52</p>
<p>INDRT (rtserv), 80, 81, 82, 83</p>
<p>INDRT2 (rtserv2), 62, 63, 64</p>
<p>examples</p>
<p>INDRT2 (rtserv2), 68, 69</p>
<p>overview, 40</p>
<p>Serial, 644, 646, 647, 649</p>
<p>Standard, 42, 43, 44</p>
<p>Temporary, 49</p>
<p>Connection Organizer</p>
<p>connected targets in, 54, 57</p>
<p>connecting to target from, 54</p>
<p>Connection Files in, 52, 55</p>
<p>Connection Methods in, 52, 56</p>
<p>opening, 50</p>
<p>CONTINUECOUNT system variable, 310</p>
<p>CONTINUING status bar message, 36</p>
<p>conventions</p>
<p>typographical, xxvi</p>
<p>converting debugging information (see translating, debugging</p>
<p>information)</p>
<p>Copy menu item, 681</p>
<p>copying text</p>
<p>in main Debugger window, 161</p>
<p>core file</p>
<p>debugging, 117</p>
<p>specifying with -C, 722</p>
<p>cores, multiple (see multi-core systems)</p>
<p>coverage analysis profiling data, 354, 355, 360, 475</p>
<p><i>809</i></p>
<p><i>Green Hills Software</i></p>
<p><i>commands (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>coverage profiling report, 369</p>
<p>CPU % target list column, 20, 603</p>
<p>CRC compare test, 533</p>
<p>CRC compute test, 532</p>
<p>cross references</p>
<p>browsing, 213, 236, 238</p>
<p>current line pointer, 22</p>
<p>Current PC menu item, 163, 676</p>
<p>_CURRENT_TASKID system variable, 314</p>
<p>Custom Connection Methods, 42, 47</p>
<p>Customize Menus menu item, 687</p>
<p>Customize Toolbar menu item, 687</p>
<p>Customize Toolbar window, 698</p>
<p>cutting text in Debugger windows, 160</p>
<p><b>D</b></p>
<p>-D command line option, 723</p>
<p>data bus walking test, 527</p>
<p>-data command line option, 723</p>
<p>data descriptions</p>
<p>MULTI data visualization (.mdv) files, 743, 747</p>
<p>Data Explorer</p>
<p>activating variables, 186, 189</p>
<p>adding variables to, 187</p>
<p>arrays, viewing, 193</p>
<p>buttons, 186</p>
<p>C++ classes, viewing, 195</p>
<p>closing, 184</p>
<p>custom, 742, 746</p>
<p>dimensions, 198, 200</p>
<p>edit bar, 187</p>
<p>freezing variables, 186, 189</p>
<p>global options for, 199</p>
<p>limiting data complexity, 199</p>
<p>linked lists, viewing, 191</p>
<p>messages, 200</p>
<p>modifying variables in, 187, 198</p>
<p>opening, 184, 188</p>
<p>pointers, viewing, 193, 196</p>
<p>structures, viewing, 190</p>
<p>toolbar, 186</p>
<p>types, changing, 195</p>
<p>updating, 189</p>
<p>viewing multiple items in, 188</p>
<p>window, 185</p>
<p>... Data Explorer message, 200</p>
<p>data offsets, position-independent data (PID)</p>
<p>specifying with -data, 723</p>
<p>specifying with _DATA, 313</p>
<p>specifying with Data Offset, 112</p>
<p>data pattern test, 529</p>
<p>_DATA system variable, 313</p>
<p>data types</p>
<p>browsing, 213, 214, 233, 234, 235</p>
<p>profiling, 354</p>
<p>data visualization (see MULTI data visualization)</p>
<p>data visualization profile, 744, 766</p>
<p>dataview command, 746, 747, 767</p>
<p>Dead Data Explorer message, 200</p>
<p>Debug menu, 665</p>
<p>Debug Program as New Entry menu item, 661</p>
<p>Debug Program menu item, 661</p>
<p>debug servers</p>
<p>connecting to with -connect, 7, 723</p>
<p>debugging interfaces supported by, 90</p>
<p>setting default timeout with -servertimeout, 726</p>
<p>starting, 47, 49</p>
<p>use, 42</p>
<p>Debug Settings menu item, 668</p>
<p>Debug Translator</p>
<p>translating debugging information, 730</p>
<p>DebugBrk target list status, 19</p>
<p>Debugger, 4</p>
<p>(see also debugging)</p>
<p>command line options (see command line options)</p>
<p>connecting to your target, 40</p>
<p>graphical (GUI) mode, 6, 7, 723</p>
<p>menus (see Debugger menus)</p>
<p>non-GUI mode, 8, 724</p>
<p>notes in code (see Debugger Notes)</p>
<p>overview, 4</p>
<p>passive mode, 574, 575</p>
<p>searching source, 167, 712</p>
<p>special operators, 317</p>
<p>starting, 5</p>
<p>system variables, 310, 312</p>
<p>version information, 727</p>
<p>window (see Debugger window)</p>
<p>Debugger Help menu item, 691</p>
<p>Debugger menus</p>
<p>Browse, 679</p>
<p>Config, 687</p>
<p>Debug, 665</p>
<p>File, 661</p>
<p>Help, 691</p>
<p>Target, 680</p>
<p>TimeMachine, 683</p>
<p>Tools, 685</p>
<p>View, 673</p>
<p>Windows, 690</p>
<p>Debugger Notes</p>
<p><i>MULTI: Debugging</i></p>
<p><i>810</i></p>
<p><i>coverage profiling report</i></p>
<h1 style="page-break-before:always; "></h1>
<p>browsing, 178</p>
<p>creating, 174</p>
<p>editing, 174, 176</p>
<p>grouping, 177, 178</p>
<p>markers, 22</p>
<p>overview, 174</p>
<p>properties, 174</p>
<p>Debugger Notes menu item, 675</p>
<p>Debugger window</p>
<p>assembly code, viewing, 23</p>
<p>breakdots, 22, 125</p>
<p>breakpoint markers, 126, 129</p>
<p>button-command equivalents, 716</p>
<p>buttons, 691, 692</p>
<p>(see also buttons)</p>
<p>navigation buttons, 167</p>
<p>closing, 663</p>
<p>command pane, 28, 172</p>
<p>controlling process from, 122</p>
<p>copying text, 161</p>
<p>current line pointer, 22</p>
<p>cutting text, 160</p>
<p>Debugger Note marker, 22</p>
<p>File Locator, 164</p>
<p>I/O pane, 30</p>
<p>information pane, 13, 26</p>
<p>interlaced assembly code, viewing, 23</p>
<p>line numbers, 21, 24</p>
<p>menu bar, 13, 660</p>
<p>(see also Debugger menus)</p>
<p>navigation bar, 13, 25</p>
<p>navigation buttons, 167</p>
<p>opening, 5</p>
<p>opening multiple, 14</p>
<p>output pane, 13, 26</p>
<p>overview, 12</p>
<p>pasting text, 160, 161</p>
<p>PC pointer, 22, 123</p>
<p>Procedure Locator, 165</p>
<p>python pane, 32</p>
<p>reusing, 14</p>
<p>scroll bar with diamond, 156</p>
<p>selecting text, 160, 161</p>
<p>serial terminal pane, 31</p>
<p>shortcut menus, 704, 705, 707, 708, 709, 710, 711, 712</p>
<p>shortcuts, 716</p>
<p>source code, viewing, 23</p>
<p>source pane, 13, 21, 162</p>
<p>(see also source pane)</p>
<p>status bar, 14, 36</p>
<p>target list, 15</p>
<p>(see also target list)</p>
<p>target pane, 30</p>
<p>toolbar (see toolbar)</p>
<p>tracepoint markers, 126</p>
<p>traffic pane, 33</p>
<p>debugging</p>
<p>core files, 117</p>
<p>disabling for shared libraries with -noshared, 725</p>
<p>in freeze mode, 606</p>
<p>(see also freeze-mode debugging)</p>
<p>multi-core systems, 620</p>
<p>(see also multi-core systems)</p>
<p>multiple files with -E, 724</p>
<p>multiple-language applications, 294</p>
<p>multitasking applications, 606</p>
<p>native processes, 390</p>
<p>non-intrusively with tracepoints, 560</p>
<p>operating systems (see freeze-mode debugging) (see</p>
<p>run-mode debugging)</p>
<p>in passive mode, 574, 575</p>
<p>preliminary steps, 5</p>
<p>programs compiled with third-party tools, 730</p>
<p>programs with specification files, 727</p>
<p>(see also -m command line option)</p>
<p>real-time operating systems</p>
<p>INDRT (rtserv), 78</p>
<p>INDRT2 (rtserv2), 60</p>
<p>ROM programs, 554</p>
<p>in run mode, 578</p>
<p>(see also run-mode debugging)</p>
<p>run-mode</p>
<p>INDRT (rtserv), 78</p>
<p>INDRT2 (rtserv2), 60</p>
<p>tasks, 583</p>
<p>debugging information, 5</p>
<p>generated by third-party tools, 730</p>
<p>debugging interfaces</p>
<p>debug servers associated with, 90</p>
<p>DEBUGSHARED system variable, 311</p>
<p>default.con file, 42</p>
<p>Defines menu item, 678</p>
<p>Delete all view windows button, 700</p>
<p>DEREFPOINTER system variable, 311</p>
<p>destructors in C++, 296</p>
<p>Detach from Process menu item, 662</p>
<p>detailed display pane in Register Information window, 273</p>
<p>Dialog Boxes menu item, 678</p>
<p>dialog boxes, listing, 678</p>
<p>dialogsearch command, 712</p>
<p>diamond on Debugger scroll bar, 156</p>
<p>Direct hardware access target list message, 18</p>
<p><i>811</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Debugger Notes (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>directories, alternate</p>
<p>ignoring with -D, 723</p>
<p>specifying for search with -I, 724</p>
<p>Disable Trace menu item, 683</p>
<p>disabling</p>
<p>profiling data collection, 360</p>
<p>TimeMachine, 415</p>
<p>trace collection, 406</p>
<p>Disassemble From Host menu item, 671</p>
<p>discarding trace, 410</p>
<p>Disconnect from Serial menu item, 686</p>
<p>Disconnect from Target menu item, 58, 680</p>
<p>disconnecting</p>
<p>from target, 58</p>
<p>DISNAMELEN system variable, 311</p>
<p>-display MULTI command line option, 7, 723</p>
<p>DisplayMode menu item, 673</p>
<p>_DISPMODE system variable, 313</p>
<p>document set, xxiv, xxv</p>
<p>dollar sign ($) variable search designator, 298</p>
<p>dots in source pane, 22, 125</p>
<p>Download Program button, 701</p>
<p>Download to RAM option, 114</p>
<p>downloading</p>
<p>modules with -preload, 725</p>
<p>separate executables on multi-core system, 627</p>
<p>single executable on multi-core system, 626</p>
<p>to RAM, 114</p>
<p>Downstack button, 695, 717</p>
<p>DownStack menu item, 163, 676</p>
<p>Dump and Show Events button, 696</p>
<p>dump, core file, 117</p>
<p>dumping profiling data, 381</p>
<p>dvclear command, 745</p>
<p>dvload command, 745</p>
<p>dvprofile command, 744, 766</p>
<p>DWARF debugging information</p>
<p>converting, 730</p>
<p>DYING status bar message, 36</p>
<p>Dynamic Calls menu item, 679</p>
<p><b>E</b></p>
<p>e command, 163</p>
<p>-e command line option, 723</p>
<p>-E command line option, 724</p>
<p>early MULTI board setup scripts, 101</p>
<p>edit bar</p>
<p>in Data Explorer, 187</p>
<p>Edit button, 696</p>
<p>Editor menu item, 685</p>
<p>Editor, MULTI, 170</p>
<p>Empty Data Explorer message, 200</p>
<p>Enable Trace menu item, 683</p>
<p>enabling</p>
<p>OS trace collection, 406</p>
<p>TimeMachine, 414</p>
<p>trace collection, 405</p>
<p>$entadr() special operator, 318</p>
<p>entry label, specifying with -e, 723</p>
<p>_ENTRYPOINT system variable, 314</p>
<p>epilogue code</p>
<p>debugging, 390</p>
<p>equal sign (=) operator, 294</p>
<p>equal sign-double (==) operator, 294</p>
<p>error checking, run-time (see run-time error checking)</p>
<p>eval command, 94</p>
<p>evaluating</p>
<p>expressions, 292</p>
<p>EventAnalyzer (see MULTI EventAnalyzer)</p>
<p>EventAnalyzer menu item, 684</p>
<p>events</p>
<p>complex</p>
<p>specifying with Advanced Event Editor, 443, 497, 504</p>
<p>trace</p>
<p>viewing in EventAnalyzer, 474</p>
<p>examining data (see viewing)</p>
<p>examples</p>
<p>Connection Methods, custom</p>
<p>INDRT2 (rtserv2), 68, 69</p>
<p>exception handlers</p>
<p>call stack for, 390</p>
<p>exception type descriptions, 502</p>
<p>EXEC'ING status bar message, 36</p>
<p>_EXEC_NAME system variable, 314</p>
<p>Execing target list status, 19</p>
<p>$exists() special operator, 318</p>
<p>Exit All menu item, 663</p>
<p>Exited target list status, 19</p>
<p>expressions</p>
<p>caveats for, 294</p>
<p>in Debugger commands, 292</p>
<p>evaluating, 292</p>
<p>formats for, 300</p>
<p>language-independent, 294</p>
<p>unsupported operators, casts, destructors in C++, 296</p>
<p>viewing with wildcards, 303</p>
<p><b>F</b></p>
<p>F1 key, for help, 691</p>
<p>Fast Source Step menu item, 672</p>
<p><i>MULTI: Debugging</i></p>
<p><i>812</i></p>
<p><i>directories, alternate</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Fast-Find, PathAnalyzer, 430</p>
<p>FASTSTEP system variable, 311</p>
<p>field debugging (see non-intrusive debugging)</p>
<p>File Calls menu item, 679</p>
<p>file chooser dialog box (Linux/Solaris), 713</p>
<p>file interface, TimeMachine, 467, 469, 470, 472</p>
<p>File Locator on navigation bar, 164</p>
<p>File menu, 661</p>
<p>_FILE system variable, 314</p>
<p>file-relative line numbers</p>
<p>displaying in source pane, 21, 24</p>
<p>files</p>
<p>debugging multiple with -E, 724</p>
<p>listing, 678</p>
<p>recently opened from File menu, 662</p>
<p>searching, 159</p>
<p>Files menu item</p>
<p>in Browse menu, 679</p>
<p>in ViewList submenu, 678</p>
<p>Fill menu item, 681</p>
<p>filtering content in</p>
<p>Browse window, 216, 217, 218, 219</p>
<p>Find Address in Cache menu item, 675</p>
<p>Find menu item, 682</p>
<p>find start/end ranges test, 533</p>
<p>flash gui command, 541</p>
<p>flash memory</p>
<p>base address, setting, 541</p>
<p>erasing, 544</p>
<p>file, selecting, 542</p>
<p>flash bank, specifying, 541</p>
<p>MULTI Fast Flash Programmer, 540</p>
<p>operations, 541</p>
<p>option in Prepare Target dialog, 114</p>
<p>prerequisites to working with, 541</p>
<p>programming, 541, 543</p>
<p>troubleshooting problems, 547</p>
<p>verifying download to, 544</p>
<p>write offset, specifying, 542</p>
<p>Flash menu item, 681</p>
<p>flashing to ROM, 114</p>
<p>formats for expressions, 300</p>
<p>Freeze button</p>
<p>in Data Explorer, 186, 189</p>
<p>freeze-mode AddressSpaces, 16</p>
<p>freeze-mode breakpoints, 420, 618</p>
<p>freeze-mode connections</p>
<p>concurrent with run-mode connections, 69</p>
<p>troubleshooting, 73</p>
<p>freeze-mode debugging, 614</p>
<p>(see also OSA Explorer)</p>
<p>AddressSpaces, 16</p>
<p>breakpoints, 420, 618</p>
<p>configuration file, 632</p>
<p>I/O, 620</p>
<p>in Debugger windows, 614, 615</p>
<p>kernel, 613, 614</p>
<p>Master Debugger mode, 614</p>
<p>multi-core systems, 620</p>
<p>(see also multi-core systems)</p>
<p>overview, 606</p>
<p>starting, 607</p>
<p>target environments supported, 606</p>
<p>Task Debugger mode, 615</p>
<p>task-specific single-stepping, 616</p>
<p>tasks, 613, 614, 615</p>
<p>with TimeMachine, 418, 419</p>
<p>freeze-mode tasks, 615</p>
<p>in TimeMachine mode, 418, 419</p>
<p>functions (see procedures)</p>
<p><b>G</b></p>
<p>generating profiling data, 356</p>
<p>global variables</p>
<p>browsing, 214, 228, 230</p>
<p>listing, 678</p>
<p>Globals menu item</p>
<p>in Browse menu, 679</p>
<p>in ViewList submenu, 678</p>
<p>Go Back button, 692</p>
<p>Go on Selected Items button, 693, 716</p>
<p>Go on Selected Items menu item, 665</p>
<p>Go to next selected location in trace data button, 701</p>
<p>Go to previous selected location in trace data button, 701</p>
<p>Goto Location menu item, 163, 677</p>
<p>Graph View window</p>
<p>controlling layout in, 248</p>
<p>custom, 742, 746</p>
<p>history buttons, 251</p>
<p>includes, browsing, 247</p>
<p>Layout menu, 248</p>
<p>navigating, 248</p>
<p>Search for Objects window, 250</p>
<p>shortcut menus, 249</p>
<p>window, 247</p>
<p>graphical (GUI) mode</p>
<p>starting Debugger in, 6, 7, 723</p>
<p>GRD register definition files</p>
<p>format, 776</p>
<p>location of, 286</p>
<p>saving, 276</p>
<p><i>813</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Fast-Find, PathAnalyzer</i></p>
<h1 style="page-break-before:always; "></h1>
<p>greater than sign (&gt;)</p>
<p>in C++ classes, 195</p>
<p>Green Hills Monitors</p>
<p>setup scripts unnecessary for, 91</p>
<p>grep utility, 160</p>
<p>(see also searching)</p>
<p>licensing, 160</p>
<p>group breakpoints, run-mode, 588, 589</p>
<p>GrpHalt target list status, 19</p>
<p><b>H</b></p>
<p>h command, 689</p>
<p>-h command line option, 7, 724</p>
<p>-H command line option, 7, 724</p>
<p>halt command, 95</p>
<p>Halt on Attach menu item, 672</p>
<p>Halt on Selected Items button, 693</p>
<p>Halt on Selected Items menu item, 665</p>
<p>Halt System menu item, 666</p>
<p>Halted target list status, 19</p>
<p>halting tasks on attach, 583</p>
<p>hardware breakpoints</p>
<p>editing, 133</p>
<p>managing, 135, 146, 148, 149, 150</p>
<p>managing deleted, 152</p>
<p>overview, 133</p>
<p>properties of, 134, 139</p>
<p>setting, 133</p>
<p>viewing, 135, 146, 148, 149, 150</p>
<p>viewing deleted, 152</p>
<p>hardware, target (see targets)</p>
<p>headings</p>
<p>in Browse window, 220, 227, 233, 235</p>
<p>-help command line option, 7, 724</p>
<p>Help menu, 691</p>
<p>hierarchical target list display, 18</p>
<p>hooks</p>
<p>in early MULTI board setup scripts, 101</p>
<p>in multi-core setup scripts, 623</p>
<p>HostIO target list status, 19</p>
<p><b>I</b></p>
<p>-I command line option, 724</p>
<p>I/O</p>
<p>program, with INTEGRITY, 620</p>
<p>redirection, 665</p>
<p>I/O pane, 30</p>
<p>ignoring</p>
<p>alternate directories with -D, 723</p>
<p>.cfg files with -nocfg, 724</p>
<p>.rc files with -norc, 7, 725</p>
<p>$in() special operator, 318</p>
<p>Included Files menu item, 678</p>
<p>includes</p>
<p>browsing, 247</p>
<p>Includes menu item, 679</p>
<p>incremental searching</p>
<p>beeping in, 157</p>
<p>for strings, 156</p>
<p>INDRT, 78</p>
<p>connecting MULTI to (see Connection Methods)</p>
<p>INDRT2, 60</p>
<p>connecting MULTI to (see Connection Methods)</p>
<p>infinite scrolling, 156</p>
<p>information pane, 13, 26, 597</p>
<p>_INIT_SP system variable, 313</p>
<p>Initial Position (XxY) configuration option, 200</p>
<p>input/output pane, 30</p>
<p>input/output redirection, 665</p>
<p>installing target hardware, 90</p>
<p>instruction pane in Trace List, 436</p>
<p>instructions</p>
<p>conditionally not executed, 123</p>
<p>dimmed, 123</p>
<p>stepping through, 666</p>
<p>instrumented profiling, 356</p>
<p>Integrate, 802</p>
<p>INTEGRITY</p>
<p>freeze-mode debugging, 606</p>
<p>program I/O in freeze mode, 620</p>
<p>run-mode tasks, 422</p>
<p>Separate Session TimeMachine with, 422</p>
<p>TimeMachine with, 418, 419</p>
<p>trace data, 406, 436</p>
<p>INTEGRITY Object Viewer button, 697</p>
<p>interfaces, TimeMachine API, 467, 469, 470, 471, 472</p>
<p>_INTERLACE system variable, 314</p>
<p>interlaced assembly code</p>
<p>viewing in Debugger, 23</p>
<p>Interlaced Assembly menu item, 677</p>
<p>interrupt handlers</p>
<p>call stack for, 390</p>
<p>interrupts</p>
<p>disabling during target setup, 93</p>
<p><b>J</b></p>
<p>jump breakpoints, setting, 707</p>
<p><b>K</b></p>
<p>kernel</p>
<p><i>MULTI: Debugging</i></p>
<p><i>814</i></p>
<p><i>greater than sign (&gt;)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>debugging in freeze mode, 613, 614</p>
<p>keyboard shortcuts (see shortcuts)</p>
<p>keywords, language, 294</p>
<p>Kill Selected Items menu item, 665</p>
<p><b>L</b></p>
<p>language dependencies, 303</p>
<p>language keywords, 294</p>
<p>_LANGUAGE system variable, 313</p>
<p>language-independent expressions, 294</p>
<p>_LAST_COMMAND_STATUS system variable, 314</p>
<p>_LAST_CONNECT_CMD_LINE system variable, 314</p>
<p>Launch Utility Programs menu item, 685</p>
<p>Launcher menu item, 685</p>
<p>left angle bracket (&lt;) command</p>
<p>menu equivalent, 690</p>
<p>legacy debug server setup scripts (.dbs) (see board setup</p>
<p>scripts)</p>
<p>lifetime information for variables, 299</p>
<p>line numbers</p>
<p>displaying in source pane, 21, 24</p>
<p>jumping to with line pointer, 22</p>
<p>memory address of, 293</p>
<p>program counter, 22, 123</p>
<p>line pointer, 22</p>
<p>_LINE system variable, 314</p>
<p>_LINES system variable, 313</p>
<p>linked lists in Data Explorer, 191</p>
<p>linker directives files</p>
<p>created by Project Wizard, 90</p>
<p>editing, 98</p>
<p>need for, 90</p>
<p>Linux/Solaris</p>
<p>file chooser dialog box, 713</p>
<p>printing, 663</p>
<p>List menu item, 675</p>
<p>listing</p>
<p>breakpoints, 678</p>
<p>command line options with -h, 7, 724</p>
<p>dialog boxes, 678</p>
<p>files, 678</p>
<p>global variables, 678</p>
<p>included source files, 678</p>
<p>local variable addresses, 678</p>
<p>local variables, 678</p>
<p>macros, 678</p>
<p>mangled procedures, 678</p>
<p>procedure variables, 678</p>
<p>procedures, 678</p>
<p>processes, 678</p>
<p>register synonyms, 678</p>
<p>registers, 678</p>
<p>signals, 678</p>
<p>source paths, 678</p>
<p>special variables, 678</p>
<p>static variables, 678</p>
<p>lists</p>
<p>selecting items from, 161</p>
<p>live TimeMachine interface, 467, 471</p>
<p>Load Configuration menu item, 688</p>
<p>Load Module menu item, 680</p>
<p>Load Trace Session menu item, 683</p>
<p>loading (see downloading)</p>
<p>Local Addresses menu item, 678</p>
<p>local variables, 673, 678</p>
<p>Local Variables menu item, 673</p>
<p>Locals ($locals$) window, 169</p>
<p>Locals button, 695</p>
<p>Locals menu item, 678</p>
<p>-log option</p>
<p>for rtserv2, 67, 68</p>
<p>logging</p>
<p>INDRT (rtserv), 83</p>
<p>INDRT2 (rtserv2), 64, 67, 68</p>
<p><b>M</b></p>
<p>-m command line option, 724, 728</p>
<p>$M_called_from() special operator, 318</p>
<p>$M_can_read_address() special operator, 318</p>
<p>$M_file_exists() special operator, 318</p>
<p>$M_get_temp_memory() special operator, 318</p>
<p>$M_offsetof() special operator, 319</p>
<p>$M_sec_begin() special operator, 319</p>
<p>$M_sec_end() special operator, 319</p>
<p>$M_sec_exists() special operator, 319</p>
<p>$M_sec_size() special operator, 319</p>
<p>$M_strcaseprefix() special operator, 319</p>
<p>$M_strcmp() special operator, 319</p>
<p>$M_strcpy() special operator, 319</p>
<p>$M_strprefix() special operator, 319</p>
<p>$M_strstr() special operator, 319</p>
<p>$M_sym_exists() special operator, 318</p>
<p>$M_typeof() special operator, 320</p>
<p>$M_var_is_valid() special operator, 320</p>
<p>macros</p>
<p>calling, 307</p>
<p>evaluating, 307</p>
<p>listing, 678</p>
<p>shortcut menu, 711</p>
<p>Make Serial Connection menu item, 686</p>
<p><i>815</i></p>
<p><i>Green Hills Software</i></p>
<p><i>kernel (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Manage Bookmarks menu item, 691</p>
<p>Mangled Procedures menu item, 678</p>
<p>mangled procedures, listing, 678</p>
<p>Manuals menu item, 691</p>
<p>Master Debugger mode, 614</p>
<p>master process, OSA, 614</p>
<p>in TimeMachine mode, 419</p>
<p>Maximum initial size (WxH) configuration option, 200</p>
<p>.mdv files (see MULTI data visualization (.mdv) files)</p>
<p>memory</p>
<p>accessing from Memory View window, 328</p>
<p>allocation errors (see memory allocation)</p>
<p>coherency, 536</p>
<p>configuring via setup script, 93</p>
<p>editing from Memory View window, 329</p>
<p>flash (see flash memory)</p>
<p>leaks, finding, 347</p>
<p>manipulating in Memory Allocations window, 348</p>
<p>testing (see memory testing)</p>
<p>testing access to, 97</p>
<p>viewing, 324</p>
<p>(see also Memory View window)</p>
<p>from Data Explorer, 184</p>
<p>memory allocation</p>
<p>tracking, 350</p>
<p>viewing, 343, 347</p>
<p>window (see Memory Allocations window)</p>
<p>Memory Allocations menu item, 674</p>
<p>Memory Allocations window</p>
<p>leaks, viewing, 347</p>
<p>menus, 342</p>
<p>opening, 340, 674</p>
<p>overview, 340</p>
<p>procedures, manipulating, 348</p>
<p>refreshing, 349</p>
<p>tabs, 341</p>
<p>tracking leaks and allocations, 350</p>
<p>updating, 346</p>
<p>visualization, 343</p>
<p>Memory button, 695</p>
<p>Memory Dump menu item, 682</p>
<p>Memory Load menu item, 682</p>
<p>Memory Manipulation menu item, 681</p>
<p>Memory menu item, 674</p>
<p>Memory Sensitive menu item, 671</p>
<p>memory sensitive mode, 115</p>
<p>Memory Test menu item, 681</p>
<p>Memory Test Results window, 523</p>
<p>Memory Test Wizard, 512</p>
<p>memory testing</p>
<p>address bus walking test, 525</p>
<p>advanced, 515</p>
<p>coherency errors, 536</p>
<p>command line, 535</p>
<p>continuous, 524</p>
<p>CRC compare test, 533</p>
<p>CRC compute test, 532</p>
<p>data bus walking test, 527</p>
<p>data pattern test, 529</p>
<p>find start/end ranges test, 533</p>
<p>hints for efficient testing, 535</p>
<p>memory read test, 532</p>
<p>Memory Test Results window, 523</p>
<p>Memory Test Wizard, 512</p>
<p>overview, 512</p>
<p>Perform Memory Test window, 515, 516</p>
<p>(see also Perform Memory Test window)</p>
<p>quick, 512</p>
<p>results, viewing, 523</p>
<p>running, 522</p>
<p>selecting, 518</p>
<p>with target agent, 524</p>
<p>test area, specifying, 516</p>
<p>test method, specifying, 521</p>
<p>test options, setting, 520</p>
<p>types, 525</p>
<p>Memory View window</p>
<p>active location, setting, 325</p>
<p>columns, 334</p>
<p>editing memory from, 329</p>
<p>formatting columns, 326</p>
<p>freezing, 328</p>
<p>infinite scrolling, 156</p>
<p>memory pane, 326</p>
<p>opening, 324, 674</p>
<p>overview, 324</p>
<p>updating, 328</p>
<p>memread command, 95</p>
<p>memtest command, 535</p>
<p>memwrite command, 95</p>
<p>menu bar, 13, 660</p>
<p>(see also Debugger menus)</p>
<p>menus</p>
<p>Debugger (see Debugger menus)</p>
<p>messages</p>
<p>Data Explorer, 200</p>
<p>status bar, 36</p>
<p>Minimum initial size (WxH) configuration option, 200</p>
<p>minus sign, right angle bracket, asterisk (-&gt;*) operator, 296</p>
<p>minus sign-double (--) command line option, 722</p>
<p>Modify Register Definition dialog, 276, 277, 278</p>
<p>modules, downloading with -preload, 725</p>
<p><i>MULTI: Debugging</i></p>
<p><i>816</i></p>
<p><i>Manage Bookmarks menu item</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Move splitter down button, 15</p>
<p>Move splitter left button, 15</p>
<p>Move splitter right button, 15</p>
<p>Move splitter up button, 15</p>
<p>Move target list to left button, 15</p>
<p>moving software breakpoints, 132</p>
<p>mterminal command, 654</p>
<p>MTerminal serial terminal emulator, 644</p>
<p>(see also serial connections)</p>
<p>configuring, 646, 647, 649</p>
<p>console mode, 653</p>
<p>creating Connection Methods, 646, 647, 649</p>
<p>overview, 644</p>
<p>as stand-alone application, 654</p>
<p>starting, 644</p>
<p>window features, 650</p>
<p>MULTI (see MULTI Integrated Development Environment</p>
<p>(IDE))</p>
<p>MULTI board setup scripts (.mbs) (see board setup scripts)</p>
<p>MULTI data visualization</p>
<p>with Data Explorer, 191</p>
<p>invoking, 746</p>
<p>MULTI data visualization (.mdv) files (see MULTI data</p>
<p>visualization (.mdv) files)</p>
<p>overview, 742</p>
<p>MULTI data visualization (.mdv) files</p>
<p>clearing, 745</p>
<p>data descriptions, 743, 747</p>
<p>expressions in, 770</p>
<p>file format, 747</p>
<p>loading, 745</p>
<p>overview, 742, 743</p>
<p>profile descriptions, 744, 766</p>
<p>type-specific fields, 750, 751, 752, 753, 754, 755, 756, </p>
<p>757, 758, 759, 760, 761, 762, 763</p>
<p>view descriptions, 744, 768</p>
<p>MULTI Debugger (see Debugger)</p>
<p>MULTI Editor, 170</p>
<p>MULTI EventAnalyzer</p>
<p>pane in PathAnalyzer, 432</p>
<p>viewing trace events in, 474</p>
<p>MULTI EventAnalyzer button, 697</p>
<p>MULTI EventAnalyzer menu item, 685</p>
<p>MULTI Fast Flash Programmer</p>
<p>base address, setting, 541</p>
<p>erasing flash memory, 544</p>
<p>file, selecting, 542</p>
<p>flash bank, specifying, 541</p>
<p>opening, 540</p>
<p>operations, 541</p>
<p>prerequisites to working with flash, 541</p>
<p>programming flash memory, 541, 543</p>
<p>troubleshooting problems, 547</p>
<p>verifying flash download, 544</p>
<p>write offset, specifying, 542</p>
<p>MULTI Integrated Development Environment (IDE)</p>
<p>document set, xxv</p>
<p>exiting, 663</p>
<p>starting for Object Structure Awareness (OSA), 725</p>
<p>starting from command line, 6, 722</p>
<p>viewing information about, 691</p>
<p>MULTI ResourceAnalyzer button, 697</p>
<p>MULTI ResourceAnalyzer menu item, 685</p>
<p>MULTI Variables menu item, 678</p>
<p>multi-core systems</p>
<p>display in target list, 620</p>
<p>display in Task Manager, 621</p>
<p>hook commands in setup script, 623</p>
<p>limitations, 631</p>
<p>running separate executables on, 627</p>
<p>running single executable on, 626</p>
<p>synchronous run control, 629</p>
<p>_MULTI_DIR system variable, 314</p>
<p>_MULTI_MAJOR_VERSION system variable, 314</p>
<p>_MULTI_MICRO_VERSION system variable, 315</p>
<p>_MULTI_MINOR_VERSION system variable, 315</p>
<p>multiple files, debugging with -E, 724</p>
<p>multiple run-mode connections, 578</p>
<p>multiple-language applications, debugging, 294</p>
<p>multitasking applications, debugging, 606</p>
<p><b>N</b></p>
<p>NaN Data Explorer message, 200</p>
<p>native processes</p>
<p>viewing, 390</p>
<p>navigating</p>
<p>buttons for, 167</p>
<p>MULTI windows, 156</p>
<p>navigation bar, 13, 25</p>
<p>Navigation menu item, 673</p>
<p>Next (over Functions) on Selected Items button, 693, 717</p>
<p>Next (over Functions) on Selected Items menu item, 666</p>
<p>No process Data Explorer message, 200</p>
<p>NO PROCESS status bar message, 36</p>
<p>No Stack Trace menu item, 671</p>
<p>no stack trace mode, 116</p>
<p>No symbols for this procedure Data Explorer message, 201</p>
<p>No TimeMachine Data target list status, 19</p>
<p>-nocfg command line option, 724</p>
<p>node operations in Tree Browser, 242</p>
<p>-nodisplay MULTI command line option, 724</p>
<p><i>817</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Move splitter down button</i></p>
<h1 style="page-break-before:always; "></h1>
<p>non-GUI mode</p>
<p>starting Debugger in, 8, 724</p>
<p>non-intrusive debugging, 560</p>
<p>(see also tracepoints)</p>
<p>example, 567</p>
<p>limitations, 570</p>
<p>overview, 560</p>
<p>with passive mode, 574, 575</p>
<p>_NONGUIMODE system variable, 315</p>
<p>-norc command line option, 7, 725</p>
<p>-noshared command line option, 725</p>
<p>-nosplash command line option, 725</p>
<p>Not Initialized Data Explorer message, 201</p>
<p>Not loaded target list status, 19</p>
<p>Note Browser, 178</p>
<p>Number of Addresses to Check menu item, 672</p>
<p>number sign (#) variable search designator, 293, 298</p>
<p><b>O</b></p>
<p>Object Structure Awareness (OSA), 607</p>
<p>(see also OSA Explorer)</p>
<p>starting MULTI for, 607, 725</p>
<p>offsetof() special operator, 319</p>
<p>offsets</p>
<p>position-independent code (PIC), 112, 313, 726</p>
<p>position-independent data (PID), 112, 313, 723</p>
<p>online help</p>
<p>opening with -help, 7, 724</p>
<p>opening with F1, 691</p>
<p>_OPCODE system variable, 313</p>
<p>Open project manager for current project button, 701</p>
<p>operating systems</p>
<p>collecting trace for, 406</p>
<p>debugging (see freeze-mode debugging) (see run-mode</p>
<p>debugging)</p>
<p>navigating trace for, 436</p>
<p>tasks, launching TimeMachine on, 418</p>
<p>operators</p>
<p>in count expressions, 506</p>
<p>in state expressions, 507</p>
<p>language-independent, 294</p>
<p>not supported in expressions, 296, 306</p>
<p>overloaded in C++, 304</p>
<p>special (see special operators)</p>
<p>Optimized away Data Explorer message, 201</p>
<p>options (see command line options)</p>
<p>rtserv2</p>
<p>-log, 67, 68</p>
<p>-serial, 68</p>
<p>Options menu item, 687</p>
<p>Original procedure not on stack Data Explorer message, 201</p>
<p>OS-awareness, 602, 606, 607, 632</p>
<p>(see also freeze-mode debugging)</p>
<p>(see also OSA Explorer)</p>
<p>(see also OSA Object Viewer)</p>
<p>_OS_DIR system variable, 315</p>
<p>OSA AddressSpaces in target list, 16</p>
<p>-osa command line option, 607, 725</p>
<p>OSA Explorer, 609</p>
<p>(see also Object Structure Awareness (OSA))</p>
<p>displaying, 609</p>
<p>menus, 611</p>
<p>object list, 612</p>
<p>opening, 674</p>
<p>overview, 609</p>
<p>shortcut menus, 612, 638</p>
<p>toolbar, 611</p>
<p>OSA Explorer button, 696</p>
<p>OSA Explorer menu item, 674</p>
<p>OSA master process, 614</p>
<p>in TimeMachine mode, 419</p>
<p>OSA Object Viewer, 602</p>
<p>OSA tasks, 615</p>
<p>in TimeMachine mode, 418, 419</p>
<p>osaSwitchToUserTaskAutomatically configuration option,</p>
<p>614</p>
<p>osaTaskAutoAttachLimit configuration option, 614</p>
<p>output</p>
<p>recording to playback files, 726</p>
<p>output pane, 13, 26</p>
<p>output/input redirection, 665</p>
<p><b>P</b></p>
<p>-p command line option, 7, 725</p>
<p>-P command line option, 725</p>
<p>pane-switching tabs, 13, 26</p>
<p>partner, run-mode (see run-mode partner)</p>
<p>passing arguments with -- (minus sign-double), 722</p>
<p>passive command, 574, 575</p>
<p>passive mode, 574, 575</p>
<p>pasting text</p>
<p>in Debugger windows, 160</p>
<p>in main Debugger window, 161</p>
<p>PathAnalyzer, 424</p>
<p>(see also trace)</p>
<p>analyzing OS data, 432</p>
<p>bookmarks in, 432</p>
<p>browsing references, 431</p>
<p>EventAnalyzer pane in, 432</p>
<p>Fast-Find, 430</p>
<p><i>MULTI: Debugging</i></p>
<p><i>818</i></p>
<p><i>non-GUI mode</i></p>
<h1 style="page-break-before:always; "></h1>
<p>navigating, 428, 429</p>
<p>opening, 424</p>
<p>searching, 430</p>
<p>thumbnail pane, 427</p>
<p>viewing a single AddressSpace, 434</p>
<p>window, 425</p>
<p>PathAnalyzer menu item, 684</p>
<p>PC (program counter), 22</p>
<p>dimmed, 123</p>
<p>location in TimeMachine mode, 416</p>
<p>samples, 354, 355, 356, 360, 475</p>
<p>Pended target list status, 19</p>
<p>Perform Memory Test window, 515</p>
<p>running tests from, 522</p>
<p>test area, setting, 516</p>
<p>test method, specifying, 521</p>
<p>test options, setting, 520</p>
<p>test type, selecting, 518</p>
<p>period (.) variable search designator, 299</p>
<p>period, asterisk (.*) operator, 296</p>
<p>_PID system variable, 315</p>
<p>Playback Commands menu item, 690</p>
<p>playback files, 7, 725, 726</p>
<p>pointers in Data Explorer, 193, 196</p>
<p>position-independent code (PIC)</p>
<p>offset, specifying with -text, 726</p>
<p>offset, specifying with _TEXT, 313</p>
<p>offset, specifying with Text Offset, 112</p>
<p>position-independent data (PID)</p>
<p>offset, specifying with -data, 723</p>
<p>offset, specifying with _DATA, 313</p>
<p>offset, specifying with Data Offset, 112</p>
<p>-preload command line option, 725</p>
<p>Prepare Target button, 694</p>
<p>Prepare Target dialog box, 110</p>
<p>Prepare Target menu item, 667</p>
<p>preparing a target</p>
<p>basics, 108</p>
<p>by downloading, 114</p>
<p>by flashing, 114</p>
<p>by verifying, 114</p>
<p>multi-core, 626, 627</p>
<p>settings related to, 115, 116</p>
<p>Previous button, 692</p>
<p>Print Expression menu item, 675</p>
<p>Print menu item, 661</p>
<p>Print Setup dialog box, 663</p>
<p>Print Window menu item, 661</p>
<p>printing</p>
<p>on Linux/Solaris, 663</p>
<p>Procedure Locator on navigation bar, 165</p>
<p>_PROCEDURE system variable, 315</p>
<p>procedure-relative line numbers</p>
<p>displaying in source pane, 21, 24</p>
<p>procedures</p>
<p>ambiguities, Browse dialog box for, 227</p>
<p>browsing (see Browse window)</p>
<p>calling from command line, 306</p>
<p>calling from Debugger, 304</p>
<p>epilogues, 390</p>
<p>listing, 678</p>
<p>mangled, listing, 678</p>
<p>manipulating in Memory Allocations window, 348</p>
<p>in Procedure Locator, 165</p>
<p>prologues, 390</p>
<p>shortcut menu for, 708</p>
<p>stepping into, out of, over, 666</p>
<p>Procedures in Files menu item, 679</p>
<p>Procedures menu item</p>
<p>in Browse menu, 679</p>
<p>in ViewList submenu, 678</p>
<p>Process running Data Explorer message, 201</p>
<p>_PROCESS system variable, 315</p>
<p>Process Viewer</p>
<p>opening, 674, 727</p>
<p>window, 390</p>
<p>process-specific breakpoints (see task-specific breakpoints)</p>
<p>processes</p>
<p>attaching to, 662, 725</p>
<p>controlling from Debugger, 122</p>
<p>halting, 665</p>
<p>killing current, 665</p>
<p>listing, 678</p>
<p>native, viewing, 390</p>
<p>sending signal to, 666</p>
<p>state of, 36</p>
<p>stopping, 122</p>
<p>Processes menu item, 678</p>
<p>processing profiling data, 383</p>
<p>ProcRelativeLines configuration option, 24</p>
<p>profdump command, 377, 382</p>
<p>profile command, 357, 359</p>
<p>profile descriptions</p>
<p>MULTI data visualization (.mdv) files, 744, 766</p>
<p>Profile menu item, 674, 684</p>
<p>Profile window, 361</p>
<p>(see also profiling reports)</p>
<p>menus, 372, 373</p>
<p>overview, 361</p>
<p>toolbar, 375</p>
<p>updates in, 363</p>
<p><i>819</i></p>
<p><i>Green Hills Software</i></p>
<p><i>PathAnalyzer (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>profilemode command, 373, 374, 375, 376, 377, 378, 381, </p>
<p>382, 383, 384</p>
<p>profilereport command, 363, 364, 372</p>
<p>profiling, 355</p>
<p>(see also profiling data)</p>
<p>AddressSpaces, 355, 359</p>
<p>caveats, 360</p>
<p>instrumented, 356</p>
<p>methods overview, 355</p>
<p>PC sampling, 355, 356, 603</p>
<p>range, 379</p>
<p>stand-alone program, 355, 359</p>
<p>tasks</p>
<p>all in system, 355, 357, 603</p>
<p>single, 355, 356, 359, 360</p>
<p>trace-enabled target, 355, 358, 475</p>
<p>profiling data, 354</p>
<p>(see also profiling)</p>
<p>(see also profiling reports)</p>
<p>adding to, 380</p>
<p>call count, 354, 355, 360, 475</p>
<p>call graph, 354, 355, 475</p>
<p>clearing, 384</p>
<p>collecting, 356, 357, 358, 359</p>
<p>converted from trace, 475</p>
<p>coverage analysis, 354, 355, 360, 475</p>
<p>disabling collection of, 360</p>
<p>dumping, 381</p>
<p>instrumenting code to generate, 356</p>
<p>overwriting, 380</p>
<p>PC (program counter) samples, 354, 355, 356, 360, 475</p>
<p>processing manually, 383</p>
<p>types of, 354</p>
<p>viewing, 361, 363, 377</p>
<p>profiling reports</p>
<p>block detailed, 370</p>
<p>call graph, 367</p>
<p>coverage, 369</p>
<p>overview, 363</p>
<p>source, 371</p>
<p>standard calls, 365</p>
<p>status, 365</p>
<p>Program already present on target. Verify option, 114</p>
<p>program counter (PC), 22</p>
<p>dimmed, 123</p>
<p>location in TimeMachine mode, 416, 419</p>
<p>samples, 354, 355, 356, 360, 475</p>
<p>Program Counter button, 694</p>
<p>Program Flash ROM option, 114</p>
<p>programs</p>
<p>execution of, 122</p>
<p>profiling stand-alone, 355, 359</p>
<p>RAM download, 111</p>
<p>ROM copy, 113</p>
<p>ROM run, 112</p>
<p>in Separate Session TimeMachine mode, 422</p>
<p>starting, 122</p>
<p>stepping through, 123</p>
<p>in TimeMachine mode, 17, 413</p>
<p>unknown, 113</p>
<p>Project Manager</p>
<p>opening, 685, 701</p>
<p>Project Manager menu item, 685</p>
<p>prologue code</p>
<p>debugging, 390</p>
<p>Py pane, 32</p>
<p>python pane, 32</p>
<p>Python scripts, TimeMachine API, 471, 472</p>
<p><b>Q</b></p>
<p>question mark (?) wildcard character, 303</p>
<p><b>R</b></p>
<p>-r command line option, 725</p>
<p>-R command line option, 726</p>
<p>RAM download programs, 111</p>
<p>range analysis, 379</p>
<p>-rc command line option, 726</p>
<p>.rc files</p>
<p>customizing registers with, 285</p>
<p>ignoring with -norc, 7, 725</p>
<p>read-only system variables, 314</p>
<p>reading command scripts on startup, 726</p>
<p>real-time operating systems (RTOS)</p>
<p>debugging</p>
<p>INDRT (rtserv), 78</p>
<p>INDRT2 (rtserv2), 60</p>
<p>Rebuild menu item, 685</p>
<p>Reconstructed Registers window, 476</p>
<p>Record Command+Output menu item, 689</p>
<p>Record Commands menu item, 689</p>
<p>recording commands</p>
<p>menu items for, 689, 690</p>
<p>to playback files, 725, 726</p>
<p>recording output</p>
<p>to playback files, 726</p>
<p>redirecting input/output, 665</p>
<p>Refresh Views menu item, 675</p>
<p>register definition files</p>
<p>customizing, 285, 288, 289</p>
<p>default, 285, 288, 289</p>
<p><i>MULTI: Debugging</i></p>
<p><i>820</i></p>
<p><i>profilemode command</i></p>
<h1 style="page-break-before:always; "></h1>
<p>GRD format, 276, 776</p>
<p>location of, 286</p>
<p>overloading, 288</p>
<p>overview, 776</p>
<p>searching for, 286</p>
<p>Register Explorer, 254</p>
<p>(see also register definition files)</p>
<p>(see also Register Information window)</p>
<p>(see also Register View window)</p>
<p>overview, 254</p>
<p>startup, 286</p>
<p>Register Information window</p>
<p>buttons, 275</p>
<p>opening, 271</p>
<p>overview, 270, 271</p>
<p>panes, 272, 273, 274</p>
<p>register values, changing, 275</p>
<p>shortcut menus, 272, 274</p>
<p>Register Search window, 280</p>
<p>Register Setup dialog, 279, 280</p>
<p>Register Synonyms menu item, 678</p>
<p>Register View window</p>
<p>configuration files, 269</p>
<p>copying register values, 267</p>
<p>customizing, 263, 264, 265, 266</p>
<p>editing register contents, 267</p>
<p>File menu, 256</p>
<p>Format menu, 258</p>
<p>opening, 254, 673</p>
<p>overview, 254, 255</p>
<p>printing window contents, 269</p>
<p>refreshing, 268</p>
<p>register tree, 260, 266, 267</p>
<p>shortcut menus, 262</p>
<p>tabs, 260, 264, 265, 266</p>
<p>toolbar, 259</p>
<p>View menu, 257</p>
<p>registers</p>
<p>bitfield definitions, 276</p>
<p>changing values of, 275</p>
<p>commands, 282</p>
<p>copying values, 267</p>
<p>creating, 279, 280</p>
<p>customizing, 285</p>
<p>defining (see register definition files)</p>
<p>editing contents, 267</p>
<p>listing, 678</p>
<p>printing list of, 269</p>
<p>searching for, 280</p>
<p>testing access to, 96</p>
<p>viewing (see Register Information window) (see Register</p>
<p>View window)</p>
<p>Registers button, 695</p>
<p>Registers menu item</p>
<p>in View menu, 673</p>
<p>in ViewList submenu, 678</p>
<p>relationship view, Integrate, 802</p>
<p>Reload button, 694</p>
<p>_REMOTE_CONNECTED system variable, 315</p>
<p>Remove All Breakpoints menu item, 667</p>
<p>reports, profiling (see profiling reports)</p>
<p>reprogramming</p>
<p>buttons, 700</p>
<p>rerooting Tree Browser, 243</p>
<p>Reset button, 694</p>
<p>reset command, 95</p>
<p>Restart button, 693, 716</p>
<p>Restart menu item, 665</p>
<p>restore command, 689</p>
<p>Restore State menu item, 689</p>
<p>restoring</p>
<p>deleted breakpoints, 137</p>
<p>$result special predefined variable, 317</p>
<p>$retadr() special operator, 320</p>
<p>Retrieve Trace menu item, 683</p>
<p>retrieving trace, 408</p>
<p>Return on Selected Items button, 693, 717</p>
<p>Return on Selected Items menu item, 666</p>
<p>reusing windows, 14</p>
<p>Rhapsody, integration with MULTI, 732, 733, 734, 735, 736</p>
<p>right angle bracket (&gt;) command</p>
<p>menu equivalent, 689, 690</p>
<p>right angle bracket-double (&gt;&gt;) command</p>
<p>menu equivalent, 689, 690</p>
<p>right-click</p>
<p>in command pane, 719</p>
<p>-RO command line option, 726</p>
<p>ROM</p>
<p>attaching to a process running in, 552</p>
<p>configuring a project to run in, 551</p>
<p>creating executables for, 550</p>
<p>debugging a process running in, 554</p>
<p>differences in programs built to run from, 550</p>
<p>executing a program in, 552, 553</p>
<p>loading programs from ROM to RAM (see ROM-to-RAM</p>
<p>programs)</p>
<p>working with when using MULTI, 550</p>
<p>ROM copy programs, 113</p>
<p>ROM run programs, 112</p>
<p>ROM-to-RAM programs</p>
<p>configuring, 555</p>
<p><i>821</i></p>
<p><i>Green Hills Software</i></p>
<p><i>register definition files (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>creating, 555</p>
<p>debugging, 557</p>
<p>differences from RAM programs, 554</p>
<p>executing, 556</p>
<p>routines (see procedures)</p>
<p>rtserv debug server</p>
<p>logging, 83</p>
<p>serial port access, exclusive, 82</p>
<p>TFTP directory, 81</p>
<p>_RTSERV_VER system variable, 315</p>
<p>rtserv2 debug server</p>
<p>connection examples, custom, 68, 69</p>
<p>logging, 64, 67, 68</p>
<p>-run command line option, 726</p>
<p>run control, synchronous</p>
<p>on multi-core systems, 629</p>
<p>Run on Detach menu item, 673</p>
<p>Run System menu item, 666</p>
<p>Run to Cursor menu item, 666</p>
<p>run-control buttons, TimeMachine, 414, 416</p>
<p>run-mode AddressSpaces, 581</p>
<p>run-mode breakpoints</p>
<p>any-task, setting, 587</p>
<p>group, 588, 589</p>
<p>task-specific, 587</p>
<p>run-mode connections</p>
<p>automatically established (see run-mode partner)</p>
<p>concurrent with freeze-mode connections, 69</p>
<p>troubleshooting, 73</p>
<p>multiple, 578</p>
<p>overview, 578</p>
<p>run-mode debugging, 60, 78, 580</p>
<p>(see also Task Manager)</p>
<p>AddressSpaces, 581</p>
<p>attaching to tasks, 582</p>
<p>breakpoints, 587</p>
<p>overview, 578</p>
<p>with Separate Session TimeMachine, 422</p>
<p>with TimeMachine, 418</p>
<p>run-mode partner</p>
<p>disabling, 73</p>
<p>overview, 69</p>
<p>setting, 70, 71</p>
<p>troubleshooting, 73</p>
<p>run-mode tasks</p>
<p>attaching to, 582</p>
<p>in TimeMachine mode, 418</p>
<p>run-time error checking</p>
<p>generating information for, 5</p>
<p>memory allocation, 340</p>
<p>RUNNING status bar message, 36</p>
<p>Running target list status, 19</p>
<p><b>S</b></p>
<p>save command, 689</p>
<p>Save Configuration As menu item, 688</p>
<p>Save Configuration as User Default menu item, 687</p>
<p>Save State menu item, 689</p>
<p>Save Trace Session menu item, 683</p>
<p>sb command, 587, 619</p>
<p>scripts</p>
<p>command, reading on startup, 726</p>
<p>syntax checking, 320</p>
<p>scroll bars</p>
<p>diamond in, 156</p>
<p>scrolling</p>
<p>infinite, 156</p>
<p>Search for Objects window, 250</p>
<p>Search in Files menu item, 686</p>
<p>Search menu item, 686</p>
<p>searching</p>
<p>beeping in incremental, 157</p>
<p>caches, 396</p>
<p>files, 159</p>
<p>incrementally, 156</p>
<p>MULTI windows, 156</p>
<p>shortcuts for, 157, 713</p>
<p>source pane, 167, 712</p>
<p>with variable search designators, 297, 298</p>
<p>with wildcards, 303</p>
<p>security view, Integrate, 802</p>
<p>selecting</p>
<p>items from lists, 161</p>
<p>text in Debugger windows, 160</p>
<p>text in main Debugger window, 161</p>
<p>_SELECTION system variable, 315</p>
<p>Send Signal menu item, 666</p>
<p>Separate Session TimeMachine, 422</p>
<p>Serial Connection Chooser, 646</p>
<p>Serial Connection Settings dialog, 647, 649</p>
<p>serial connections, 644</p>
<p>(see also MTerminal serial terminal emulator)</p>
<p>configuring, 646, 647, 649</p>
<p>creating, 646, 647, 649</p>
<p>overview, 644</p>
<p>starting, 644</p>
<p>-serial option</p>
<p>for rtserv2, 68</p>
<p>serial port access, exclusive</p>
<p>INDRT (rtserv), 82</p>
<p>Serial Terminal menu item, 685</p>
<p><i>MULTI: Debugging</i></p>
<p><i>822</i></p>
<p><i>ROM-to-RAM programs (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>serial terminal pane, 31</p>
<p>serialconnect command, 686</p>
<p>serialdisconnect command, 686</p>
<p>ServerPollinterval option, 604</p>
<p>-servertimeout command line option, 726</p>
<p>SERVERTIMEOUT system variable, 311</p>
<p>Session, Separate TimeMachine, 422</p>
<p>Set And Edit menu item, 706</p>
<p>Set Any Task Breakpoint menu item, 707</p>
<p>Set Breakpoint menu item, 706</p>
<p>Set INTEGRITY Distribution menu item, 688</p>
<p>Set Jump Breakpoint menu item, 707</p>
<p>Set Program Arguments menu item, 665</p>
<p>Set Run-Mode Partner dialog box, 70, 71</p>
<p>Set Run-Mode Partner menu item, 71, 73, 680</p>
<p>Set Triggers menu item, 683</p>
<p>Set Triggers window</p>
<p>events, 494, 495</p>
<p>opening, 493</p>
<p>triggers, setting, 497</p>
<p>Set u-velOSity Distribution menu item, 688</p>
<p>Set Watchpoint menu item, 667</p>
<p>set_runmode_partner command, 71</p>
<p>setup scripts, board (see board setup scripts)</p>
<p>_SETUP_SCRIPT system variable, 315</p>
<p>_SETUP_SCRIPT_DIR system variable, 315</p>
<p>shared libraries</p>
<p>disable debugging for with -noshared, 725</p>
<p>shared object breakpoints, 136</p>
<p>managing, 136, 146, 148, 149, 150</p>
<p>managing deleted, 152</p>
<p>viewing, 136, 146, 148, 149, 150</p>
<p>viewing deleted, 152</p>
<p>sharing breakpoints between TimeMachine and live target,</p>
<p>417</p>
<p>shortcuts</p>
<p>command pane, 29, 718</p>
<p>Debugger window, main, 716</p>
<p>search, 157, 713</p>
<p>source pane, 717</p>
<p>Show Command History menu item, 689</p>
<p>signals</p>
<p>listing, 678</p>
<p>sending to current process, 666</p>
<p>Signals menu item, 678</p>
<p>simulators</p>
<p>connecting to, 41</p>
<p>single-stepping</p>
<p>process, 123</p>
<p>task-specific, in freeze mode, 616</p>
<p>sizeof() special operator, 320, 500</p>
<p>slash, asterisk-double, slash (/* */) comments, 295</p>
<p>slash-double (//) comments, 295</p>
<p>-socket command line option, 726</p>
<p>software breakpoints</p>
<p>editing, 130</p>
<p>managing, 131, 146, 148, 149, 150</p>
<p>managing deleted, 152</p>
<p>moving, 132</p>
<p>overview, 128</p>
<p>properties of, 139</p>
<p>setting, 130</p>
<p>viewing, 131, 146, 148, 149, 150</p>
<p>viewing deleted, 152</p>
<p>Solaris/Linux</p>
<p>file chooser dialog box, 713</p>
<p>printing, 663</p>
<p>source addresses</p>
<p>expressing in Debugger, 293</p>
<p>source code</p>
<p>interlaced with assembly code, 23</p>
<p>stepping through, 666</p>
<p>viewing in Debugger, 23</p>
<p>source files</p>
<p>browsing, 165, 214, 230, 231, 232, 233</p>
<p>listing, 678</p>
<p>source lines</p>
<p>shortcut menu for, 705</p>
<p>Source Only menu item, 677</p>
<p>source pane</p>
<p>browsing, 162</p>
<p>content displayed in, 16</p>
<p>display modes, 23</p>
<p>navigating, 162</p>
<p>overview, 13, 21</p>
<p>searching, 162, 167, 712</p>
<p>shortcut menus, 704</p>
<p>shortcuts, 704, 717</p>
<p>Source Path menu item, 675</p>
<p>source paths</p>
<p>listing, 678</p>
<p>Source Paths menu item, 678</p>
<p>source profiling report, 371</p>
<p>special operators</p>
<p>$bp_adr(), 318</p>
<p>$entadr(), 318</p>
<p>$exists(), 318</p>
<p>$in(), 318</p>
<p>$M_called_from(), 318</p>
<p>$M_can_read_address(), 318</p>
<p>$M_file_exists(), 318</p>
<p>$M_get_temp_memory(), 318</p>
<p><i>823</i></p>
<p><i>Green Hills Software</i></p>
<p><i>serial terminal pane</i></p>
<h1 style="page-break-before:always; "></h1>
<p>$M_offsetof(), 319</p>
<p>$M_sec_begin(), 319</p>
<p>$M_sec_end(), 319</p>
<p>$M_sec_exists(), 319</p>
<p>$M_sec_size(), 319</p>
<p>$M_strcaseprefix(), 319</p>
<p>$M_strcmp(), 319</p>
<p>$M_strcpy(), 319</p>
<p>$M_strprefix(), 319</p>
<p>$M_strstr(), 319</p>
<p>$M_sym_exists(), 318</p>
<p>$M_typeof(), 320</p>
<p>$M_var_is_valid(), 320</p>
<p>offsetof(), 319</p>
<p>$retadr(), 320</p>
<p>sizeof(), 320, 500</p>
<p>special variables</p>
<p>listing, 678</p>
<p>$result, 317</p>
<p>specification files</p>
<p>specifying with -m, 724</p>
<p>using, 727</p>
<p>splash screen</p>
<p>disabling with -nosplash, 725</p>
<p>Srch status bar message, 36, 156</p>
<p>Srl pane, 31</p>
<p>Stabs debugging information</p>
<p>converting, 730</p>
<p>stand-alone program</p>
<p>profiling, 355, 359</p>
<p>stand-alone windows, 168</p>
<p>standard calls profiling report, 365</p>
<p>Standard Connection Methods, 42, 43, 44</p>
<p>Start collecting trace data button, 701</p>
<p>starting</p>
<p>Debugger, 5</p>
<p>in graphical (GUI) mode, 6, 7, 723</p>
<p>in non-GUI mode, 8, 724</p>
<p>MULTI for Object Structure Awareness (OSA), 725</p>
<p>MULTI from command line, 6, 722</p>
<p>State menu item, 688</p>
<p>state of process, 36</p>
<p>_STATE system variable, 316</p>
<p>Static Calls menu item, 679</p>
<p>static variables</p>
<p>listing, 678</p>
<p>Statics menu item, 678</p>
<p>status bar</p>
<p>in Debugger window, 14</p>
<p>status bar messages, 36</p>
<p>status profiling report, 365</p>
<p>Status target list column, 19</p>
<p>status(TimeMachine) target list status, 19</p>
<p>Step (into Functions) on Selected Items button, 692, 717</p>
<p>Step (into Functions) on Selected Items menu item, 666</p>
<p>Step Back button, 692</p>
<p>Step Up button, 692</p>
<p>Stop on Task Creation menu item, 672</p>
<p>Stop Record Commands+Output menu item, 690</p>
<p>Stop Recording Commands menu item, 690</p>
<p>stop sign in source pane, 129</p>
<p>STOPPED arrow (red) in Debugger, 22</p>
<p>dimmed, 123</p>
<p>STOPPED INSIDE status bar message, 37</p>
<p>STOPPED status bar message, 36</p>
<p>Stopped target list status, 19</p>
<p>strings</p>
<p>searching incrementally for, 156</p>
<p>structures in Data Explorer, 190</p>
<p>subroutines</p>
<p>stepping, 666</p>
<p>synchronous run control, multi-core systems, 629</p>
<p>syntax checking</p>
<p>commands, 320</p>
<p>scripts, 320</p>
<p>SysHalt target list status, 19</p>
<p>system variables</p>
<p>in Debugger, 310, 312</p>
<p>listing, 678</p>
<p>read-only, 314</p>
<p><b>T</b></p>
<p>target command, 95</p>
<p>target list</p>
<p>auto-sizing of, 15</p>
<p>compressed display, 17</p>
<p>CPU % column, 20, 603</p>
<p>grouping of items in, 17</p>
<p>hiding, 15</p>
<p>hierarchical display, 17</p>
<p>identifying items in, 16</p>
<p>multiple cores in, 620</p>
<p>opening multiple Debugger windows from, 14</p>
<p>reusing Debugger window with, 14</p>
<p>shortcut menu, 702</p>
<p>showing, 15</p>
<p>Status column, 19</p>
<p>terminology, 18</p>
<p>Target menu, 680</p>
<p>target pane, 30</p>
<p>Target Settings menu item, 668</p>
<p><i>MULTI: Debugging</i></p>
<p><i>824</i></p>
<p><i>special operators (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>_TARGET system variable, 316</p>
<p>_TARGET_COPROCESSOR system variable, 316</p>
<p>_TARGET_FAMILY system variable, 316</p>
<p>_TARGET_IS_BIGENDIAN system variable, 316</p>
<p>_TARGET_MINOR_OS system variable, 316</p>
<p>_TARGET_OS system variable, 316</p>
<p>_TARGET_SERIES system variable, 316</p>
<p>targets</p>
<p>concurrent freeze-/run-mode connections to, 69</p>
<p>troubleshooting, 73</p>
<p>configuring, 90</p>
<p>(see also board setup scripts)</p>
<p>connecting to, 40</p>
<p>disconnecting from, 58</p>
<p>installing hardware, 90</p>
<p>multi-core (see multi-core systems)</p>
<p>preparing (see preparing a target)</p>
<p>simulated, 41</p>
<p>testing initialization of, 96, 97</p>
<p>trace-enabled, profiling, 355, 358, 475</p>
<p>Task Debugger mode, 615</p>
<p>task groups, 584</p>
<p>(see also Task Manager)</p>
<p>(see also tasks)</p>
<p>breakpoints for, 588, 589</p>
<p>configuration file for, 600</p>
<p>creating, 584</p>
<p>default, 585</p>
<p>synchronous operations, relating to, 589</p>
<p>Task Manager, 580</p>
<p>(see also task groups)</p>
<p>(see also tasks)</p>
<p>attaching to tasks, 582</p>
<p>debugging tasks, 583</p>
<p>freezing task list, 584</p>
<p>halting tasks, 582, 583</p>
<p>information pane, 597</p>
<p>killing tasks, 582</p>
<p>menus, 592, 593, 594</p>
<p>mouse operations, 598</p>
<p>multiple cores in, 621</p>
<p>opening, 580, 674</p>
<p>overview, 580, 592</p>
<p>running tasks, 582</p>
<p>shortcut menus, 598</p>
<p>task groups in, 584, 585</p>
<p>task list pane, 596</p>
<p>toolbar, 595</p>
<p>_TASK_EXIT_CODE system variable, 316</p>
<p>task-specific breakpoints, 587</p>
<p>freeze-mode, 420, 618</p>
<p>task-specific single-stepping, freeze-mode, 616</p>
<p>tasks, 578</p>
<p>(see also task groups)</p>
<p>(see also Task Manager)</p>
<p>breakpoints for, 587, 618</p>
<p>displaying in the Debugger source pane, 583</p>
<p>freeze mode, debugging, 613, 614, 615</p>
<p>halting, 582</p>
<p>halting on attach, 583</p>
<p>killing, 582</p>
<p>profiling</p>
<p>all, 355, 357, 603</p>
<p>single, 355, 356, 359, 360</p>
<p>run-mode, attaching to, 582</p>
<p>running, 582</p>
<p>in Separate Session TimeMachine mode, 422</p>
<p>in target list, 614</p>
<p>terminology conventions, 578, 607</p>
<p>in TimeMachine mode, 17, 418, 419</p>
<p>in Trace List, 436</p>
<p>Tasks menu item, 674</p>
<p>TASKWIND system variable, 311</p>
<p>Temporary Connection Methods, 49</p>
<p>terminal server connections, 68</p>
<p>tests, memory (see memory testing)</p>
<p>-text command line option, 726</p>
<p>text offsets, position-independent code (PIC)</p>
<p>specifying with -text, 726</p>
<p>specifying with _TEXT, 313</p>
<p>specifying with Text Offset, 112</p>
<p>_TEXT system variable, 313</p>
<p>text, selecting, cutting, and pasting, 160</p>
<p>Tfc pane, 33</p>
<p>TFTP directory</p>
<p>INDRT (rtserv), 81</p>
<p>third-party tools</p>
<p>compilers, 730</p>
<p>Rhapsody, 732</p>
<p>running from Debugger, 731</p>
<p>Thread ID,</p>
<p>(see also ThreadX)</p>
<p>threads, 607</p>
<p>ThreadX</p>
<p>freeze-mode debugging, 606</p>
<p>Thread ID,</p>
<p>_tx_thread_created_ptr OS-specific symbol, 607</p>
<p>thumbnail pane</p>
<p>in PathAnalyzer, 427</p>
<p>in Trace List, 439</p>
<p>time analysis, trace, 439</p>
<p>TimeMachine API</p>
<p><i>825</i></p>
<p><i>Green Hills Software</i></p>
<p><i>_TARGET system variable</i></p>
<h1 style="page-break-before:always; "></h1>
<p>C/C++ example, 473</p>
<p>file interface, 467, 469, 470, 472</p>
<p>live interface, 467, 471</p>
<p>overview, 466</p>
<p>Python examples, 471, 472</p>
<p>timemachine command, 414, 415, 418, 422</p>
<p>TimeMachine Debugger, 413</p>
<p>(see also TimeMachine tools)</p>
<p>(see also trace)</p>
<p>commands, 416</p>
<p>disabling, 415</p>
<p>enabling, 414</p>
<p>limitations, 413</p>
<p>location of program counter in, 416, 419</p>
<p>OS trace in, 418, 419</p>
<p>overview, 413</p>
<p>run-control buttons, 414, 416</p>
<p>Separate Session, 422</p>
<p>TimeMachine Debugger button, 696</p>
<p>TimeMachine Debugger menu item, 684</p>
<p>TimeMachine menu, 683</p>
<p>TimeMachine mode</p>
<p>program or task in, 17, 413</p>
<p>TimeMachine tools, 404</p>
<p>(see also MULTI EventAnalyzer)</p>
<p>(see also PathAnalyzer)</p>
<p>(see also Profile window)</p>
<p>(see also TimeMachine API)</p>
<p>(see also TimeMachine Debugger)</p>
<p>(see also Trace Browsers)</p>
<p>(see also Trace List)</p>
<p>(see also Trace Statistics window)</p>
<p>accessing from Trace List, 444</p>
<p>overview, 404</p>
<p>timeout</p>
<p>setting for debug servers, 726</p>
<p>Toggle All Breakpoints menu item, 667</p>
<p>Toggle IO Buffering menu item, 681</p>
<p>toggling</p>
<p>breakpoint status, 127</p>
<p>tracepoint status, 127</p>
<p>toolbar</p>
<p>adding buttons to, 698</p>
<p>button descriptions, 691</p>
<p>removing buttons from, 698</p>
<p>Tools menu, 685</p>
<p>-top command line option, 727</p>
<p>Top Project</p>
<p>contents, 90</p>
<p>_TOP_PROJECT system variable, 317</p>
<p>_TOP_PROJECT_DIR system variable, 317</p>
<p>tpset command, 562, 568, 570, 571</p>
<p>trace</p>
<p>accessing with TimeMachine API, 466</p>
<p>analyzing</p>
<p>with TimeMachine, 404</p>
<p>with TimeMachine API, 466</p>
<p>bookmarking, 444, 445, 446, 448</p>
<p>browsing, 431, 451, 452, 454, 456, 457</p>
<p>clearing, 410</p>
<p>collecting, 405</p>
<p>configuring collection of, 489, 491, 492, 493, 497</p>
<p>converting to</p>
<p>EventAnalyzer information, 474</p>
<p>profiling data, 475</p>
<p>disabling collection of, 406</p>
<p>discarding, 410</p>
<p>events supported, by architecture, 494</p>
<p>events, defining, 504</p>
<p>events, modifying with Set Triggers window, 495</p>
<p>events, specifying with</p>
<p>Advanced Event Editor, 443, 497</p>
<p>count expressions, 505</p>
<p>state machine expressions, 506</p>
<p>state machine resources, 502</p>
<p>events, viewing in the EventAnalyzer, 474</p>
<p>filtering, 442, 443</p>
<p>loading, 448</p>
<p>managing, 405</p>
<p>navigating, 428, 436, 440, 441, 442</p>
<p>operating system</p>
<p>collecting, 406</p>
<p>navigating, 436</p>
<p>options, setting, 480</p>
<p>overview, 402</p>
<p>quick start, 403</p>
<p>reconstructed register values, viewing, 476</p>
<p>retrieving, 408</p>
<p>saving, 448</p>
<p>searching, 430, 446, 447</p>
<p>statistics, viewing, 460, 462, 463, 464, 465</p>
<p>targets</p>
<p>configuring, 488</p>
<p>profiling, 355, 358, 475</p>
<p>supported, 402</p>
<p>viewing information about, 489</p>
<p>time analysis, 439</p>
<p>triggers, 489, 491, 493, 497</p>
<p>viewing with Trace List, 434, 435, 436</p>
<p>(see also Trace List)</p>
<p>trace abort command, 408</p>
<p>Trace Branch Browser, 454</p>
<p><i>MULTI: Debugging</i></p>
<p><i>826</i></p>
<p><i>TimeMachine API (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Trace Browsers, 451</p>
<p>Trace Call Browser, 431, 457</p>
<p>trace clear command, 411</p>
<p>trace disable command, 406</p>
<p>trace enable command, 406</p>
<p>Trace Function Interval menu item, 492</p>
<p>Trace Instruction Browser, 456</p>
<p>Trace List, 434</p>
<p>(see also trace)</p>
<p>AddressSpaces in, 436</p>
<p>columns, 436</p>
<p>display formats, 435</p>
<p>filtering trace with, 442</p>
<p>instruction pane, 436</p>
<p>navigating with, 436, 440, 441, 442</p>
<p>OS trace data in, 436</p>
<p>overview, 434</p>
<p>tasks in, 436</p>
<p>thumbnail pane, 439</p>
<p>time analysis, 439</p>
<p>TimeMachine functions, accessing, 444</p>
<p>tree pane, 435</p>
<p>Trace List menu item, 684</p>
<p>Trace Memory Browser, 452</p>
<p>Trace Options menu item, 684</p>
<p>Trace Options window, 480</p>
<p>trace retrieve command, 408</p>
<p>trace session</p>
<p>saving and loading, 448</p>
<p>Trace Statistics menu item, 684</p>
<p>Trace Statistics window</p>
<p>AddressSpaces tab, 462</p>
<p>Branches tab, 464</p>
<p>Functions tab, 465</p>
<p>Memory tab, 463</p>
<p>opening, 460</p>
<p>overview, 460</p>
<p>Summary tab, 460</p>
<p>traceload command, 450</p>
<p>tracemevsys command, 475</p>
<p>tracepoints</p>
<p>buffer</p>
<p>overview, 560</p>
<p>purging, 567</p>
<p>viewing, 566</p>
<p>deleting, 564</p>
<p>disabling, 127, 565</p>
<p>editing, 562, 563</p>
<p>enabling, 127, 565</p>
<p>example, 567</p>
<p>limitations, 570</p>
<p>listing, 564</p>
<p>markers, 125, 561</p>
<p>overview, 124, 560, 561</p>
<p>properties, 562</p>
<p>resetting, 565</p>
<p>setting, 561</p>
<p>timeout feature, 563</p>
<p>toggling status of, 127</p>
<p>viewing information about, 128</p>
<p>tracepro command, 358</p>
<p>tracesave command, 449</p>
<p>traffic pane, 33</p>
<p>translating</p>
<p>debugging information, 730</p>
<p>Tree Browser, 239</p>
<p>calls, browsing, 244, 245, 246</p>
<p>classes, browsing, 243</p>
<p>node operations, 242</p>
<p>opening, 239</p>
<p>rerooting, 243</p>
<p>tree pane in Trace List, 435</p>
<p>Trg pane, 30</p>
<p>triggers, trace, 489, 491, 493, 497</p>
<p>troubleshooting</p>
<p>concurrent freeze-/run-mode connections, 73</p>
<p>flash memory, 547</p>
<p>-tv command line option, 727</p>
<p>_tx_thread_created_ptr OS-specific symbol, 607</p>
<p>Type menu item, 679</p>
<p>types</p>
<p>in Data Explorer, 195</p>
<p>data, browsing, 213, 214, 233, 234, 235</p>
<p>shortcut menu for, 710, 711</p>
<p>typographical conventions, xxvi</p>
<p><b>U</b></p>
<p>u-velOSity (see operating systems)</p>
<p>Unconnected Executables target list message, 18</p>
<p>unknown programs, 113</p>
<p>Unload Module menu item, 680</p>
<p>Unreadable memory Data Explorer message, 201</p>
<p>Unreadable/Unknown Data Explorer message, 201</p>
<p>update command, 189</p>
<p>Upstack button, 694, 717</p>
<p>UpStack menu item, 162, 676</p>
<p>UpStack To Source menu item, 163, 677</p>
<p>-usage command line option, 727</p>
<p>Use Connection menu item, 667</p>
<p>Use Which Connection/CPU? dialog box, 105</p>
<p>using a connection, 105</p>
<p><i>827</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Trace Browsers</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Utility Program Launcher, 685</p>
<p><b>V</b></p>
<p>-V command line option, 727</p>
<p>variable lifetime information, 299</p>
<p>variables</p>
<p>global, listing, 678</p>
<p>local, listing, 673, 678</p>
<p>in procedure, listing, 678</p>
<p>$result, 317</p>
<p>search designators, 297, 298</p>
<p>shortcut menu for, 709</p>
<p>static, listing, 678</p>
<p>system, 310, 312</p>
<p>viewing value of, 300</p>
<p>viewing values of, 297</p>
<p>Variables In Procedure menu item, 678</p>
<p>velOSity (see operating systems)</p>
<p>VERIFYHALT system variable, 311</p>
<p>verifying presence of executable, 114</p>
<p>view command, 184</p>
<p>view descriptions</p>
<p>MULTI data visualization (.mdv) files, 744, 768</p>
<p>View Expression menu item, 675</p>
<p>View menu, 673</p>
<p>viewdel command, 185</p>
<p>viewing</p>
<p>assembly code, 23</p>
<p>caches, 392, 396</p>
<p>Debugger version information, 727</p>
<p>information about MULTI, 691</p>
<p>interlaced assembly code, 23</p>
<p>line numbers, 21, 24</p>
<p>local variables, 673</p>
<p>memory, 324</p>
<p>(see also Memory View window)</p>
<p>native processes, 390</p>
<p>profiling data, 361, 363, 377</p>
<p>program at addresses, 163, 677</p>
<p>source code, 23</p>
<p>variables, 297, 300</p>
<p>viewlist command, 192</p>
<p>views, Integrate, 802</p>
<p>visualizations</p>
<p>custom (see MULTI data visualization)</p>
<p><b>W</b></p>
<p>wait command, 95</p>
<p>wildcards, 303</p>
<p>windows</p>
<p>closing multiple, 676</p>
<p>in MULTI, 156</p>
<p>opening multiple, 14</p>
<p>reusing, 14</p>
<p>stand-alone, 168</p>
<p>Windows menu, 690</p>
<p>Write to file menu item, 662</p>
<p><b>Z</b></p>
<p>ZOMBIE status bar message, 37</p>
<p>Zombied target list status, 19</p>
<p><i>MULTI: Debugging</i></p>
<p><i>828</i></p>
<p><i>Utility Program Launcher</i></p>
</body>
</html>
{% endraw %}