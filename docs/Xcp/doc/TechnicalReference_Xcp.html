---
layout: default
title: TechnicalReference_Xcp
nav_order: 2
parent: Universal Measurement and Calibration Protocol (XCP)
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>XCP Protocol Layer </b></p>
<p>Technical Reference </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Version 2.05.00 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Version: </b></p>
<p>2.05.00 </p>
<p><b>Status: </b></p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>2 / 94 </p>
<p><b>1 </b></p>
<p><b>History </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>2005-01-17 </p>
<p>1.00.00 </p>
<p>ESCAN00009143: Initial draft </p>
<p>Warning Text added </p>
<p>2005-06-22 </p>
<p>1.01.00 </p>
<p>FAQ extended: ESCAN00012356, ESCAN00012314 </p>
<p>ESCAN00012617: Add service to retrieve XCP state </p>
<p>2005-12-20 </p>
<p>1.02.00 </p>
<p>ESCAN00013883: Revise Resume Mode </p>
<p>2006-03-09 </p>
<p>1.03.00 </p>
<p>ESCAN00015608: Support command </p>
<p>TRANSPORT_LAYER_CMD </p>
<p>ESCAN00015609: Support XCP on FlexRay Transport Layer </p>
<p>2006-04-24 </p>
<p>1.04.00 </p>
<p>ESCAN00015913: Correct filenames </p>
<p>Data page banking support of application callback template </p>
<p>added </p>
<p>2006-05-08 </p>
<p>1.05.00 </p>
<p>ESCAN00016263: Describe support of reflected CRC16 CCITT </p>
<p>ESCAN00016159: Add demo disclaimer to XCP Basic </p>
<p>2006-05-29 </p>
<p>1.06.00 </p>
<p>ESCAN00016226: Support XCP on LIN Transport Layer </p>
<p>2006-07-20 </p>
<p>1.07.00 </p>
<p>ESCAN00012636: Add configuration with GENy </p>
<p>ESCAN00016956: Support AUTOSAR CRC module </p>
<p>2006-10-26 </p>
<p>1.08.00 </p>
<p>ESCAN00018115: DPRAM Support only available in XCP Basic </p>
<p>ESCAN00017948: Add paging support </p>
<p>ESCAN00017221: Documentation of reentrant capability of all </p>
<p>functions </p>
<p>2007-01-18 </p>
<p>1.09.00 </p>
<p>ESCAN00018809: Support data paging on Star12X / Cosmic </p>
<p>2007-05-07 </p>
<p>1.10.00 </p>
<p>Description of new features added </p>
<p>2007-09-14 </p>
<p>1.11.00 </p>
<p>Segment freeze mode now supported </p>
<p>2008-07-23 </p>
<p>1.12.00 </p>
<p>ESCAN00028586: Support of Program_Start callback </p>
<p>ESCAN00017955: Support MIN_ST_PGM </p>
<p>ESCAN00017952: Open Interface for command processing </p>
<p>2008-09-10 </p>
<p>1.13.00 </p>
<p>Additional pending return value of call backs added </p>
<p>MIN_ST configuration added </p>
<p>2008-12-01 </p>
<p>1.14.00 </p>
<p>ESCAN00018157: SERV_RESET is not supported </p>
<p>ESCAN00032344: Update of XCP Basic Limitations </p>
<p>2009-05-14 </p>
<p>1.15.00 </p>
<p>ESCAN00033909: New features implemented: Prog Write </p>
<p>Protection, Timestamps, Calibration activation </p>
<p>2009-07-30 </p>
<p>1.15.01 </p>
<p>Fixed some editorial errors </p>
<p>2009-11-13 </p>
<p>1.16.00 </p>
<p>Added AUTOSAR Compiler Abstraction </p>
<p>2010-04-30 </p>
<p>1.16.01 </p>
<p>Fixed some editorial errors </p>
<p>2010-07-27 </p>
<p>1.16.02 </p>
<p>Fixed some editorial errors </p>
<p>2010-08-19 </p>
<p>1.17.00 </p>
<p>ESCAN00044693: New callbacks XcpCalibrationWrite and </p>
<p>XcpCalibrationRead </p>
<p>ESCAN00042867: Support Multiple Transport Layers </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>3 / 94 </p>
<p>2010-12-10 </p>
<p>1.18.00 </p>
<p>ESCAN00045981: Add support to read out FR Parameters </p>
<p>2011-07-20 </p>
<p>1.19.00 </p>
<p>ESCAN00049542: Describe IDT_VECTOR_MAPNAMES format </p>
<p>in TechRef </p>
<p>ESCAN00043487: XCP shall support user selectable behaviour </p>
<p>of Send Queue overrun </p>
<p>2011-08-04 </p>
<p> </p>
<p>ESCAN00052564: Adapt ReadCcConfig Parameter to ASR3.2.1 </p>
<p>2012-02-20 </p>
<p>1.19.01 </p>
<p>ESCAN00055214: DAQ Lists can be extended after </p>
<p>START_STOP_SYNCH </p>
<p>2012-09-03 </p>
<p>1.19.02 </p>
<p>ESCAN00061159: Provide an API to detect XCP state and usage </p>
<p>2012-11-08 </p>
<p>1.19.03 </p>
<p>Added Option for AMD Runtime Measurement </p>
<p>2011-03-23 </p>
<p>2.00.00 </p>
<p>ESCAN00049471: Create branch for AUTOSAR 4 </p>
<p>2013-02-11 </p>
<p>2.01.01 </p>
<p>Editorial Changes </p>
<p>2013-07-08 </p>
<p>2.02.00 </p>
<p>ESCAN00068035: Xcp_SetTransmissionMode not supported </p>
<p>ESCAN00070127: AR4-322/AR3_2552: Support of Vx1000 </p>
<p>System </p>
<p>ESCAN00070082: The API ApplXcpDaqResumeStore has a </p>
<p>wrong description </p>
<p>ESCAN00069019: Mapping to critical sections not described in </p>
<p>detail for Protocol Layer </p>
<p>ESCAN00068639: Describe data consistency on ODT Level </p>
<p>ESCAN00067332: Document the usage of the </p>
<p>Xcp_MainFunction/XcpBackground </p>
<p>2013-12-04 </p>
<p>2.03.00 </p>
<p>ESCAN00072401: Support custom CRC Cbk </p>
<p>ESCAN00072326: Support Generic GET_ID </p>
<p>2014-08-15 </p>
<p>2.03.01 </p>
<p>ESCAN00077231: AR3-2679: Description BCD-coded return-</p>
<p>value of Xcp_GetVersionInfo() in TechRef </p>
<p>ESCAN00077813: Specify supported ASAM Version </p>
<p>2015-02-02 </p>
<p>2.03.02 </p>
<p>ESCAN00080981: SET_CAL_PAGE is limited to synchronous </p>
<p>operation </p>
<p>2015-06-09 </p>
<p>2.04.00 </p>
<p>ESCAN00082215: FEAT-1450: Basic MultiCore XCP </p>
<p>2016-02-18 </p>
<p>2.04.01 </p>
<p>ESCAN00087492: New API </p>
<p>ApplXcpMeasurementRead/ApplXcpCalibrationWrite not </p>
<p>documented </p>
<p>ESCAN00087496: Return code description of ApplXcp call-backs </p>
<p>incomplete </p>
<p>2016-10-04 </p>
<p>2.05.00 </p>
<p>Replaced Xcp_Control API by variable. </p>
<p>ESCAN00091747: FEAT-1980: Add Multi Client / Multi </p>
<p>Connection support </p>
<p>ESCAN00092229: Support API to modify Protection State </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>4 / 94 </p>
<p> </p>
<p><b>Please note </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector’s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p> </p>
<p> </p>
<p><b>Note for XCP Basic </b></p>
<p>Please note, that the demo and example programs only show special aspects of the </p>
<p>software. With regard to the fact that these programs are meant for demonstration </p>
<p>purposes only, Vector Informatik’s liability shall be expressly excluded in cases of </p>
<p>ordinary negligence, to the extent admissible by law or statute. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>5 / 94 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>History ........................................................................................................................... 2</b></p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Overview ..................................................................................................................... 11</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>Abbreviations and Items used in this paper ...................................................... 11</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>Naming Conventions ........................................................................................ 13</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 14</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Overview of the Functional Scope .................................................................... 14</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Communication Mode Info ............................................................................... 14</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Block Transfer Communication Model (XCP Professional only) ....................... 14</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>Slave Device Identification ............................................................................... 14</p>
<p> </p>
<p>3.4.1</p>
<p> </p>
<p>XCP Station Identifier ....................................................................... 14</p>
<p> </p>
<p>3.4.2</p>
<p> </p>
<p>XCP Generic Identification ............................................................... 15</p>
<p> </p>
<p>3.4.3</p>
<p> </p>
<p>Identification of FlexRay Parameters ................................................ 15</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Seed &amp; Key ...................................................................................................... 15</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Checksum Calculation ..................................................................................... 17</p>
<p> </p>
<p>3.6.1</p>
<p> </p>
<p>Custom CRC calculation .................................................................. 17</p>
<p> </p>
<p>3.7</p>
<p> </p>
<p>MainFunction ................................................................................................... 17</p>
<p> </p>
<p>3.8</p>
<p> </p>
<p>Memory Protection (XCP Professional only) .................................................... 18</p>
<p> </p>
<p>3.9</p>
<p> </p>
<p>Memory Access by Application ......................................................................... 18</p>
<p> </p>
<p>3.9.1</p>
<p> </p>
<p>Special use case “Type Safe Copy” ................................................. 18</p>
<p> </p>
<p>3.10</p>
<p> </p>
<p>Event Codes .................................................................................................... 18</p>
<p> </p>
<p>3.11</p>
<p> </p>
<p>Service Request Messages ............................................................................. 19</p>
<p> </p>
<p>3.12</p>
<p> </p>
<p>User Defined Command ................................................................................... 19</p>
<p> </p>
<p>3.13</p>
<p> </p>
<p>Transport Layer Command .............................................................................. 19</p>
<p> </p>
<p>3.14</p>
<p> </p>
<p>Synchronous Data Transfer ............................................................................. 20</p>
<p> </p>
<p>3.14.1</p>
<p> </p>
<p>Synchronous Data Acquisition (DAQ) ............................................... 20</p>
<p> </p>
<p>3.14.2</p>
<p> </p>
<p>DAQ Timestamp ............................................................................... 20</p>
<p> </p>
<p>3.14.3</p>
<p> </p>
<p>Power-Up Data Transfer .................................................................. 21</p>
<p> </p>
<p>3.14.4</p>
<p> </p>
<p>Send Queue ..................................................................................... 21</p>
<p> </p>
<p>3.14.5</p>
<p> </p>
<p>Data Stimulation (STIM) ................................................................... 22</p>
<p> </p>
<p>3.14.6</p>
<p> </p>
<p>Bypassing ........................................................................................ 22</p>
<p> </p>
<p>3.14.7</p>
<p> </p>
<p>Data Acquisition Plug &amp; Play Mechanisms ....................................... 22</p>
<p> </p>
<p>3.14.8</p>
<p> </p>
<p>Event Channel Plug &amp; Play Mechanism ........................................... 23</p>
<p> </p>
<p>3.14.9</p>
<p> </p>
<p>Data consistency .............................................................................. 23</p>
<p> </p>
<p>3.15</p>
<p> </p>
<p>The Online Data Calibration Model .................................................................. 24</p>
<p> </p>
<p>3.15.1</p>
<p> </p>
<p>Page Switching ................................................................................ 24</p>
<p> </p>
<p>3.15.2</p>
<p> </p>
<p>Page Switching Plug &amp; Play Mechanism .......................................... 24</p>
<p> </p>
<p>3.15.3</p>
<p> </p>
<p>Calibration Data Page Copying ........................................................ 24</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>6 / 94 </p>
<p>3.15.4</p>
<p> </p>
<p>Freeze Mode Handling ..................................................................... 24</p>
<p> </p>
<p>3.16</p>
<p> </p>
<p>Flash Programming .......................................................................................... 25</p>
<p> </p>
<p>3.16.1</p>
<p> </p>
<p>Flash Programming by the ECU’s Application .................................. 25</p>
<p> </p>
<p>3.16.2</p>
<p> </p>
<p>Flash Programming with a Flash Kernel ........................................... 26</p>
<p> </p>
<p>3.16.3</p>
<p> </p>
<p>Flash Programming Write Protection ................................................ 26</p>
<p> </p>
<p>3.17</p>
<p> </p>
<p>EEPROM Access ............................................................................................. 26</p>
<p> </p>
<p>3.18</p>
<p> </p>
<p>Parameter Check ............................................................................................. 27</p>
<p> </p>
<p>3.19</p>
<p> </p>
<p>Performance Optimizations .............................................................................. 27</p>
<p> </p>
<p>3.20</p>
<p> </p>
<p>Interrupt Locks / Exclusive Areas ..................................................................... 27</p>
<p> </p>
<p>3.20.1</p>
<p> </p>
<p>XCP_EXCLUSIVE_AREA_0 ............................................................ 28</p>
<p> </p>
<p>3.20.2</p>
<p> </p>
<p>XCP_EXCLUSIVE_AREA_1 ............................................................ 28</p>
<p> </p>
<p>3.20.3</p>
<p> </p>
<p>XCP_EXCLUSIVE_AREA_2 ............................................................ 28</p>
<p> </p>
<p>3.21</p>
<p> </p>
<p>Basic Multi Core support .................................................................................. 28</p>
<p> </p>
<p>3.21.1</p>
<p> </p>
<p>Type safe copy ................................................................................. 28</p>
<p> </p>
<p>3.22</p>
<p> </p>
<p>Accessing internal data .................................................................................... 28</p>
<p> </p>
<p>3.23</p>
<p> </p>
<p>En- / Disabling the XCP module ....................................................................... 28</p>
<p> </p>
<p>3.24</p>
<p> </p>
<p>XCP measurement during the follow up time ................................................... 29</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Integration into the Application ................................................................................. 30</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Files of XCP Professional ................................................................................ 30</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Version changes .............................................................................................. 30</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Compiler Abstraction and Memory Mapping ..................................................... 30</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Support of Vx1000 Integration.......................................................................... 31</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Feature List ................................................................................................................. 32</b></p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Description of the API ................................................................................................ 34</b></p>
<p> </p>
<p>6.1</p>
<p> </p>
<p>Version of the Source Code ............................................................................. 34</p>
<p> </p>
<p>6.2</p>
<p> </p>
<p>XCP Services called by the Application ............................................................ 35</p>
<p> </p>
<p>6.2.1</p>
<p> </p>
<p>Xcp_InitMemory: Initialization of the XCP Protocol Layer Memory ... 35</p>
<p> </p>
<p>6.2.2</p>
<p> </p>
<p>Xcp_Init: Initialization of the XCP Protocol Layer .............................. 35</p>
<p> </p>
<p>6.2.3</p>
<p> </p>
<p>Xcp_Event: Handling of a data acquisition event channel ................ 36</p>
<p> </p>
<p>6.2.4</p>
<p> </p>
<p>Xcp_StimEventStatus: Check data stimulation events ..................... 37</p>
<p> </p>
<p>6.2.5</p>
<p> </p>
<p>Xcp_MainFunction: Background calculation of checksum ................ 37</p>
<p> </p>
<p>6.2.6</p>
<p> </p>
<p>Xcp_SendEvent: Transmission of event codes ................................. 38</p>
<p> </p>
<p>6.2.7</p>
<p> </p>
<p>Xcp_Putchar: Put a char into a service request packet .................... 38</p>
<p> </p>
<p>6.2.8</p>
<p> </p>
<p>Xcp_Print: Transmission of a service request packet ....................... 39</p>
<p> </p>
<p>6.2.9</p>
<p> </p>
<p>Xcp_Disconnect: Disconnect from XCP master ................................ 40</p>
<p> </p>
<p>6.2.10</p>
<p> </p>
<p>Xcp_SendCrm: Transmit response or error packet ........................... 40</p>
<p> </p>
<p>6.2.11</p>
<p> </p>
<p>Xcp_GetXcpDataPointer: Request internal data pointer ................... 41</p>
<p> </p>
<p>6.2.12</p>
<p> </p>
<p>Xcp_GetVersionInfo: Request module version information ............... 41</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>7 / 94 </p>
<p>6.2.13</p>
<p> </p>
<p>Xcp_ModifyProtectionStatus: Influence seed&amp;key behaviour ........... 42</p>
<p> </p>
<p>6.3</p>
<p> </p>
<p>XCP Protocol Layer Functions, called by the XCP Transport Layer .................. 42</p>
<p> </p>
<p>6.3.1</p>
<p> </p>
<p>Xcp_Command: Evaluation of XCP packets and command </p>
<p>interpreter ........................................................................................ 43</p>
<p> </p>
<p>6.3.2</p>
<p> </p>
<p>Xcp_SendCallBack: Confirmation of the successful transmission of </p>
<p>a XCP packet ................................................................................... 43</p>
<p> </p>
<p>6.3.3</p>
<p> </p>
<p>Xcp_GetSessionStatus: Get session state of XCP ........................... 44</p>
<p> </p>
<p>6.3.4</p>
<p> </p>
<p>Xcp_SetActiveTl: Set the active Transport Layer .............................. 45</p>
<p> </p>
<p>6.3.5</p>
<p> </p>
<p>Xcp_GetActiveTl: Get the currently active Transport Layer .............. 45</p>
<p> </p>
<p>6.4</p>
<p> </p>
<p>XCP Transport Layer Services called by the XCP Protocol Layer .................... 46</p>
<p> </p>
<p>6.4.1</p>
<p> </p>
<p>&lt;Bus&gt;Xcp_Send: Request for the transmission of a DTO or CTO </p>
<p>message .......................................................................................... 46</p>
<p> </p>
<p>6.4.2</p>
<p> </p>
<p>&lt;Bus&gt;Xcp_SendFlush: Flush transmit buffer ................................... 46</p>
<p> </p>
<p>6.4.3</p>
<p> </p>
<p>XcpAppl_InterruptEnable: Enable interrupts ..................................... 47</p>
<p> </p>
<p>6.4.4</p>
<p> </p>
<p>XcpAppl_InterruptDisable: Disable interrupts ................................... 48</p>
<p> </p>
<p>6.4.5</p>
<p> </p>
<p>&lt;Bus&gt;Xcp_TLService: Transport Layer specific commands ............. 48</p>
<p> </p>
<p>6.5</p>
<p> </p>
<p>Application Services called by the XCP Protocol Layer .................................... 49</p>
<p> </p>
<p>6.5.1</p>
<p> </p>
<p>XcpAppl_GetPointer: Pointer conversion ......................................... 49</p>
<p> </p>
<p>6.5.2</p>
<p> </p>
<p>XcpAppl_GetIdData: Get Identification ............................................. 50</p>
<p> </p>
<p>6.5.3</p>
<p> </p>
<p>XcpAppl_GetSeed: Generate a seed ............................................... 50</p>
<p> </p>
<p>6.5.4</p>
<p> </p>
<p>XcpAppl_Unlock: Valid key and unlock resource .............................. 51</p>
<p> </p>
<p>6.5.5</p>
<p> </p>
<p>XcpAppl_CheckReadEEPROM: Check read access from </p>
<p>EEPROM ......................................................................................... 52</p>
<p> </p>
<p>6.5.6</p>
<p> </p>
<p>XcpAppl_CheckWriteEEPROM: Check write access to the </p>
<p>EEPROM ......................................................................................... 53</p>
<p> </p>
<p>6.5.7</p>
<p> </p>
<p>XcpAppl_CheckWriteAccess: Check address for valid write access . 53</p>
<p> </p>
<p>6.5.8</p>
<p> </p>
<p>XcpAppl_CheckReadAccess: Check address for valid read access . 54</p>
<p> </p>
<p>6.5.9</p>
<p> </p>
<p>XcpAppl_CheckDAQAccess: Check address for valid read or write </p>
<p>access.............................................................................................. 55</p>
<p> </p>
<p>6.5.10</p>
<p> </p>
<p>XcpAppl_CheckProgramAccess: Check address for valid write </p>
<p>access.............................................................................................. 55</p>
<p> </p>
<p>6.5.11</p>
<p> </p>
<p>XcpAppl_UserService: User defined command ................................ 56</p>
<p> </p>
<p>6.5.12</p>
<p> </p>
<p>XcpAppl_OpenCmdIf: XCP command extension interface ............... 56</p>
<p> </p>
<p>6.5.13</p>
<p> </p>
<p>XcpAppl_SendStall: Resolve a transmit stall condition ..................... 57</p>
<p> </p>
<p>6.5.14</p>
<p> </p>
<p>XcpAppl_DisableNormalOperation: Disable normal operation of the </p>
<p>ECU ................................................................................................. 58</p>
<p> </p>
<p>6.5.15</p>
<p> </p>
<p>XcpAppl_StartBootLoader: Start of boot loader ................................ 58</p>
<p> </p>
<p>6.5.16</p>
<p> </p>
<p>XcpAppl_Reset: Perform ECU reset ................................................ 59</p>
<p> </p>
<p>6.5.17</p>
<p> </p>
<p>XcpAppl_ProgramStart: Prepare flash programming ........................ 59</p>
<p> </p>
<p>6.5.18</p>
<p> </p>
<p>XcpAppl_FlashClear: Clear flash memory ........................................ 60</p>
<p> </p>
<p>6.5.19</p>
<p> </p>
<p>XcpAppl_FlashProgram: Program flash memory .............................. 60</p>
<p> </p>
<p>6.5.20</p>
<p> </p>
<p>XcpAppl_DaqResume: Resume automatic data transfer .................. 61</p>
<p> </p>
<p>6.5.21</p>
<p> </p>
<p>XcpAppl_DaqResumeStore: Store DAQ lists for resume mode ........ 62</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>8 / 94 </p>
<p>6.5.22</p>
<p> </p>
<p>XcpAppl_DaqResumeClear: Clear stored DAQ lists......................... 62</p>
<p> </p>
<p>6.5.23</p>
<p> </p>
<p>XcpAppl_CalResumeStore: Store Calibration data for resume </p>
<p>mode ................................................................................................ 63</p>
<p> </p>
<p>6.5.24</p>
<p> </p>
<p>XcpAppl_GetTimestamp: Returns the current timestamp ................. 64</p>
<p> </p>
<p>6.5.25</p>
<p> </p>
<p>XcpAppl_GetCalPage: Get calibration page ..................................... 64</p>
<p> </p>
<p>6.5.26</p>
<p> </p>
<p>XcpAppl_SetCalPage: Set calibration page ..................................... 65</p>
<p> </p>
<p>6.5.27</p>
<p> </p>
<p>XcpAppl_CopyCalPage: Copying of calibration data pages ............. 66</p>
<p> </p>
<p>6.5.28</p>
<p> </p>
<p>XcpAppl_SetFreezeMode: Setting the freeze mode of a segment .... 66</p>
<p> </p>
<p>6.5.29</p>
<p> </p>
<p>XcpAppl_GetFreezeMode: Reading the freeze mode of a segment . 67</p>
<p> </p>
<p>6.5.30</p>
<p> </p>
<p>XcpAppl_Read: Read a single byte from memory ............................ 67</p>
<p> </p>
<p>6.5.31</p>
<p> </p>
<p>XcpAppl_Write: Write a single byte to RAM ...................................... 68</p>
<p> </p>
<p>6.5.32</p>
<p> </p>
<p>XcpAppl_MeasurementRead: Read multiple bytes from memory ..... 68</p>
<p> </p>
<p>6.5.33</p>
<p> </p>
<p>XcpAppl_CalibrationWrite: Write multiple bytes to memory .............. 69</p>
<p> </p>
<p>6.5.34</p>
<p> </p>
<p>XcpAppl_ReadChecksumValue: Read checksum value ................... 70</p>
<p> </p>
<p>6.5.35</p>
<p> </p>
<p>XcpAppl_CalculateChecksum: Custom checksum calculation ......... 70</p>
<p> </p>
<p>6.6</p>
<p> </p>
<p>XCP Protocol Layer Functions that can be overwritten ..................................... 71</p>
<p> </p>
<p>6.6.1</p>
<p> </p>
<p>Xcp_MemCpy: Copying of a memory range ..................................... 71</p>
<p> </p>
<p>6.6.2</p>
<p> </p>
<p>Xcp_MemSet: Initialization of a memory range ................................ 72</p>
<p> </p>
<p>6.6.3</p>
<p> </p>
<p>Xcp_MemClr: Clear a memory range ............................................... 72</p>
<p> </p>
<p>6.7</p>
<p> </p>
<p>AUTOSAR CRC Module Services called by the XCP Protocol Layer (XCP </p>
<p>Professional Only) ............................................................................................ 73</p>
<p> </p>
<p>6.8</p>
<p> </p>
<p>Configuration without Generation Tool ............................................................. 75</p>
<p> </p>
<p>6.8.1</p>
<p> </p>
<p>Compiler Switches ........................................................................... 75</p>
<p> </p>
<p>6.8.2</p>
<p> </p>
<p>Configuration of Constant Definitions ............................................... 78</p>
<p> </p>
<p>6.8.3</p>
<p> </p>
<p>Configuration of the CPU Type ......................................................... 80</p>
<p> </p>
<p>6.8.4</p>
<p> </p>
<p>Configuration of Slave Device Identification ..................................... 80</p>
<p> </p>
<p>6.8.5</p>
<p> </p>
<p>Configuration of the Event Channel Plug &amp; Play Mechanism ........... 82</p>
<p> </p>
<p>6.8.6</p>
<p> </p>
<p>Configuration of the DAQ Time Stamped Mode ................................ 83</p>
<p> </p>
<p>6.8.7</p>
<p> </p>
<p>Configuration of the Flash Programming Plug &amp; Play Mechanism .... 84</p>
<p> </p>
<p>6.8.8</p>
<p> </p>
<p>Configuration of the Page Switching Plug &amp; Play Mechanism .......... 85</p>
<p> </p>
<p>6.8.9</p>
<p> </p>
<p>Configuration of the used Transport Layer ....................................... 85</p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Resource Requirements............................................................................................. 87</b></p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Limitations .................................................................................................................. 88</b></p>
<p> </p>
<p>8.1</p>
<p> </p>
<p>General Limitations .......................................................................................... 88</p>
<p> </p>
<p>8.2</p>
<p> </p>
<p>Limitations Regarding Platforms, Compilers and Memory Models .................... 89</p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>FAQ .............................................................................................................................. 90</b></p>
<p> </p>
<p>9.1</p>
<p> </p>
<p>Invalid Time Stamp Unit ................................................................................... 90</p>
<p> </p>
<p>9.2</p>
<p> </p>
<p>Support of small and medium memory model .................................................. 90</p>
<p> </p>
<p>9.3</p>
<p> </p>
<p>Small memory model on ST10 / XC16X / C16X with Tasking Compiler ............ 91</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>9 / 94 </p>
<p>9.4</p>
<p> </p>
<p>Data Page Banking on Star12X / Metrowerks .................................................. 91</p>
<p> </p>
<p>9.5</p>
<p> </p>
<p>Memory model banked on Star12X / Cosmic ................................................... 91</p>
<p> </p>
<p>9.6</p>
<p> </p>
<p>Reflected CRC16 CCITT Checksum Calculation Algorithm .............................. 92</p>
<p> </p>
<p><b>10</b></p>
<p> </p>
<p><b>Bibliography ................................................................................................................ 93</b></p>
<p> </p>
<p><b>11</b></p>
<p> </p>
<p><b>Contact ........................................................................................................................ 94</b></p>
<p> </p>
<p><i><b> </b></i></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>10 / 94 </p>
<p><b>Illustrations </b></p>
<p>Figure 3-1</p>
<p> </p>
<p>Data consistency ...................................................................................... 23</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>11 / 94 </p>
<p><b>2 </b></p>
<p><b>Overview </b></p>
<p>This  document  describes  the  features,  API,  configuration  and  integration  of  the  XCP </p>
<p>Protocol Layer. Both XCP versions: XCP Professional and XCP Basic are covered by this </p>
<p>document. Chapters that are only relevant for XCP Professional are marked. </p>
<p>This document does not cover the XCP Transport Layers for CAN, FlexRay and LIN, which </p>
<p>are available at Vector Informatik.  </p>
<p>Please refer to [IV] for further information about XCP on CAN and the integration of XCP </p>
<p>on CAN with the Vector CANbedded software components. Further information about XCP </p>
<p>on  FlexRay  Transport  Layer  and  XCP  on  LIN  Transport  Layer  can  be  found  in  its </p>
<p>documentation. </p>
<p>Please </p>
<p>also </p>
<p>refer </p>
<p>to </p>
<p>“The </p>
<p>Universal </p>
<p>Measurement </p>
<p>and </p>
<p>Calibration </p>
<p>Protocol </p>
<p>Family” </p>
<p>specification by ASAM e.V. </p>
<p>The XCP Protocol Layer is a hardware independent protocol that can be ported to almost </p>
<p>any  hardware.  Due  to  there  are  numerous  combinations  of  micro  controllers,  compilers </p>
<p>and memory models it cannot be guaranteed that it will run properly on any of the above </p>
<p>mentioned combinations. </p>
<p>Please  note  that  in  this  document  the  term Application  is  not  used  strictly  for  the  user </p>
<p>software but also for any higher software layer, like e.g. a Communication Control Layer. </p>
<p>Therefore, Application refers to any of the software components using XCP. </p>
<p>The API of the functions is described in a separate chapter at the end of this document. </p>
<p>Referred functions are always shown in the single channel mode.  </p>
<p> </p>
<p> </p>
<p><b>Info</b> </p>
<p>The source code of the XCP Protocol Layer, configuration examples and </p>
<p>documentation are available on the Internet at www.vector-informatik.de in a </p>
<p>functional restricted form. </p>
<p> </p>
<p><b>2.1 </b></p>
<p><b>Abbreviations and Items used in this paper </b></p>
<p> </p>
<p><b>Abbreviations </b></p>
<p><b>Complete expression </b></p>
<p><b>A2L </b></p>
<p>File Extension for an <b>A</b>SAM <b>2</b>MC <b>L</b>anguage File </p>
<p><b>AML </b></p>
<p><b>A</b>SAM 2 <b>M</b>eta <b>L</b>anguage </p>
<p><b>API </b></p>
<p><b>A</b>pplication <b>P</b>rogramming <b>I</b>nterface </p>
<p><b>ASAM </b></p>
<p><b>A</b>ssociation for <b>S</b>tandardization of <b>A</b>utomation and <b>M</b>easuring Systems </p>
<p><b>BYP </b></p>
<p><b>BYP</b>assing </p>
<p><b>CAN </b></p>
<p><b>C</b>ontroller <b>A</b>rea <b>N</b>etwork </p>
<p><b>CAL </b></p>
<p><b>CAL</b>ibration </p>
<p><b>CANape </b></p>
<p>Calibration </p>
<p>and </p>
<p>Measurement </p>
<p>Data  Acquisition </p>
<p>for </p>
<p>Electronic </p>
<p>Control </p>
<p>Systems </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>12 / 94 </p>
<p><b>CMD </b></p>
<p><b>C</b>o<b>m</b>man<b>d </b></p>
<p><b>CTO </b></p>
<p><b>C</b>ommand <b>T</b>ransfer <b>O</b>bject </p>
<p><b>DAQ </b></p>
<p>Synchronous <b>D</b>ata <b>A</b>c<b>q</b>uistion </p>
<p><b>DLC </b></p>
<p><b>D</b>ata <b>L</b>ength <b>C</b>ode ( Number of data bytes of a CAN message ) </p>
<p><b>DLL </b></p>
<p><b>D</b>ata <b>l</b>ink <b>l</b>ayer </p>
<p><b>DTO </b></p>
<p><b>D</b>ata <b>T</b>ransfer <b>O</b>bject </p>
<p><b>ECU </b></p>
<p><b>E</b>lectronic <b>C</b>ontrol <b>U</b>nit </p>
<p><b>ERR </b></p>
<p><b>Err</b>or Packet </p>
<p><b>EV </b></p>
<p><b>Ev</b>ent packet </p>
<p><b>ID </b></p>
<p><b>Id</b>entifier (of a CAN message) </p>
<p><b>Identifier </b></p>
<p>Identifies a CAN message </p>
<p><b>ISR </b></p>
<p><b>I</b>nterrupt <b>S</b>ervice <b>R</b>outine </p>
<p><b>MCS </b></p>
<p><b>M</b>aster <b>C</b>alibration <b>S</b>ystem </p>
<p><b>Message </b></p>
<p>One or more signals are assigned to each message. </p>
<p><b>ODT </b></p>
<p><b>O</b>bject <b>D</b>escriptor <b>T</b>able </p>
<p><b>OEM </b></p>
<p><b>O</b>riginal <b>e</b>quipment <b>m</b>anufacturer (vehicle manufacturer) </p>
<p><b>PAG </b></p>
<p><b>PAG</b>ing </p>
<p><b>PID </b></p>
<p><b>P</b>acket <b>Id</b>entifier </p>
<p><b>PGM </b></p>
<p><b>P</b>ro<b>g</b>ra<b>m</b>ming </p>
<p><b>RAM </b></p>
<p><b>R</b>andom <b>A</b>ccess <b>M</b>emory </p>
<p><b>RES </b></p>
<p>Command <b>Res</b>ponse Packet </p>
<p><b>ROM </b></p>
<p><b>R</b>ead <b>O</b>nly <b>M</b>emory </p>
<p><b>SERV </b></p>
<p><b>Ser</b>vice Request Packet </p>
<p><b>STIM </b></p>
<p><b>Stim</b>ulation </p>
<p><b>TCP/IP </b></p>
<p><b>T</b>ransfer <b>C</b>ontrol <b>P</b>rotocol / <b>I</b>nternet <b>P</b>rotocol </p>
<p><b>UDP/IP </b></p>
<p><b>U</b>nified <b>D</b>ata <b>P</b>rotocol / <b>I</b>nternet <b>P</b>rotocol </p>
<p><b>USB </b></p>
<p><b>U</b>niversal <b>S</b>erial <b>B</b>us </p>
<p><b>XCP </b></p>
<p>Universal Measurement and <b>C</b>alibration <b>P</b>rotocol </p>
<p><b>VI </b></p>
<p><b>V</b>ector <b>I</b>nformatik GmbH </p>
<p> </p>
<p>Also refer to ‘AN-AND-1-108 Glossary of CAN Protocol Terminology.pdf’, which can be </p>
<p>found in the download area of http://www.vector-informatik.de. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>13 / 94 </p>
<p><b>2.2 </b></p>
<p><b>Naming Conventions </b></p>
<p>The names of the access functions provided by the XCP Protocol Layer always start with a </p>
<p>prefix  that  includes  the  characters </p>
<p>Xcp</p>
<p>.  The  characters </p>
<p>Xcp</p>
<p>  are  surrounded  by  an </p>
<p>abbreviation which refers to the service or to the layer which requests a XCP service. The </p>
<p>designation of the main services is listed below: </p>
<p> </p>
<p><b>Naming conventions </b></p>
<p>Xcp_</p>
<p>… </p>
<p>It is mandatory to use all functions beginning with Xcp… </p>
<p>These services are called by either the data link layer or the application. </p>
<p>They are e.g. used for the initialization of the XCP Protocol Layer and for the </p>
<p>cyclic background task. </p>
<p>XcpAppl_</p>
<p>... </p>
<p>The  functions,  starting  with </p>
<p>ApplXcp</p>
<p>…  are  functions  that  are  provided </p>
<p>either by any XCP Transport Layer or the application and are called by the </p>
<p>XCP Protocol Layer. </p>
<p>These services are user callback functions that are application specific and have </p>
<p>to be implemented depending on the application. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>14 / 94 </p>
<p><b>3 </b></p>
<p><b>Functional Description </b></p>
<p><b>3.1 </b></p>
<p><b>Overview of the Functional Scope </b></p>
<p>The  Universal  Measurement </p>
<p>and  Calibration  Protocol  (XCP)  is  standardized  by  the </p>
<p>European ASAM  working  committee  for  standardization  of  interfaces  used  in  calibration </p>
<p>and measurement data acquisition. XCP is a higher level protocol used for communication </p>
<p>between  a  measurement  and  calibration  system  (MCS,  i.e.  CANape)  and  an  electronic </p>
<p>control unit (ECU). The implementation supports the ASAM XCP 1.1 Specification. </p>
<p><b>3.2 </b></p>
<p><b>Communication Mode Info </b></p>
<p>In order to gather information about the XCP Slave device, e.g. the implementation version </p>
<p>number </p>
<p>of </p>
<p>the </p>
<p>XCP </p>
<p>Protocol </p>
<p>Layer </p>
<p>and </p>
<p>supported </p>
<p>communications </p>
<p>models, </p>
<p>the </p>
<p>communication mode info can be enabled by the switch </p>
<p>XCP_ENABLE_COMM_MODE_INFO</p>
<p>. </p>
<p><b>3.3 </b></p>
<p><b>Block Transfer Communication Model (XCP Professional only) </b></p>
<p>In  the  standard  communication  model,  each  request  packet  is  responded  by  a  single </p>
<p>response packet or an error packet. To speed up memory uploads, downloads and flash </p>
<p>programming  the  XCP  commands  UPLOAD,  DOWNLOAD  and  PROGRAM  support  a </p>
<p>block transfer mode similar to ISO/DIS 15765-2. </p>
<p>In  the  Master  Block  Transfer  Mode  can  the  master  transmit  subsequent  (up  to  the </p>
<p>maximum block size MAX_BS) request packets to the slave without getting any response </p>
<p>in between. The slave responds after transmission of the last request packet of the block. </p>
<p>In Slave Block Transfer Mode the slave can respond subsequent (there is no limitation) to </p>
<p>a request without additional requests in between. </p>
<p>Refer to chapter 6.8.1 for configuration details. </p>
<p><b>3.4 </b></p>
<p><b>Slave Device Identification </b></p>
<p><b>3.4.1 </b></p>
<p><b>XCP Station Identifier </b></p>
<p>The  XCP  station  identifier  is  an ASCII  string  that  identifies  the  ECU’s  software  program </p>
<p>version. </p>
<p>The  MCS  can  interpret  this  identifier  as  file  name  for  the  ECU  database.  The  ECU </p>
<p>developer should change the XCP station identifier with each program change. This will </p>
<p>prevent database mix-ups and grant the correct access of measurement and calibration </p>
<p>objects  from  the  MCS  to  the  ECU.  Another  benefit  of  the  usage  of  the  XCP  station </p>
<p>identifier is the automatic assignment of the correct ECU database at program start of the </p>
<p>MCS via the plug &amp; play mechanism. The plug &amp; play mechanism prevents the user from </p>
<p>selecting the wrong ECU database. </p>
<p>Refer </p>
<p>to </p>
<p>chapter </p>
<p>6.8.4.1 </p>
<p>(Identification </p>
<p>by </p>
<p>ASAM-MC2 </p>
<p>Filename </p>
<p>without </p>
<p>Path </p>
<p>and </p>
<p>Extension) for configuration details. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>15 / 94 </p>
<p><b>3.4.2 </b></p>
<p><b>XCP Generic Identification </b></p>
<p>The XCP provides a generic mechanism for identification by the GET_ID command. For </p>
<p>this  purpose  a  call-back  exist  which  can  be  implemented  by  the  user  to  provide  the </p>
<p>requested information. The following function  </p>
<p>uint32 <b>XcpAppl_GetIdData</b>( MTABYTEPTR *pData, uint8 id )</p>
<p> </p>
<p>(6.5.2)</p>
<p> </p>
<p>has to set a pointer to the identification information based on the requested id and return </p>
<p>the length of this information. </p>
<p>Refer to chapter 6.8.4.2 (Automatic Session Configuration with MAP Filenames) for an </p>
<p>example implementation. </p>
<p> </p>
<p><b>3.4.3 </b></p>
<p><b>Identification of FlexRay Parameters </b></p>
<p>If the “Virtual FlexRay Parameters” feature is enabled, the parameters can be read out in a </p>
<p>platform independent way. They will be provided as virtual measurement values that can </p>
<p>be read at fixed memory locations with a configurable Address Extension. </p>
<p>To calculate the memory address for each parameter please read the Technical Reference </p>
<p>and the AUTOSAR specification of the FlexRay Driver. Each FlexRay parameter is defined </p>
<p>with a unique ID to be used as parameter for the API call. Use this ID and multiply it with </p>
<p>four to get the address where this variable can be measured at. </p>
<p>If this parameter is enabled the API: </p>
<p> </p>
<p>Std_ReturnType </p>
<p><b>FrIf_ReadCCConfig</b>( </p>
<p>uint8 </p>
<p>ClusterIdx, </p>
<p>uint8 </p>
<p>FrIf_CCLLParamIndex,  P2VAR(uint32,  AUTOMATIC,  FRIF_APPL_DATA) </p>
<p>FrIf_CCLLParamValue )</p>
<p> </p>
<p>will be called. The FlexRay parameters can be measured from CAN and FlexRay but the </p>
<p>API is only provided if the FlexRay Interface is present. </p>
<p><b>3.5 </b></p>
<p><b>Seed &amp; Key </b></p>
<p>The </p>
<p>seed </p>
<p>and </p>
<p>key </p>
<p>feature </p>
<p>allows </p>
<p>individual </p>
<p>access </p>
<p>protection </p>
<p>for </p>
<p>calibration, </p>
<p>flash </p>
<p>programming,  synchronous  data  acquisition  and  data  stimulation.  The  MCS  requests  a </p>
<p>seed  (a  few  data  bytes)  from  the  ECU  and  calculates  a  key  based  on  a  proprietary </p>
<p>algorithm and sends it back to the ECU. </p>
<p>The seed &amp; key functionality can be enabled with the switch </p>
<p>XCP_ENABLE_SEED_KEY</p>
<p> and </p>
<p>disabled with </p>
<p>XCP_DISABLE_SEED_KEY</p>
<p> in order to save ROM. Also refer to chapter 6.8.1. </p>
<p>The application callback function </p>
<p>uint8 <b> XcpAppl_GetSeed</b>(  uint8  Xcp_Channel,  MEMORY_ROM  uint8 </p>
<p>resourceMask, BYTEPTR seed ) </p>
<p>(6.5.3) </p>
<p>returns a seed that is transferred to the MCS. The callback function </p>
<p>uint8 <b>XcpAppl_Unlock</b>( uint8 Xcp_Channel, MEMORY_ROM uint8 *key, </p>
<p>MEMORY_ROM uint8 length ) </p>
<p>(6.5.4) </p>
<p>has to verify a received key and if appropriate return the resource that shall be unlocked. </p>
<p>The service: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>16 / 94 </p>
<p>uint8 </p>
<p><b>Xcp_ModifyProtectionStatus</b>( </p>
<p>uint8 </p>
<p>Xcp_Channel, </p>
<p>uint8 </p>
<p>andState, uint8 orState ) </p>
<p>(6.2.13) </p>
<p>can be used to modify the protection state by software. </p>
<p> </p>
<p>Annotation for the usage of CANape </p>
<p>The calculation of the key is done in a DLL named SEEDKEY1.DLL, which is developed by </p>
<p>the  ECU  manufacturer  and  which  must  be  located  in  the  EXEC  directory  of  CANape. </p>
<p>CANape can access the ECU only if the ECU accepts the key. If the key is not valid, the </p>
<p>ECU stays locked. </p>
<p>Example Implementation for SEEDKEY1.DLL </p>
<p>The function call of ASAP1A_XCP_ComputeKeyFromSeed() is standardized by the ASAM </p>
<p>committee. </p>
<p> </p>
<p> </p>
<p><b>Example </b></p>
<p>FILE SEEDKEY1.H </p>
<p>#ifndef _SEEDKEY_H_ </p>
<p> </p>
<p>#define _SEEDKEY_H_ </p>
<p>#ifndef DllImport </p>
<p>#define DllImport  __declspec(dllimport) </p>
<p>#endif </p>
<p>#ifndef DllExport </p>
<p>#define DllExport  __declspec(dllexport) </p>
<p>#endif </p>
<p>#ifdef SEEDKEYAPI_IMPL </p>
<p>#define SEEDKEYAPI DllExport __cdecl </p>
<p>#else </p>
<p>#define SEEDKEYAPI DllImport __cdecl </p>
<p>#endif </p>
<p>#ifdef __cplusplus </p>
<p>extern &quot;C&quot; { </p>
<p>#endif </p>
<p> </p>
<p>BOOL SEEDKEYAPI ASAP1A_XCP_ComputeKeyFromSeed( BYTE *seed, </p>
<p>  unsigned short sizeSeed, </p>
<p>  BYTE *key, </p>
<p>  unsigned short maxSizeKey, </p>
<p>  unsigned short *sizeKey </p>
<p>  ); </p>
<p>#ifdef __cplusplus </p>
<p>} </p>
<p>#endif </p>
<p>#endif </p>
<p> </p>
<p>FILE SEEDKEY1.C </p>
<p>#include &lt;windows.h&gt; </p>
<p>#define SEEDKEYAPI_IMPL </p>
<p>#include &quot;SeedKey1.h&quot; </p>
<p> </p>
<p>extern &quot;C&quot; { </p>
<p>BOOL SEEDKEYAPI ASAP1A_XCP_ComputeKeyFromSeed( BYTE *seed, </p>
<p>  unsigned short sizeSeed, </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>17 / 94 </p>
<p>  BYTE *key, </p>
<p>  unsigned short maxSizeKey, </p>
<p>  unsigned short *sizeKey </p>
<p>  ) </p>
<p>{  // in that example sizeSeed == 4 is expected only </p>
<p>  if( sizeSeed != 4 ) return FALSE; </p>
<p>    if( maxSizeKey &lt; 4 ) return FALSE; </p>
<p>    *((unsigned long*)key) *= 3; </p>
<p>    *((unsigned long*)key) &amp;= 0x55555555; </p>
<p>    *((unsigned long*)key) *= 5;  </p>
<p>    *sizeKey = 4; </p>
<p>    return TRUE; </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p> </p>
<p><b>3.6 </b></p>
<p><b>Checksum Calculation </b></p>
<p>The  XCP  Protocol  Layer  supports  calculation  of  a  checksum  over  a  specific  memory </p>
<p>range. The XCP Protocol Layer supports all XCP ADD algorithms and the CRC16CCITT </p>
<p>checksum calculation algorithm. </p>
<p>XCP Professional allows the usage of the AUTOSAR CRC Module [VII]. If the AUTOSAR </p>
<p>CRC Module is used also the XCP CRC32 algorithm can be used. </p>
<p>Also refer to 6.8.2.1 ‘Table of Checksum Calculation Methods’. </p>
<p>If checksum calculation is enabled the background task has to be called cyclically. </p>
<p><b>3.6.1 </b></p>
<p><b>Custom CRC calculation </b></p>
<p>The Protocol Layer also allows the calculation of the CRC by the application. For this the </p>
<p>call-back: </p>
<p>uint8 <b> XcpAppl_CalculateChecksum</b>(  uint8  Xcp_Channel,  ROMBYTEPTR </p>
<p>pMemArea, BYTEPTR pRes, uint32 length ) </p>
<p>is  called.  This  call-back  can  either  calculate  the  checksum  synchronously  and  return </p>
<p>XCP_CMD_OK</p>
<p> or it can trigger the calculation and return </p>
<p>XCP_CMD_PENDING</p>
<p> for asynchronous </p>
<p>calculation of the checksum. In every case the response frame has to be assembled. </p>
<p><b>3.7 </b></p>
<p><b>MainFunction </b></p>
<p>The Xcp provides a MainFunction: </p>
<p>void <b>Xcp_MainFunction</b>( void )</p>
<p>  </p>
<p>(6.2.5)</p>
<p> </p>
<p> which must be called cyclically and performs the following tasks: </p>
<p></p>
<p> </p>
<p>Checksum  calculation  which  is  done  asynchronously  in  configurable  chunks  to </p>
<p>prevent extensive runtime </p>
<p></p>
<p> </p>
<p>Resume Mode Handling </p>
<p>The Xcp MainFunction is normally called by the SchM. If you use a 3</p>
<p>rd</p>
<p> party SchM you </p>
<p>must configure it accordingly such that the function is called cyclically. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>18 / 94 </p>
<p><b>3.8 </b></p>
<p><b>Memory Protection (XCP Professional only) </b></p>
<p>If </p>
<p>XCP_ENABLE_WRITE_PROTECTION</p>
<p> is defined write access of specific RAM areas can </p>
<p>be checked with the function </p>
<p>uint8 <b>XcpAppl_CheckWriteAccess</b>( MTABYTEPTR addr, uint8 size )</p>
<p>(6.5.7) </p>
<p>It should only be used, if write protection of memory areas is required. </p>
<p>If </p>
<p>XCP_ENABLE_READ_PROTECTION</p>
<p> is defined read access of specific RAM areas can be </p>
<p>checked with the function </p>
<p>uint8 <b>XcpAppl_CheckReadAccess</b>( MTABYTEPTR addr, uint8 size )</p>
<p>(6.5.8) </p>
<p>It should only be used, if read protection of memory areas is required. </p>
<p>While  the  first  two  functions  are  used  during  polling,  the  following  function  is  used  for </p>
<p>DAQ/STIM access: </p>
<p>uint8 <b>XcpAppl_CheckDAQAccess</b>( DAQBYTEPTR addr, uint8 size )</p>
<p> (6.5.9) </p>
<p>These  functions  can  be  used  to  protect  memory  areas  that  are  not  allowed  to  be </p>
<p>accessed, e.g. memory mapped registers or the xcp memory itself. </p>
<p><b>3.9 </b></p>
<p><b>Memory Access by Application </b></p>
<p>There are two APIs available that allow memory access by application. Those APIs can be </p>
<p>enabled by setting </p>
<p>XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL.</p>
<p> Please note that these </p>
<p>API are only used for polling access. DAQ/STIM still uses direct memory access. </p>
<p>uint8 </p>
<p><b>XcpAppl_CalibrationWrite</b>( </p>
<p>P2VAR(void, </p>
<p>AUTOMATIC, </p>
<p>XCP_APPL_DATA) dst, P2CONST(void, AUTOMATIC, XCP_APPL_DATA) src, </p>
<p>uint8 len )</p>
<p> </p>
<p>(6.5.33) </p>
<p>uint8 </p>
<p><b>XcpAppl_MeasurementRead</b>( </p>
<p>P2VAR(void, </p>
<p>AUTOMATIC, </p>
<p>XCP_APPL_DATA) dst, P2CONST(void, AUTOMATIC, XCP_APPL_DATA) src, </p>
<p>uint8 len )</p>
<p>  </p>
<p>(6.5.32) </p>
<p>If </p>
<p>the </p>
<p>option </p>
<p>XCP_ENABLE_DAQ_MEM_ACCESS_BY_APPL </p>
<p>is </p>
<p>set </p>
<p>the </p>
<p>function </p>
<p><b>XcpAppl_MeasurementRead </b></p>
<p>is also called for DAQ measurement. </p>
<p><b>3.9.1 </b></p>
<p><b>Special use case “Type Safe Copy” </b></p>
<p>The above mentioned APIs will also be used if the feature “Type Safe Copy” is enabled. If </p>
<p>this  is  the  case  polling  as  well  as  DAQ/STIM  measurement  will  use  these  functions  to </p>
<p>read/write data. The template code for these functions performs read/write access in an </p>
<p>atomic way. See 3.21.1 for further information. </p>
<p><b>3.10 </b></p>
<p><b>Event Codes </b></p>
<p>The slave device may report events by sending asynchronous event packets (EV), which </p>
<p>contain event codes, to the master device. The transmission is not guaranteed due to the </p>
<p>fact that these event packets are not acknowledged. </p>
<p>The </p>
<p>transmission </p>
<p>of </p>
<p>event </p>
<p>codes </p>
<p>is </p>
<p>enabled </p>
<p>with </p>
<p>XCP_ENABLE_SEND_EVENT</p>
<p>. </p>
<p>The </p>
<p>transmission is done by the service </p>
<p>void <b>Xcp_SendEvent</b>( uint8 evc, ROMBYTEPTR c, uint8 len )</p>
<p> </p>
<p>(6.2.6) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>19 / 94 </p>
<p>The event codes can be found in the following table. </p>
<p><b>Event </b></p>
<p><b>Code </b></p>
<p><b>Description </b></p>
<p>EV_RESUME_MODE </p>
<p>0x00</p>
<p> </p>
<p>The slave indicates that it is starting in RESUME mode. </p>
<p>EV_CLEAR_DAQ </p>
<p>0x01</p>
<p> </p>
<p>The slave indicates that the DAQ configuration in non-</p>
<p>volatile memory has been cleared. </p>
<p>EV_STORE_DAQ </p>
<p>0x02</p>
<p> </p>
<p>The slave indicates that the DAQ configuration has been </p>
<p>stored into non-volatile memory. </p>
<p>EV_STORE_CAL </p>
<p>0x03</p>
<p> </p>
<p>The slave indicates that the calibration data has been </p>
<p>stored. </p>
<p>EV_CMD_PENDING </p>
<p>0x05</p>
<p> </p>
<p>The slave requests the master to restart the time-out </p>
<p>detection. </p>
<p>EV_DAQ_OVERLOAD </p>
<p>0x06</p>
<p> </p>
<p>The slave indicates an overload situation when </p>
<p>transferring DAQ lists. </p>
<p>EV_SESSION_TERMINATED </p>
<p>0x07</p>
<p> </p>
<p>The slave indicates to the master that it autonomously </p>
<p>decided to disconnect the current XCP session. </p>
<p>EV_USER </p>
<p>0xFE</p>
<p> </p>
<p>User-defined event. </p>
<p>EV_TRANSPORT </p>
<p>0xFF</p>
<p> </p>
<p>Transport layer specific event. </p>
<p> </p>
<p><b>3.11 </b></p>
<p><b>Service Request Messages  </b></p>
<p>The slave device may request some action to be performed by the master device. This is </p>
<p>done by the transmission of a Service Request Packet (SERV) that contains the service </p>
<p>request  code.  The  transmission  of  service  request  packets  is  asynchronous  and  not </p>
<p>guaranteed due to these packets are not being acknowledged. </p>
<p>The service request messages can be sent by the following functions </p>
<p>void <b>Xcp_PutChar </b>( const uint8 c )</p>
<p> </p>
<p>(6.2.7) </p>
<p>void <b>Xcp_Print </b>( const uint8 *str )</p>
<p> </p>
<p>(6.2.8) </p>
<p>Refer to 6.8.1 for the configuration of the service request message. </p>
<p><b>3.12 </b></p>
<p><b>User Defined Command </b></p>
<p>The  XCP  Protocol  allows  having  a  user  defined  command  with  an  application  specific </p>
<p>functionality. </p>
<p>The </p>
<p>user </p>
<p>defined </p>
<p>command </p>
<p>is </p>
<p>enabled </p>
<p>by </p>
<p>setting </p>
<p>XCP_ENABLE_USER_COMMAND</p>
<p>  and  upon  reception  of  the  user  command  the  following </p>
<p>callback function is called by the XCP command processor: </p>
<p>uint8 <b>XcpAppl_UserService </b>( uint8 Xcp_Channel, ROMBYTEPTR pCmd </p>
<p>)</p>
<p> </p>
<p>(6.5.11) </p>
<p><b>3.13 </b></p>
<p><b>Transport Layer Command </b></p>
<p>The transport layer commands are received by the XCP Protocol Layer and processed by </p>
<p>the XCP Transport Layer. The XCP Protocol Layer transmits the XCP response packets </p>
<p>(RES) or XCP error packets (ERR).  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>20 / 94 </p>
<p>The transport layer command is enabled by setting </p>
<p>XCP_ENABLE_TL_COMMAND</p>
<p>. </p>
<p> </p>
<p>Upon reception of any transport layer command the following callback function is called by </p>
<p>the XCP command processor: </p>
<p>uint8 <b>ApplXcpTLService </b>( ROMBYTEPTR pCmd )</p>
<p> </p>
<p>(6.4.5) </p>
<p> </p>
<p><b>3.14 </b></p>
<p><b>Synchronous Data Transfer </b></p>
<p><b>3.14.1 </b></p>
<p><b>Synchronous Data Acquisition (DAQ) </b></p>
<p>The </p>
<p>synchronous </p>
<p>data </p>
<p>transfer </p>
<p>can </p>
<p>be </p>
<p>enabled </p>
<p>with </p>
<p>the </p>
<p>compiler </p>
<p>switch </p>
<p>XCP_ENABLE_DAQ</p>
<p>. In this mode, the MCS configures tables of memory addresses in the </p>
<p>XCP Protocol Layer. These tables contain pointers to measurement objects, which have </p>
<p>been  configured  previously  for  the  measurement  in  the  MCS.  Each  configured  table  is </p>
<p>assigned to an event channel. </p>
<p>The function </p>
<p>Xcp_Event(x)</p>
<p> has to be called cyclically for each event channel with the </p>
<p>corresponding  event  channel  number  as  parameter.  The  application  has  to  ensure  that </p>
<p>Xcp_Event</p>
<p> is called with the correct cycle time, which is defined in the MCS. Note that </p>
<p>the event channel numbers are given by the GenTool when the Event Info feature is used. </p>
<p>The  ECU  automatically  transmits  the  current  value  of  the  measurement  objects  via </p>
<p>messages to the MCS, when the function </p>
<p>Xcp_Event</p>
<p> is executed in the ECU’s code with </p>
<p>the corresponding event channel number. This means that the data can be transmitted at </p>
<p>any particular point of the ECU code when the data values are valid. </p>
<p>The data acquisition mode can be used in multiple configurations that are described within </p>
<p>the next chapters. </p>
<p>Annotation for the usage of CANape </p>
<p>It is recommended to enable both data acquisition plug &amp; play mechanisms to detect the </p>
<p>DAQ settings. </p>
<p><b>3.14.2 </b></p>
<p><b>DAQ Timestamp </b></p>
<p>There are two methods to generate timestamps for data acquisition signals. </p>
<p>1. By the MCS tool on reception of the message </p>
<p>2. By the ECU (XCP slave) </p>
<p>The time precision of the MCS tool is adequate for the most applications; however, some </p>
<p>applications  like  the  monitoring  of  the  OSEK  operating  system </p>
<p>or  measurement  on </p>
<p>FlexRay  with  an  event  cycle  time  smaller  than  the  FlexRay  cycle  time  require  higher </p>
<p>precision timestamps. In such cases, ECU generated timestamps are recommended. </p>
<p>The timestamp must be implemented in a call-back which returns the current value: </p>
<p>XcpDaqTimestampType <b>XcpAppl_GetTimestamp </b>( void )</p>
<p>                         (6.5.24) </p>
<p>There are several possibilities to implement such a timestamp: </p>
<p></p>
<p> </p>
<p>16bit Counter variable, incremented by software in a fast task (.e.g. 1ms task) for </p>
<p>applications </p>
<p>where </p>
<p>such </p>
<p>a </p>
<p>resolution </p>
<p>is </p>
<p>sufficient </p>
<p>and </p>
<p>returned </p>
<p>in </p>
<p>the </p>
<p>above </p>
<p>mentioned call-back </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>21 / 94 </p>
<p></p>
<p> </p>
<p>32bit General Purpose Timer of the used µC, configured to a certain repetition rate </p>
<p>(e.g. 1µs increment) for applications that require a high resolution of the timestamp </p>
<p>and returned in the above mentioned call-back </p>
<p>The resolution and increment value of this timer must be configured in the configuration </p>
<p>Tool (e.g. GENy) accordingly. </p>
<p>For the configuration of the DAQ time stamped mode refer to chapter 6.8.6 (Configuration </p>
<p>of the DAQ Time Stamped Mode). </p>
<p><b>3.14.3 </b></p>
<p><b>Power-Up Data Transfer  </b></p>
<p>Power-up data transfer (also called resume mode) allows automatic data transfer (DAQ, </p>
<p>STIM) </p>
<p>of </p>
<p>the </p>
<p>slave </p>
<p>directly </p>
<p>after </p>
<p>power-up. </p>
<p>Automotive </p>
<p>applications </p>
<p>would </p>
<p>e.g. </p>
<p>be </p>
<p>measurements during cold start. </p>
<p>The slave and the master have to store all the necessary communication parameters for </p>
<p>the automatic data transfer after power-up. Therefore  the following functions have to be </p>
<p>implemented in the slave. </p>
<p>uint8 <b>XcpAppl_DaqResume </b>( uint8 Xcp_Channel, tXcpDaq * daq )</p>
<p> (6.5.20) </p>
<p>void <b>XcpAppl_DaqResumeStore </b>( uint8 Xcp_Channel, const tXcpDaq </p>
<p>* daq )</p>
<p>  </p>
<p>(6.5.21) </p>
<p>void <b>XcpAppl_DaqResumeClear </b>( uint8 Xcp_Channel )</p>
<p>  </p>
<p>(6.5.22) </p>
<p>uint8 <b>XcpAppl_CalResumeStore </b>( uint8 Xcp_Channel )</p>
<p>  </p>
<p>(6.5.23) </p>
<p>To </p>
<p>use </p>
<p>the </p>
<p>resume </p>
<p>mode </p>
<p>the </p>
<p>compiler </p>
<p>switches </p>
<p>XCP_ENBALE_DAQ</p>
<p> </p>
<p>and </p>
<p>XCP_ENABLE_RESUME_MODE</p>
<p> have to be defined. </p>
<p>Keep also in mind that the Xcp_MainFunction has to be called cyclically in order for the </p>
<p>resume  mode  to  work.  If  Resume  Mode  is  enabled  by  the  Master  Tool  the  before </p>
<p>mentioned call-back XcpAppl_DaqResumeStore is called by the MainFunction. </p>
<p>void <b>Xcp_MainFunction</b>( void )</p>
<p>  </p>
<p>(6.2.5)</p>
<p> </p>
<p>Annotation for the usage of CANape </p>
<p>Start the resume mode with the menu command Measurement | Start and push the button </p>
<p>“Measure offline” on the dialog box. </p>
<p><b>3.14.4 </b></p>
<p><b>Send Queue </b></p>
<p>The send queue is used to store measurement values until they can be transmitted on the </p>
<p>bus. This is required if the used Transport Layer does not perform buffering on its own. </p>
<p>Vector Transport Layers do not buffer any data and therefore this feature should be used. </p>
<p>The  send  queue  size  can  be  indirectly  configured  in  the  GenTool.  It  is  defined  by  the </p>
<p>parameter “Memory Size” – the memory size used by the dynamic DAQ lists. As the DAQ </p>
<p>lists are created during runtime by the tool no detailed calculation is possible. A worst case </p>
<p>analysis can be made and the parameter should be chosen such that enough space is left </p>
<p>for the send queue. </p>
<p>Furthermore  the  behaviour  of  the  send  queue  in  case  of  an  overrun  condition  can  be </p>
<p>influenced. There are two possible options: </p>
<p>1. </p>
<p>Throw away oldest element </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>22 / 94 </p>
<p></p>
<p> The oldest odt in the send queue is discarded and the new measurement value is </p>
<p>inserted. The send queue behaves as a ring buffer. </p>
<p>2. </p>
<p>Throw away latest element </p>
<p></p>
<p>  The  latest  measurement  values  are  discarded.  The  send  queue  behaves  like  a </p>
<p>linear buffer. </p>
<p>The  GenTool </p>
<p>option  “Replace  First </p>
<p>Element”  determines  the  default  behaviour.  The </p>
<p>behaviour </p>
<p>can </p>
<p>be </p>
<p>changed </p>
<p>during </p>
<p>runtime </p>
<p>by </p>
<p>modifying </p>
<p>the </p>
<p>variable </p>
<p>xcp.Daq.SendQueueBehaviour</p>
<p>. If this variable is zero linear mode is selected, if this variable </p>
<p>is one the ring buffer mode is selected. This variable can be modified by the Master Tool. </p>
<p> </p>
<p><b>3.14.5 </b></p>
<p><b>Data Stimulation (STIM)  </b></p>
<p>Synchronous Data Stimulation is the inverse mode of Synchronous Data Acquisition. </p>
<p>The  STIM  processor  buffers  incoming  data  stimulation  packets.  When  an  event  occurs </p>
<p>(</p>
<p>Xcp_Event</p>
<p> is called), which triggers a DAQ list in data stimulation mode, the buffered </p>
<p>data is transferred to the slave device’s memory. </p>
<p>To use data stimulation the compiler switches </p>
<p>XCP_ENBALE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_STIM</p>
<p> </p>
<p>have to be defined. </p>
<p><b>3.14.6 </b></p>
<p><b>Bypassing  </b></p>
<p>Bypassing  can  be  realized  by  making  use  of  Synchronous  Data Acquisition  (DAQ)  and </p>
<p>Synchronous Data Stimulation (STIM) simultaneously. </p>
<p>State-of-the-art Bypassing also requires the administration of the bypassed functions. This </p>
<p>administration has to be performed in a MCS like e.g. CANape. </p>
<p>Also  the  slave  should  perform  plausibility  checks  on  the  data  it  receives  through  data </p>
<p>stimulation.  The  borders  and  actions  of  these  checks  are  set  by  standard  calibration </p>
<p>methods. No special XCP commands are needed for this. </p>
<p><b>3.14.7 </b></p>
<p><b>Data Acquisition Plug &amp; Play Mechanisms </b></p>
<p>The XCP Protocol Layer comprises two plug &amp; play mechanisms for data acquisition: </p>
<p><b>&gt; </b></p>
<p>general information on the DAQ processor  </p>
<p>(enabled with </p>
<p>XCP_ENABLE_DAQ_PROCESSOR_INFO</p>
<p>) </p>
<p><b>&gt; </b></p>
<p>general information on DAQ processing resolution  </p>
<p>(enabled with </p>
<p>XCP_ENABLE_DAQ_RESOLUTION_INFO</p>
<p>) </p>
<p>The general information on the DAQ processor contains: </p>
<p><b>&gt; </b></p>
<p>general properties of DAQ lists </p>
<p><b>&gt; </b></p>
<p>total number of available DAQ lists and event channels </p>
<p>The general information on the DAQ processing resolution contains: </p>
<p><b>&gt; </b></p>
<p>granularity and maximum size of ODT entries for both directions </p>
<p><b>&gt; </b></p>
<p>information on the time stamp mode </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>23 / 94 </p>
<p><b>3.14.8 </b></p>
<p><b>Event Channel Plug &amp; Play Mechanism </b></p>
<p>The  XCP  Protocol  Layer  supports  a  plug  &amp;  play  mechanism  that  allows  the  MCS  to </p>
<p>automatically detect the available event channels in the slave. </p>
<p>Please refer to chapter 6.8.5 (Configuration of the Event Channel Plug &amp; Play Mechanism) </p>
<p>for details about the configuration of this plug &amp; play mechanism. </p>
<p>Annotation for the usage of CANape </p>
<p>If the plug &amp; play mechanism is not built-in, you must open the dialog XCP Device Setup </p>
<p>with the menu command Tools|Driver parameters. Go to the Event tab. Make one entry for </p>
<p>each event channel. An event channel is an </p>
<p>Xcp_Event(x)</p>
<p> function call in ECU source </p>
<p>code. </p>
<p><b>3.14.9 </b></p>
<p><b>Data consistency </b></p>
<p>The  Xcp  supports  a  data  consistency  on  ODT  level.  If  a  consistency  on  DAQ  level  is </p>
<p>required, interrupts must be disabled prior calling Xcp_Event and enabled again after the </p>
<p>function  returns.  The  following  example  demonstrates  the  integrity  on  ODT  level  by </p>
<p>showing the XCP ODT frames as sent on the bus. Two Events (x, y) are configured with </p>
<p>DAQ list DAQ1 assigned to Event(x) and DAQ list DAQ2 assigned to Event(y). A call of the </p>
<p>Xcp_Event </p>
<p>function </p>
<p>with </p>
<p>the </p>
<p>respective </p>
<p>event </p>
<p>channel </p>
<p>number </p>
<p>will </p>
<p>then </p>
<p>trigger </p>
<p>the </p>
<p>transmission of the associated DAQ list. </p>
<p>Example1: a call of Xcp_Event(x) is interrupted by a call of Xcp_Event(y). This is allowed </p>
<p>as  long  as  the  interrupt  locks  are  provided  by  the  Schedule  Manager  (default  with </p>
<p>MICROSAR stack). </p>
<p>Example2: a call of Xcp_Event(x) is interrupted by a call of Xcp_Event(x). As a result a </p>
<p>DAQ  list  is  interrupted  by  itself.  This  is  not  allowed  and  must  be  prevented  by  data </p>
<p>consistency on DAQ level. For this use a interrupt lock when calling Xcp_Event() </p>
<p> </p>
<p> </p>
<p>DAQ1 </p>
<p> </p>
<p>DAQ2 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ODT0 </p>
<p> </p>
<p> </p>
<p>ODT3 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ODT1 </p>
<p> </p>
<p> </p>
<p>ODT4 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>ODT2 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Example1 </p>
<p>ODT0 </p>
<p>ODT1 </p>
<p>ODT3 </p>
<p>ODT4 </p>
<p>ODT2 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Example2 </p>
<p>ODT0 </p>
<p>ODT1 </p>
<p>ODT0 </p>
<p>ODT1 </p>
<p>ODT2 </p>
<p>ODT2 </p>
<p>Figure 3-1 Data consistency </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>24 / 94 </p>
<p><b>3.15 </b></p>
<p><b>The Online Data Calibration Model </b></p>
<p><b>3.15.1 </b></p>
<p><b>Page Switching </b></p>
<p>The  MCS  can  switch  between  a  flash  page  and  a  RAM  page.  The  XCP  command </p>
<p>SET_CAL_PAGE is used to activate the required page. The page switching is enabled with </p>
<p>the </p>
<p>XCP_ENABLE_CALIBRATION_PAGE</p>
<p> definition. </p>
<p>The following application callback functions have to be implemented: </p>
<p>uint8 <b>XcpAppl_GetCalPage </b>( uint8 Xcp_Channel, uint8 segment, </p>
<p>uint8 mode )</p>
<p> </p>
<p>(6.5.25) </p>
<p>uint8 <b>XcpAppl_SetCalPage </b>( uint8 Xcp_Channel, uint8 segment, </p>
<p>uint8 page, uint8 mode )</p>
<p> </p>
<p>(6.5.26) </p>
<p> </p>
<p>Annotation for the usage of CANape </p>
<p>Open the dialog XCP Device Setup with the menu command Tools|Driver Configuration. </p>
<p>Go to the tab “FLASH”. Activate page switching. Enter a flash selector value e.g. 1 and a </p>
<p>Ram selector e.g. 0. </p>
<p><b>3.15.2 </b></p>
<p><b>Page Switching Plug &amp; Play Mechanism </b></p>
<p>The MCS can be automatically configured if the page switching plug &amp; play mechanism is </p>
<p>used. This mechanism comprises </p>
<p><b>&gt; </b></p>
<p>general information about the paging processor </p>
<p>Also refer to chapter 6.8.8 (Configuration of the Page Switching Plug &amp; Play Mechanism) </p>
<p>and to the XCP Specification [II]. </p>
<p>The </p>
<p>page </p>
<p>switching </p>
<p>plug </p>
<p>&amp; </p>
<p>play </p>
<p>mechanism </p>
<p>is </p>
<p>enabled </p>
<p>with </p>
<p>the </p>
<p>switch </p>
<p>XCP_ENABLE_PAGE_INFO</p>
<p>. </p>
<p><b>3.15.3 </b></p>
<p><b>Calibration Data Page Copying </b></p>
<p>Calibration data page copying is performed by the XCP command COPY_CAL_PAGE. To </p>
<p>enable this feature the compiler switch </p>
<p>XCP_ENABLE_PAGE_COPY</p>
<p> has to be set. </p>
<p>For  calibration  data  page  copying  the  following  application  callback  function  has  to  be </p>
<p>provided by the application: </p>
<p>uint8 <b>XcpAppl_CopyCalPage</b>( uint8 Xcp_Channel, uint8 srcSeg,  </p>
<p>uint8 srcPage, uint8 destSeg, uint8 </p>
<p>destPage )</p>
<p> </p>
<p>(6.5.27) </p>
<p><b>3.15.4 </b></p>
<p><b>Freeze Mode Handling </b></p>
<p>Freeze mode handling is performed by the XCP commands SET_SEGMENT_MODE and </p>
<p>GET_SEGMENT_MODE. </p>
<p>To </p>
<p>enable </p>
<p>this </p>
<p>feature </p>
<p>the </p>
<p>compiler </p>
<p>switch </p>
<p>XCP_ENABLE_PAGE_FREEZE</p>
<p> has to be set. </p>
<p>For freeze mode handling the following application callback functions have to be provided </p>
<p>by the application: </p>
<p>void <b>XcpAppl_SetFreezeMode</b>( uint8 segment, uint8 mode )</p>
<p> </p>
<p>(6.5.28) </p>
<p>uint8 <b>XcpAppl_GetFreezeMode</b>( uint8 segment )</p>
<p> </p>
<p>(6.5.29) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>25 / 94 </p>
<p><b>3.16 </b></p>
<p><b>Flash Programming  </b></p>
<p>There are two methods available for the programming of flash memory. </p>
<p><b>&gt; </b></p>
<p>Flash programming by the ECU’s application </p>
<p><b>&gt; </b></p>
<p>Flash programming with a flash kernel </p>
<p>Depending on the hardware it might not be possible to reprogram an internal flash sector, </p>
<p>while a program is running from another sector. In this case the usage of a special flash </p>
<p>kernel is necessary. </p>
<p><b>3.16.1 </b></p>
<p><b>Flash Programming by the ECU’s Application </b></p>
<p>If </p>
<p>the </p>
<p>internal </p>
<p>flash </p>
<p>has </p>
<p>to </p>
<p>be </p>
<p>reprogrammed </p>
<p>and </p>
<p>the </p>
<p>microcontroller </p>
<p>allows </p>
<p>to </p>
<p>simultaneously  reprogram  and  execute  code  from  the  flash  the  programming  can  be </p>
<p>performed with the ECU’s application that contains the XCP. This method is also used for </p>
<p>the programming of external flash. </p>
<p>The  flash  programming  is  done  with  the  following  XCP  commands  PROGRAM_START, </p>
<p>PROGRAM_RESET, </p>
<p>PROGRAM_CLEAR, </p>
<p>PROGRAM, </p>
<p>PROGRAM_NEXT, </p>
<p>PROGRAM_MAX, PROGRAM_RESET, PROGRAM_FORMAT</p>
<p>1</p>
<p>, PROGRAM_VERIFY</p>
<p>1</p>
<p>. </p>
<p>The  flash  prepare,  flash  program  and  the  clear  routines  are  platform  dependent  and </p>
<p>therefore have to be implemented by the application. </p>
<p>uint8 <b>XcpAppl_ProgramStart</b>( void )</p>
<p>  </p>
<p>(6.5.17) </p>
<p>uint8 <b>XcpAppl_FlashClear</b>( MTABYTEPTR a, uint32 size )</p>
<p>  </p>
<p>(6.5.18) </p>
<p>uint8 <b>XcpAppl_FlashProgram</b>( ROMBYTEPTR data,  </p>
<p>    MTABYTEPTR a, uint8 size )</p>
<p>  </p>
<p>(6.5.19) </p>
<p>The flash programming is enabled with the switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p>. </p>
<p>Annotation for the usage of CANape </p>
<p>Open the dialog XCP Device Setup with the menu command Tools|Driver Configuration. </p>
<p>Go to the tab “FLASH” and select the entry “Direct” in the flash kernel drop down list. </p>
<p><b>3.16.1.1 </b></p>
<p><b>Flash Programming Plug &amp; Play Mechanism </b></p>
<p>The </p>
<p>MCS </p>
<p>(like </p>
<p>e.g. </p>
<p>CANape) </p>
<p>can </p>
<p>get </p>
<p>information </p>
<p>about </p>
<p>the </p>
<p>Flash </p>
<p>and </p>
<p>the </p>
<p>Flash </p>
<p>programming process from the ECU. The following information is provided by the ECU: </p>
<p><b>&gt; </b></p>
<p>number of sectors, start address or length of each sector </p>
<p><b>&gt; </b></p>
<p>the program sequence number, clear sequence number and programming method </p>
<p><b>&gt; </b></p>
<p>additional information about compression, encryption </p>
<p>Also </p>
<p>refer </p>
<p>to </p>
<p>chapter </p>
<p>6.8.7 </p>
<p>(Configuration </p>
<p>of </p>
<p>the </p>
<p>Flash </p>
<p>Programming </p>
<p>Plug </p>
<p>&amp; </p>
<p>Play </p>
<p>Mechanism) and to the XCP Specification [II]. </p>
<p>The </p>
<p>flash </p>
<p>programming </p>
<p>plug </p>
<p>&amp; </p>
<p>play </p>
<p>mechanism </p>
<p>is </p>
<p>enabled </p>
<p>with </p>
<p>the </p>
<p>switch </p>
<p>XCP_ENABLE_PROGRAM_INFO</p>
<p>. </p>
<p>                                            </p>
<p>1</p>
<p> Command not supported </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>26 / 94 </p>
<p><b>3.16.2 </b></p>
<p><b>Flash Programming with a Flash Kernel </b></p>
<p>A </p>
<p>flash </p>
<p>kernel </p>
<p>has </p>
<p>to </p>
<p>be </p>
<p>used </p>
<p>for </p>
<p>the </p>
<p>flash </p>
<p>programming </p>
<p>if </p>
<p>it </p>
<p>is </p>
<p>not </p>
<p>possible </p>
<p>to </p>
<p>simultaneously </p>
<p>reprogram </p>
<p>and </p>
<p>execute </p>
<p>code </p>
<p>from </p>
<p>the </p>
<p>flash. </p>
<p>Even </p>
<p>though </p>
<p>the </p>
<p>reprogrammed sector and the sector the code is executed from are different sectors. </p>
<p>The application callback function </p>
<p>uint8 <b>XcpAppl_DisableNormalOperation</b>( MTABYTEPTR a, uint16 size </p>
<p>)</p>
<p>  </p>
<p> (6.5.14) </p>
<p>is  called  prior  to  the  flash  kernel  download  in  the  RAM. Within  this  function  the  normal </p>
<p>operation of the ECU has to be stopped and the flash kernel download can be prepared. </p>
<p>Due  to  the flash  kernel  is downloaded  in  the  RAM  typically  data  gets  lost  and  no  more </p>
<p>normal operation of the ECU is possible. </p>
<p>The </p>
<p>flash </p>
<p>programming </p>
<p>with </p>
<p>a </p>
<p>flash </p>
<p>kernel </p>
<p>is </p>
<p>enabled </p>
<p>with </p>
<p>the </p>
<p>switch </p>
<p>XCP_ENABLE_BOOTLOADER_DOWNLOAD</p>
<p>. </p>
<p>Annotation for the usage of CANape </p>
<p>The flash kernel is loaded by CANape into the microcontroller’s RAM via XCP whenever </p>
<p>the flash memory has to be reprogrammed. The flash kernel contains the necessary flash </p>
<p>routines,  its  own  CAN-Driver  and  XCP  Protocol  implementation  to  communicate  via  the </p>
<p>CAN interface with CANape. </p>
<p>Every  flash  kernel  must  be  customized  to  the  microcontroller  and  the  flash  type  being </p>
<p>used. CANape already includes some flash kernels for several microcontrollers. There is </p>
<p>also </p>
<p>an </p>
<p>application </p>
<p>note </p>
<p>available </p>
<p>by </p>
<p>Vector </p>
<p>Informatik </p>
<p>GmbH </p>
<p>that </p>
<p>describes </p>
<p>the </p>
<p>development of a proprietary flash kernel. </p>
<p>Open the dialog XCP Device Setup with the menu command Tools|Driver Configuration. </p>
<p>Go to the tab “FLASH”, and select in the ‘flash kernel’ drop down list, the corresponding <i>fkl </i></p>
<p>file for the microcontroller being used. </p>
<p><b>3.16.3 </b></p>
<p><b>Flash Programming Write Protection </b></p>
<p>If </p>
<p>XCP_ENABLE_PROGRAMMING_WRITE_PROTECTION</p>
<p> is defined write access of specific </p>
<p>FLASH areas can be checked with the function </p>
<p>uint8 <b>XcpAppl_CheckProgramAccess </b></p>
<p><b>        </b>( MTABYTEPTR addr, uint32 size )</p>
<p> </p>
<p>(6.5.10) </p>
<p>It should only be used, if write protection of flash areas is required. </p>
<p><b>3.17 </b></p>
<p><b>EEPROM Access  </b></p>
<p>For  uploading  data  from  the  ECU  to  a  MCS  the  XCP  commands </p>
<p>SHORT_UPLOAD</p>
<p>  and </p>
<p>UPLOAD</p>
<p> are used. The switch </p>
<p>XCP_ENABLE_READ_EEPROM</p>
<p> allows EEPROM access for </p>
<p>these commands. </p>
<p>Before reading from an address it is checked within the following callback function whether </p>
<p>EEPROM or RAM is accessed: </p>
<p>uint8 <b>XcpAppl_CheckReadEEPROM </b></p>
<p>( MTABYTEPTR addr, uint8 size, BYTEPTR data )</p>
<p> </p>
<p>(6.5.5) </p>
<p>The EEPROM access is directly performed within this function. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>27 / 94 </p>
<p>For </p>
<p>downloading </p>
<p>data </p>
<p>from </p>
<p>the </p>
<p>MCS </p>
<p>to </p>
<p>the </p>
<p>ECU </p>
<p>the </p>
<p>XCP </p>
<p>commands </p>
<p>SHORT_DOWNLOAD, DOWNLOAD, DOWNLOAD_NEXT and DOWNLOAD_MAX can be </p>
<p>used.  The  switch </p>
<p>XCP_ENABLE_WRITE_EEPROM</p>
<p>  allows  the  EEPROM  access  for  these </p>
<p>commands. </p>
<p>Also  before  writing  to  an  address  within  the  following  callback  function  it  is  checked </p>
<p>whether EEPROM or RAM is accessed </p>
<p>uint8 <b>XcpAppl_CheckWriteEEPROM </b></p>
<p>( uint8 Xcp_Channel, MTABYTEPTR addr, uint8 size, </p>
<p>ROMBYTEPTR data )</p>
<p> </p>
<p>(6.5.6) </p>
<p><b>3.18 </b></p>
<p><b>Parameter Check </b></p>
<p>As  long  as  the  XCP  Protocol  Layer  is  not  thoroughly  tested  together  with  the  XCP </p>
<p>Transport Layer and the application, the parameter check should be enabled. This is done </p>
<p>by setting the compiler switch </p>
<p>XCP_ENABLE_PARAMETER_CHECK</p>
<p>. </p>
<p>The parameter check may be removed in order to save code space. </p>
<p><b>3.19 </b></p>
<p><b>Performance Optimizations </b></p>
<p>The XCP Protocol Layer is a platform comprehensive higher software layer and therefore </p>
<p>platform  specific  optimizations  are  not  implemented.  However  it  is  possible  to  apply </p>
<p>platform specific optimizations. </p>
<p>The following memory access functions can be overwritten by either macros or functions: </p>
<p>void <b>Xcp_MemCpy</b>( DAQBYTEPTR dest,  </p>
<p>ROMDAQBYTEPTR src, uint16 n )</p>
<p> </p>
<p>(6.6.1) </p>
<p>void <b>Xcp_MemSet</b>( BYTEPTR p, uint16 n, uint8 b )</p>
<p>  </p>
<p>(6.6.2) </p>
<p>static void <b>Xcp_MemClr</b>( BYTEPTR p, uint16 n )</p>
<p>  </p>
<p>(6.6.3) </p>
<p>It  is  recommended  to  use  DMA  access  as  far  as  possible  for  faster  execution  of  these </p>
<p>services. </p>
<p><b>3.20 </b></p>
<p><b>Interrupt Locks / Exclusive Areas </b></p>
<p>The </p>
<p>functions </p>
<p>Xcp_Event</p>
<p>, </p>
<p>Xcp_SendCallBack</p>
<p>, </p>
<p>Xcp_MainFunction</p>
<p> </p>
<p>and </p>
<p>Xcp_Command</p>
<p> are not reentrant. If one of these functions may interrupt one of the others, </p>
<p>they must be protected against each other. See also 3.14.9. </p>
<p>For this purpose the Xcp Protocol Layer makes use of three exclusive areas. The SchM </p>
<p>must provide the following sections: </p>
<p></p>
<p> </p>
<p>XCP_EXCLUSIVE_AREA_0</p>
<p> </p>
<p></p>
<p> </p>
<p>XCP_EXCLUSIVE_AREA_1</p>
<p> </p>
<p></p>
<p> </p>
<p>XCP_EXCLUSIVE_AREA_2</p>
<p> </p>
<p>The individual exclusive areas must not be allowed to interrupt each other. The areas are </p>
<p>used for the following cases: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>28 / 94 </p>
<p><b>3.20.1 </b></p>
<p><b>XCP_EXCLUSIVE_AREA_0 </b></p>
<p>Is  used  by  functions </p>
<p>Xcp_SendCallBack</p>
<p>, </p>
<p>Xcp_MainFunction</p>
<p>  and </p>
<p>Xcp_Command</p>
<p>  to </p>
<p>protect these non-reentrant functions. </p>
<p><b>3.20.2 </b></p>
<p><b>XCP_EXCLUSIVE_AREA_1 </b></p>
<p>Is used by </p>
<p>Xcp_Event</p>
<p> during DAQ measurement. </p>
<p><b>3.20.3 </b></p>
<p><b>XCP_EXCLUSIVE_AREA_2 </b></p>
<p>Is used by </p>
<p>Xcp_Event</p>
<p> during STIM measurement. </p>
<p><b>3.21 </b></p>
<p><b>Basic Multi Core support </b></p>
<p><b>3.21.1 </b></p>
<p><b>Type safe copy </b></p>
<p>The Xcp Protocol Layer supports a feature called “Type Safe Copy” which provides atomic </p>
<p>access to aligned uint16 and uint32 measurement values. This is important on multi core </p>
<p>platforms where one core is accessing a measurement value while the Xcp is trying to do </p>
<p>the same running from another core. </p>
<p>With this option disabled, access to measurement values is performed byte wise which is </p>
<p>not an atomic operation. </p>
<p>The following points must be taken into consideration when enabling this option: </p>
<p></p>
<p> </p>
<p>This option allows the Xcp to only read/write basic data types used on another core; </p>
<p>it cannot provide data consistency on ODT level. </p>
<p></p>
<p> </p>
<p>This option has a slightly higher runtime. </p>
<p></p>
<p> </p>
<p>Some Master Tools perform an optimization by grouping measurement values. This </p>
<p>option  must  be  disabled,  otherwise  they  do  not  represent  unique  data  types </p>
<p>anymore. </p>
<p><b>3.22 </b></p>
<p><b>Accessing internal data </b></p>
<p>The function  </p>
<p>void <b>Xcp_GetXcpDataPointer </b>(P2VAR(tXcpData, AUTOMATIC, </p>
<p>XCP_APPL_DATA) *pXcpData )</p>
<p>  </p>
<p>(6.2.11) </p>
<p>provides  access  to  the  internal  data  structure  of  the  XCP  module.  By  means  of  this </p>
<p>function the internal data can be preset to a certain value. This can be used to process a </p>
<p>measurement  further  that  has  been  started  in  application  mode  but  is  finished  in  boot </p>
<p>mode.  </p>
<p>As the whole data can be accessed, it must be handled with care. </p>
<p><b>3.23 </b></p>
<p><b>En- / Disabling the XCP module </b></p>
<p>The variable </p>
<p>Xcp_ControlState</p>
<p>  </p>
<p>can be used to en- or disable the XCP module during run time. Thus the XCP functionality </p>
<p>can be controlled by the application. </p>
<p>Furthermore  two  macros  are  available:  XCP_ACTIVATE  and  XCP_DEACTIVATE.  They </p>
<p>can be used to control the protocol and transport layer together, i.e. enabling or disabling </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>29 / 94 </p>
<p>them  as  a  whole.  It  is  recommended  to  use  these  macros.  It  is  also  recommended  to </p>
<p>perform a Xcp_Disconnect() API call to bring the Xcp in a save state before it is disabled. </p>
<p><b>3.24 </b></p>
<p><b>XCP measurement during the follow up time </b></p>
<p>In use cases where there is no further communication request except XCP measurement </p>
<p>the session state of the XCP can be determined to prevent an early shutdown of the ECU. </p>
<p>For this purpose the following API exist: </p>
<p>SessionStatusType <b>Xcp_GetSessionStatus </b>( void )</p>
<p>  </p>
<p>(6.3.3) </p>
<p> </p>
<p>An example implementation that is called cyclically could look like the following example: </p>
<p> </p>
<p> </p>
<p><b>Example </b></p>
<p>{ </p>
<p>  SessionStatusType sessionState; </p>
<p> </p>
<p>  sessionState = Xcp_GetSessionStatus(); </p>
<p>  if( 0 != (sessionState &amp; SS_CONNECTED) ) </p>
<p>  { </p>
<p>    /* Is the xcp actively used? */ </p>
<p>    if( 0 != (sessionState &amp; (SS_DAQ | SS_POLLING)) ) </p>
<p>    { </p>
<p>      /* Yes, reaload timer */ </p>
<p>      swTimer = XCP_TIMEOUT_TIMER_RELOAD; </p>
<p>    } </p>
<p>  } </p>
<p> </p>
<p>  if( swTimer &gt; 0 ) </p>
<p>  { </p>
<p>    /* No timeout so far */ </p>
<p>    swTimer--; </p>
<p>  } </p>
<p>  else </p>
<p>  { </p>
<p>    /* Timer timeout happened, release xcp communication request */ </p>
<p>  } </p>
<p>} </p>
<p> </p>
<p> </p>
<p>Please note that polling requests may happen erratically. Therefore it is important not to </p>
<p>choose the timeout value </p>
<p>XCP_TIMEOUT_TIMER_RELOAD </p>
<p>too small. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>30 / 94 </p>
<p><b>4 </b></p>
<p><b>Integration into the Application </b></p>
<p>This  chapter  describes  the  steps  for  the  integration  of  the  XCP  Protocol  Layer  into  an </p>
<p>application environment of an ECU. </p>
<p><b>4.1 </b></p>
<p><b>Files of XCP Professional </b></p>
<p>The XCP Protocol Layer consists of the following files.  </p>
<p><b>Files of the XCP Protocol Layer </b></p>
<p>Xcp.c </p>
<p>XCP Professional source code. </p>
<p>This file <b>must not </b>be changed by the user! </p>
<p> </p>
<p>Xcp.h </p>
<p>API of XCP Professional. </p>
<p>This file <b>must not </b>be changed by the user! </p>
<p> </p>
<p>_xcp_appl.c </p>
<p>Template that contains the application callback functions of the XCP </p>
<p>Protocol Layer. It is just an example and has to be customized. </p>
<p> </p>
<p>v_def.h </p>
<p>General Vector definitions of memory qualifiers and types. </p>
<p>This file <b>must not </b>be changed by the application! </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Additionally the following files are generated by the generation tool. If no generation tool or </p>
<p>if CANgen is used the XPC Protocol Layer has to be customized manually. In this case the </p>
<p>following files will be available as template. </p>
<p><b>Files generated by GENy </b></p>
<p>xcp_Cfg.h </p>
<p>XCP Protocol Layer configuration file. </p>
<p> </p>
<p>xcp_Lcfg.c </p>
<p>Parameter definition for the XCP Protocol Layer. </p>
<p> </p>
<p>xcp_Lcfg.h </p>
<p>External declarations for the parameters. </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Note that all files of XCP Professional <b>must not </b>be changed manually! </p>
<p> </p>
<p><b>4.2 </b></p>
<p><b>Version changes </b></p>
<p>Changes and the release versions of the XCP Protocol Layer are listed at the beginning of </p>
<p>the header and source code. </p>
<p> </p>
<p><b>4.3 </b></p>
<p><b>Compiler Abstraction and Memory Mapping  </b></p>
<p>The  objects  (e.g.  variables,  functions,  constants)  are  declared  by  compiler  independent </p>
<p>definitions  –  the  compiler  abstraction  definitions.  Each  compiler  abstraction  definition  is </p>
<p>assigned to a memory section. </p>
<p>The  following  table  contains  the  memory  section  names  and  the  compiler  abstraction </p>
<p>definitions defined for XCP, and illustrates their assignment among each other. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>31 / 94 </p>
<p><b>Compiler Abstraction </b></p>
<p><b>Definitions </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Memory Mapping </b></p>
<p><b>Sections </b></p>
<p>XCP_CONST </p>
<p>XCP_DAQ_DATA </p>
<p>XCP_MTA_DATA </p>
<p>XCP_APPL_DATA </p>
<p>XCP_CODE </p>
<p>XCP_START_SEC_CONST_16BIT</p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>XCP_START_SEC_CONST_8BIT</p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>XCP_START_SEC_VAR_NOINIT_UNSPECIFIED</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>XCP_START_SEC_VAR_NOINIT_8BIT</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>XCP_START_SEC_CODE </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p>XCP_START_SEC_VAR_INIT_UNSPECIFIED_SAFE </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p>Table 4-1  </p>
<p>Compiler abstraction and memory mapping </p>
<p>Please  see  the  document:  “AUTOSAR_SWS_CompilerAbstraction.pdf”  for  details  about </p>
<p>how to use these definitions. </p>
<p> </p>
<p><b>4.4 </b></p>
<p><b>Support of Vx1000 Integration </b></p>
<p>The XcpProf provides basic support for the Vx1000 Hardware which can be enabled in the </p>
<p>configuration tool. If enabled the code size is increased, yet the same API calls as used for </p>
<p>the XcpProf are reused for the Vx which minimizes integration effort. </p>
<p>When  the  option  is  enabled  the  sources  provided  with  your  Vx1000  hardware  must  be </p>
<p>integrated. The XcpProf includes the Vx1000.h header and makes use of the respective </p>
<p>macros. </p>
<p>If the Vx hardware is attached prior to ECU Initialization the XcpProf itself is deactivated, </p>
<p>hence  no  access  via  the  bus  interface  is  possible  anymore.  If  you  want  to  perform </p>
<p>measurement  &amp;  calibration  via  the  bus  interface  again,  detach  the  Vx  hardware  and </p>
<p>perform an ECU reset. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>32 / 94 </p>
<p><b>5 </b></p>
<p><b>Feature List </b></p>
<p>This general feature list describes the overall feature set of the XCP Protocol Layer. </p>
<p><b>Description of the XCP functionality </b></p>
<p><b>Functions </b></p>
<p><b>Initialization </b></p>
<p>Initialization </p>
<p>Xcp_Init </p>
<p>ApplXcpInit </p>
<p><b>Task</b></p>
<p><b> </b></p>
<p>Background task </p>
<p>Xcp_MainFunction </p>
<p><b>XCP Command Processor</b></p>
<p><b> </b></p>
<p>Command Processor </p>
<p>Xcp_Command </p>
<p>Transmission and Confirmation of XCP Packets </p>
<p>&lt;Bus&gt;Xcp_Send </p>
<p>Xcp_SendCallBack </p>
<p>Transmission of Response packets </p>
<p>Xcp_SendCrm </p>
<p>Transmission of XCP Packets </p>
<p>XcpAppl_SendStall </p>
<p>&lt;Bus&gt;Xcp_SendFlush </p>
<p><b>XCP Commands</b></p>
<p><b> </b></p>
<p>Get Identification </p>
<p>XcpAppl_GetIdData </p>
<p>Seed &amp; Key </p>
<p>XcpAppl_GetSeed </p>
<p>XcpAppl_Unlock </p>
<p>Short Download </p>
<p>- </p>
<p>Modify Bits </p>
<p>- </p>
<p>Write DAQ Multiple </p>
<p>XcpAppl_CheckDAQAccess  </p>
<p>Transport Layer Command </p>
<p>&lt;Bus&gt;Xcp_TLService </p>
<p>Open Command Interface </p>
<p>XcpAppl_OpenCmdIf </p>
<p>User command </p>
<p>XcpAppl_UserService </p>
<p><b>Data Acquisition (DAQ) </b></p>
<p>Synchronous Data Acquisition and Stimulation </p>
<p>Xcp_Event </p>
<p>XcpAppl_CheckDAQAccess </p>
<p>DAQ Timestamp </p>
<p>XcpAppl_GetTimestamp </p>
<p>Resume Mode </p>
<p>XcpAppl_DaqResume </p>
<p>XcpAppl_DaqResumeStore </p>
<p>XcpAppl_DaqResumeClear </p>
<p>XcpAppl_CalResumeStore </p>
<p><b>Online Data Calibration</b></p>
<p><b> </b></p>
<p>Calibration page switching </p>
<p>XcpAppl_GetCalPage </p>
<p>XcpAppl_SetCalPage </p>
<p>Copy calibration page </p>
<p>XcpAppl_CopyCalPage </p>
<p>Freeze Mode </p>
<p>XcpAppl_SetFreezeMode </p>
<p>XcpAppl_GetFreezeMode </p>
<p><b>Boot loader Download</b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>33 / 94 </p>
<p>Disable normal operation of ECU </p>
<p>XcpAppl_DisableNormalOper</p>
<p>ation </p>
<p>Start of the boot loader </p>
<p>XcpAppl_StartBootLoader </p>
<p><b>Flash Programming </b></p>
<p>Reset of ECU </p>
<p>XcpAppl_Reset </p>
<p>Clear flash memory </p>
<p>XcpAppl_FlashClear </p>
<p>Prepare flash programming </p>
<p>XcpAppl_ProgramStart </p>
<p>Program flash memory </p>
<p>XcpAppl_FlashProgram </p>
<p><b>Special Features</b></p>
<p><b> </b></p>
<p>Interrupt Control </p>
<p>ApplXcpInterruptEnable </p>
<p>ApplXcpInterruptDisable </p>
<p>Event Codes </p>
<p>Xcp_SendEvent </p>
<p>Service Request Packets </p>
<p>Xcp_Putchar </p>
<p>Xcp_Print </p>
<p>Disconnect XCP </p>
<p>Xcp_Disconnect </p>
<p>Pointer conversion </p>
<p>XcpAppl_GetPointer </p>
<p>EEPROM access </p>
<p>XcpAppl_CheckReadEEPROM </p>
<p>XcpAppl_CheckWriteEEPROM </p>
<p>Write protection </p>
<p>XcpAppl_CheckWriteAccess </p>
<p>Read protection </p>
<p>XcpAppl_CheckReadAccess </p>
<p>Overwriteable macros </p>
<p>Xcp_MemCpy </p>
<p>Xcp_MemSet </p>
<p>Xcp_MemClr </p>
<p>Xcp_SendDto </p>
<p>Access to internal data </p>
<p>Xcp_GetXcpDataPointer </p>
<p>En-/Disable Calibration </p>
<p>- </p>
<p>Programming Write Protection </p>
<p>XcpAppl_CheckProgramAcces</p>
<p>s </p>
<p>Session Status </p>
<p>Xcp_GetSessionStatus </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>34 / 94 </p>
<p><b>6 </b></p>
<p><b>Description of the API </b></p>
<p>The XCP Protocol Layer application programming interface consists of services, which are </p>
<p>realized  by  function  calls.  These  services  are  called  wherever  they  are  required.  They </p>
<p>transfer  information  to-  or  take  over  information  from  the  XCP  Protocol  Layer.  This </p>
<p>information </p>
<p>is </p>
<p>stored </p>
<p>in </p>
<p>the </p>
<p>XCP </p>
<p>Protocol </p>
<p>Layer </p>
<p>until </p>
<p>it </p>
<p>is </p>
<p>not </p>
<p>required </p>
<p>anymore, </p>
<p>respectively until it is changed by other operations. </p>
<p>Examples  for  calling  the  services </p>
<p>of </p>
<p>the  XCP  Protocol  Layer  can  be  found  in  the </p>
<p>description of the services. </p>
<p> </p>
<p><b>6.1 </b></p>
<p><b>Version of the Source Code </b></p>
<p>The  source  code  version  of  the  XCP  Protocol  Layer  is  provided  by  three  BCD  coded </p>
<p>constants: </p>
<p>CONST(uint8, XCP_CONST)</p>
<p> kXcpMainVersion =  </p>
<p>(uint8)(CP_XCP_VERSION &gt;&gt; 8);</p>
<p> </p>
<p>CONST(uint8, XCP_CONST)</p>
<p>  kXcpSubVersion  = </p>
<p>(uint8)(CP_XCP_ VERSION); </p>
<p>CONST(uint8, XCP_CONST)</p>
<p> kXcpReleaseVersion = </p>
<p>(uint8)(CP_XCP_RELEASE_VERSION);</p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Example</b> </p>
<p>Version 1.00.00 is registered as: </p>
<p>kXcpMainVersion    = 0x01; </p>
<p>kXcpSubVersion     = 0x00; </p>
<p>kXcpReleaseVersion = 0x00;</p>
<p> </p>
<p> </p>
<p>These constants are declared as external and can be read by the application at any time. </p>
<p>Alternatively the Version can be obtained with the GetVersionInfo API if enabled: </p>
<p>void </p>
<p> </p>
<p><b>Xcp_GetVersionInfo </b>(P2VAR(Std_VersionInfoType, AUTOMATIC, </p>
<p>XCP_APPL_DATA) XcpVerInfoPtr)</p>
<p>  </p>
<p>(6.2.12) </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>35 / 94 </p>
<p><b>6.2 </b></p>
<p><b>XCP Services called by the Application </b></p>
<p>The following XCP services that are called by the application are all not reentrant. If they </p>
<p>are called within interrupt context at least the CAN-Interrupts have to be disabled. </p>
<p> </p>
<p><b>6.2.1 </b></p>
<p><b>Xcp_InitMemory: Initialization of the XCP Protocol Layer Memory </b></p>
<p><b>Xcp_InitMemory </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_InitMemory </b>( </p>
<p>void </p>
<p>) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This service initializes the XCP Protocol Layer memory. It must be called from the application </p>
<p>program before any other XCP function is called. This is only required if the Startup Code does not </p>
<p>initialize the memory with zero. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>This service function has to be called after the initialization of XCP Transport Layer. </p>
<p><b>&gt; </b></p>
<p>The global interrupts have to be disabled while this service function is executed. This function </p>
<p>should be called during initialization of the ECU before the interrupts have been enabled </p>
<p>before. </p>
<p> </p>
<p><b>6.2.2 </b></p>
<p><b>Xcp_Init: Initialization of the XCP Protocol Layer </b></p>
<p><b>Xcp_Init </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_Init  </b>( </p>
<p>void </p>
<p>) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>36 / 94 </p>
<p><b>Functional Description </b></p>
<p>This service initializes the XCP Protocol Layer and its internal variables. It must be called from the </p>
<p>application program before any other XCP function is called. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>This service function has to be called after the initialization of XCP Transport Layer. </p>
<p><b>&gt; </b></p>
<p>The global interrupts have to be disabled while this service function is executed. This function </p>
<p>should be called during initialization of the ECU before the interrupts have been enabled </p>
<p>before. </p>
<p> </p>
<p><b>6.2.3 </b></p>
<p><b>Xcp_Event: Handling of a data acquisition event channel </b></p>
<p><b>Xcp_Event</b> </p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>Xcp_Event  </b>( uint8 event ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>event </p>
<p>Number of event channels to process </p>
<p>The event channel numbers have to start at 0 and have to be </p>
<p>continuous. The range is: 0..x </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_EVENT_NO :   </p>
<p>Inactive (DAQ not running, Event not configured) </p>
<p>XCP_EVENT_DAQ :  DAQ active */ </p>
<p>XCP_EVENT_DAQ_OVERRUN :  DAQ queue overflow </p>
<p>XCP_EVENT_STIM :  STIM active </p>
<p>XCP_EVENT_STIM_OVERRUN :  STIM data not available </p>
<p><b>Functional Description </b></p>
<p>Calling Xcp_Event with a particular event channel number triggers the sampling and transmission </p>
<p>of all DAQ lists that are assigned to this event channel. </p>
<p>The event channels are defined by the ECU developer in the application program. An MCS (e.g. </p>
<p>CANape) must know about the meaning of the event channel numbers. These are usually </p>
<p>described in the tool configuration files or in the interface specific part of the ASAM MC2 (ASAP2) </p>
<p>database. </p>
<p>Example: </p>
<p>A motor control unit may have a 10ms, a 100ms and a crank synchronous event channel. In this </p>
<p>case, the three Xcp_Event calls have to be placed at the appropriate locations in the ECU’s </p>
<p>program: </p>
<p>Xcp_Event (0); /* 10ms cycle */ </p>
<p>xcp_Event (1); /* 100ms cycle */ </p>
<p>xcp_Event (2); /* Crank synchronous cycle */ </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>37 / 94 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>Data acquisition has to be enabled: XCP_ENABLE_DAQ has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.2.4 </b></p>
<p><b>Xcp_StimEventStatus: Check data stimulation events </b></p>
<p><b>Xcp_StimEventStatus </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>Xcp_StimEventStatus  </b>( uint8 event, uint8 action ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>event </p>
<p>Event channel number </p>
<p>action </p>
<p>STIM_CHECK_ODT_BUFFER</p>
<p> : check ODT buffer </p>
<p>STIM_RESET_ODT_BUFFER</p>
<p> : reset ODT buffer </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0</p>
<p> : stimulation data not available</p>
<p> </p>
<p>1</p>
<p> : new stimulation data is available</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Check if data stimulation (STIM) event can perform or delete the buffers. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>Data acquisition has to be enabled: XCP_ENABLE_STIM has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.2.5 </b></p>
<p><b>Xcp_MainFunction: Background calculation of checksum </b></p>
<p><b>Xcp_MainFunction </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_MainFunction  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>38 / 94 </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 : background calculation finished </p>
<p>1 : background calculation is still in progress </p>
<p><b>Functional Description </b></p>
<p>If the XCP command for the calculation of the memory checksum has to be used for large memory </p>
<p>areas, it might not be appropriate to block the processor for a long period of time. Therefore, the </p>
<p>checksum calculation is divided into smaller sections that are handled in </p>
<p>Xcp_MainFunction</p>
<p>. </p>
<p>Therefore </p>
<p>Xcp_MainFunction</p>
<p> should be called periodically whenever the ECU’s CPU is idle. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task level </p>
<p> </p>
<p><b>6.2.6 </b></p>
<p><b>Xcp_SendEvent: Transmission of event codes </b></p>
<p><b>Xcp_SendEvent </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_SendEvent  </b>( uint8 Xcp_Channel, uint8 evc, ROMBYTEPTR </p>
<p>c, uint8 len ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>evc </p>
<p>event code </p>
<p>c  </p>
<p>pointer to event data </p>
<p>len </p>
<p>event data length </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Transmission of event codes via event packets (EV). </p>
<p>Please refer to chapter 3.10 Event Codes. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>Data acquisition has to be enabled: XCP_ENABLE_SEND_EVENT has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p> </p>
<p><b>6.2.7 </b></p>
<p><b>Xcp_Putchar: Put a char into a service request packet </b></p>
<p><b>Xcp_Putchar </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>39 / 94 </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_Putchar  </b>( uint8 Xcp_Channel, const uint8 c ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>c </p>
<p>character that is put in a service request packet </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Put a char into a service request packet (SERV). </p>
<p>The service request packet is transmitted if either the maximum packet length is reached (the </p>
<p>service request message packet is full) or the character 0x00 is out in the service request packet. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SERV_TEXT_PUTCHAR</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.2.8 </b></p>
<p><b>Xcp_Print: Transmission of a service request packet </b></p>
<p><b>Xcp_Print </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_Print  </b>( uint8 Xcp_Channel, P2CONST(uint8, AUTOMATIC, </p>
<p>XCP_APPL_DATA) str ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>str </p>
<p>pointer to a string that is terminated by 0x00 </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Transmission of a service request packet (SERV). </p>
<p>The string </p>
<p>str</p>
<p> is sent via service request packets. The string has to be terminated by 0x00. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SERV_TEXT_PRINT</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>40 / 94 </p>
<p><b>6.2.9 </b></p>
<p><b>Xcp_Disconnect: Disconnect from XCP master </b></p>
<p><b>Xcp_Disconnect </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_Disconnect  </b>( uint8 Xcp_Channel ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>If the XCP slave is connected to a XCP master a call of this function discontinues the connection </p>
<p>(transition to disconnected state). If the XCP slave is not connected this function performs no </p>
<p>action. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly and XCP is in connected state. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.2.10 </b></p>
<p><b>Xcp_SendCrm: Transmit response or error packet </b></p>
<p><b>Xcp_SendCrm </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_SendCrm  </b>( uint8 Xcp_Channel ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Transmission of a command response packet (RES), or error packet (ERR) if no other packet is </p>
<p>pending. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly, XCP is in connected state and a </p>
<p>command packet (CMD) has been received. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>41 / 94 </p>
<p> </p>
<p><b>6.2.11 </b></p>
<p><b>Xcp_GetXcpDataPointer: Request internal data pointer </b></p>
<p><b>Xcp_GetXcpDataPointer </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_GetXcpDataPointer </b>( tXcpData ** pXcpData ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>pXcpData</p>
<p> </p>
<p>pointer to store the pointer to the module internal data </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>With this function the pointer to the module internal data can be received. With this pointer the </p>
<p>internal variable can be set to a certain configuration (e.g. after entering a boot mode where no </p>
<p>connection shall be established again). As this pointer allows the access to all internal data it must </p>
<p>be handled with care. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_GET_XCP_DATA_POINTER</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.2.12 </b></p>
<p><b>Xcp_GetVersionInfo: Request module version information </b></p>
<p><b>Xcp_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_GetVersionInfo </b>(P2VAR(Std_VersionInfoType, AUTOMATIC, </p>
<p>XCP_APPL_DATA) XcpVerInfoPtr) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>XcpVerInfoPtr </p>
<p> </p>
<p>Pointer to the location where the Version information shall be stored. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Xcp_GetVersionInfo() returns version information, vendor ID and AUTOSAR module ID of the </p>
<p>component. The versions are BCD-coded. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>42 / 94 </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>The switch </p>
<p>XCP_ENABLE_VERSION_INFO_API</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: task level (Re-entrant) </p>
<p> </p>
<p><b>6.2.13 </b></p>
<p><b>Xcp_ModifyProtectionStatus: Influence seed&amp;key behaviour </b></p>
<p><b>Xcp_ModifyProtectionStatus </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_ModifyProtectionStatus </b>( uint8 Xcp_Channel, uint8 </p>
<p>andState, uint8 orState ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>andState </p>
<p>The following flags: RM_CAL_PAG, RM_DAQ, RM_STIM and </p>
<p>RM_PGM can be used to clear the protection state of the respective </p>
<p>resource. The modified state is persistent until Xcp_Init. </p>
<p>orState </p>
<p>The following flags: RM_CAL_PAG, RM_DAQ, RM_STIM and </p>
<p>RM_PGM can be used to set the protection state of the respective </p>
<p>resource. The modified state is persistent until Xcp_Init. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This method can be used to enable or disable the protection state of an individual resource during </p>
<p>runtime. The newly set protection state is persistent until the next call of the Xcp_Init function </p>
<p>where all flags are set again. </p>
<p><b>Particularities and Limitations </b></p>
<p></p>
<p> </p>
<p>The switch </p>
<p>XCP_ENABLE_VERSION_INFO_API</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Call context: task level (Re-entrant) </p>
<p> </p>
<p> </p>
<p><b>6.3 </b></p>
<p><b>XCP Protocol Layer Functions, called by the XCP Transport Layer </b></p>
<p>For using the following functions there are some limitations which have to be taken into </p>
<p>consideration – especially when using an operation system like, i.e. OSEK OS: </p>
<p><b>&gt; </b></p>
<p>The ISR level for the transmission and reception of CAN messages has to be the same. </p>
<p><b>&gt; </b></p>
<p>Interrupts must be mutually </p>
<p><b>&gt; </b></p>
<p>No nested calls of these functions are allowed. (i.e. these functions are not reentrant) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>43 / 94 </p>
<p>All functions provided by the application must match the required interfaces. This can be </p>
<p>ensured by including the header file in the modules which provide the required functions. If </p>
<p>these interfaces do not match unexpected run-time behavior may occur. </p>
<p> </p>
<p><b>6.3.1 </b></p>
<p><b>Xcp_Command: Evaluation of XCP packets and command interpreter </b></p>
<p><b>Xcp_Command </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_Command  </b>( uint8 Xcp_Channel, P2CONST(uint32, </p>
<p>AUTOMATIC, XCP_APPL_DATA) pCommand ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>pCommand</p>
<p> </p>
<p>Pointer to the XCP protocol message, which must be extracted from </p>
<p>the XCP protocol packet. </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Every time the XCP Transport Layer receives a XCP CTO Packet this function has to be called. </p>
<p>The parameter is a pointer to the XCP protocol message, which must be extracted from the XCP </p>
<p>protocol packet. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has to be initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p> </p>
<p><b>6.3.2 </b></p>
<p><b>Xcp_SendCallBack: Confirmation of the successful transmission of a XCP </b></p>
<p><b>packet </b></p>
<p><b>Xcp_SendCallBack </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>Xcp_SendCallBack  </b>( uint8 Xcp_Channel ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>44 / 94 </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>0</p>
<p> : </p>
<p>if the XCP Protocol Layer is idle (no transmit messages are </p>
<p>pending) </p>
<p><b>Functional Description </b></p>
<p>The XCP Protocol Layer does not call </p>
<p>&lt;Bus&gt;Xcp_Send</p>
<p> again, until </p>
<p>Xcp_SendCallBack</p>
<p> has </p>
<p>confirmed the successful transmission of the previous message. </p>
<p>Xcp_SendCallBack</p>
<p> transmits </p>
<p>pending data acquisition messages by calling </p>
<p>&lt;Bus&gt;Xcp_Send</p>
<p> again.  </p>
<p>Note that if </p>
<p>Xcp_SendCallBack</p>
<p> is called from inside </p>
<p>&lt;Bus&gt;Xcp_Send</p>
<p> a recursion occurs, which </p>
<p>assumes enough space on the call stack. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.3.3 </b></p>
<p><b>Xcp_GetSessionStatus: Get session state of XCP </b></p>
<p><b>Xcp_GetSessionStatus </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>SessionStatusType <b>Xcp_GetSessionStatus  </b>( uint8 </p>
<p>Xcp_Channel ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>SS_CONNECTED</p>
<p> </p>
<p>XCP is connected </p>
<p>SS_DAQ </p>
<p>DAQ measurement is running </p>
<p>SS_POLLING</p>
<p> </p>
<p>Polling is running (depending on polling rate this flag is not </p>
<p>always set) </p>
<p><b>Functional Description </b></p>
<p>This service can be used to get the session state of the XCP Protocol Layer. The session state is </p>
<p>returned as bit mask where the individual bits can be tested. </p>
<p>E.g. this service is used by the XCP on CAN Transport Layer to determine the connection state in </p>
<p>case multiple CAN channels are used and can be used by the application to prevent an ECU </p>
<p>shutdown. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has to be initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p><b>&gt; </b></p>
<p>Enabled/Disabled by </p>
<p>XCP_xxx_GET_SESSION_STATUS_API</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>45 / 94 </p>
<p><b>6.3.4 </b></p>
<p><b>Xcp_SetActiveTl: Set the active Transport Layer </b></p>
<p><b>Xcp_SetActiveTl </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_SetActiveTl  </b>( uint8 Xcp_Channel, uint8 MaxCto, uint8 </p>
<p>MaxDto, uint8 ActiveTl ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>MaxCto </p>
<p>Max CTO used by the respective XCP Transport Layer </p>
<p>MaxDto </p>
<p>Max DTO used by the respective XCP Transport Layer </p>
<p>ActiveTl </p>
<p>XCP_TRANSPORT_LAYER_CAN:</p>
<p> XCP on CAN Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_FR:</p>
<p> XCP on Fr Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_ETH:</p>
<p> XCP on Ethernet Transport Layer</p>
<p> </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Set the active Transport Layer the XCP Protocol Layer uses. </p>
<p>This service is used by the XCP Transport Layers to set the Transport Layer to be used by the </p>
<p>XCP Protocol Layer </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has to be initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p><b>6.3.5 </b></p>
<p><b>Xcp_GetActiveTl: Get the currently active Transport Layer </b></p>
<p><b>Xcp_GetActiveTl </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>Xcp_GetActiveTl  </b>( uint8 Xcp_Channel ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_TRANSPORT_LAYER_CAN:</p>
<p> XCP on CAN Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_FR:</p>
<p> XCP on Fr Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_ETH:</p>
<p> XCP on Ethernet Transport Layer</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>46 / 94 </p>
<p><b>Functional Description </b></p>
<p>Get the active Transport Layer the XCP Protocol Layer uses. </p>
<p>This service is used by the XCP Transport Layers to get the currently active Transport Layer used </p>
<p>by the XCP Protocol Layer </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has to be initialized correctly. </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant) </p>
<p> </p>
<p> </p>
<p><b>6.4 </b></p>
<p><b>XCP Transport Layer Services called by the XCP Protocol Layer </b></p>
<p>The prototypes of the functions that are required by the XCP Protocol Layer can be found in the </p>
<p>component’s header. </p>
<p> </p>
<p><b>6.4.1 </b></p>
<p><b>&lt;Bus&gt;Xcp_Send: Request for the transmission of a DTO or CTO message </b></p>
<p><b>&lt;Bus&gt;Xcp_Send </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>&lt;Bus&gt;Xcp_Send  </b>( uint8 Xcp_Channel, uint8 len, ROMBYTEPTR </p>
<p>msg ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>len </p>
<p>Length of message data </p>
<p>msg </p>
<p>Pointer to message </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0</p>
<p> : if the XCP Protocol Layer is idle (no transmit messages are </p>
<p>pending) </p>
<p><b>Functional Description </b></p>
<p>Requests for the transmission of a command transfer object (CTO) or data transfer object (DTO). </p>
<p>Xcp_SendCallBack</p>
<p> must be called after the successful transmission of any XCP message. The </p>
<p>XCP Protocol Layer will not request further transmissions, until </p>
<p>Xcp_SendCallBack</p>
<p> has been </p>
<p>called. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level (not reentrant)</p>
<p> </p>
<p><b>&gt; </b></p>
<p>&lt;Bus&gt;Xcp_Send </p>
<p>is not defined as macro</p>
<p> </p>
<p> </p>
<p><b>6.4.2 </b></p>
<p><b>&lt;Bus&gt;Xcp_SendFlush: Flush transmit buffer </b></p>
<p><b>&lt;Bus&gt;Xcp_SendFlush </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>47 / 94 </p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>&lt;Bus&gt;Xcp_SendFlush  </b>( uint8 Xcp_Channel ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Flush the transmit buffer. </p>
<p><b>Particularities and Limitations </b></p>
<p>- </p>
<p> </p>
<p><b>6.4.3 </b></p>
<p><b>XcpAppl_InterruptEnable: Enable interrupts </b></p>
<p><b>XcpAppl_InterruptEnable </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpAppl_InterruptEnable  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Enabling of the global interrupts. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>This function is reentrant! </p>
<p><b>&gt; </b></p>
<p>The function </p>
<p>XcpAppl_InterruptEnable</p>
<p> can be overwritten by the macro </p>
<p>XcpAppl_InterruptEnable</p>
<p>. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>48 / 94 </p>
<p><b>6.4.4 </b></p>
<p><b>XcpAppl_InterruptDisable: Disable interrupts </b></p>
<p><b>XcpAppl_InterruptDisable </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpAppl_InterruptDisable  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Disabling of the global interrupts. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>This function is reentrant! </p>
<p><b>&gt; </b></p>
<p>The function </p>
<p>XcpAppl_InterruptDisable</p>
<p> can be overwritten by the macro </p>
<p>XcpAppl_InterruptDisable</p>
<p>. </p>
<p> </p>
<p><b>6.4.5 </b></p>
<p><b>&lt;Bus&gt;Xcp_TLService: Transport Layer specific commands </b></p>
<p><b>&lt;Bus&gt;Xcp_TLService </b></p>
<p>Prototype </p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>&lt;Bus&gt;Xcp_TLService  </b>( uint8 Xcp_Channel, ROMBYTEPTR  </p>
<p>pCmd ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p>Parameter </p>
<p>pCmd </p>
<p>Pointer to COMMAND that has been received by the XCP Slave. </p>
<p>Return code </p>
<p>uint8 </p>
<p>XCP_CMD_OK </p>
<p>:  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Done </p>
<p>XCP_CMD_PENDING</p>
<p> :   </p>
<p> </p>
<p> </p>
<p> </p>
<p>Call Xcp_SendCrm() when done </p>
<p>XCP_CMD_SYNTAX</p>
<p> :  </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Error </p>
<p>XCP_CMD_BUSY</p>
<p> :   </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>not executed </p>
<p>XCP_CMD_UNKNOWN</p>
<p> :   </p>
<p> </p>
<p> </p>
<p> </p>
<p>not implemented optional command </p>
<p>XCP_CMD_OUT_OF_RANGE </p>
<p>:  command parameters out of range </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>49 / 94 </p>
<p>Functional Description </p>
<p>Transport Layer specific command that is processed within the XCP Transport Layer. </p>
<p> </p>
<p>Particularities and Limitations </p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_TL_COMMAND</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5 </b></p>
<p><b>Application Services called by the XCP Protocol Layer </b></p>
<p>The prototypes of the functions that are required by the XCP Protocol Layer can be found </p>
<p>in the header. </p>
<p>The  XCP  Protocol  Layer  provides  application  callback  functions  in  order  to  perform </p>
<p>application and hardware specific tasks. </p>
<p>Note: All services within this chapter are called from task or interrupt level. All services are </p>
<p>not reentrant. </p>
<p><b>6.5.1 </b></p>
<p><b>XcpAppl_GetPointer: Pointer conversion </b></p>
<p><b>XcpAppl_GetPointer </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>MTABYTEPTR <b>XcpAppl_GetPointer  </b>( uint8 addr_ext, uint32 addr ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr_ext </p>
<p>8 bit address extension </p>
<p>addr </p>
<p>32 bit address </p>
<p><b>Return code </b></p>
<p>MTABYTEPTR </p>
<p>Pointer to the address specified by the parameters </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>50 / 94 </p>
<p><b>Functional Description </b></p>
<p>This function converts a memory address from XCP format (32-bit address plus 8-bit address </p>
<p>extension) to a C style pointer. An MCS like CANape usually reads this memory addresses from </p>
<p>the ASAP2 database or from a linker map file. </p>
<p>The address extension may be used to distinguish different address spaces or memory types. In </p>
<p>most cases, the address extension is not used and may be ignored. </p>
<p>This function is used for memory transfers like DOWNLOAD and UPLOAD. </p>
<p>Example:  </p>
<p>The following code shows an example of a typical implementation of </p>
<p>XcpAppl_GetPointer</p>
<p>: </p>
<p>MTABYTEPTR XcpAppl_GetPointer( uint8 addr_ext, uint32 addr ) </p>
<p>{ </p>
<p>  return (MTABYTEPTR)addr; </p>
<p>} </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>This function can be overwritten by defining </p>
<p>XcpAppl_GetPointer</p>
<p> as macro. </p>
<p> </p>
<p><b>6.5.2 </b></p>
<p><b>XcpAppl_GetIdData: Get Identification </b></p>
<p><b>XcpAppl_GetIdData </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint32 <b>XcpAppl_GetIdData  </b>( MTABYTEPTR *pData, uint8 id ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>pData </p>
<p>Returns a pointer to a pointer of MAP file names </p>
<p>id </p>
<p>Identification of the requested information/identification </p>
<p><b>Return code </b></p>
<p>uint32 </p>
<p>length of the MAP file names </p>
<p><b>Functional Description </b></p>
<p>Returns a pointer to a pointer of MAP file names. </p>
<p>Refer to chapter 3.4.2 (XCP Generic Identification).</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_GET_ID_GENERIC</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.3 </b></p>
<p><b>XcpAppl_GetSeed: Generate a seed </b></p>
<p><b>XcpAppl_GetSeed </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>51 / 94 </p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 XcpAppl_GetSeed  ( uint8 Xcp_Channel, const uint8 resource, </p>
<p> P2VAR(uint8, AUTOMATIC, XCP_APPL_DATA) seed ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>Resource </p>
<p>Resource for which the seed has to be generated </p>
<p>XCP Professional and XPC Basic </p>
<p>RM_CAL_PAG</p>
<p> :  </p>
<p>to unlock the resource calibration/paging </p>
<p>RM_DAQ</p>
<p> :  </p>
<p>to unlock the resource data acquisition </p>
<p>XCP Professional only </p>
<p>RM_STIM</p>
<p> : </p>
<p>to unlock the resource stimulation </p>
<p>RM_PGM</p>
<p> :  </p>
<p>to unlock the resource programming </p>
<p>Seed </p>
<p>Pointer to RAM where the seed has to be generated to. </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>The length of the generated seed that is returned by <i>seed</i>. </p>
<p><b>Functional Description </b></p>
<p>Generate a seed for the appropriate resource. </p>
<p>The seed has a maximum length of MAX_CTO-2 bytes.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SEED_KEY</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.4 </b></p>
<p><b>XcpAppl_Unlock: Valid key and unlock resource </b></p>
<p><b>XcpAppl_Unlock </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 XcpAppl_Unlock  ( uint8 Xcp_Channel, P2CONST(uint8, </p>
<p>AUTOMATIC, XCP_APPL_DATA) key, const uint8 length )</p>
<p> </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>key </p>
<p>Pointer to the key. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>52 / 94 </p>
<p>length </p>
<p>Length of the key. </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP Professional and XPC Basic </p>
<p>0</p>
<p> :  </p>
<p>if the key is not valid </p>
<p>RM_CAL_PAG</p>
<p> :  </p>
<p>to unlock the resource calibration/paging </p>
<p>RM_DAQ</p>
<p> :  </p>
<p>to unlock the resource data acquisition </p>
<p>XCP Professional only </p>
<p>RM_STIM</p>
<p> : </p>
<p>to unlock the resource stimulation </p>
<p>RM_PGM</p>
<p> :  </p>
<p>to unlock the resource programming </p>
<p><b>Functional Description </b></p>
<p>Check the key and return the resource that has to be unlocked. </p>
<p>Only one resource may be unlocked at one time.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SEED_KEY</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.5 </b></p>
<p><b>XcpAppl_CheckReadEEPROM: Check read access from EEPROM </b></p>
<p><b>XcpAppl_CheckReadEEPROM </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_CheckReadEEPROM  </b>( MTABYTEPTR addr, </p>
<p> </p>
<p>uint8 size, </p>
<p> </p>
<p>BYTEPTR data )</p>
<p> </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr </p>
<p>Address that is checked </p>
<p>size </p>
<p>Number of bytes </p>
<p>data </p>
<p>Pointer to data </p>
<p>(if the address is on the EEPROM the data is written here) </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> :  </p>
<p>EEPROM read </p>
<p>XCP_CMD_DENIED</p>
<p> :  This is not EEPROM </p>
<p>XCP_CMD_PENDING</p>
<p> :  EEPROM read in progress, call </p>
<p>Xcp_SendCrm</p>
<p>  </p>
<p> </p>
<p>when done</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Checks whether the address lies within the EEPROM memory or in the RAM area. </p>
<p>If the area is within the EEPROM area </p>
<p>size</p>
<p> data byte are read from </p>
<p>addr</p>
<p> and written to </p>
<p>data</p>
<p>.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>53 / 94 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_READ_EEPROM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.6 </b></p>
<p><b>XcpAppl_CheckWriteEEPROM: Check write access to the EEPROM </b></p>
<p><b>XcpAppl_CheckWriteEEPROM </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_CheckWriteEEPROM  </b>( uint8 Xcp_Channel, </p>
<p>MTABYTEPTR addr,</p>
<p> </p>
<p>uint8 size,</p>
<p> </p>
<p>ROMBYTEPTR data)</p>
<p> </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>addr </p>
<p>Address that is checked </p>
<p>size </p>
<p>number of bytes </p>
<p>data </p>
<p>pointer to data </p>
<p>(if </p>
<p>addr</p>
<p> is on the EEPROM this data is written to </p>
<p>addr</p>
<p>) </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> :  </p>
<p>EEPROM written </p>
<p>XCP_CMD_DENIED</p>
<p> :  This is not EEPROM </p>
<p>XCP_CMD_PENDING</p>
<p> :  EEPROM write in progress, call </p>
<p>XcpSendCrm</p>
<p>  </p>
<p> </p>
<p>when done </p>
<p><b>Functional Description </b></p>
<p>Checks whether the address </p>
<p>addr</p>
<p> is within the EEPROM memory. If not, the function returns </p>
<p>XCP_CMD_DENIED</p>
<p>. If it lies within, EEPROM programming is performed. The function may return </p>
<p>during programming with </p>
<p>XCP_CMD_PENDING</p>
<p> or may wait until the programming sequence has </p>
<p>finished and then returns with </p>
<p>XCP_CMD_OK</p>
<p>.  </p>
<p>If the programming sequence has finished, the </p>
<p>Xcp_SendCrm</p>
<p> function must be called. </p>
<p>Xcp_SendCrm</p>
<p> is an internal function of the XCP Protocol Layer.</p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_WRITE_EEPROM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.7 </b></p>
<p><b>XcpAppl_CheckWriteAccess: Check address for valid write access </b></p>
<p><b>XcpAppl_CheckWriteAccess </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>54 / 94 </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_CheckWriteAccess  </b>( MTABYTEPTR address, </p>
<p> </p>
<p>uint8 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>address </p>
<p>size </p>
<p>number of bytes </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_DENIED </p>
<p>:   if access is denied </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>if access is granted </p>
<p><b>Functional Description </b></p>
<p>Check addresses for valid write access. A write access is enabled with the </p>
<p>XCP_ENABLE_WRITE_PROTECTION</p>
<p>, it should be only used, if write protection of memory </p>
<p>areas is required </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_WRITE_PROTECTION</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Can be overwritten by the macro </p>
<p>XcpAppl_CheckWriteAccess</p>
<p> </p>
<p> </p>
<p><b>6.5.8 </b></p>
<p><b>XcpAppl_CheckReadAccess: Check address for valid read access </b></p>
<p><b>XcpAppl_CheckReadAccess </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_CheckReadAccess  </b>( MTABYTEPTR address, </p>
<p> </p>
<p>uint8 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>address </p>
<p>size </p>
<p>number of bytes </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_DENIED</p>
<p> : </p>
<p>if access is denied </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>if access is granted </p>
<p><b>Functional Description </b></p>
<p>Check addresses for valid read access. A read access is enabled with the </p>
<p>XCP_ENABLE_READ_PROTECTION</p>
<p>, it should be only used, if read protection of memory areas </p>
<p>is required </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>55 / 94 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_READ_PROTECTION</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Can be overwritten by the macro </p>
<p>XcpAppl_CheckReadAccess</p>
<p> </p>
<p> </p>
<p><b>6.5.9 </b></p>
<p><b>XcpAppl_CheckDAQAccess: Check address for valid read or write access </b></p>
<p><b>XcpAppl_CheckDAQAccess </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_CheckDAQAccess  </b>( DAQBYTEPTR address, </p>
<p> </p>
<p>uint8 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>address </p>
<p>size </p>
<p>number of bytes </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_DENIED</p>
<p> : </p>
<p>if access is denied </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>if access is granted </p>
<p><b>Functional Description </b></p>
<p>Check addresses for valid read or write access. This callback is called when a WRITE_DAQ </p>
<p>command is performed. Therefore it is not possible to know whether this is a read or write </p>
<p>access. Out of this reason this unified function is called. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_READ_PROTECTION</p>
<p> or </p>
<p>XCP_ENABLE_WRITE_PROTECTION</p>
<p> has to </p>
<p>be defined </p>
<p> </p>
<p><b>6.5.10 </b></p>
<p><b>XcpAppl_CheckProgramAccess: Check address for valid write access </b></p>
<p><b>XcpAppl_CheckProgramAccess </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_CheckProgramAccess  </b>( MTABYTEPTR address, </p>
<p> </p>
<p>      uint32 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>address </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>56 / 94 </p>
<p>size </p>
<p>number of bytes </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_DENIED</p>
<p> : </p>
<p>if access is denied </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>if access is granted </p>
<p><b>Functional Description </b></p>
<p>Check addresses for valid write access. A write access is enabled with the </p>
<p>XCP_ENABLE_PROGRAMMING_WRITE_PROTECTION</p>
<p>, it should be only used, if write protection </p>
<p>of memory areas is required </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAMMING_WRITE_PROTECTION</p>
<p> has to be defined </p>
<p><b>&gt; </b></p>
<p>Can be overwritten by the macro </p>
<p>XcpAppl_CheckWriteAccess</p>
<p> </p>
<p> </p>
<p><b>6.5.11 </b></p>
<p><b>XcpAppl_UserService: User defined command </b></p>
<p><b>XcpAppl_UserService </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_UserService </b>( uint8 Xcp_Channel, ROMBYTEPTR </p>
<p>pCmd ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>pCmd </p>
<p>Pointer to XCP command packet </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> :  </p>
<p>positive response </p>
<p>XCP_CMD_PENDING</p>
<p> :  Call XcpSendCrm() when done </p>
<p>XCP_CMD_SYNTAX</p>
<p> :  negative response </p>
<p><b>Functional Description </b></p>
<p>Application specific user command. </p>
<p>Please refer to 3.12 User Defined Command. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_USER_COMMAND</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.12 </b></p>
<p><b>XcpAppl_OpenCmdIf: XCP command extension interface </b></p>
<p><b>XcpAppl_OpenCmdIf </b></p>
<p>Prototype </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>57 / 94 </p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_OpenCmdIf  </b>( uint8 Xcp_Channel, ROMBYTEPTR  </p>
<p>pCmd </p>
<p>BYTEPTR pRes, BYTEPTR pLength ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p>Parameter </p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>pCmd </p>
<p>Pointer to COMMAND that has been received by the XCP Slave. </p>
<p>pRes </p>
<p>Pointer to response buffer that will be sent by the XCP Slave. </p>
<p>pLength </p>
<p>Number of bytes that will be sent in the response. </p>
<p>Return code </p>
<p>uint8 </p>
<p>XCP_CMD_OK </p>
<p>:  </p>
<p> </p>
<p> </p>
<p> </p>
<p>Done </p>
<p>XCP_CMD_PENDING </p>
<p>:  </p>
<p>Call Xcp_SendCrm() when done </p>
<p>XCP_CMD_ERROR</p>
<p> : </p>
<p> </p>
<p> </p>
<p>Error </p>
<p>Functional Description </p>
<p>Call back that can be used to extend the XCP commands of the XCP protocol layer. </p>
<p> </p>
<p>Particularities and Limitations </p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly </p>
<p><b>&gt; </b></p>
<p>Call context: Task and interrupt level </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_OPENCMDIF</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.13 </b></p>
<p><b>XcpAppl_SendStall: Resolve a transmit stall condition </b></p>
<p><b>XcpAppl_SendStall </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_SendStall  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p>Parameter </p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 :     if not successful </p>
<p>&gt; 0 :  successful </p>
<p><b>Functional Description </b></p>
<p>Resolve a transmit stall condition in </p>
<p>Xcp_Putchar</p>
<p> or </p>
<p>Xcp_SendEvent</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>58 / 94 </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_SEND_EVENT</p>
<p> or </p>
<p>XCP_ENABLE_SERV_TEXT_PUTCHAR</p>
<p> and </p>
<p>XCP_ENABLE_SEND_QUEUE</p>
<p> are defined </p>
<p><b>&gt; </b></p>
<p>The function can be overwritten by the macro </p>
<p>XcpAppl_SendStall()</p>
<p> </p>
<p> </p>
<p><b>6.5.14 </b></p>
<p><b>XcpAppl_DisableNormalOperation: Disable normal operation of the ECU </b></p>
<p><b>XcpAppl_DisableNormalOperation </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_DisableNormalOperation  </b>( MTABYTEPTR a, </p>
<p> </p>
<p>uint16 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>a </p>
<p>Address (where the flash kernel is downloaded to) </p>
<p>size </p>
<p>Size (of the flash kernel) </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>download of flash kernel confirmed </p>
<p>XCP_CMD_DENIED</p>
<p> : download of flash kernel refused </p>
<p><b>Functional Description </b></p>
<p>Prior to the flash kernel download has the ECU’s normal operation to be stopped in order to </p>
<p>avoid misbehavior due to data inconsistencies. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_BOOTLOADER_DOWNLAOD</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.15 </b></p>
<p><b>XcpAppl_StartBootLoader: Start of boot loader </b></p>
<p><b>XcpAppl_StartBootLoader </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_StartBootLoader  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>59 / 94 </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>This function should not return. </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>positive response </p>
<p>XCP_CMD_BUSY</p>
<p> </p>
<p>: </p>
<p>negative response </p>
<p><b>Functional Description </b></p>
<p>Start of the boot loader. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_BOOTLOADER_DOWNLAOD</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.16 </b></p>
<p><b>XcpAppl_Reset: Perform ECU reset </b></p>
<p><b>XcpAppl_Reset </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpAppl_Reset  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Perform an ECU reset after reprogramming of the application. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.17 </b></p>
<p><b>XcpAppl_ProgramStart: Prepare flash programming </b></p>
<p><b>XcpAppl_ProgramStart </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_ProgramStart  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>60 / 94 </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> :  </p>
<p>Preparation done </p>
<p>XCP_CMD_PENDING </p>
<p>:  </p>
<p>Call Xcp_SendCrm() when done </p>
<p>XCP_CMD_ERROR</p>
<p> :  </p>
<p>Flash programming not possible </p>
<p><b>Functional Description </b></p>
<p>Prepare the ECU for flash programming. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.18 </b></p>
<p><b>XcpAppl_FlashClear: Clear flash memory </b></p>
<p><b>XcpAppl_FlashClear </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_FlashClear  </b>( MTABYTEPTR address, </p>
<p> </p>
<p>uint32 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>address </p>
<p>Address </p>
<p>size </p>
<p>Size </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK </p>
<p>: </p>
<p>Flash memory erase done </p>
<p>XCP_CMD_PENDING</p>
<p> :  Call Xcp_SendCrm() when done </p>
<p>XCP_CMD_ERROR</p>
<p> : </p>
<p>Flash memory erase error </p>
<p><b>Functional Description </b></p>
<p>Clear the flash memory, before the flash memory will be reprogrammed. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.19 </b></p>
<p><b>XcpAppl_FlashProgram: Program flash memory </b></p>
<p><b>XcpAppl_FlashProgram </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>61 / 94 </p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_FlashProgram  </b>( ROMBYTEPTR data, </p>
<p> </p>
<p>MTABYTEPTR address, </p>
<p> </p>
<p>uint8 size ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>data </p>
<p>Pointer to data </p>
<p>address </p>
<p>Address </p>
<p>size </p>
<p>Size </p>
<p><b>Return code </b></p>
<p>uint8</p>
<p> </p>
<p>XCP_CMD_OK</p>
<p> : </p>
<p>Flash memory programming finished </p>
<p>XCP_CMD_PENDING </p>
<p>: Flash memory programming in progress. </p>
<p> </p>
<p>Xcp_SendCrm</p>
<p> has to be called when done. </p>
<p><b>Functional Description </b></p>
<p>Program the cleared flash memory. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switch </p>
<p>XCP_ENABLE_PROGRAM</p>
<p> has to be defined </p>
<p> </p>
<p><b>6.5.20 </b></p>
<p><b>XcpAppl_DaqResume: Resume automatic data transfer </b></p>
<p><b>XcpAppl_DaqResume </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_DaqResume  </b>( uint8 Xcp_Channel, tXcpDaq * daq ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>daq </p>
<p>Pointer to dynamic DAQ list structure </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 : </p>
<p>No resume mode data available </p>
<p>&gt;0 : </p>
<p>Resume mode initialization ok </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>62 / 94 </p>
<p><b>Functional Description </b></p>
<p>Resume the automatic data transfer. </p>
<p>The whole dynamic DAQ list structure that had been stored in non-volatile memory within the </p>
<p>service </p>
<p>XcpAppl_DaqResumeStore(..)</p>
<p> has to be restored to RAM. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_RESUME</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.21 </b></p>
<p><b>XcpAppl_DaqResumeStore: Store DAQ lists for resume mode </b></p>
<p><b>XcpAppl_DaqResumeStore </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void XcpAppl_DaqResumeStore  (uint8 Xcp_Channel, </p>
<p>P2CONST(tXcpDaq, AUTOMATIC, XCP_APPL_DATA) daq , uint16 </p>
<p>size, uint8 measurementStart) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>daq </p>
<p>Pointer to dynamic DAQ list structure. </p>
<p>size </p>
<p>Size of DAQ data that needs to be stored </p>
<p>MeasurementStart </p>
<p>If &gt; 0 then set flag to start measurement during next init </p>
<p><b>Return code </b></p>
<p>-</p>
<p> </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This application callback service has to store the whole dynamic DAQ list structure in non-</p>
<p>volatile memory for the DAQ resume mode. Any old DAQ list configuration that might have </p>
<p>been stored in non-volatile memory before this command, must not be applicable anymore. </p>
<p>After a cold start or reset the dynamic DAQ list structure has to be restored by the application </p>
<p>callback service </p>
<p>XcpAppl_DaqResume(..)</p>
<p>when the flag measurementStart is &gt; 0. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_RESUME</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.22 </b></p>
<p><b>XcpAppl_DaqResumeClear: Clear stored DAQ lists </b></p>
<p><b>XcpAppl_DaqResumeClear </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>63 / 94 </p>
<p>Single Receive Channel </p>
<p>void <b>XcpAppl_DaqResumeClear  </b>( uint8 Xcp_Channel  ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p><b>Return code </b></p>
<p>-</p>
<p> </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>The whole dynamic DAQ list structure that had been stored in non-volatile memory within the </p>
<p>service </p>
<p>XcpAppl_DaqResumeStore(..)</p>
<p> has to be cleared. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_RESUME</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.23 </b></p>
<p><b>XcpAppl_CalResumeStore: Store Calibration data for resume mode </b></p>
<p><b>XcpAppl_CalResumeStore </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_CalResumeStore  </b>( uint8 Xcp_Channel ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel</p>
<p> </p>
<p> A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>0 :    Storing not yet finished (STORE_CAL_REQ flag kept) </p>
<p>&gt;0 :  Storing finished (STORE_CAL_REQ flag cleared) </p>
<p><b>Functional Description </b></p>
<p>This application callback service has to store the current calibration data in non-volatile </p>
<p>memory for the resume mode. </p>
<p>After a cold start or reset the calibration data has to be restored by the application. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_RESUME</p>
<p> are defined </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>64 / 94 </p>
<p><b>6.5.24 </b></p>
<p><b>XcpAppl_GetTimestamp: Returns the current timestamp </b></p>
<p><b>XcpAppl_GetTimestamp </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>XcpDaqTimestampType <b>XcpAppl_GetTimestamp  </b>( void ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>- </p>
<p>- </p>
<p><b>Return code </b></p>
<p>XcpDaqTimestampType </p>
<p>timestamp </p>
<p><b>Functional Description </b></p>
<p>Returns the current timestamp. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP</p>
<p> are defined </p>
<p><b>&gt; </b></p>
<p>The parameter </p>
<p>kXcpDaqTimestampSize</p>
<p> defines the timestamp size. It can either be </p>
<p>DAQ_TIMESTAMP_BYTE, DAQ_TIMESTAMP_WORD, DAQ_TIMESTAMP_DWORD</p>
<p> </p>
<p> </p>
<p><b>6.5.25 </b></p>
<p><b>XcpAppl_GetCalPage: Get calibration page </b></p>
<p><b>XcpAppl_GetCalPage </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_GetCalPage  </b>( uint8 Xcp_Channel, uint8 segment, </p>
<p>uint8 mode ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>segment </p>
<p>Logical data segment number </p>
<p>mode </p>
<p>Access mode </p>
<p>The access mode can be one of the following values: </p>
<p>CAL_ECU</p>
<p> : ECU access </p>
<p>CAL_XCP</p>
<p> : XCP access </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>Logical data page number </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>65 / 94 </p>
<p><b>Functional Description </b></p>
<p>This function returns the logical number of the calibration data page that is currently activated </p>
<p>for the specified access mode and data segment. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.26 </b></p>
<p><b>XcpAppl_SetCalPage: Set calibration page </b></p>
<p><b>XcpAppl_SetCalPage </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_SetCalPage  </b>( uint8 Xcp_Channel, uint8 segment, </p>
<p> </p>
<p>uint8 page, uint8 mode ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>segment </p>
<p>Logical data segment number </p>
<p>Page </p>
<p>Logical data page number </p>
<p>mode </p>
<p>Access mode </p>
<p>CAL_ECU</p>
<p> : the given page will be used by the slave device application </p>
<p>CAL_XCP</p>
<p> : the slave device XCP driver will access the given page </p>
<p>Both flags may be set simultaneously or separately. </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK : </p>
<p>Operation completed successfully</p>
<p> </p>
<p>XCP_CMD_PENDING : </p>
<p>Call Xcp_SendCrm() when done </p>
<p>CRC_OUT_OF_RANGE : </p>
<p>segment out of range  </p>
<p>( only one segment supported) </p>
<p>CRC_PAGE_NOT_VALID : </p>
<p>Selected page not available </p>
<p>CRC_PAGE_MODE_NOT_VALID : </p>
<p>Selected page mode not available</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Set the access mode for a calibration data segment. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_DAQ</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP</p>
<p> are defined </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>66 / 94 </p>
<p><b>6.5.27 </b></p>
<p><b>XcpAppl_CopyCalPage: Copying of calibration data pages </b></p>
<p><b>XcpAppl_CopyCalPage </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_CopyCalPage  </b>( uint8 Xcp_Channel, uint8 srcSeg,  </p>
<p>                            uint8 srcPage, uint8 destSeg, uint8 destPage ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>srcSeg </p>
<p>Source segment </p>
<p>srcPage </p>
<p>Source page </p>
<p>destSeg </p>
<p>Destination segment </p>
<p>destPage </p>
<p>Destination page </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK</p>
<p> : Operation completed successfully </p>
<p>XCP_CMD_PENDING</p>
<p> : Call XcpSendCrm() when done </p>
<p>CRC_PAGE_NOT_VALID</p>
<p> : Page not available </p>
<p>CRC_SEGMENT_NOT_VALID</p>
<p> :  Segment not available </p>
<p>CRC_WRITE_PROTECTED </p>
<p>: Destination page is write protected. </p>
<p><b>Functional Description </b></p>
<p>Copying of calibration data pages. </p>
<p>The pages are copied from source to destination. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_PAGE_COPY</p>
<p> and </p>
<p>XCP_ENABLE_DAQ_TIMEOUT</p>
<p> are defined </p>
<p> </p>
<p><b>6.5.28 </b></p>
<p><b>XcpAppl_SetFreezeMode: Setting the freeze mode of a segment </b></p>
<p><b>XcpAppl_SetFreezeMode </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>XcpAppl_SetFreezeMode </b>( uint8 segment, uint8 mode ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>segment </p>
<p>Segment to set freeze mode </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>67 / 94 </p>
<p>mode </p>
<p>New freeze mode </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Setting the freeze mode of a certain segment. Application must store the current freeze mode </p>
<p>of each segment. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_PAGE_FREEZE</p>
<p> is defined </p>
<p> </p>
<p><b>6.5.29 </b></p>
<p><b>XcpAppl_GetFreezeMode: Reading the freeze mode of a segment </b></p>
<p><b>XcpAppl_GetFreezeMode </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>uint8 <b>XcpAppl_GetFreezeMode </b>( uint8 segment ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>segment </p>
<p>Segment to read freeze mode </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>Return the current freeze mode, set by XcpAppl_SetFreezeMode(). </p>
<p><b>Functional Description </b></p>
<p>Reading the freeze mode of a certain segment. Application must store the current freeze mode </p>
<p>of each segment and report it by the return value of this function. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_PAGE_FREEZE</p>
<p> is defined </p>
<p> </p>
<p><b>6.5.30 </b></p>
<p><b>XcpAppl_Read: Read a single byte from memory </b></p>
<p><b>XcpAppl_Read </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>uint8 <b>XcpAppl_Read  </b>( uint32 addr ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr </p>
<p>32 Bit address </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>68 / 94 </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>Pointer to the address specified by the parameters </p>
<p><b>Functional Description </b></p>
<p>Read a single byte from the memory. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_MEM_ACCESS_BY_APPL</p>
<p> is defined </p>
<p> </p>
<p><b>6.5.31 </b></p>
<p><b>XcpAppl_Write: Write a single byte to RAM </b></p>
<p><b>XcpAppl_Write </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>void <b>XcpAppl_Write  </b>( uint32 addr, uint8 data ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>addr </p>
<p>32 Bit address </p>
<p>data </p>
<p>data to be written to memory </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Write a single byte to RAM. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_MEM_ACCESS_BY_APPL</p>
<p> is defined </p>
<p> </p>
<p><b>6.5.32 </b></p>
<p><b>XcpAppl_MeasurementRead: Read multiple bytes from memory </b></p>
<p><b>XcpAppl_MeasurementRead </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>uint8 <b>XcpAppl_MeasurementRead  </b>( P2VAR(void, AUTOMATIC, </p>
<p>XCP_APPL_DATA) dst, P2CONST(void, AUTOMATIC, </p>
<p>XCP_APPL_DATA) src, uint8 len ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>69 / 94 </p>
<p><b>Parameter </b></p>
<p>dst </p>
<p>Address pointer </p>
<p>len </p>
<p>Number of bytes to read </p>
<p>src </p>
<p>Pointer to data </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK </p>
<p>if read operation was successful</p>
<p> otherwise return </p>
<p>protection code, e.g. </p>
<p>XCP_CMD_DENIED</p>
<p> </p>
<p><b>Functional Description </b></p>
<p>Read multiple bytes from memory. This service is used in MultiCore use case for type safe read </p>
<p>operation. </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL </p>
<p>or</p>
<p> </p>
<p>XCP_ENABLE_TYPESAVE_COPY</p>
<p> is defined </p>
<p> </p>
<p><b>6.5.33 </b></p>
<p><b>XcpAppl_CalibrationWrite: Write multiple bytes to memory </b></p>
<p><b>XcpAppl_CalibrationWrite </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>uint8 <b>XcpAppl_CalibrationWrite  </b>( P2VAR(void, AUTOMATIC, </p>
<p>XCP_APPL_DATA) dst, P2CONST(void, AUTOMATIC, </p>
<p>XCP_APPL_DATA) src, uint8 len ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>dst </p>
<p>Address pointer </p>
<p>len </p>
<p>Number of bytes to write </p>
<p>src </p>
<p>Pointer to data </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>Protection code, </p>
<p>XCP_CMD_OK </p>
<p>if write operation was successful </p>
<p><b>Functional Description </b></p>
<p>Write multiple bytes to memory. This service is used in MultiCore use case for type safe write </p>
<p>operation.  </p>
<p> </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL or </p>
<p>XCP_ENABLE_TYPESAVE_COPY</p>
<p> is defined </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>70 / 94 </p>
<p> </p>
<p><b>6.5.34 </b></p>
<p><b>XcpAppl_ReadChecksumValue: Read checksum value </b></p>
<p><b>XcpAppl_ReadChecksumValue </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>tXcpChecksumAddType <b>XcpAppl_ReadChecksumValue  </b>( uint32 </p>
<p>addr ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Addr </p>
<p>Address pointer </p>
<p><b>Return code </b></p>
<p>tXcpChecksumAddType </p>
<p>New value for checksum calculation </p>
<p><b>Functional Description </b></p>
<p>This function is used to access checksum values when no direct access to memory is allowed. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_CALIBRATION_MEM_ACCESS_BY_APPL </p>
<p>is defined </p>
<p> </p>
<p><b>6.5.35 </b></p>
<p><b>XcpAppl_CalculateChecksum: Custom checksum calculation </b></p>
<p><b>XcpAppl_CalculateChecksum </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Channel </p>
<p>uint8 <b>XcpAppl_CalculateChecksum  </b>( uint8 Xcp_Channel, </p>
<p>ROMBYTEPTR pMemArea, BYTEPTR pRes, uint32 length ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>Xcp_Channel </p>
<p>A channel parameter, used when the multi client feature is active. </p>
<p>Please use the macro </p>
<p>XCP_CHANNEL_IDX </p>
<p>to get the channel index. </p>
<p>pMemArea </p>
<p>Address pointer </p>
<p>pRes </p>
<p>Pointer to response string </p>
<p>Length </p>
<p>Length of mem area, used for checksum calculation </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>71 / 94 </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>XCP_CMD_OK : </p>
<p>CRC calculation performed successfully</p>
<p> </p>
<p>XCP_CMD_PENDING : </p>
<p>Pending response, triggered by call of </p>
<p>Xcp_SendCrm</p>
<p> </p>
<p>XCP_CMD_DENIED : </p>
<p>CRC calculation not possible </p>
<p><b>Functional Description </b></p>
<p>Normally the XCP uses internal checksum calculation functions. If the internal checksum </p>
<p>calculation does not fit the user requirements this call-back can be used to calculate the </p>
<p>checksum by the application. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>XCP is initialized correctly and in connected state </p>
<p><b>&gt; </b></p>
<p>The switches </p>
<p>XCP_ENABLE_CHECKSUM </p>
<p>and</p>
<p> XCP_ENABLE_CUSTOM_CRC </p>
<p>is defined </p>
<p> </p>
<p> </p>
<p><b>6.6 </b></p>
<p><b>XCP Protocol Layer Functions that can be overwritten </b></p>
<p>The following functions are defined within the XCP Protocol Layer and can be overwritten </p>
<p>for optimization purposes. </p>
<p>Note: All services within this chapter are called from task or interrupt level. All services are </p>
<p>not reentrant. </p>
<p> </p>
<p><b>6.6.1 </b></p>
<p><b>Xcp_MemCpy: Copying of a memory range </b></p>
<p><b>Xcp_MemCpy </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_MemCpy  </b>( DAQBYTEPTR dest,  </p>
<p>ROMDAQBYTEPTR src, uint8 n ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>dest </p>
<p>pointer to destination address </p>
<p>src </p>
<p>pointer to source address </p>
<p>n </p>
<p>number of data bytes to copy </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>72 / 94 </p>
<p><b>Functional Description </b></p>
<p>General memory copy function that copies a memory range from source to destination. </p>
<p>This function is used in the inner loop of </p>
<p>Xcp_Event</p>
<p> for data acquisition sampling. </p>
<p>This function is already defined in the XCP Protocol Layer, but can be overwritten by a macro or </p>
<p>function for optimization purposes. E.g. it would be possible to use DMA for faster execution. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly. </p>
<p><b>&gt; </b></p>
<p>This function can be overwritten </p>
<p>Xcp_MemCpy</p>
<p> is defined. </p>
<p> </p>
<p><b>6.6.2 </b></p>
<p><b>Xcp_MemSet: Initialization of a memory range </b></p>
<p><b>Xcp_MemSet </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>void <b>Xcp_MemSet  </b>( BYTEPTR p, uint16 n, uint8 b ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<p><b>Parameter </b></p>
<p>p </p>
<p>pointer to start address </p>
<p>n </p>
<p>number of data bytes </p>
<p>b </p>
<p>data byte to initialize with </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Initialization of </p>
<p>n</p>
<p> bytes starting from address </p>
<p>p</p>
<p> with </p>
<p>b</p>
<p>. </p>
<p>This function is already defined in the XCP Protocol Layer, but can be overwritten by a macro or </p>
<p>function for optimization purposes. E.g. it would be possible to use DMA for faster execution. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly. </p>
<p><b>&gt; </b></p>
<p>This function can be overwritten if </p>
<p>Xcp_MemSet</p>
<p> is defined. </p>
<p> </p>
<p><b>6.6.3 </b></p>
<p><b>Xcp_MemClr: Clear a memory range </b></p>
<p><b>Xcp_MemClr </b></p>
<p><b>Prototype </b></p>
<p>Single Channel </p>
<p>Single Receive Channel </p>
<p>static void <b>Xcp_MemClr  </b>( BYTEPTR p, uint16 n ) </p>
<p>Multi Channel </p>
<p>Indexed </p>
<p>not supported </p>
<p>Code replicated </p>
<p>not supported </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>73 / 94 </p>
<p><b>Parameter </b></p>
<p>p </p>
<p>pointer to start address </p>
<p>n </p>
<p>number of data bytes </p>
<p><b>Return code </b></p>
<p>- </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Initialize </p>
<p>n</p>
<p> data bytes starting from address </p>
<p>p</p>
<p> with </p>
<p>0x00</p>
<p>. </p>
<p>This function is already defined in the XCP Protocol Layer, but can be overwritten by a macro or </p>
<p>function for optimization purposes. E.g. it would be possible to use DMA for faster execution. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>The XCP Protocol Layer has been initialized correctly. </p>
<p><b>&gt; </b></p>
<p>This function can be overwritten if </p>
<p>Xcp_MemClr</p>
<p> is defined. </p>
<p> </p>
<p> </p>
<p><b>6.7 </b></p>
<p><b>AUTOSAR CRC Module Services called by the XCP Protocol Layer (XCP </b></p>
<p><b>Professional Only) </b></p>
<p>The  following  services  of  the  AUTOSAR  CRC  Module  are  called  by  the  XCP  Protocol </p>
<p>Layer: </p>
<p>Crc_CalculateCRC16(…) </p>
<p>Crc_CalculateCRC32(…) </p>
<p>A  detailed  description  of  the API  can  be  found  in  the  software  specification  of  the  CRC </p>
<p>Module [VII]. </p>
<p> </p>
<p><b>6.7.1.1 </b></p>
<p><b>Generated a2l files </b></p>
<p>The  GenTool  also  generates  multiple  a2l files  which  can  be  used  in  the  Master  tool  for </p>
<p>easier integration. The following files are generated: </p>
<p></p>
<p> </p>
<p>XCP.a2l (general protocol layer settings) </p>
<p></p>
<p> </p>
<p>XCP_daq.a2l (DAQ specific settings) </p>
<p></p>
<p> </p>
<p>XCP_events.a2l (DAQ event info) </p>
<p></p>
<p> </p>
<p>XCP_Checksum.a2l (Checksum information) </p>
<p> </p>
<p> </p>
<p><b>Example Master.a2l: </b></p>
<p><b> </b></p>
<p>... </p>
<p>/begin IF_DATA XCP </p>
<p>  /include XCP.a2l </p>
<p>  <b>/begin DAQ </b></p>
<p><b>    /include XCP_daq.a2l </b></p>
<p><b>    /include XCP_events.a2l </b></p>
<p><b>    /include XCP_checksum.a2l </b></p>
<p><b>    ... </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>74 / 94 </p>
<p><b>  /end DAQ </b></p>
<p>  /include CanXCPAsr.a2l </p>
<p>/end IF_DATA </p>
<p>... </p>
<p>/include bsw.a2l </p>
<p>...</p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>75 / 94 </p>
<p><b>6.8 </b></p>
<p><b>Configuration without Generation Tool </b></p>
<p>The </p>
<p>configuration </p>
<p>of </p>
<p>the </p>
<p>configuration </p>
<p>switches </p>
<p>and </p>
<p>constants </p>
<p>is </p>
<p>done </p>
<p>in </p>
<p>the </p>
<p>file </p>
<p>Xcp_Cfg.h</p>
<p>. </p>
<p><b>6.8.1 </b></p>
<p><b>Compiler Switches </b></p>
<p>Compiler switches are used to enable/disable optional functionalities in order to save code </p>
<p>space and RAM. </p>
<p>In  the  following  table  you  will  find  a  complete  list  of  all  configuration  switches,  used  to </p>
<p>control the functional units. The default values are bold. </p>
<p><b>Configuration switches </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>XCP_xxx_DAQ</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Enables/disables </p>
<p>synchronous data </p>
<p>acquisition. </p>
<p>XCP_xxx_DAQ_PRESCALER </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Enables/disables the </p>
<p>DAQ prescaler. </p>
<p>XCP_xxx_DAQ_OVERRUN_INDICATION </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Enables/disables the </p>
<p>DAQ overrun </p>
<p>detection. </p>
<p>XCP_xxx_DAQ_HDR_ODT_DAQ</p>
<p>2</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>The 2 Byte DAQ/ODT </p>
<p>XCP Packet </p>
<p>identification is used </p>
<p>instead of the PID. </p>
<p>Enabled: Relative </p>
<p>ODT number, </p>
<p>absolute list number </p>
<p>(BYTE) </p>
<p>Disabled: Absolute </p>
<p>ODT number </p>
<p>XCP_xxx_DAQ_PROCESSOR_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Plug &amp; play </p>
<p>mechanism for the </p>
<p>data acquisition </p>
<p>processor. </p>
<p>XCP_xxx_DAQ_RESOLUTION_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Plug &amp; play </p>
<p>mechanism for the </p>
<p>data acquisition </p>
<p>resolution. </p>
<p>XCP_xxx_DAQ_EVENT_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Plug &amp; play </p>
<p>mechanism for the </p>
<p>event definitions. </p>
<p>XCP_xxx_DAQ_TIMESTAMP </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>DAQ timestamps </p>
<p>                                            </p>
<p>2</p>
<p> The XCP Protocol allows three identification field types for DTOs: ‘absolute ODT number’, ‘relative ODT </p>
<p>number and absolute DAQ list number’, ‘empty identification field’ (not supported) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>76 / 94 </p>
<p>XCP_xxx_DAQ_TIMESTAMP_FIXED </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Slave always sends </p>
<p>DTO Packets in time </p>
<p>stamped mode. </p>
<p>Otherwise are </p>
<p>timestamps used </p>
<p>individual by each </p>
<p>DAQ-list. </p>
<p>kXcpDaqTimestampSize</p>
<p> </p>
<p>DAQ_TIMESTAMP_BYTE, </p>
<p>DAQ_TIMESTAMP_WORD, </p>
<p>DAQ_TIMESTAMP_DWORD</p>
<p> </p>
<p>The size of </p>
<p>timestamps which can </p>
<p>either be 1Byte, </p>
<p>2Bytes or 4Bytes. </p>
<p>XCP_xxx_SEED_KEY</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Seed &amp; key access </p>
<p>protection </p>
<p>XCP_xxx_CHECKSUM</p>
<p> </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Calculation of </p>
<p>checksum </p>
<p>XCP_xxx_CUSTOM_CRC </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable call-back for </p>
<p>custom CRC </p>
<p>calculation </p>
<p>XCP_xxx_CRC16CCITT_REFLECTED </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable/disable </p>
<p>reflected CRC16 </p>
<p>CCITT checksum </p>
<p>calculation algorithm. </p>
<p>Also refer to 6.8.2.1 </p>
<p>‘Table of Checksum </p>
<p>Calculation Methods’. </p>
<p>XCP_xxx_AUTOSAR_CRC_MODULE </p>
<p><b>ENABLE</b>, DISABLE </p>
<p>Usage of CRC </p>
<p>algorithms of </p>
<p>AUTOSAR CRC </p>
<p>module. </p>
<p>XCP_xxx_PARAMETER_CHECK </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Parameter check </p>
<p>XCP_xxx_SEND_QUEUE </p>
<p><b>ENABLE</b>, DISABLE </p>
<p>Transmission send </p>
<p>queue  </p>
<p>(shall be used in </p>
<p>conjunction with </p>
<p>synchronous data </p>
<p>acquisition and </p>
<p>stimulation). </p>
<p>XCP_xxx_SEND_EVENT </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Transmission of event </p>
<p>packets (EV) </p>
<p>XCP_xxx_USER_COMMAND </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>User defined </p>
<p>command </p>
<p>XCP_xxx_GET_ID_GENERIC </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>ECU identification </p>
<p>XCP_xxx_TL_COMMAND </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Transport Layer </p>
<p>command </p>
<p>XCP_xxx_COMM_MODE_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Communication mode </p>
<p>info </p>
<p>XCP_xxx_CALIBRATION_PAGE </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Calibration data page </p>
<p>switching </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>77 / 94 </p>
<p>XCP_xxx_PAGE_INFO </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Calibration data page </p>
<p>plug &amp; play </p>
<p>mechanism </p>
<p>XCP_xxx_PAGE_COPY </p>
<p>ENABLE, <b>DISABLE</b></p>
<p> </p>
<p>Calibration data page </p>
<p>copying </p>
<p>XCP_xxx_PAGE_FREEZE </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Segment freeze mode </p>
<p>handling  </p>
<p>XCP_xxx_DPRAM</p>
<p>3</p>
<p> </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Supports the usage of </p>
<p>dual port RAM </p>
<p>XCP_xxx_BLOCK_UPLOAD </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enables/disables the </p>
<p>slave block transfer. </p>
<p>XCP_xxx_BLOCK_DOWNLOAD </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enables/disables the </p>
<p>master block transfer. </p>
<p>XCP_xxx_WRITE_PROTECTION </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Write access to RAM </p>
<p>XCP_xxx_READ_PROTECTION </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Read access to RAM </p>
<p>XCP_xxx_READ_EEPROM </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Read access to </p>
<p>EEPROM </p>
<p>XCP_xxx_WRITE_EEPROM </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Write access to </p>
<p>EEPROM </p>
<p>XCP_xxx_PROGRAMMING_WRITE_PROTECTION </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Write access to flash </p>
<p>XCP_xxx_PROGRAM </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Flash programming </p>
<p>XCP_xxx_PROGRAM_INFO </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Flash programming </p>
<p>plug &amp; play </p>
<p>mechanism </p>
<p>XCP_xxx_BOOTLOADER_DOWNLOAD </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Flash programming </p>
<p>with a flash kernel </p>
<p>XCP_xxx_STIM </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enables/disables data </p>
<p>stimulation. </p>
<p>(also </p>
<p>XCP_ENABLE_DAQ</p>
<p> </p>
<p>has to be defined in </p>
<p>order to use data </p>
<p>stimulation) </p>
<p>XCP_xxx_DAQ_RESUME </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Data acquisition </p>
<p>resume mode. </p>
<p>XCP_xxx_SERV_TEXT </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Transmission of </p>
<p>service request codes </p>
<p>XCP_xxx_SERV_TEXT_PUTCHAR </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Putchar function for </p>
<p>the transmission of </p>
<p>service request </p>
<p>messages </p>
<p>XCP_xxx_SERV_TEXT_PRINTF </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Print function for the </p>
<p>transmission of </p>
<p>service request </p>
<p>messages </p>
<p>                                            </p>
<p>3</p>
<p> Not supported by XCP Professional </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>78 / 94 </p>
<p>XCP_</p>
<p>xxx</p>
<p>_MEM_ACCESS_BY_APPL</p>
<p> </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Memory access by </p>
<p>application </p>
<p>XCP_xxx_MODEL_PAGED </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Support for paging / </p>
<p>banking </p>
<p>XCP_xxx_SHORT_DOWNLOAD </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Support for </p>
<p>SHORT_DOWNLOAD </p>
<p>command </p>
<p>XCP_xxx_MODIFY_BITS </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Support for </p>
<p>MODIFY_BITS </p>
<p>command </p>
<p>XCP_xxx_WRITE_DAQ_MULTIPLE</p>
<p> </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Write DAQ multiple </p>
<p>command </p>
<p>XCP_xxx_GET_XCP_DATA_POINTER</p>
<p> </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable API for </p>
<p>internal data access </p>
<p>XCP_xxx_CONTROL </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable functionality to </p>
<p>en- / disable XCP </p>
<p>module </p>
<p>XCP_xxx_DEV_ERROR_DETECT </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable Development </p>
<p>Error check </p>
<p>XCP_xxx_READCCCONFIG </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable Read of </p>
<p>FlexRay Parameters </p>
<p>XCP_ADDR_EXT_READCCCONFIG </p>
<p>0x00…0xff </p>
<p>Address  Extension to </p>
<p>be used for FlexRay </p>
<p>Parameters </p>
<p>XCP_xxx_VECTOR_GENERICMEASUREMENT </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Support for Generic </p>
<p>Measurement feature </p>
<p>XCP_xxx_GET_SESSION_STATUS_API </p>
<p>ENABLE, <b>DISABLE </b></p>
<p>Enable API to acquire </p>
<p>the current session </p>
<p>status </p>
<p> </p>
<p> </p>
<p><b>6.8.2 </b></p>
<p><b>Configuration of Constant Definitions </b></p>
<p>The configuration of constant definitions is done as described below.  </p>
<p>The default values are bold. </p>
<p><b>Constant definitions </b></p>
<p><b>Range </b></p>
<p><b>Default </b></p>
<p><b>Description </b></p>
<p>kXcpMaxCTOMax</p>
<p> </p>
<p>8..255 </p>
<p><b>8 </b></p>
<p>Maximum length of XCP command transfer </p>
<p>objects (CTO). </p>
<p>The length of the CTO can be variable. </p>
<p>However it has to be configured according to the </p>
<p>used XCP Transport Layer. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>79 / 94 </p>
<p>kXcpMaxDTOMax</p>
<p> </p>
<p>8..255</p>
<p>4</p>
<p> </p>
<p><b>8 </b></p>
<p>Maximum length of XCP data transfer objects </p>
<p>(DTO). </p>
<p>The length of the DTO can be variable. </p>
<p>However it has to be configured according to the </p>
<p>used XCP Transport Layer. </p>
<p>kXcpDaqMemSize </p>
<p>0.. </p>
<p>0xFFFF </p>
<p><b>256 </b></p>
<p>Define the amount of memory used for the DAQ </p>
<p>lists and buffers. </p>
<p>Also refer to chapter 7 (Resource </p>
<p>Requirements). </p>
<p>kXcpSendQueueMinSize </p>
<p>1..0x7F </p>
<p><b>- </b></p>
<p>The minimum queue size required for DAQ. The </p>
<p>queue size is the unallocated memory reserved </p>
<p>by </p>
<p>kXcpDaqMemSize</p>
<p>. </p>
<p>kXcpMaxEvent </p>
<p>0..0xFF</p>
<p>5</p>
<p> </p>
<p><b>- </b></p>
<p>Number of available events in the slave (part of </p>
<p>event channel plug &amp; play mechanism) </p>
<p>Also refer to chapter 6.8.5. </p>
<p>kXcpStimOdtCount </p>
<p>0..0xC0 </p>
<p><b>0xC0 </b></p>
<p>Maximum number of ODTs that may be used for </p>
<p>Synchronous Data Stimulation. </p>
<p>kXcpChecksumMethod </p>
<p>- </p>
<p><b>- </b></p>
<p>Checksum calculation method. </p>
<p>Refer to chapter 6.8.2.1 ‘Table of Checksum </p>
<p>Calculation Methods’ for valid values. </p>
<p>kXcpChecksumBlockSize </p>
<p>1 .. </p>
<p>0xFFFF </p>
<p><b>256 </b></p>
<p>Each call of </p>
<p>Xcp_MainFunction</p>
<p> calculates the </p>
<p>checksum on the amount of bytes specified by </p>
<p>kXcpChecksumBlockSize</p>
<p>. </p>
<p>XCP_TRANSPORT_LAYER_V</p>
<p>ERSION </p>
<p>0.. </p>
<p>0xFFFF </p>
<p><b>- </b></p>
<p>Version of the XCP Transport Layer that is used. </p>
<p>(this version gets transferred to the MCS) </p>
<p>kXcpMaxSector </p>
<p>1..0xFF </p>
<p><b>- </b></p>
<p>Number of flash sectors </p>
<p>Also refer to chapter 6.8.7 </p>
<p>kXcpMaxSegment </p>
<p>1 </p>
<p><b>1 </b></p>
<p>Number of memory segments </p>
<p>Also refer to chapter 6.8.8. </p>
<p>kXcpMaxPages </p>
<p>1..2 </p>
<p><b>2 </b></p>
<p>Number of pages </p>
<p>Also refer to chapter 6.8.8. </p>
<p>NUMBER_OF_TRANSPORTLA</p>
<p>YERS </p>
<p>1.. </p>
<p><b>1 </b></p>
<p>Number of used Transport Layers </p>
<p>XCP_TRANSPORT_LAYER_C</p>
<p>AN </p>
<p>0.. </p>
<p><b>0 </b></p>
<p>Index of Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_F</p>
<p>R </p>
<p>0.. </p>
<p><b>1 </b></p>
<p>Index of Transport Layer </p>
<p>XCP_TRANSPORT_LAYER_E</p>
<p>TH </p>
<p>0.. </p>
<p><b>2 </b></p>
<p>Index of Transport Layer </p>
<p> </p>
<p><b>6.8.2.1 </b></p>
<p><b>Table of Checksum Calculation Methods </b></p>
<p><b>Constant </b></p>
<p><b>Checksum calculation method </b></p>
<p>XCP_CHECKSUM_TYPE_ADD11 </p>
<p>Add BYTE into a BYTE checksum, ignore overflows. </p>
<p>XCP_CHECKSUM_TYPE_ADD12 </p>
<p>Add BYTE into a WORD checksum, ignore overflows </p>
<p>                                            </p>
<p>4</p>
<p> Implementation specific range. The range is 8..0xFFFF according to XCP specification [I], [II]. </p>
<p>5</p>
<p> Implementation specific range. The range is 0..0xFFFE according to XCP specification [I], [II]. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>80 / 94 </p>
<p>XCP_CHECKSUM_TYPE_ADD14 </p>
<p>Add BYTE into a DWORD checksum, ignore overflows </p>
<p>XCP_CHECKSUM_TYPE_ADD22 </p>
<p>Add WORD into a WORD checksum, ignore overflows, block </p>
<p>size must be modulo 2 </p>
<p>XCP_CHECKSUM_TYPE_ADD24 </p>
<p>Add WORD into a DWORD checksum, ignore overflows, </p>
<p>block size must be modulo 2 </p>
<p>XCP_CHECKSUM_TYPE_ADD44 </p>
<p>Add DWORD into DWORD, ignore overflows, block size </p>
<p>must be modulo 4 </p>
<p>XCP_CHECKSUM_TYPE_CRC16CCITT </p>
<p>CRC16 CCITT checksum calculation algorithm </p>
<p>Both the standard and the reflected algorithm are supported. </p>
<p>Please refer to chapter 9.6 ‘Reflected CRC16 CCITT </p>
<p>Checksum Calculation Algorithm’. </p>
<p>The CRC16 CCITT algorithm of the AUTOSAR CRC module </p>
<p>is only supported by XCP Professional. </p>
<p>XCP_CHECKSUM_TYPE_CRC32 </p>
<p>CRC32 checksum calculation algorithm </p>
<p>The CRC32 algorithm is only supported in XCP Professional </p>
<p>if the AUTOSAR CRC module is used. </p>
<p> </p>
<p><b>6.8.3 </b></p>
<p><b>Configuration of the CPU Type  </b></p>
<p>To provide platform independent code platform, the CPU type has to be defined. </p>
<p><b>Configuration switches </b></p>
<p><b>Value </b></p>
<p><b>Description </b></p>
<p>C_CPUTYPE_xxxENDIAN </p>
<p>LITTLE, </p>
<p><b>BIG</b></p>
<p> </p>
<p>Definition whether the CPU is little endian (Intel </p>
<p>format) or big endian (Motorola format). </p>
<p>XCP_xxx_UNALIGNED_MEM_ACCESS </p>
<p>ENABLE, </p>
<p>DISABLE</p>
<p> </p>
<p>Enables / disables unaligned memory access. </p>
<p>If </p>
<p>XCP_DISBLE_UNALIGNED_MEM_ACCESS </p>
<p>is </p>
<p>defined WORDs are located on WORD aligned and </p>
<p>DWORD are located on DWORD aligned addresses. </p>
<p> </p>
<p><b>6.8.4 </b></p>
<p><b>Configuration of Slave Device Identification </b></p>
<p>The configuration of the slave device identification and automatic session configuration is </p>
<p>described within this chapter. Only one of the following options can be used at one time. </p>
<p><b>6.8.4.1 </b></p>
<p><b>Identification by ASAM-MC2 Filename without Path and Extension </b></p>
<p>If  the  slave  device  identification  is  done  by  identification  with  an  ASAM-MC2  filename </p>
<p>without path and extension the filename length has to be defined: </p>
<p>#define kXcpStationIdLength <i>length </i></p>
<p>and the station ID itself has to be defined as string: </p>
<p>const uint8 kXcpStationId[] = “<i>station ID</i>” </p>
<p>The range of </p>
<p>kXcpStationIdLength</p>
<p> is </p>
<p>0..0xFF</p>
<p>. </p>
<p><b>6.8.4.2 </b></p>
<p><b>Automatic Session Configuration with MAP Filenames </b></p>
<p>The  automatic  session  configuration  by  transferring  MAP  filenames  is  a  Vector  specific </p>
<p>extension that works with CANape and can be enabled by the “XcpGetIdGeneric” attribute.</p>
<p> </p>
<p>When this feature is enabled the API as described in  3.4.2 XCP Generic Identification is </p>
<p>enabled. This API will be called, should CANape request the MAP filename, and must be </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>81 / 94 </p>
<p>implemented by the user accordingly. This feature must explicitly be enabled in CANape </p>
<p>as well! </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p> </p>
<p> </p>
<p>#define MAP_FORMAT 29  </p>
<p>#define MAP_NAME   &quot;xcpsim&quot;  </p>
<p>  </p>
<p>uint8 MapTest[500];  </p>
<p>uint32 MapTestSize;  </p>
<p>  </p>
<p>uint32 XcpAppl_GetIdData( MTABYTEPTR *pData, uint8 id )  </p>
<p>{  </p>
<p>  if( id == IDT_VECTOR_MAPNAMES ) </p>
<p>  { </p>
<p>    MapTestSize = </p>
<p>sprintf((char*)MapTest,&quot;%c%c%s.map&quot;,MAP_FORMAT,0,MAP_NAME);  </p>
<p>    /* Result: MapTest = ”290xcpsim.map” */ </p>
<p>    *pData = MapTest;  </p>
<p>    return MapTestSize;  </p>
<p>  } </p>
<p>  else </p>
<p>  { </p>
<p>    return 0; /* Id not available */ </p>
<p>  } </p>
<p>}  </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>‘MAP_FORMAT’ represents the format of the MAP file. (See table below) </p>
<p>‘0’ is a counter that is used as address extension. Please set this parameter to 0. </p>
<p>Table of MAP file formats: </p>
<p>  1 = &quot;BorlandC 16 Bit&quot;             29 = &quot;Microsoft standard&quot;  </p>
<p>  2 = &quot;M166&quot;                        30 = &quot;ELF/DWARF 16 Bit&quot;  </p>
<p>  3 = &quot;Watcom&quot;                      31 = &quot;ELF/DWARF 32 Bit&quot;  </p>
<p>  4 = &quot;HiTech HC05&quot;                 32 = &quot;Fujitsu Softune 3..8(.mps)&quot;  </p>
<p>  6 = &quot;IEEE&quot;                        33 = &quot;Microware Hawk&quot;  </p>
<p>  7 = &quot;Cosmic&quot;                      34 = &quot;TI C6711&quot;  </p>
<p>  8 = &quot;SDS&quot;                         35 = &quot;Hitachi H8S&quot;  </p>
<p>  9 = &quot;Fujitsu Softune 1(.mp1)&quot;     36 = &quot;IAR HC12&quot;  </p>
<p>  10 = &quot;GNU&quot;                        37 = &quot;Greenhill Multi 2000&quot;  </p>
<p>  11 = &quot;Keil 16x&quot;                   38 = &quot;LN308(MITSUBISHI) for M16C/80&quot;  </p>
<p>  12 = &quot;BorlandC 32 Bit&quot;            39 = &quot;COFF settings auto detected&quot;  </p>
<p>  13 = &quot;Keil 16x (static)&quot;          40 = &quot;NEC CC78K/0 v35&quot;  </p>
<p>  14 = &quot;Keil 8051&quot;                  41 = &quot;Microsoft extended&quot;  </p>
<p>  15 = &quot;ISI&quot;                        42 = &quot;ICCAVR&quot;  </p>
<p>  16 = &quot;Hiware HC12&quot;                43 = &quot;Omf96 (.m96)&quot;  </p>
<p>  17 = &quot;TI TMS470&quot;                  44 = &quot;COFF/DWARF&quot;  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>82 / 94 </p>
<p>  18 = &quot;Archimedes&quot;                 45 = &quot;OMF96 Binary (Tasking C196)&quot;  </p>
<p>  19 = &quot;COFF&quot;                       46 = &quot;OMF166 Binary (Keil C166)&quot;  </p>
<p>  20 = &quot;IAR&quot;                        47 = &quot;Microware Hawk Plug&amp;Play ASCII&quot;  </p>
<p>  21 = &quot;VisualDSP&quot;                  48 = &quot;UBROF Binary (IAR)&quot;  </p>
<p>  22 = &quot;GNU 16x&quot;                    49 = &quot;Renesas M32R/M32192 ASCII&quot;  </p>
<p>  23 = &quot;GNU VxWorks&quot;                50 = &quot;OMF251 Binary (Keil C251)&quot;  </p>
<p>  24 = &quot;GNU 68k&quot;                    51 = &quot;Microsoft standard VC8&quot;  </p>
<p>  25 = &quot;DiabData&quot;                   52 = &quot;Microsoft VC8 Release Build (MATLAB DLL)&quot;  </p>
<p>  26 = &quot;VisualDSP DOS&quot;              53 = &quot;Microsoft VC8 Debug Build (MATLAB DLL)&quot;  </p>
<p>  27 = &quot;HEW SH7055&quot;                 54 = &quot;Microsoft VC8 Debug file (pdb)&quot;  </p>
<p>  28 = &quot;Metrowerks&quot; </p>
<p> </p>
<p><b>6.8.5 </b></p>
<p><b>Configuration of the Event Channel Plug &amp; Play Mechanism </b></p>
<p>The event channel plug &amp; play mechanism is enabled with the switch </p>
<p>XCP_ENABLE_DAQ_EVENT_INFO</p>
<p> </p>
<p>A prerequisite for the event channel plug &amp; play mechanism is the general data acquisition </p>
<p>plug  &amp;  play  mechanism.  If  the  mechanism  is  enabled  the  following  configurations  items </p>
<p>have to be defined as described below: </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>kXcpMaxEvent </p>
<p>0..0xFF</p>
<p>6</p>
<p> </p>
<p>Number of available events in the slave </p>
<p>(part of event channel plug &amp; play mechanism) </p>
<p>If the event numbers do not start at 0 or are not </p>
<p>continuous this is the maximum used event channel </p>
<p>number plus 1. </p>
<p>kXcpEventName[] </p>
<p>kXcpMaxEvent </p>
<p>List with pointers to the event channel names that are </p>
<p>defined as strings. </p>
<p>kXcpEventNameLength[]  kXcpMaxEvent </p>
<p>Length of the event channel names without the </p>
<p>terminating char. </p>
<p>kXcpEventCycle[] </p>
<p>kXcpMaxEvent</p>
<p> </p>
<p>Cycle time of the event channels in milliseconds. </p>
<p>kXcpEventDirection[] </p>
<p>kXcpMaxEvent</p>
<p> </p>
<p>Direction of the event channels. </p>
<p>For XCP Basic valid values are: </p>
<p>-</p>
<p> </p>
<p>kXcpEventDirectionDaq </p>
<p>For XCP Professional valid values are: </p>
<p>-</p>
<p> </p>
<p>kXcpEventDirectionDaq </p>
<p>-</p>
<p> </p>
<p>kXcpEventDirectionStim</p>
<p> </p>
<p> </p>
<p>- </p>
<p>kXcpEventDirectionDaqStim</p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Example </b></p>
<p> </p>
<p>#define XCP_ENABLE_DAQ_EVENT_INFO </p>
<p>#define kXcpMaxEvent 3 </p>
<p> </p>
<p>CONST(uint8, XCP_CONST) kXcpEventName_0[] = &quot;10ms&quot;; </p>
<p>                                            </p>
<p>6</p>
<p> Implementation specific range. The range is 0..0xFFFE according to XCP specification [I], [II]. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>83 / 94 </p>
<p>CONST(uint8, XCP_CONST) kXcpEventName_1[] = &quot;100ms DAQ&quot;; </p>
<p>CONST(uint8, XCP_CONST) kXcpEventName_2[] = &quot;100ms STIM&quot;; </p>
<p>CONSTP2CONST(uint8, XCP_CONST, XCP_CONST) kXcpEventName[] =  </p>
<p>{ </p>
<p>  &amp;kXcpEventName_0[0], </p>
<p>  &amp;kXcpEventName_1[0], </p>
<p>  &amp;kXcpEventName_2[0] </p>
<p>}; </p>
<p> </p>
<p>CONST(uint8, XCP_CONST) kXcpEventNameLength[] = </p>
<p>{ </p>
<p>  4, </p>
<p>  9, </p>
<p>  10 </p>
<p>}; </p>
<p> </p>
<p>CONST(uint8, XCP_CONST) kXcpEventCycle[] =  </p>
<p>{ </p>
<p>  10, </p>
<p>  100, </p>
<p>  100 </p>
<p>}; </p>
<p> </p>
<p>CONST(uint8, XCP_CONST) kXcpEventDirection[] =  </p>
<p>{ </p>
<p>  kXcpEventDirectionDaq,  </p>
<p>  kXcpEventDirectionDaq,  </p>
<p>  kXcpEventDirectionStim </p>
<p>}; </p>
<p> </p>
<p> </p>
<p><b>6.8.6 </b></p>
<p><b>Configuration of the DAQ Time Stamped Mode </b></p>
<p>Transmission  of  DAQ  timestamps  is  enabled  with </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP</p>
<p>.  If </p>
<p>XCP_ENABLE_DAQ_TIMESTAMP_FIXED</p>
<p> is defined all DTO Packets will be transmitted in </p>
<p>time stamped mode.  </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>kXcpDaqTimestampSize </p>
<p>DAQ_TIMESTAMP_BYTE, </p>
<p>DAQ_TIMESTAMP_WORD, </p>
<p>DAQ_TIMESTAMP_DWORD </p>
<p>This parameter defines the </p>
<p>size of timestamps. It can </p>
<p>either be 1 byte, 2 bytes or 4 </p>
<p>bytes. </p>
<p>XcpDaqTimestampType </p>
<p>uint8, uint16 or uint32 </p>
<p>Type of the timestamp </p>
<p>depends on the parameter </p>
<p> </p>
<p>kXcpDaqTimestampSize.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>84 / 94 </p>
<p>kXcpDaqTimestampUnit </p>
<p>DAQ_TIMESTAMP_UNIT_1NS </p>
<p>DAQ_TIMESTAMP_UNIT_10NS </p>
<p>DAQ_TIMESTAMP_UNIT_100NS </p>
<p>DAQ_TIMESTAMP_UNIT_1US </p>
<p>DAQ_TIMESTAMP_UNIT_10US </p>
<p>DAQ_TIMESTAMP_UNIT_100US </p>
<p>DAQ_TIMESTAMP_UNIT_1MS </p>
<p>DAQ_TIMESTAMP_UNIT_10MS </p>
<p>DAQ_TIMESTAMP_UNIT_100MS </p>
<p>DAQ_TIMESTAMP_UNIT_1S </p>
<p>DAQ_TIMESTAMP_UNIT_1pS </p>
<p>DAQ_TIMESTAMP_UNIT_10pS </p>
<p>DAQ_TIMESTAMP_UNIT_100pS </p>
<p>Unit of the timestamp </p>
<p>(1 ns, 10 ns .. 1 s) </p>
<p> </p>
<p> </p>
<p> </p>
<p>kXcpDaqTimestampTicksPerUnit  0..0xFFFF </p>
<p>Time stamp ticks per unit </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>6.8.7 </b></p>
<p><b>Configuration of the Flash Programming Plug &amp; Play Mechanism </b></p>
<p>The flash programming plug &amp; play mechanism is enabled with the switch </p>
<p>XCP_ENABLE_PROGRAM_INFO</p>
<p> </p>
<p>If the plug &amp; play mechanism is enabled the number of sectors and the start address and </p>
<p>end address of each sector has to be defined. The constants that have to be defined can </p>
<p>be found in the following table. </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>kXcpMaxSector </p>
<p>0..0xFF </p>
<p>Number of available flash sectors in the slave </p>
<p>kXcpSectorName[] </p>
<p>kXcpMaxSector </p>
<p>List with pointers to the Sector names that are </p>
<p>defined as strings. </p>
<p>kXcpSectorNameLength </p>
<p>kXcpMaxSector </p>
<p>Length of the Sector names without the terminating </p>
<p>char. </p>
<p>kXcpProgramSectorStart[] kXcpMaxSector </p>
<p>List with the start addresses of the sectors </p>
<p>kXcpProgramSectorEnd[] </p>
<p>kXcpMaxSector </p>
<p>List with the end address of the sectors </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Example </b></p>
<p><b> </b></p>
<p>#define XCP_ENABLE_PROGRAM_INFO </p>
<p>#define kXcpMaxSector 2 </p>
<p> </p>
<p>CONST(XcpCharType, XCP_CONST) kXcpSectorName_0[] = &quot;Sector0&quot;; </p>
<p>CONST(XcpCharType, XCP_CONST) kXcpSectorName_1[] = &quot;Sector1&quot;; </p>
<p> </p>
<p>CONSTP2CONST(XcpCharType, XCP_CONST, XCP_CONST) kXcpSectorName[] =  </p>
<p>{ </p>
<p>  &amp;kXcpSectorName_0[0], </p>
<p>  &amp;kXcpSectorName_1[0] </p>
<p>}; </p>
<p>CONST(uint8, XCP_CONST) kXcpSectorNameLength[] =  </p>
<p>{ </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>85 / 94 </p>
<p>  7U, </p>
<p>  7U </p>
<p>}; </p>
<p>CONST(uint32, XCP_CONST) kXcpProgramSectorStart [] =  </p>
<p>{ </p>
<p>  (uint32)0x000000u,  </p>
<p>  (uint32)0x010000u,  </p>
<p>}; </p>
<p>CONST(uint32, XCP_CONST) kXcpProgramSectorEnd [] =  </p>
<p>{ </p>
<p>  (uint32)0x00FFFFu,  </p>
<p>  (uint32)0x01FFFFu,  </p>
<p>}; </p>
<p> </p>
<p> </p>
<p><b>6.8.8 </b></p>
<p><b>Configuration of the Page Switching Plug &amp; Play Mechanism </b></p>
<p>The page switching plug &amp; play mechanism is enabled with the switch </p>
<p>XCP_ENABLE_PAGE_INFO</p>
<p> </p>
<p>If  the  plug  &amp;  play  mechanism  is  enabled  the  following  configurations  items  have  to  be </p>
<p>defined as described below: </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>kXcpMaxSegment </p>
<p>0x01 </p>
<p>Number of memory segments </p>
<p>kXcpMaxPages </p>
<p> </p>
<p>0x01..0x02 </p>
<p>Number of pages </p>
<p> </p>
<p><b>6.8.9 </b></p>
<p><b>Configuration of the used Transport Layer </b></p>
<p>The XCP Protocol Layer uses a jump table to call respective Transport Layer Functions. </p>
<p>This jump table has to contain certain Function names </p>
<p><b>Constant </b></p>
<p><b>Range </b></p>
<p><b>Description </b></p>
<p>Xcp_TlApi </p>
<p>Number of TL </p>
<p>Function Pointer table containing pointers to the </p>
<p>respective Transport Layer </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Example </b></p>
<p><b> </b></p>
<p>#define NUMBER_OF_TRANSPORTLAYERS            1 </p>
<p>#define XCP_TRANSPORT_LAYER_CAN              0u </p>
<p> </p>
<p>CONST(Xcp_TlApiType, XCP_CONST) </p>
<p>Xcp_TlApi[NUMBER_OF_TRANSPORTLAYERS] = </p>
<p>{ </p>
<p>  { </p>
<p>    CanXcp_Send, /* ApplXcpSend */ </p>
<p>    CanXcp_SendFlush /* ApplXcpSendFlush */ </p>
<p>    #if defined ( XCP_ENABLE_TL_COMMAND ) </p>
<p>    , </p>
<p>    CanXcp_TLService /* ApplXcpTLService */ </p>
<p>    #endif </p>
<p>  } </p>
<p>}; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>86 / 94 </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>87 / 94 </p>
<p><b>7 </b></p>
<p><b>Resource Requirements </b></p>
<p>The  resource  requirements  of  the  XCP  Protocol  Layer  mainly  depend  on  the  micro </p>
<p>controller,  compiler  options  and  configuration.  Within  this  chapter  only  the  configuration </p>
<p>specific resource requirements are taken in consideration. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>88 / 94 </p>
<p><b>8 </b></p>
<p><b>Limitations </b></p>
<p><b>8.1 </b></p>
<p><b>General Limitations </b></p>
<p>The functional limitations of the XCP Professional Version are listed below: </p>
<p><b>&gt; </b></p>
<p>Bit stimulation is not supported </p>
<p><b>&gt; </b></p>
<p>Only dynamic DAQ list allocation supported </p>
<p><b>&gt; </b></p>
<p>The interleaved communication model is not supported </p>
<p><b>&gt; </b></p>
<p>Only default programming data format is supported </p>
<p><b>&gt; </b></p>
<p>GET_SECTOR_INFO does not return sequence numbers </p>
<p><b>&gt; </b></p>
<p>Program Verify and Program Format are not supported </p>
<p><b>&gt; </b></p>
<p>DAQ numbers are limited to byte size </p>
<p><b>&gt; </b></p>
<p>DAQ does not support address extension </p>
<p><b>&gt; </b></p>
<p>DAQ-list and event channel prioritization is not supported </p>
<p><b>&gt; </b></p>
<p>Event channels contain one DAQ-list </p>
<p><b>&gt; </b></p>
<p>ODT optimization not supported </p>
<p><b>&gt; </b></p>
<p>Assignments of CAN identifiers to DAQ lists is not supported </p>
<p><b>&gt; </b></p>
<p>MAX_DTO is limited to 0xFF </p>
<p><b>&gt; </b></p>
<p>The resume bits in DAQ lists are not set </p>
<p><b>&gt; </b></p>
<p>STORE_DAQ, CLEAR_DAQ and STORE_CAL do not send an event message </p>
<p><b>&gt; </b></p>
<p>Entering resume mode does not send an event message </p>
<p><b>&gt; </b></p>
<p>Overload indication by an event is not supported </p>
<p><b>&gt; </b></p>
<p>SERV_RESET is not supported </p>
<p><b>&gt; </b></p>
<p>The following checksum types are not supported </p>
<p><b>&gt; </b></p>
<p>XCP_CRC_16 </p>
<p><b>&gt; </b></p>
<p>XCP_CRC_32 </p>
<p><b>&gt; </b></p>
<p>XCP_USER_DEFINED </p>
<p><b>&gt; </b></p>
<p>Maximum checksum block size is 0xFFFF </p>
<p><b>&gt; </b></p>
<p>Page Info and Segment Info is not supported </p>
<p><b>&gt; </b></p>
<p>Only one segment and two pages are supported </p>
<p><b>&gt; </b></p>
<p>The seed size and key size must be equal or less MAX_CTO-2 </p>
<p><b>&gt; </b></p>
<p>Consistency only supported on ODT level </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>89 / 94 </p>
<p>Planned: </p>
<p><b>&gt; </b></p>
<p>User defined checksum calculations </p>
<p><b>&gt; </b></p>
<p>CRC16 and CRC32 </p>
<p><b>&gt; </b></p>
<p>The AUTOSAR API Xcp_SetTransmissionMode is not supported </p>
<p> </p>
<p><b>8.2 </b></p>
<p><b>Limitations Regarding Platforms, Compilers and Memory Models </b></p>
<p>Even </p>
<p>though </p>
<p>the </p>
<p>XCP </p>
<p>is </p>
<p>a </p>
<p>Protocol </p>
<p>Layer </p>
<p>and </p>
<p>therefore </p>
<p>higher </p>
<p>software </p>
<p>layer, </p>
<p>it </p>
<p>manipulates memory addresses and directly access the memory with these addresses. </p>
<p>This  might  cause  issues  for  some  combinations  of  platforms,  compilers  and  memory </p>
<p>models.  The  following  list  provides  all  known  restrictions  on  platforms,  compilers  and </p>
<p>linkers: </p>
<p><b>&gt; </b></p>
<p>CANoeOSEK Emulation is not supported </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>90 / 94 </p>
<p><b>9 </b></p>
<p><b>FAQ </b></p>
<p><b>9.1 </b></p>
<p><b>Invalid Time Stamp Unit </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>If using data acquisition CANape reports an error due to an invalid timestamp </p>
<p>unit. </p>
<p> </p>
<p>If you are using CANape 5.5.x or an earlier version please define </p>
<p>#define XCP_ENABLE_CANAPE_5_5_X_SUPPORT </p>
<p>in your user config file. </p>
<p><b>9.2 </b></p>
<p><b>Support of small and medium memory model </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How is the XCP Protocol Layer configured in order to access the whole memory </p>
<p>in the small and medium memory model? </p>
<p> </p>
<p>By  default The  XCP  Protocol  Layer  accesses  the  memory  with  a  default  pointer.  I.e.  in </p>
<p>small and medium memory model a near pointer is used. If the far memory (e.g. code or </p>
<p>read-only  sections)  needs  to  be  accessed  via  the  XCP  Protocol  the  memory  qualifiers </p>
<p>have to be defined as far pointers by the user within the user config file.   </p>
<p>Two memory qualifiers are used to access the memory: </p>
<p>MTABYTEPTR </p>
<p>#define MTABYTEPTR P2VAR(uint8, AUTOMATIC, XCP_MTA_DATA) </p>
<p>This pointer is used to access memory for standard read and </p>
<p>write operations </p>
<p>DAQBYTEPTR </p>
<p>#define DAQBYTEPTR P2VAR(uint8, AUTOMATIC, XCP_DAQ_DATA) </p>
<p>This pointer is used to access memory for the Synchronous Data </p>
<p>Acquisition </p>
<p>Depending </p>
<p>on </p>
<p>the </p>
<p>use </p>
<p>case, </p>
<p>microcontroller, </p>
<p>memory </p>
<p>model </p>
<p>and </p>
<p>compiler </p>
<p>either </p>
<p>XCP_MEMORY_FAR</p>
<p> or both memory qualifiers (</p>
<p>DAQBYTEPTR </p>
<p>and </p>
<p>MTABYTEPTR</p>
<p>) have to </p>
<p>be defined by the user. Alternatively the AUTOSAR Compiler Abstraction can be used. In </p>
<p>this case the pointer classes </p>
<p>XCP_MTA_DATA and </p>
<p>XCP_DAQ_DATA </p>
<p>Have to be defined as “far” according to the used compiler. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>91 / 94 </p>
<p><b>9.3 </b></p>
<p><b>Small memory model on ST10 / XC16X / C16X with Tasking Compiler </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How has XCP Protocol Layer to be configured in order to support small memory </p>
<p>model on the following microcontrollers: </p>
<p>ST10, XC16X, C16X with Tasking </p>
<p>Compiler</p>
<p>? </p>
<p> </p>
<p>If the small memory model is used and the two least significant bits of the DPP register </p>
<p>where the data of XCP is located is not equal the default DPP register value (i.e. the two </p>
<p>least significant bits of DPPx are unequal x, x=0..3) the configuration of the XCP Protocol </p>
<p>Layer has to be adapted in the user config file  </p>
<p>Disable type casts from pointers to integers : </p>
<p>#define XCP_ENABLE_NO_P2INT_CAST </p>
<p><b>9.4 </b></p>
<p><b>Data Page Banking on Star12X / Metrowerks </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How has the XCP Protocol Layer to be configured in order to support data page </p>
<p>banking on the Star12X with Metrowerks compiler? </p>
<p> </p>
<p>In  order  to  use  data  page  banking  the  following  definition  has  to  be  added  to  the  user </p>
<p>config file: </p>
<p>#define XCP_MEMORY_MODEL_PAGED </p>
<p>If this option is enabled far pointers are used for memory access, and address conversions </p>
<p>are carried out in the in the application callback template </p>
<p>_xcp_appl.c</p>
<p>. These address </p>
<p>conversions have to adapted to the used derivative. </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>The data page banking support is implemented in the template </p>
<p>_xcp_appl.c</p>
<p> for </p>
<p>the MC9S12XDP512. For other Star12X derivatives the template has to be </p>
<p>adapted.</p>
<p> </p>
<p> </p>
<p><b>9.5 </b></p>
<p><b>Memory model banked on Star12X / Cosmic </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How has the XCP Protocol Layer to be configured in order to support the access </p>
<p>to far pages in the banked memory model on the Star12X with Cosmic compiler? </p>
<p> </p>
<p>In order to access far pages or support data page banking the following definitions have to </p>
<p>be added to the user config file: </p>
<p>#define XCP_MEMORY_MODEL_PAGED </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>92 / 94 </p>
<p>#define XCP_ENABLE_MEM_ACCESS_BY_APPL </p>
<p>If this option is enabled far pointers are used for memory access, and address conversions </p>
<p>are carried out in the in the application callback template </p>
<p>_xcp_appl.c</p>
<p>. These address </p>
<p>conversions have to adapted to the used derivative. </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>The data page banking support is implemented in the template </p>
<p>_xcp_appl.c</p>
<p> for </p>
<p>the MC9S12XDP512. For other Star12X derivatives the template has to be </p>
<p>adapted.</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>9.6 </b></p>
<p><b>Reflected CRC16 CCITT Checksum Calculation Algorithm </b></p>
<p> </p>
<p> </p>
<p><b>FAQ</b> </p>
<p>How is the reflected CRC16 CCITT checksum calculation algorithm configured? </p>
<p> </p>
<p>The  XCP  Protocol  Layer  supports  both  the  standard  CRC16  CCITT  algorithm  and  the </p>
<p>reflected  CRC16  CCITT  algorithm.  In  order  to  use  the  reflected  algorithm  the  following </p>
<p>definition has to be added to the user config file: </p>
<p>#define XCP_ENABLE_CRC16CCITT_REFLECTED </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>Up to CANape version 5.6.30.3 (SP3) the standard CRC16 CCITT algorithm is </p>
<p>not supported, but the reflected one. </p>
<p>However a user checksum calculation DLL can be used in order to use the </p>
<p>standard algorithm with former versions of CANape.</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>93 / 94 </p>
<p><b>10  Bibliography </b></p>
<p>This manual refers to the following documents: </p>
<p>[I] </p>
<p>XCP -Part 1 - Overview  </p>
<p>Version 1.1  </p>
<p>[II]  XCP -Part 2- Protocol Layer Specification </p>
<p>Version 1.1 </p>
<p>[III] XCP -Part 5- Example Communication Sequences </p>
<p>Version 1.1 </p>
<p>[IV] Technical Reference XCP on CAN Transport Layer </p>
<p>Version 1.6 </p>
<p>[V] Technical Reference XCP on FlexRay Transport Layer </p>
<p>Version 1.9 </p>
<p>[VI] Technical Reference XCP on LIN Transport Layer </p>
<p>Version 1.0 </p>
<p>[VII] </p>
<p>AUTOSAR Specification of CRC Routines </p>
<p>Release 2.0.0 of 2006-04-28 </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference XCP Protocol Layer </p>
<p> </p>
<p></p>
<p>2016, Vector Informatik GmbH </p>
<p>Version: 2.05.00 </p>
<p> </p>
<p>94 / 94 </p>
<p><b>11  Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p>&gt;   News </p>
<p>&gt;   Products </p>
<p>&gt;   Demo software </p>
<p>&gt;   Support </p>
<p>&gt;   Training data </p>
<p>&gt;   Addresses </p>
<p> </p>
<p><b>www.vector-informatik.com </b></p>
<p> </p>
<p> </p>
</body>
</html>
{% endraw %}