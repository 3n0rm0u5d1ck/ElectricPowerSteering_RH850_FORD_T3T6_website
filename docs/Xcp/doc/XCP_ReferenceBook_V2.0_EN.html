---
layout: default
title: XCP_ReferenceBook_V2.0_EN
nav_order: 5
parent: Universal Measurement and Calibration Protocol (XCP)
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p><b>XCP – The Standard Protocol</b></p>
<p><b>for ECU Development</b></p>
<p><b>Fundamentals and Application Areas</b></p>
<p>Andreas Patzer | Rainer Zaiser</p>
<h1 style="page-break-before:always; "></h1>
<p><b>Andreas Patzer | Rainer Zaiser</b></p>
<p><b>XCP – The Standard Protocol for ECU Development</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Date April 2014 | Reproduction only with expressed permission from  </p>
<p>Vector Informatik GmbH, Ingersheimer Str. 24, 70499 Stuttgart, Germany</p>
<p>© 2014 by Vector Informatik GmbH. All rights reserved. This book is only intended for personal use, but not for technical or  </p>
<p>commercial use. It may not be used as a basis for contracts of any kind. All information in this book was compiled with the  </p>
<p>greatest possible care, but Vector Informatik does not assume any guarantee or warranty whatsoever for the correctness of the  </p>
<p>information it contains. The liability of Vector Informatik is excluded, except for malicious intent or gross negligence, to the extent  </p>
<p>that laws do not make it legally liable. </p>
<p>  </p>
<p>Information contained in this book may be protected by copyright and / or patent rights. Product names of software, hardware and  </p>
<p>other product names that are used in this book may be registered brands or otherwise protected by branding laws, regardless of  </p>
<p>whether or not they are identified as registered brands.</p>
<h1 style="page-break-before:always; "></h1>
<p><b>XCP – </b></p>
<p><b>The Standard Protocol</b></p>
<p><b>for ECU Development</b></p>
<p><b>Fundamentals and Application Areas</b></p>
<p>Andreas Patzer, Rainer Zaiser </p>
<p>Vector Informatik GmbH</p>
<h1 style="page-break-before:always; "></h1>
<p><b>Table of Contents  </b></p>
<p><b>Introduction </b></p>
<p>7</p>
<p><b>1  Fundamentals of the XCP Protocol </b></p>
<p>13</p>
<p><b>1.1  XCP Protocol Layer </b></p>
<p>19</p>
<p> </p>
<p>1.1.1 </p>
<p>Identification Field </p>
<p>21</p>
<p><b> </b></p>
<p>1.1.2 </p>
<p>Time Stamp </p>
<p>21</p>
<p><b> </b></p>
<p>1.1.3 </p>
<p>Data Field </p>
<p>22</p>
<p><b>1.2  Exchange of CTOs </b></p>
<p>22</p>
<p><b> </b></p>
<p>1.2.1 </p>
<p>XCP Command Structure </p>
<p>22</p>
<p><b> </b></p>
<p>1.2.2 </p>
<p>CMD </p>
<p>25</p>
<p> </p>
<p>1.2.3 </p>
<p>RES </p>
<p>28</p>
<p> </p>
<p>1.2.4 </p>
<p>ERR </p>
<p>28</p>
<p> </p>
<p>1.2.5 </p>
<p>EV </p>
<p>29</p>
<p> </p>
<p>1.2.6 </p>
<p>SERV </p>
<p>29</p>
<p> </p>
<p>1.2.7 </p>
<p>Calibrating Parameters in the Slave </p>
<p>29</p>
<p><b>1.3  Exchanging DTOs – Synchronous Data Exchange </b></p>
<p>32</p>
<p><b> </b></p>
<p>1.3.1 </p>
<p>Measurement Methods: Polling versus DAQ </p>
<p>33</p>
<p><b> </b></p>
<p>1.3.2 </p>
<p>DAQ Measurement Method </p>
<p>34</p>
<p> </p>
<p>1.3.3 </p>
<p>STIM Calibration Method </p>
<p>41</p>
<p> </p>
<p>1.3.4 </p>
<p>XCP Packet Addressing for DAQ and STIM </p>
<p>42</p>
<p> </p>
<p>1.3.5 </p>
<p>Bypassing = DAQ + STIM </p>
<p>44</p>
<p><b>1.4  XCP Transport Layers </b></p>
<p>45</p>
<p> </p>
<p>1.4.1 </p>
<p>CAN </p>
<p>45</p>
<p> </p>
<p>1.4.2 </p>
<p>CAN FD </p>
<p>48</p>
<p> </p>
<p>1.4.3 </p>
<p>FlexRay </p>
<p>50</p>
<p> </p>
<p>1.4.4 </p>
<p>Ethernet </p>
<p>53</p>
<p> </p>
<p>1.4.5 </p>
<p>SxI </p>
<p>55</p>
<p> </p>
<p>1.4.6 </p>
<p>USB </p>
<p>55</p>
<p> </p>
<p>1.4.7 </p>
<p>LIN </p>
<p>55</p>
<p><b>1.5  XCP Services </b></p>
<p>56</p>
<p> </p>
<p>1.5.1 </p>
<p>Memory Page Swapping </p>
<p>56</p>
<p> </p>
<p>1.5.2 </p>
<p>Saving Memory Pages – Data Page Freezing </p>
<p>58</p>
<p> </p>
<p>1.5.3 </p>
<p>Flash Programming </p>
<p>58</p>
<p> </p>
<p>1.5.4 </p>
<p>Automatic Detection of the Slave </p>
<p>60</p>
<p> </p>
<p>1.5.5 </p>
<p>Block Transfer Mode for Upload, Download and Flashing </p>
<p>61</p>
<p> </p>
<p>1.5.6 </p>
<p>Cold Start Measurement (start of measurement during power-on) </p>
<p>62</p>
<p> </p>
<p>1.5.7 </p>
<p>Security Mechanisms with XCP </p>
<p>63</p>
<h1 style="page-break-before:always; "></h1>
<p><b>2 </b></p>
<p><b>ECU Description File A2L </b></p>
<p>65</p>
<p><b>2.1  Setting Up an A2L File for an XCP Slave </b></p>
<p>68</p>
<p><b>2.2  Manually Creating an A2L File </b></p>
<p>69</p>
<p><b>2.3  A2L Contents versus ECU Implementation </b></p>
<p>70</p>
<p><b>3</b></p>
<p><b> </b></p>
<p><b>Calibration Concepts </b></p>
<p>73</p>
<p><b>3.1  Parameters in Flash </b></p>
<p>74</p>
<p><b>3.2  Parameters in RAM </b></p>
<p>76</p>
<p><b>3.3  Flash Overlay </b></p>
<p>78</p>
<p><b>3.4  Dynamic Flash Overlay Allocation </b></p>
<p>79</p>
<p><b>3.5  RAM Pointer Based Calibration Concept per AUTOSAR </b></p>
<p>80</p>
<p><b> </b></p>
<p>3.5.1 Single Pointer Concept </p>
<p>80</p>
<p> </p>
<p>3.5.2 Double Pointer Concept </p>
<p>82</p>
<p><b>3.6  Flash Pointer Based Calibration Concept </b></p>
<p>83</p>
<p><b>4</b></p>
<p><b> </b></p>
<p><b>Application Areas of XCP </b></p>
<p>85</p>
<p><b>4.1  MIL: Model in the Loop </b></p>
<p>87</p>
<p><b>4.2  SIL: Software in the Loop </b></p>
<p>88</p>
<p><b>4.3  HIL: Hardware in the Loop </b></p>
<p>89</p>
<p><b>4.4  RCP: Rapid Control Prototyping </b></p>
<p>91</p>
<p><b>4.5  Bypassing </b></p>
<p>92</p>
<p><b>4.6  Shortening Iteration Cycles with Virtual ECUs </b></p>
<p>95</p>
<p><b>5</b></p>
<p><b> </b></p>
<p><b>Example of an XCP Implementation </b></p>
<p>99</p>
<p><b>5.1  Description of Functions </b></p>
<p>102</p>
<p><b>5.2  Parameterization of the Driver </b></p>
<p>104</p>
<p><b>The Authors </b></p>
<p>106</p>
<p><b>Table of Abbreviations and Acronyms </b></p>
<p>108</p>
<p><b>Literature </b></p>
<p>109</p>
<p><b>Web Addresses </b></p>
<p>109</p>
<p><b>Table of Figures </b></p>
<p>110</p>
<p><b>Appendix – XCP Solutions at Vector </b></p>
<p>112</p>
<p><b>Index </b></p>
<p>114</p>
<h1 style="page-break-before:always; "></h1>
<p>7</p>
<p>Introduction</p>
<p><b>Introduction</b></p>
<p>In  optimal  parameterization  (calibration)  of  electronic  ECUs,  you  calibrate  parameter  values </p>
<p>during the system runtime and simultaneously acquire measured signals. The physical connec-</p>
<p>tion between the development tool and the ECU is via a measurement and calibration protocol. </p>
<p>XCP has become established as a standard here.</p>
<p>First, the fundamentals and mechanisms of XCP will be explained briefly and then the applica-</p>
<p>tion areas and added value for ECU calibration will be discussed.</p>
<p>First, some facts about XCP:</p>
<p>&gt;   XCP signifies “Universal Measurement and Calibration Protocol”. The “X” stands for the vari-</p>
<p>able and interchangeable transport layer.</p>
<p>&gt;   It was standardized by an ASAM working committee (Association for Standardisation of Auto-</p>
<p>mation and Measuring Systems). ASAM is an organization of automotive OEMs, suppliers and </p>
<p>tool producers.</p>
<p>&gt;   XCP is the protocol that succeeds CCP (CAN Calibration Protocol).</p>
<p>&gt;   The conceptual idea of the CAN Calibration Protocol was to permit read and write access to </p>
<p>internal  ECU  data  over  CAN.  XCP  was  developed  to  implement  this  capability  via  different </p>
<p>transmission media. Then one speaks of XCP on CAN, XCP on FlexRay or XCP on Ethernet. </p>
<p>&gt;   The primary applications of XCP are measurement and calibration of internal ECU parameters. </p>
<p>Here, the protocol offers the ability to acquire measured values “event synchronous” to pro-</p>
<p>cesses in ECUs. This ensures consistency of the data between one another.</p>
<p>To  visualize  the  underlying  idea,  we  initially  view  the  ECU  and  the  software  running  in  it  as </p>
<p>a black box. In a black box, only the inputs into the ECU (e.g. CAN messages and sensor val-</p>
<p>ues) and the output from the ECU (e.g. CAN messages and actuator drives) are acquired. Details </p>
<p>about  the  internal  processing  of  algorithms  are  not  immediately  apparent  and  can  only  be </p>
<p>determined from an analysis of the input and output data. </p>
<p>Now imagine that you had a look into the behavior of your ECU with every computation cycle. At </p>
<p>any time, you could acquire detailed information on how the algorithm is running. You would </p>
<p>no longer have a black box, but a white box instead with a full view of internal processes. That </p>
<p>is precisely what you get with XCP! </p>
<p>What contribution can XCP make for the overall development process? To check the functional-</p>
<p>ity of the attained development status, the developer can execute the code repeatedly. In this </p>
<p>way, the developer finds out how the algorithm behaves and what might be optimized. It does </p>
<p>not matter here whether a compiled code runs on a specific hardware or whether it is developed </p>
<p>in a model-based way and the application runs in the form of a model.</p>
<p>A central focus is on the evaluation of the algorithm process. For example, if the algorithm is </p>
<p>running  as  a  model  in  a  development  environment,  such  as  Simulink  from  The  MathWorks,  it </p>
<p>is  helpful  to  developers  if  they  can  also  acquire  intermediate  results  to  their  applications,  in </p>
<p>order to obtain findings about other changes. In the final analysis, this method enables noth-</p>
<p>ing other than read access to parameters so that they can be visualized and analyzed – and all </p>
<p>of this at model runtime or retrospectively after a time-limited test run has been completed. A </p>
<p>write access is needed if parameterizations are changed, e.g. if the proportional component of a </p>
<h1 style="page-break-before:always; "></h1>
<p>8</p>
<p>Introduction</p>
<p>PID controller is modified to adapt the algorithm behavior to the system under control. Regard-</p>
<p>less of where your application runs – focal points are always the detailed analysis of algorithm </p>
<p>processes and optimization by changes to the parameterization.</p>
<p>This generalization can be made: The algorithms may exist in any type of executable form (code </p>
<p>or model description). Different systems may be used as the runtime environment (Simulink, </p>
<p>as DLL on the PC, on a rapid prototyping platform, in the ECU etc.). Process flows are analyzed </p>
<p>by read access to data and acquisition of its time-based flow. Parameter sets are modified iter-</p>
<p>atively  to  optimize  algorithms.  To  simplify  the  representation,  the  acquisition  of  data  can  be </p>
<p>externalized to an external PC-based tool, although it is understood here that runtime environ-</p>
<p>ments themselves can even offer analysis capabilities.</p>
<p><b>Figure 1: </b></p>
<p><b>Fundamental  </b></p>
<p><b>communication  </b></p>
<p><b>with a runtime </b></p>
<p><b>environment</b></p>
<p>Application</p>
<p>Operating System</p>
<p>Runtime Environment</p>
<p>Communication</p>
<p>PC Tool</p>
<p>The  type  of  runtime  environment  and  the  form  of  communication  generally  differ  from  one </p>
<p>another considerably. The reason is that the runtime environments are developed by different </p>
<p>producers  and  are  based  on  different  solution  approaches.  Different  types  of  protocols,  con-</p>
<p>figurations, measurement data formats, etc. make it a futile effort to try to exchange parame-</p>
<p>ter sets and results in all development steps. In the end, however, all of these solutions can be </p>
<p>reduced to read and write access at runtime. And there is a standard for this: XCP.</p>
<p>XCP  is  an  ASAM  standard  whose  Version  1.0  was  released  in  2003.  The  acronym  ASAM  stands </p>
<p>for “Association for Standardisation of Automation and Measuring Systems.” Suppliers, vehicle </p>
<p>OEMs and tool manufacturers are all represented in the ASAM working group. The purpose of the </p>
<p>XCP working group is to define a generalized measurement and calibration protocol that can be </p>
<p>used independent of the specific transport medium. Experience gained from working with CCP </p>
<p>(CAN Calibration Protocol) flowed into the development as well.</p>
<p>XCP was defined based on the ASAM interfaces model. The following figure shows a measure-</p>
<p>ment and calibration tool’s interfaces to the XCP Slave, to the description file and the connec-</p>
<p>tion to a higher-level automation system. </p>
<h1 style="page-break-before:always; "></h1>
<p>9</p>
<p>Introduction</p>
<p>Measurement and</p>
<p>Calibration System</p>
<p>ASAM MCD 3MC</p>
<p>ASAM MCD 1MC</p>
<p>ASAM</p>
<p>MCD 2MC</p>
<p>*.a2L </p>
<p>ECU Description File</p>
<p>Upper Level</p>
<p>Automation System</p>
<p>ECU </p>
<p>XCP Driver</p>
<p>XCP Driver</p>
<p><b>Figure 2:</b></p>
<p><b>The Interface Model </b></p>
<p><b>of ASAM</b></p>
<p><b>Interface 1: “ASAM MCD-1 MC” between the ECU and the measurement and calibration system</b></p>
<p>This interface describes the physical and the protocol-specific parts. Strictly speaking, a dis-</p>
<p>tinction was made between interfaces ASAP1a and ASAP1b here. The ASAP1b interface, how-</p>
<p>ever, never received general acceptance and for all practical purposes it has no relevance today. </p>
<p>The XCP protocol is so flexible that it can practically assume the role of a general manufacturer-</p>
<p>independent interface. For example, today all measurement and calibration hardware manufac-</p>
<p>turers offer systems (xETK, VX1000, etc.) which can be connected via the XCP on Ether  net stan-</p>
<p>dard. An ASAP1b interface – as it was still described for CCP – is no longer necessary. </p>
<p><b>Interface 2: “ASAM MCD-2 MC” A2L ECU description file </b></p>
<p>As already mentioned, XCP works in an address-oriented way. Read or write accesses to objects </p>
<p>are always based on an address entry. Ultimately, however, this would mean that the user would </p>
<p>have to search for his ECU objects in the Master based on the address. That would be extremely </p>
<p>inconvenient. To let users work with symbolic object names, for example, a file is needed that </p>
<p>describes the relationship between the object name and the object address. The next chapter is </p>
<p>devoted to this A2L description file.</p>
<p><b>Interface 3: “ASAM MCD-3 MC” automation interface </b></p>
<p>This interface is used to connect another system to the measurement and calibration tool, e.g. </p>
<p>for test bench automation. The interface is not further explained in this document, because it is </p>
<p>irrelevant to understanding XCP. </p>
<h1 style="page-break-before:always; "></h1>
<p>10</p>
<p>Introduction</p>
<p>XCP is based on the Master-Slave principle. The ECU is the Slave and the measurement and cali-</p>
<p>bration tool is the Master. A Slave may only communicate with one Master at any given time; on </p>
<p>the other hand, the Master can simultaneous communicate with many Slaves.</p>
<p><b>Figure 3:</b></p>
<p><b>An XCP Master can </b></p>
<p><b>simultaneously  </b></p>
<p><b>communicate with  </b></p>
<p><b>multiple Slaves</b></p>
<p>Bus</p>
<p>Master</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>To  be  able  to  access  data  and  configurations  over  the  entire  development  process,  XCP  must </p>
<p>be used in every runtime environment. Fewer tools would need to be purchased, operated and </p>
<p>maintained. This would also eliminate the need for manual copying of configurations from one </p>
<p>tool to another, a process that is susceptible to errors. This would simplify iterative loops, in </p>
<p>which results from later work steps are transferred back to prior work steps. </p>
<p>But let us turn our attention away from what might be feasible to what is possible today: every-</p>
<p>thing! XCP solutions are already used in a wide variety of work environments. It is the intention </p>
<p>of this book to describe the main properties of the measurement and calibration protocol and </p>
<p>introduce its use in the various runtime environments. What you will not find in this book: nei-</p>
<p>ther the entire XCP specification in detailed form, nor precise instructions for integrating XCP </p>
<p>drivers in a specific runtime environment. It explains the relationships, but not the individual </p>
<p>protocol and implementation details. Internet links in the appendix refer to openly available </p>
<p>XCP driver source code and sample implementations, which let you understand and see how the </p>
<p>implementation is made. </p>
<p>Screenshots of the PC tool used in this book were prepared using the CANape measurement and </p>
<p>calibration tool from Vector. Other process flows are also explained based on CANape, including </p>
<p>how to create an A2L file and even more. With a cost-free demo version, which is available to you </p>
<p>in the Download Center of the Vector website at www.vector.com/canape_demo, you can see for </p>
<p>yourself.</p>
<h1 style="page-break-before:always; "></h1>
<p>11</p>
<p>Introduction</p>
<h1 style="page-break-before:always; "></h1>
<p>12</p>
<h1 style="page-break-before:always; "></h1>
<p>13</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>1 Fundamentals of the XCP Protocol</b></p>
<h1 style="page-break-before:always; "></h1>
<p>14</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>Interface 1 of the ASAM interfaces model describes sending and receiving commands and data </p>
<p>between the Slave and the Master. To achieve independence from a specific physical transport </p>
<p>layer, XCP was subdivided into a protocol layer and a transport layer. </p>
<p><b>Figure 4: Subdivision of the XCP protocol into protocol layer and transport layer</b></p>
<p>CAN</p>
<p>Ethernet</p>
<p>FlexRay</p>
<p>SxI</p>
<p>USB</p>
<p>...</p>
<p>Depending on the transport layer, one refers to XCP on CAN, XCP on Ethernet, etc. The extend-</p>
<p>ibility to new transport layers was proven as early as 2005 when XCP on FlexRay made its debut. </p>
<p>The current version of the XCP protocol is Version 1.1, which was approved in 2008.</p>
<p>Adherence to the following principles was given high priority in designing the protocol:</p>
<p>&gt;  Minimal resource usage in the ECU</p>
<p>&gt;  Efficient communication</p>
<p>&gt;  Simple Slave implementation </p>
<p>&gt;  Plug-and-play configuration with just a small number of parameters</p>
<p>&gt;  Scalability</p>
<h1 style="page-break-before:always; "></h1>
<p>15</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>A key functionality of XCP is that it enables read and write access to the memory of the Slave. </p>
<p>Read access lets users measure the time response of an internal ECU parameter. ECUs are sys-</p>
<p>tems with discrete time behavior, whose parameters only change at specific time intervals: only </p>
<p>when the processor recalculates the value and updates it in RAM. One of the great strengths of </p>
<p>XCP lies in acquiring measured values from RAM which change synchronously to process flows </p>
<p>or events in the ECU. This lets users evaluate direct relationships between time-based process </p>
<p>flows in the ECU and the changing values. These are referred to as event-synchronous measure-</p>
<p>ments. The related mechanisms will be explained later in detail.</p>
<p>Write  access  lets  the  user  optimize  parameters  of  algorithms  in  the  Slave.  The  accesses  are </p>
<p>address-oriented,  i.e.  the  communication  between  Master  and  Slave  references  addresses  in </p>
<p>memory.  So,  the  measurement  of  a  parameter  is  essentially  implemented  as  a  request  of  the </p>
<p>Master to the Slave: “Give me the value of memory location 0x1234”. Calibration of a parameter </p>
<p>– the write access – to the Slave means: “Set the value at address 0x9876 to 5”.</p>
<p>An  XCP  Slave  does  not  absolutely  need  to  be  used  in  ECUs.  It  may  be  implemented  in  differ-</p>
<p>ent environments: from a model-based development environment to hardware-in-the-loop and </p>
<p>software-in-the-loop environments to hardware interfaces that are used to access ECU memory </p>
<p>via debug interfaces such as JTAG, NEXUS and DAP.</p>
<p><b>Figure 5: </b></p>
<p><b>XCP Slaves can be </b></p>
<p><b>used in many </b></p>
<p><b>different runtime </b></p>
<p><b>environments</b></p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>PC</p>
<p><b>XCP</b></p>
<p>Measurement/</p>
<p>Calibration </p>
<p>Hardware*</p>
<p>* Debug Interfaces, Memory Emulator, ...</p>
<p>HIL/SIL Systems</p>
<p>EXE/DLL</p>
<p>Prototype or</p>
<p>ECU Hardware</p>
<p>Simulink</p>
<p>Master</p>
<h1 style="page-break-before:always; "></h1>
<p>16</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>How  can  algorithms  be  optimized  using  read  and  write  access  to  the  ECU  and  what  benefits </p>
<p>does this offer? To be able to modify individual parameters at runtime in the ECU, there must be </p>
<p>access to them. Not every type of memory permits this process. It is only possible to perform a </p>
<p>read and write access to memory addresses in RAM (intentionally excluding the EEPROM here). </p>
<p>The following is a brief summary of the differences between individual memory technologies: </p>
<p>knowledge of them is very important to understanding over the further course of this book.</p>
<p><b>Memory Fundamentals</b></p>
<p>Today, flash memories are usually integrated in the microcontroller chips for ECUs and are used </p>
<p>for long-term storage of code and data, even without power supply. The special aspect of a flash </p>
<p>memory is that read and write access to individual bytes is indeed possible at any time, but writ-</p>
<p>ing of new contents can only be done blockwise, usually in rather large blocks. </p>
<p>Flash memories have a limited life, which is specified in terms of a maximum number of erasure </p>
<p>cycles (depending on the specific technology the maximum may be up to one million cycles). </p>
<p>This is also the maximum number of write cycles, because the memory must always be erased as </p>
<p>a block before it can be written again. The reason for this lies in the memory structure: electrons </p>
<p>are “pumped” via tunnel diodes. A bit is stored at a memory location as follows: electrons must </p>
<p>be  transported  into  the  memory  location  over  an  electrically  insulating  layer.  Once  the  elec-</p>
<p>trons are then behind the insulating layer, they form an electric field with their charge, which is </p>
<p>interpreted as a 1 when reading the memory location. If there are no electrons behind the layer, </p>
<p>the cell information is interpreted as a 0. A 1 can indeed be set in this way, but not a 0. Setting </p>
<p>to 0 (= erasing the 1) is performed in a separate erasing routine, in which electrons existing </p>
<p>behind the insulating layer are discharged. However, for architectural reasons, such an erasing </p>
<p>routine does not just act on single bytes, rather only on the group or block level. Depending on </p>
<p>the architecture, blocks of 128 or 256 bytes are usually used. If one wishes to overwrite a byte </p>
<p>within such a block, the entire block must first be erased. Then the entire contents of the block </p>
<p>can be written back.</p>
<p>When this erasing routine is repeated multiple times, the insulating layer (“Tunnel Oxide Film”) </p>
<p>can be damaged. This means that the electrons could slowly leak away, changing some of the </p>
<p>information from 1 to 0 over the course of time. Therefore, the number of allowable flash cycles </p>
<p>is severely limited in an ECU. In the production ECU, it is often only on the order of single digit </p>
<p>numbers. This restriction is monitored by the Flash Boot Loader, which uses a counter to keep </p>
<p>track of how many flash operations have already been executed. When the specified number is </p>
<p>exceeded, the Flash Boot Loader rejects another flash request.</p>
<p>A RAM (Random Access Memory) requires a permanent power supply; otherwise it loses its con-</p>
<p>tents. While flash memory serves the purpose of long-term storage of the application, the RAM </p>
<p>is used to buffer computed data and other temporary information. Shutting off the power sup-</p>
<p>ply causes the RAM contents to be lost. In contrast to flash memory, it is easy to read and write </p>
<p>to RAM. </p>
<h1 style="page-break-before:always; "></h1>
<p>17</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p>This fact is clear: if parameters need to be changed at runtime, it must be assured that they are </p>
<p>located in RAM. It is really very important to understand this circumstance. That is why we will </p>
<p>look at the execution of an application in the ECU based on the following example: </p>
<p>In the application, the y parameters are computed from the sensor values x. </p>
<p>// Pseudo-code representation</p>
<p>a = 5;</p>
<p>b = 2;</p>
<p>y = a * x + b;</p>
<p>If the application is flashed in the ECU, the controller handles this code as follows after booting: </p>
<p>the values of the x parameters correspond to a sensor value. At some time point, the application </p>
<p>must therefore poll the sensor value and the value is then stored in a memory location assigned </p>
<p>to the x parameters. Since this value always needs to be rewritten at runtime, the memory loca-</p>
<p>tion can only lie in RAM. </p>
<p>The parameter y is computed. The values a and b, as factor and offset, are included as informa-</p>
<p>tion in flash memory. They are stored as constants there. The value of y must also be stored in </p>
<p>RAM, because once again that is the only place where write access is possible. At precisely which </p>
<p>location in RAM the parameters x and y are located, or where a and b lie in flash, is set in the </p>
<p>compiler/linker run. This is where objects are allocated to unique addresses. The relationship </p>
<p>between object name, data type and address is documented in the linker-map file. The linker-</p>
<p>map file is generated by the Linker run and can exist in different formats. Common to all for-</p>
<p>mats, however, is that they contain the object name and address at a minimum. </p>
<p>In the example, if the offset b and factor a depend on the specific vehicle, the values of a and b </p>
<p>must be individually adapted to the specific conditions of the vehicle. This means that the algo-</p>
<p>rithm remains as it is, but the parameter values change from vehicle to vehicle.</p>
<p>In the normal operating mode of an ECU, the application runs from the flash memory. It does </p>
<p>not permit any write accesses to individual objects. This means that parameter values which are </p>
<p>located in the flash area cannot be modified at runtime. If a change to parameter values should </p>
<p>be possible during runtime, the parameters to be modified must lie in RAM and not in flash. </p>
<p>Now, how do the parameters and their initial values make their way into RAM? How does one </p>
<p>solve the problem of needing to modify more parameters than can be simultaneously stored in </p>
<p>RAM? These issues lead us to the topic of calibration concepts (see chapter 3).</p>
<h1 style="page-break-before:always; "></h1>
<p>18</p>
<p>1 Fundamentals of the XCP Protocol</p>
<p><b>Summary of XCP fundamentals</b></p>
<p>Read and write accesses to memory contents are available with the mechanisms of the XCP pro-</p>
<p>tocol. The accesses are made in an address-oriented way. Read access enables measurement of </p>
<p>parameters from RAM, and write access enables calibration of the parameters in RAM. XCP per-</p>
<p>mits  execution  of  the  measurement  synchronous  to  events  in  the  ECU.  This  ensures  that  the </p>
<p>measured values correlate with one another. With every restart of a measurement, the signals </p>
<p>to be measured can be freely selected. For write access, the parameters to be calibrated must be </p>
<p>stored in RAM. This requires a calibration concept.</p>
<p>This leads to two important questions:</p>
<p>&gt;   How does the user of the XCP protocol know the correct addresses of the measurement and </p>
<p>calibration parameters in RAM?</p>
<p>&gt;  What does the calibration concept look like?</p>
<p>The first question is answered in chapter 2 “ECUs description file A2L”. The topic of the calibra-</p>
<p>tion concept is addressed in chapter 3.</p>
<h1 style="page-break-before:always; "></h1>
<p>19</p>
<p>1.1 XCP Protocol Layer</p>
<p><b>1.1 XCP Protocol Layer</b></p>
<p>XCP data is exchanged between the Master and Slave in a message-based way. The entire “XCP </p>
<p>message frame” is embedded in a frame of the transport layer (in the case of XCP on Ethernet </p>
<p>with UDP in a UDP packet). The frame consists of three parts: the XCP header, the XCP packet </p>
<p>and the XCP tail. </p>
<p>In the following figure, part of a message is shown in red. It is used to send the current XCP </p>
<p>frame. The XCP header and XCP tail depend on the transport protocol.</p>
<p><b>Figure 6: XCP packet</b></p>
<p>XCP Header</p>
<p>XCP Message (Frame)</p>
<p><b>XCP Packet</b></p>
<p><b>PID</b></p>
<p><b>Identification</b></p>
<p><b>Field</b></p>
<p><b>Timestamp</b></p>
<p><b>Field</b></p>
<p><b>Data </b></p>
<p><b>Field</b></p>
<p><b>FILL</b></p>
<p><b>DAQ</b></p>
<p><b>TIMESTAMP</b></p>
<p><b>DATA</b></p>
<p>XCP Tail</p>
<p>The  XCP  packet  itself  is  independent  of  the  transport  protocol  used.  It  always  contains  three </p>
<p>components: “Identification Field”, “Timestamp Field” and the current data field “Data Field”. </p>
<p>Each Identification Field begins with the Packet Identifier (PID), which identifies the packet. </p>
<p>The following overview shows which PIDs have been defined:</p>
<p>0xFF</p>
<p>CMD</p>
<p>PID for frames </p>
<p>from Master to Slave</p>
<p>PID for frames </p>
<p>from Slave to Master</p>
<p>absolute or </p>
<p>relative </p>
<p>ODT number </p>
<p>for STIM</p>
<p>0xC0</p>
<p>0xBF</p>
<p>0x00</p>
<p>....</p>
<p>....</p>
<p>absolute or </p>
<p>relative </p>
<p>ODT number </p>
<p>for STIM</p>
<p>0xFF</p>
<p>0xFE</p>
<p>0xFD</p>
<p>0xFC</p>
<p>RES</p>
<p>ERR</p>
<p>EV</p>
<p>SERV</p>
<p>0xFB</p>
<p>0x00</p>
<p>....</p>
<p><b>Figure 7: Overview of XCP Packet Identifier (PID)</b></p>
<h1 style="page-break-before:always; "></h1>
<p>20</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>Communication via the XCP packet is subdivided into one area for commands (CTO) and one area </p>
<p>for sending synchronous data (DTO). </p>
<p><b>XCP Master</b></p>
<p><b>XCP Slave</b></p>
<p>CMD</p>
<p>SERV</p>
<p>RES</p>
<p>ERR</p>
<p>EV</p>
<p>CTO</p>
<p>STIM</p>
<p>DTO</p>
<p>Command / Response / Error / Event /</p>
<p>Service Request Processor </p>
<p>DAQ</p>
<p>Processor</p>
<p>STIM</p>
<p>Processor</p>
<p>DAQ</p>
<p>STIM</p>
<p>PGM</p>
<p>CAL</p>
<p>Bypass</p>
<p>XCP Handler</p>
<p>Resources</p>
<p>DAQ</p>
<p>XCP Driver</p>
<p><b>Figure 8: </b></p>
<p><b>XCP communication </b></p>
<p><b>model with CTO/DTO</b></p>
<p>The acronyms used here stand for</p>
<p>CMD </p>
<p>Command Packet  </p>
<p>sends commands </p>
<p>RES </p>
<p>Command Response Packet </p>
<p>positive response</p>
<p>ERR </p>
<p>Error </p>
<p>negative response</p>
<p>EV </p>
<p>Event Packet </p>
<p>asynchronous event</p>
<p>SERV  </p>
<p>Service Request Packet </p>
<p>service request</p>
<p>DAQ </p>
<p>Data AcQuisition </p>
<p>send periodic measured values</p>
<p>STIM </p>
<p>Stimulation </p>
<p>periodic stimulation of the Slave</p>
<p>Commands are exchanged via CTOs (Command Transfer Objects). The Master initiates contact in </p>
<p>this way, for example. The Slave must always respond to a CMD with RES or ERR. The other CTO </p>
<p>messages are sent asynchronously. The Data Transfer Objects (DTO) are used to exchange syn-</p>
<p>chronous measurement and stimulation data. </p>
<h1 style="page-break-before:always; "></h1>
<p>21</p>
<p>1.1 XCP Protocol Layer</p>
<p><b>1.1.1 Identification Field</b></p>
<p><b>Figure 9:  </b></p>
<p><b>Message </b></p>
<p><b>identification</b></p>
<p>XCP Packet</p>
<p><b>PID</b></p>
<p><b>Identification Field</b></p>
<p><b>FILL</b></p>
<p><b>DAQ</b></p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>When  messages  are  exchanged,  both  the  Master  and  Slave  must  be  able  to  determine  which </p>
<p>message was sent by the other. This is accomplished in the identification field. That is why each </p>
<p>message begins with the Packet Identifier (PID).</p>
<p>In transmitting CTOs, the PID field is fully sufficient to identify a CMD, RES or other CTO packet. </p>
<p>In Figure 7, it can be seen that commands from the Master to the Slave utilize a PID from 0xC0 to </p>
<p>0xFF. The XCP Slave responds or informs the Master with PIDs from 0xFC to 0xFF. This results in a </p>
<p>unique allocation of the PIDs to the individually sent CTOs.</p>
<p>When  DTOs  are  transmitted,  other  elements  of  the  identification  field  are  used  (see  chapter </p>
<p>1.3.4 “XCP Packet Addressing for DAQ and STIM”).</p>
<p><b>1.1.2 Time Stamp</b></p>
<p><b>Figure 10:</b></p>
<p><b>Time stamp</b></p>
<p>XCP Packet</p>
<p><b>TIMESTAMP</b></p>
<p>PID FILL</p>
<p>DAQ</p>
<p>DATA</p>
<p>DTO  packets  use  time  stamps,  but  this  is  not  possible  in  transmission  of  a  CTO  message.  The </p>
<p>Slave uses the time stamp to supply time information with measured values. That is, the Mas-</p>
<p>ter not only has the measured value, but also the time point at which the measured value was </p>
<p>acquired. The amount of time it takes for the measured value to arrive at the Master is no lon-</p>
<p>ger important, because the relationship between the measured value and the time point comes </p>
<p>directly from the Slave. </p>
<p>Transmission  of  a  time  stamp  from  the  Slave  is  optional.  This  topic  is  discussed  further  in  </p>
<p>ASAM XCP Part 2 Protocol Layer Specification. </p>
<h1 style="page-break-before:always; "></h1>
<p>22</p>
<p>1 Fundamentals of the XCP protocol</p>
<p><b>1.1.3 Data Field </b></p>
<p><b>Figure 11: </b></p>
<p><b>Data field  </b></p>
<p><b>in the XCP packet</b></p>
<p>XCP Packet</p>
<p><b>DATA</b></p>
<p><b>Data Field</b></p>
<p>PID FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>Finally,  the  XCP  packet  also  contains  the  data  stored  in  the  data  field.  In  the  case  of  CTO </p>
<p> </p>
<p>packets,  the  data  field  consists  of  specific  parameters  for  the  different  commands.  DTO </p>
<p> </p>
<p>packets contain the measured values from the Slave and when STIM data is sent the values from </p>
<p>the Master.</p>
<p><b>1.2 Exchange of CTOs </b></p>
<p>CTOs are used to transmit both commands from the Master to the Slave and responses from the </p>
<p>Slave to the Master. </p>
<p><b>1.2.1 XCP Command Structure</b></p>
<p>The Slave receives a command from the Master and must react to it with a positive or negative </p>
<p>response. The communication structure is always the same here:</p>
<p>Command (CMD):</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Command Packet Code CMD</p>
<p>1..MAX_CTO-1 </p>
<p>BYTE </p>
<p>Command specific Parameters</p>
<p>A unique number is assigned to each command. In addition, other specific parameters may be </p>
<p>sent  with  the  command.  The  maximum  number  of  parameters  is  defined  as  MAX_CTO-1  here. </p>
<p>MAX_CTO indicates the maximum length of the CTO packets in bytes. </p>
<p>Positive response:</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Command Positive Response Packet Code = RES 0xFF</p>
<p>1..MAX_CTO-1 </p>
<p>BYTE </p>
<p>Command specific Parameters </p>
<h1 style="page-break-before:always; "></h1>
<p>23</p>
<p>1.2 Exchange of CTOs </p>
<p>Negative response:</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Error Packet Code = 0xFE</p>
<p>1 </p>
<p>BYTE </p>
<p>Error code</p>
<p>2..MAX_CTO-1 </p>
<p>BYTE </p>
<p>Command specific Parameters</p>
<p>Specific parameters can be transmitted as supplemental information with negative responses as </p>
<p>well and not just with positive responses. One example is when the connection is made between </p>
<p>Master and Slave. At the start of a communication between Master and Slave, the Master sends </p>
<p>a connect request to the Slave, which in turn must respond positively to produce a continuous </p>
<p>point-to-point connection.</p>
<p>Master à Slave: Connect </p>
<p>Slave à Master: Positive response </p>
<p>Connect command:</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Command Code = 0xFF</p>
<p>1 </p>
<p>BYTE </p>
<p>Mode </p>
<p> </p>
<p> </p>
<p>00 = Normal</p>
<p> </p>
<p> </p>
<p>01 = user defined</p>
<p>Mode 00 means that the Master wishes XCP communication with the Slave. If the Master uses </p>
<p>0xFF 0x01 when making the connection, the Master is requesting XCP communication with the </p>
<p>Slave.  Simultaneously,  it  informs  the  Slave  that  it  should  switch  to  a  specific  –  user-defined </p>
<p>– mode. </p>
<p>Positive response of the Slave:</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet ID: 0xFF</p>
<p>1 </p>
<p>BYTE </p>
<p>RESOURCE</p>
<p>2 </p>
<p>BYTE </p>
<p>COMM_MODE_BASIC</p>
<p>3 </p>
<p>BYTE </p>
<p>MAX_CTO, Maximum CTO size [BYTE]</p>
<p>4 </p>
<p>WORD </p>
<p>MAX_DTO, Maximum DTO size [BYTE]</p>
<p>6 </p>
<p>BYTE </p>
<p>XCP Protocol Layer Version Number (most significant byte only)</p>
<p>7 </p>
<p>BYTE </p>
<p>XCP Transport Layer Version Number (most significant byte only)</p>
<p>The  positive  response  of  the  Slave  can  assume  a  somewhat  more  extensive  form.  The  Slave </p>
<p>already sends communication-specific information to the Master when making the connection. </p>
<p>RESOURCE, for example, is information that the Slave gives on whether it supports such features </p>
<p>as page switching or whether flashing over XCP is possible. With MAX_DTO, the Slave informs the </p>
<p>Master of the maximum packet length it supports for transfer of the measured values, etc. You </p>
<p>will find details on the parameters in ASAM XCP Part 2 Protocol Layer Specification.</p>
<h1 style="page-break-before:always; "></h1>
<p>24</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>XCP permits three different modes for exchanging commands and reactions between Master and </p>
<p>Slave: Standard, Block and Interleaved mode.</p>
<p><b>Figure 12: The three modes of the XCP protocol: Standard, Block and Interleaved mode</b></p>
<p>Time</p>
<p>Master</p>
<p>Slave</p>
<p>Time</p>
<p>Master</p>
<p>Slave</p>
<p>Time</p>
<p>Master</p>
<p>Slave</p>
<p><b>Standard Mode</b></p>
<p><b>Block Mode</b></p>
<p><b>Interleaved Mode</b></p>
<p>Request k+1</p>
<p>Response k</p>
<p>Response k+1</p>
<p>Request k</p>
<p>Response k</p>
<p>Request k+1</p>
<p>Response k+1</p>
<p>Request k</p>
<p>Part1</p>
<p>Part3</p>
<p>Part2</p>
<p>Part1</p>
<p>Part2</p>
<p>Part3</p>
<p>Request k</p>
<p>Request k+1</p>
<p>Response k</p>
<p>Response k+1</p>
<p>MIN_ST</p>
<p>MAX_BS</p>
<p>In the standard communication model, each request to a Slave is followed by a single response. </p>
<p>Except with XCP on CAN, it is not permitted for multiple Slaves to react to a command from the </p>
<p>Master. Therefore, each XCP message can always be traced back to a unique Slave. This mode is </p>
<p>the standard case in communication.</p>
<p>The  block  transfer  mode  is  optional  and  saves  time  in  large  data  transfers  (e.g.  upload  or </p>
<p>download  operations).  Nonetheless,  performance  issues  must  be  considered  in  this  mode </p>
<p>in  the  direction  of  the  Slave.  Therefore,  minimum  times  between  two  commands  (MIN_ST) </p>
<p>must  be  maintained  and  the  total  number  of  commands  must  be  limited  to  an  upper  limit </p>
<p> </p>
<p>MAX_BS. Optionally, the Master can read out these communication settings from the Slave with  </p>
<p>GET_COMM_MODE_INFO. The aforementioned limitations do not need to be observed in block </p>
<p>transfer mode in the direction of the Master, because performance of the PC nearly always suf-</p>
<p>fices to accept the data from a microcontroller.</p>
<p>The interleaved mode is also provided for performance reasons. But this method is also optional </p>
<p>and – in contrast to block transfer mode – it has no relevance in practice. </p>
<h1 style="page-break-before:always; "></h1>
<p>25</p>
<p>1.2 Exchange of CTOs </p>
<p><b>1.2.2 CMD </b></p>
<p><b>Figure 13: Overview of the CTO packet structure</b></p>
<p><b>XCP CTO Packet</b></p>
<p>PID</p>
<p>DATA</p>
<p>Data Field</p>
<p>Identification Field</p>
<p>Timestamp Field</p>
<p>empty for CTO</p>
<p>The  Master  sends  a  general  request  to  the  Slave  over  CMD.  The  PID  (Packet  Identifier)  field </p>
<p>contains  the  identification  number  of  the  command.  The  additional  specific  parameters  are </p>
<p>transported in the data field. Then the Master waits for a reaction of the Slave in the form of a </p>
<p>RESponse or an ERRor.</p>
<p>XCP is also very scalable in its implementation, so it is not necessary to implement every com-</p>
<p>mand. In the A2L file, the available CMDs are listed in what is known as the XCP IF_DATA. If there </p>
<p>is a discrepancy between the definition in the A2L file and the implementation in the Slave, the </p>
<p>Master can determine, based on the Slave’s reaction, that the Slave does not even support the </p>
<p>command. If the Master sends a command that is not implemented in the Slave, the Slave must </p>
<p>acknowledge with ERR_CMD_UNKNOWN and no further activities are initiated in the Slave. This </p>
<p>lets the Master know quickly that an optional command has not been implemented in the Slave. </p>
<p>Some other parameters are included in the commands as well. Please take the precise details </p>
<p>from the protocol layer specification in document ASAM XCP Part 2. </p>
<p> </p>
<p>The  commands  are  organized  in  groups:  Standard,  Calibration,  Page,  Programming  and  DAQ </p>
<p>measurement commands. If a group is not needed at all, its commands do not need to be imple-</p>
<p>mented.  If  the  group  is  necessary,  certain  commands  must  always  be  available  in  the  Slave, </p>
<p>while others from the group are optional.</p>
<p>The following overview serves as an example. The SET_CAL_PAGE and GET_CAL_PAGE commands </p>
<p>in the Page-Switching group are identified as not optional. This means that in an XCP Slave that </p>
<p>supports Page Switching at least these two commands must be implemented. If Page-Switching </p>
<p>support is unnecessary in the Slave, these commands do not need to be implemented. The same </p>
<p>applies to other commands.</p>
<h1 style="page-break-before:always; "></h1>
<p>26</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>Standard commands:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>CONNECT </p>
<p>0xFF </p>
<p>No</p>
<p>DISCONNECT </p>
<p>0xFE </p>
<p>No</p>
<p>GET_STATUS </p>
<p>0xFD </p>
<p>No</p>
<p>SYNCH </p>
<p>0xFC </p>
<p>No</p>
<p>GET_COMM_MODE_INFO </p>
<p>0xFB </p>
<p>Yes</p>
<p>GET_ID </p>
<p>0xFA </p>
<p>Yes</p>
<p>SET_REQUEST </p>
<p>0xF9 </p>
<p>Yes</p>
<p>GET_SEED </p>
<p>0xF8 </p>
<p>Yes</p>
<p>UNLOCK </p>
<p>0xF7 </p>
<p>Yes</p>
<p>SET_MTA </p>
<p>0xF6 </p>
<p>Yes</p>
<p>UPLOAD </p>
<p>0xF5 </p>
<p>Yes</p>
<p>SHORT_UPLOAD </p>
<p>0xF4 </p>
<p>Yes</p>
<p>BUILD_CHECKSUM </p>
<p>0xF3 </p>
<p>Yes</p>
<p>TRANSPORT_LAYER_CMD </p>
<p>0xF2 </p>
<p>Yes</p>
<p>USER_CMD </p>
<p>0xF1 </p>
<p>Yes</p>
<p>Calibration commands:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>DOWNLOAD </p>
<p>0xF0 </p>
<p>No</p>
<p>DOWNLOAD_NEXT </p>
<p>0xEF </p>
<p>Yes</p>
<p>DOWNLOAD_MAX </p>
<p>0xEE </p>
<p>Yes</p>
<p>SHORT_DOWNLOAD </p>
<p>0xED </p>
<p>Yes</p>
<p>MODIFY_BITS </p>
<p>0xEC </p>
<p>Yes</p>
<p>Standard commands:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>SET_CAL_PAGE </p>
<p>0xEB </p>
<p>No</p>
<p>GET_CAL_PAGE </p>
<p>0xEA </p>
<p>No</p>
<p>GET_PAG_PROCESSOR_INFO </p>
<p>0xE9 </p>
<p>Yes</p>
<p>GET_SEGMENT_INFO </p>
<p>0xE8 </p>
<p>Yes</p>
<p>GET_PAGE_INFO </p>
<p>0xE7 </p>
<p>Yes</p>
<p>SET_SEGMENT_MODE </p>
<p>0xE6 </p>
<p>Yes</p>
<p>GET_SEGMENT_MODE </p>
<p>0xE5 </p>
<p>Yes</p>
<p>COPY_CAL_PAGE </p>
<p>0xE4 </p>
<p>Yes</p>
<h1 style="page-break-before:always; "></h1>
<p>27</p>
<p>1.2 Exchange of CTOs </p>
<p>Periodic data exchange – basics:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>SET_DAQ_PTR </p>
<p>0xE2 </p>
<p>No</p>
<p>WRITE_DAQ </p>
<p>0xE1 </p>
<p>No</p>
<p>SET_DAQ_LIST_MODE </p>
<p>0xE0 </p>
<p>No</p>
<p>START_STOP_DAQ_LIST </p>
<p>0xDE </p>
<p>No</p>
<p>START_STOP_SYNCH </p>
<p>0xDD </p>
<p>No</p>
<p>WRITE_DAQ_MULTIPLE </p>
<p>0xC7 </p>
<p>Yes</p>
<p>READ_DAQ </p>
<p>0xDB </p>
<p>Yes</p>
<p>GET_DAQ_CLOCK </p>
<p>0xDC </p>
<p>Yes</p>
<p>GET_DAQ_PROCESSOR_INFO </p>
<p>0xDA </p>
<p>Yes</p>
<p>GET_DAQ_RESOLUTION_INFO </p>
<p>0xD9 </p>
<p>Yes</p>
<p>GET_DAQ_LIST_INFO </p>
<p>0xD8 </p>
<p>Yes</p>
<p>GET_DAQ_EVENT_INFO </p>
<p>0xD7 </p>
<p>Yes</p>
<p>Periodic data exchange – static configuration: </p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>CLEAR_DAQ_LIST </p>
<p>0xE3 </p>
<p>No</p>
<p>GET_DAQ_LIST_INFO </p>
<p>0xD8 </p>
<p>Yes</p>
<p>Periodic data exchange – dynamic configuration: </p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>FREE_DAQ </p>
<p>0xD6 </p>
<p>Yes</p>
<p>ALLOC_DAQ </p>
<p>0xD5 </p>
<p>Yes</p>
<p>ALLOC_ODT </p>
<p>0xD4 </p>
<p>Yes</p>
<p>ALLOC_ODT_ENTRY </p>
<p>0xD3 </p>
<p>Yes</p>
<h1 style="page-break-before:always; "></h1>
<p>28</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>Flash programming:</p>
<p><b>Command </b></p>
<p><b>PID </b></p>
<p><b>Optional</b></p>
<p>PROGRAM_START </p>
<p>0xD2 </p>
<p>No</p>
<p>PROGRAM_CLEAR </p>
<p>0xD1 </p>
<p>No</p>
<p>PROGRAM </p>
<p>0xD0 </p>
<p>No</p>
<p>PROGRAM_RESET </p>
<p>0xCF </p>
<p>No</p>
<p>GET_PGM_PROCESSOR_INFO </p>
<p>0xCE </p>
<p>Yes</p>
<p>GET_SECTOR_INFO </p>
<p>0xCD </p>
<p>Yes</p>
<p>PROGRAM_PREPARE </p>
<p>0xCC </p>
<p>Yes</p>
<p>PROGRAM_FORMAT </p>
<p>0xCB </p>
<p>Yes</p>
<p>PROGRAM_NEXT </p>
<p>0xCA </p>
<p>Yes</p>
<p>PROGRAM_MAX </p>
<p>0xC9 </p>
<p>Yes</p>
<p>PROGRAM_VERIFY </p>
<p>0xC8 </p>
<p>Yes</p>
<p><b>1.2.3 RES </b></p>
<p>If the Slave is able to successfully comply with a Master’s request, it gives a positive acknowl-</p>
<p>edge with RES. </p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet Identifier = RES 0xFF</p>
<p>1..MAX_CTO-1 </p>
<p>BYTE </p>
<p>Command response data</p>
<p>You will find more detailed information on the parameters in ASAM XCP Part 2 Protocol Layer </p>
<p>Specification.</p>
<p><b>1.2.4 ERR </b></p>
<p>If the request from the Master is unusable, it responds with the error message ERR and an error </p>
<p>code. </p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet Identifier = ERR 0xFE</p>
<p>1 </p>
<p>BYTE </p>
<p>Error code</p>
<p>2..MAX_CTO-1 </p>
<p>BYTE </p>
<p>Optional error information data</p>
<p>You will find a list of possible error codes in ASAM XCP Part 2 Protocol Layer Specification.</p>
<h1 style="page-break-before:always; "></h1>
<p>29</p>
<p>1.2 Exchange of CTOs </p>
<p><b>1.2.5 EV </b></p>
<p>If the Slave wishes to inform the Master of an asynchronous event, an EV can be sent to do this. </p>
<p>Its implementation is optional.</p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet Identifier = EV 0xFD</p>
<p>1 </p>
<p>BYTE </p>
<p>Event code</p>
<p>2..MAX_CTO-1 </p>
<p>BYTE </p>
<p>Optional event information data</p>
<p>You will find more detailed information on the parameters in ASAM XCP Part 2 Protocol Layer </p>
<p>Specification.</p>
<p>Events will be discussed much more in relation to measurements and stimulation. This has noth-</p>
<p>ing to do with the action of the XCP Slave that initiates sending of an EVENT. Rather it involves </p>
<p>the Slave reporting a disturbance such as the failure of a specific functionality.</p>
<p><b>1.2.6 SERV </b></p>
<p>The Slave can use this mechanism to request that the Master execute a service. </p>
<p><b>Position </b></p>
<p><b>Type </b></p>
<p><b>Description</b></p>
<p>0 </p>
<p>BYTE </p>
<p>Packet Identifier = SERV 0xFC</p>
<p>1 </p>
<p>BYTE </p>
<p>Service request code</p>
<p>2..MAX_CTO-1 </p>
<p>BYTE </p>
<p>Optional service request data</p>
<p>You will find the Service Request Code table in ASAM XCP Part 2 Protocol Layer Specification. </p>
<p><b>1.2.7 Calibrating Parameters in the Slave</b></p>
<p>To change a parameter in an XCP Slave, the XCP Master must send the parameter’s location as </p>
<p>well as the value itself to the Slave.</p>
<p>XCP always defines addresses with five bytes: four for the actual address and one byte for the </p>
<p>address extension. Based on a CAN transmission, only seven useful bytes are available for XCP </p>
<p>messages. For example, if the calibrator sets a 4-byte value and wants to send both pieces of </p>
<p>information  in  one  CAN  message,  there  is  insufficient  space  to  do  this.  Since  a  total  of  nine </p>
<p>bytes are needed to transmit the address and the new value, the change cannot be transmit-</p>
<p>ted  in  one  CAN  message  (seven  useful  bytes).  The  calibration  request  is  therefore  made  with </p>
<p>two messages from Master to Slave. The Slave must acknowledge both messages and in sum four </p>
<p>messages are exchanged.</p>
<h1 style="page-break-before:always; "></h1>
<p>30</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>The following figure shows the communication between Master and Slave, which is necessary to </p>
<p>set a parameter value. The actual message is located in the line with the envelope symbol. The </p>
<p>interpretation of the message is shown by “expanding” it with the mouse. </p>
<p><b>Figure 14: Trace example from a calibration process</b></p>
<p>In  the  first  message  of  the  Master  (highlighted  in  gray  in  Figure  14),  the  Master  sends  the  </p>
<p>command  SET_MTA  to  the  Slave  with  the  address  to  which  a  new  value  should  be  written.  In </p>
<p>the second message, the Slave gives a positive acknowledge to the command with Ok:SET_MTA.</p>
<p>The  third  message  DOWNLOAD  transmits  the  hex  value  as  well  as  the  valid  number  of  bytes. </p>
<p>In this example, the valid number of bytes is four, because it is a float value. The Slave gives </p>
<p>another positive acknowledge in the fourth message.</p>
<p>This completes the current calibration process. In the Trace display, you can recognize a termi-</p>
<p>nating SHORT_UPLOAD – a special aspect of CANape, the measurement and calibration tool from </p>
<p>Vector. To make sure that the calibration was performed successfully, the value is read out again </p>
<p>after the process and the display is updated with the read-out value. This lets the user directly </p>
<p>recognize whether the calibration command was implemented. This command also gets a posi-</p>
<p>tive acknowledge with Ok:SHORT_UPLOAD. </p>
<p>When  the  parameter  changes  in  the  ECU’s  RAM,  the  application  processes  the  new  value.  A </p>
<p>reboot of the ECU, however, would lead to erasure of the value and overwriting of the value in </p>
<p>RAM with the original value from the flash (see chapter 3 “Calibration Concepts”). So, how can </p>
<p>the modified parameter set be permanently saved?</p>
<h1 style="page-break-before:always; "></h1>
<p>31</p>
<p>1.2 Exchange of CTOs </p>
<p>Essentially, there are two possibilities: </p>
<p><b>A) Save the parameters in the ECU</b></p>
<p>The changed data in RAM could for example be saved in the ECU’s EEPROM: either automatically </p>
<p>when  ramping  down  the  ECU,  or  manually  by  the  user.  A  prerequisite  is  that  the  data  can  be </p>
<p>stored in a nonvolatile memory of the Slave. In an ECU, this would be the EEPROM or flash. ECUs </p>
<p>with  thousands  of  parameters,  however,  are  seldom  able  to  provide  so  much  unused  EEPROM </p>
<p>memory space, so this method is rare.</p>
<p>Another  possibility  is  to  write  the  RAM  parameters  back  into  the  ECU’s  flash  memory.  This </p>
<p>method is relatively complex. A flash memory must first be erased before it can be rewritten. </p>
<p>This, in turn, can only be done as a block. Consequently, it is not simply a matter of writing back </p>
<p>individual bytes. You will find more on this topic in chapter 3 “Calibration Concepts”. </p>
<p><b>B) Save the parameters in the form of a file on the PC</b></p>
<p>It is much more common to store the parameters on the PC. All parameters – or subsets of them </p>
<p>– are stored in the form of a file. Different formats are available for this; the simplest case is </p>
<p>that of an ASCII text file, which only contains the name of the object and its value. Other for-</p>
<p>mats  also  permit  saving  other  information,  such  as  findings  about  the  maturity  level  of  the </p>
<p>parameter of the history of revisions. </p>
<p>Scenario: After finishing his or her work, the calibrator wishes to enjoy a free evening. So, the </p>
<p>calibrator saves the executed changes in the ECU’s RAM in the form of a parameter set file on a </p>
<p>PC. The next day, the calibrator wants to continue working where he or she left off. The calibra-</p>
<p>tor starts the ECU. Upon booting, the parameters are initialized in RAM. However, the ECU does </p>
<p>this using values stored in flash. This means that the changes of the previous day are no longer </p>
<p>available in the ECU. To now continue where work was left off on the previous day, the calibra-</p>
<p>tor transfers the contents of the parameter set file to the ECU’s RAM by XCP using the DOWNLOAD </p>
<p>command.</p>
<p><b>Figure 15: Transfer of a parameter set file to an ECU’s RAM</b></p>
<h1 style="page-break-before:always; "></h1>
<p>32</p>
<p>1 Fundamentals of the XCP protocol</p>
<p><b>Saving parameter set file in hex files and flashing</b></p>
<p>Flashing an ECU is another way to change the parameters in flash. They are then written to RAM </p>
<p>as new parameters when the ECU is booted. A parameter set file can also be transferred to a C or </p>
<p>H file and be made into the new flash file with another compiler/linker run. However, depend-</p>
<p>ing on the parameters of the code, the process of generating a flashable hex file could take a </p>
<p>considerable amount of time. In addition, the calibrator might not have any ECU source code </p>
<p>– depending on the work process. That would prevent this method from being available to the </p>
<p>calibrator. </p>
<p>As an alternative, the calibrator can copy the parameter set file into the existing flash file. </p>
<p><b>Figure 16: Hex window</b></p>
<p>In  the  flash  file,  there  is  a  hex  file  that  contains  both  the  addresses  and  the  values.  Now  a </p>
<p>parameter file can be copied to a hex file. To do this, CANape takes the address and the value </p>
<p>from  the  parameter  set  file  and  updates  the  parameter  value  at  the  relevant  location  in  the </p>
<p>hex file. This results in a new hex file, which contains the changed parameter values. However, </p>
<p>this  Hex  file  must  now  possibly  run  through  further  process  steps  to  obtain  a  flashable  file. </p>
<p>One recurring problem here is the checksums, which the ECU checks to determine whether it </p>
<p>received the data correctly. If the flashable file exists, it can be flashed in the ECU and after the </p>
<p>reboot the new parameter values are available in the ECU. </p>
<p><b>1.3 Exchanging DTOs – Synchronous Data Exchange </b></p>
<p>As depicted in Figure 8, DTOs (Data Transfer Objects) are available for exchanging synchronous </p>
<p>measurement and calibration data. Data from the Slave are sent to the Master by DAQ – synchro-</p>
<p>nous to internal events. This communication is subdivided into two phases: </p>
<p>In an initialization phase, the Master communicates to the Slave which data the Slave should </p>
<p>send for different events. After this phase, the Master initiates the measurement in the Slave </p>
<p>and the actual measurement phase begins. From this point in time, the Slave sends the desired </p>
<p>data to the Master, which only listens until it sends a “measurement stop” to the Slave. Trigger-</p>
<p>ing of measurement data acquisition and transmission is controlled by events in the ECU.</p>
<h1 style="page-break-before:always; "></h1>
<p>33</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p>The Master sends data to the Slave by STIM. This communication also consists of two phases:</p>
<p>In the initialization phase, the Master communicates to the Slave which data it will send to the </p>
<p>Slave. After this phase, the Master sends the data to the Slave and the STIM processor saves the </p>
<p>data. As soon as a related STIM event is triggered in the Slave, the data is transferred to the </p>
<p>application memory. </p>
<p><b>1.3.1 Measurement Methods: Polling versus DAQ </b></p>
<p>Before explaining how event-synchronous, correlated data is measured from a Slave, here is a </p>
<p>brief description of another measurement method known as Polling. It is not based on DTOs, but </p>
<p>on CTOs instead. Actually, this topic should be explained in a separate chapter, but a description </p>
<p>of polling lets us derive, in a very elegant way, the necessity of DTO-based measurement, so a </p>
<p>minor side discussion at this point makes sense. </p>
<p>The Master can use the SHORT_UPLOAD command to request the value of a measurement para-</p>
<p>meter  from  the  Slave.  This  is  referred  to  as  polling.  This  is  the  simplest  case  of  a  measure -</p>
<p>ment:  sending  the  measured  value  of  a  measurement  parameter  at  the  time  at  which  the</p>
<p>  </p>
<p>SHORT_UPLOAD command has been received and executed. </p>
<p>In the following example, the measurement parameter “Triangle” is measured from the Slave: </p>
<p><b>Figure 17: </b></p>
<p><b>Address information </b></p>
<p><b>of the parameter </b></p>
<p><b>“Triangle” from the </b></p>
<p><b>A2L file</b></p>
<p>The address 0x60483 is expressed as an address with five bytes in the CAN frame: one byte for </p>
<p>the address extension and four bytes for the actual address.</p>
<h1 style="page-break-before:always; "></h1>
<p>34</p>
<p>1 Fundamentals of the XCP protocol</p>
<p><b>Figure 18: Polling communication in the CANape Trace window </b></p>
<p>The XCP specification sets a requirement for polling: that the value of each measurement param-</p>
<p>eter must be polled individually. For each value to be measured via polling, two messages must </p>
<p>go over the bus: the Master’s request to the Slave and the Slave’s response to the Master.</p>
<p>Besides this additional bus load,  there  is another  disadvantage  of  the polling  method:  When </p>
<p>polling multiple data values, the user normally wants the data to correlate to one another. How-</p>
<p>ever,  multiple  values  that  are  measured  sequentially  with  polling  do  not  necessarily  stand  in </p>
<p>correlation to one another, i.e. they might not originate from the same ECU computing cycle. </p>
<p>This limits the suitability of polling for measurement, because it produces unnecessarily high </p>
<p>data traffic and the measured values are not evaluated in relation to the process flows in the </p>
<p>ECU. </p>
<p>So, an optimized measurement must solve two tasks:</p>
<p>&gt;  Bandwidth optimization during the measurement</p>
<p>&gt;  Assurance of data correlation</p>
<p>This task is handled by the already mentioned DAQ method. DAQ stands for Data Acquisition and </p>
<p>it is implemented by sending DTOs (Data Transfer Objects) from the Slave to the Master.</p>
<p><b>1.3.2 DAQ Measurement Method </b></p>
<p>The DAQ method solves the two problems of polling as follows:</p>
<p>&gt;   The correlation of measured values is achieved by coupling the acquisition of measured val-</p>
<p>ues to the events in the ECU. The measured values are not acquired and transferred until it has </p>
<p>been assured that all computations have been completed.</p>
<p>&gt;   To  reduce  bus  load,  the  measurement  process  is  subdivided  into  two  phases:  In  a  configu-</p>
<p>ration phase, the Master communicates which values it is interested in to the Slave and the </p>
<p>second phase just involves transferring the measured values of the Slave to the Master. </p>
<h1 style="page-break-before:always; "></h1>
<p>35</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p>How can the acquisition of measured values now be coupled to processes in the ECU? Figure 19 </p>
<p>shows the relationship between calculation cycles in the ECU and the changes in parameters X </p>
<p>and Y.</p>
<p>Calculation</p>
<p>cycle n</p>
<p>Calculation</p>
<p>cycle n+1</p>
<p>Calculation</p>
<p>cycle n+2</p>
<p>time</p>
<p>10</p>
<p>  8</p>
<p>  6</p>
<p>  4</p>
<p>  2</p>
<p>  0</p>
<p>10</p>
<p>  8</p>
<p>  6</p>
<p>  4</p>
<p>  2</p>
<p>  0</p>
<p>E1</p>
<p>E1</p>
<p>E1</p>
<p><b>X</b></p>
<p><b>Y</b></p>
<p>Calculate Y = X</p>
<p>Read sensor X</p>
<p><b>Figure 19:</b></p>
<p><b>Events in the ECU</b></p>
<p>Let’s have a look at the sequence in the ECU: When event E1 (= end of computation cycle) is </p>
<p>reached, then all parameters have been acquired and calculations have been made. This means </p>
<p>that  all  values  must  match  one  another  and  correlate  at  this  time  point.  This  means  that  we </p>
<p>use an event-synchronous measurement method. This is precisely what is implemented with the </p>
<p>help of the DAQ mechanism: When the algorithm in the Slave reaches the “Computational cycle </p>
<p>completed” event, the XCP Slave collects the values of the measurement parameters, saves them </p>
<p>in a buffer and sends them to the Master. This assumes that the Slave knows which parameters </p>
<p>should be measured for which event. </p>
<p>An event does not absolutely have to be a cyclic, time-equidistant event, rather in the case of </p>
<p>an engine controller, for example, it might be angle-synchronous. This makes the time inter-</p>
<p>val between two events dependent on the engine rpm. A singular event, such as activation of a </p>
<p>switch by the driver, is also an event that is not by any means equidistant in time. </p>
<p>The user selects the signals. Besides the actual measurement object, the user must select the </p>
<p>underlying event for the measurement parameters. The events as well as the possible assign-</p>
<p>ments of the measurement objects to the events must be stored in the A2L file.</p>
<p><b>Figure 20:  </b></p>
<p><b>Event definition  </b></p>
<p><b>in an A2L</b></p>
<h1 style="page-break-before:always; "></h1>
<p>36</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>In the normal case, it does not make any sense to be able to simultaneously assign a measured </p>
<p>value to multiple events. Generally, a parameter is only modified within a single cycle (e.g. only </p>
<p>at 10-ms intervals) and not in multiple cycles (e.g. at 10-ms and 100-ms intervals). </p>
<p> </p>
<p><b>Figure 21: </b></p>
<p><b>Allocation of </b></p>
<p><b>“Triangle” to possible </b></p>
<p><b>events in the A2L</b></p>
<p>Figure 21 shows that the “Triangle” parameter can in principle be measured with the 1 ms</p>
<p>,  </p>
<p>10 ms and 100 ms events. The default setting is 10 ms.</p>
<p>Measurement parameters are allocated to events in the ECU during measurement configuration </p>
<p>by the user.</p>
<p> </p>
<p><b>Figure 22: Selecting </b></p>
<p><b>events (measurement </b></p>
<p><b>mode) for each  </b></p>
<p><b>measurement parameter</b></p>
<p>After configuring the measured signals, the user starts the measurement. The XCP Master lists </p>
<p>the desired measurement parameters in what are known as DAQ lists. In these lists, the mea-</p>
<p>sured signals are each allocated to selected events. This configuration information is sent to the </p>
<p>Slave before the actual start of measurement. Then the Slave knows which addresses it should </p>
<p>read out and transmit when an event occurs. This distribution of the measurement into a con-</p>
<p>figuration phase and a measurement phase was already mentioned at the very beginning of this </p>
<p>chapter. </p>
<p>This solves both problems that occur in polling: bandwidth is used optimally, because the Mas-</p>
<p>ter no longer needs to poll each value individually during the measurement and the measured </p>
<p>values correlate with one another. </p>
<h1 style="page-break-before:always; "></h1>
<p>37</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p><b>Figure 23: Excerpt from the CANape Trace window of a DAQ measurement</b></p>
<p>Figure  23  illustrates  an  example  of  command-response  communication  (color  highlighting) </p>
<p>between Master and Slave (overall it is significantly more extensive and is only shown in part </p>
<p>here for reasons of space). This involves transmitting the DAQ configuration to the Slave. After-</p>
<p>wards, the measurement start is triggered and the Slave sends the requested values while the </p>
<p>Master just listens. </p>
<p>Until now, the selection of a signal was described based on its name and allocation to a mea-</p>
<p>surement event. But how exactly is the configuration transferred to the XCP Slave?</p>
<p>Let us look at the problem from the perspective of memory structure in the ECU: The user has </p>
<p>selected signals and wishes to measure them. So that sending a signal value does not require </p>
<p>the use of an entire message, the signals from the Slave are combined into message packets. The </p>
<p>Slave does not create this definition of the combination independently, or else the Master would </p>
<p>not be able to interpret the data when it received the messages. Therefore, the Slave receives </p>
<p>an instruction from the Master describing how it should distribute the values to the messages. </p>
<p>The sequence in which the Slave should assemble the bytes into messages is defined in what </p>
<p>are known as Object Description Tables (ODTs). The address and object length are important to </p>
<p>uniquely identify a measurement object. An ODT provides the allocations of RAM contents from </p>
<p>the Slave to assemble a message on the bus. According to the communication model, this mes-</p>
<p>sage is transmitted as a DAQ DTO (Data Transfer Object).</p>
<h1 style="page-break-before:always; "></h1>
<p>38</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>RAM Cells</p>
<p>ODT</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>...</p>
<p>...</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>PID</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p><b>Figure 24: </b></p>
<p><b>ODT: Allocation  </b></p>
<p><b>of RAM addresses  </b></p>
<p><b>to DAQ DTO</b></p>
<p>Stated more precisely, an entry in an ODT list references a memory area in RAM by the address </p>
<p>and length of the object. </p>
<p>After receiving the measurement start command, at some point an event occurs that is asso-</p>
<p>ciated  with  a  measurement.  The  XCP  Slave  begins  to  acquire  the  data.  It  combines  the  indi-</p>
<p>vidual objects into packets and sends them on the bus. The Master reads the bus message and </p>
<p>can interpret the individual data, because it has defined the allocation of individual objects to </p>
<p> </p>
<p>packets itself and therefore it knows their relationships. </p>
<p>However,  each  packet  has  a  maximum  number  of  useful  bytes,  which  depends  on  the  trans-</p>
<p>port medium that is used. In the case of CAN, this amounts to seven bytes. If more data needs </p>
<p>to be measured, an ODT is no longer sufficient. If two or more ODTs need to be used to trans-</p>
<p>mit the measured values, then the Slave must be able to copy the data into the correct ODT and </p>
<p>the Master must be able to uniquely identify the received ODTs. If multiple measurement inter-</p>
<p>vals of the ECU are used, the relationship between ODT and measurement interval must also be </p>
<p>uniquely identifiable. </p>
<h1 style="page-break-before:always; "></h1>
<p>39</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p>The ODTs are combined into DAQ lists in the XCP protocol. Each DAQ list contains a number of </p>
<p>ODTs and is assigned to an event.</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>...</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>...</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>ODT #0</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>address, length</p>
<p>...</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>PID=0</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>...</p>
<p>PID=1</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>...</p>
<p>PID=2</p>
<p>0</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>...</p>
<p>ODT #1</p>
<p>ODT #2</p>
<p><b>Figure 25: </b></p>
<p><b>DAQ list </b></p>
<p><b>with three ODTs</b></p>
<p>For example, if the user uses two measurement intervals (= two different events in the ECU), </p>
<p>then two DAQ lists are used as well. One DAQ list is needed per event used. Each DAQ list contains </p>
<p>the entries related to the ODTs and each ODT contains references to the values in the RAM cells.</p>
<p>DAQ lists are subdivided into the types: static, predefined and dynamic. </p>
<p><b>Static DAQ lists:</b></p>
<p>If the DAQ lists and ODT tables are permanently defined in the ECU, as is familiar from CCP, they </p>
<p>are referred to as static DAQ lists. There is no definition of which measurement parameters exist </p>
<p>in the ODT lists, rather only the framework that can be filled (in contrast to this, see predefined </p>
<p>DAQ lists).</p>
<p>In static DAQ lists, the definitions are set in the ECU code and are described in the A2L. Figure </p>
<p>26 shows an excerpt of an A2L, in which static DAQ lists are defined:</p>
<p><b>Figure 26: </b></p>
<p><b>Static DAQ lists</b></p>
<p>In the above example, there is a DAQ list with the number 0, which is allocated to a 10-ms event </p>
<p>and can carry a maximum of two ODTs. The DAQ list with the number 1 has four ODTs and is linked </p>
<p>to the 100 ms event.</p>
<h1 style="page-break-before:always; "></h1>
<p>40</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>The A2L matches the contents of the ECU. In the case of static DAQ lists, the number of DAQ lists </p>
<p>and the ODT lists they each contain are defined with the download of the application into the </p>
<p>ECU. If the user now attempts to measure more signals with an event than fit in the allocated </p>
<p>DAQ list, the Slave in the ECU will not be able to fulfill the requirements and the configuration </p>
<p>attempt is terminated with an error. It does not matter that the other DAQ list is still fully avail-</p>
<p>able and therefore actually still has transmission capacity.</p>
<p><b>Predefined DAQ lists:</b></p>
<p>Entirely predefined DAQ lists can also be set up in the ECU. However, this method is practically </p>
<p>never used in ECUs due to the lack of flexibility for the user. It is different for analog measure-</p>
<p>ment systems which transmit their data by XCP: Flexibility is unnecessary here, since the physi-</p>
<p>cal structure of the measurement system remains the same over its life.</p>
<p><b>Dynamic DAQ lists: </b></p>
<p>A special aspect of the XCP protocol are the dynamic DAQ lists. It is not the absolute parameters </p>
<p>of the DAQ and ODT lists that are permanently defined in the ECU code here, but just the param-</p>
<p>eters of the memory area that can be used for the DAQ lists. The advantage is that the measure-</p>
<p>ment tool has more latitude in putting together the DAQ lists  and it can manage the structure </p>
<p>of the DAQ lists dynamically.</p>
<p>Various functions especially designed for this dynamic management are available in XCP such as </p>
<p>ALLOC_ODT which the Master can use to define the structure of a DAQ list in the Slave.</p>
<p>DAQ0</p>
<p>DAQ1</p>
<p>MIN_DAQ + DAQ_COUNT</p>
<p>ODT_ENTERIES_COUNT</p>
<p>ALLOC_ODT</p>
<p>GRANULARITY_ODT_ENTRY_SIZE_DAQ</p>
<p>ODT_COUNT</p>
<p>ALL</p>
<p>O</p>
<p>C_ODT_ENTRY</p>
<p>ALLOC_</p>
<p>D</p>
<p>AQ</p>
<p><b>Figure 27: </b></p>
<p><b>Dynamic DAQ lists</b></p>
<p>In putting together the DAQ lists, the Master must be able to distinguish whether dynamic or </p>
<p>static DAQ lists are being used, how the parameters and structures of the DAQ lists look, etc.</p>
<h1 style="page-break-before:always; "></h1>
<p>41</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p><b>1.3.3 STIM Calibration Method</b></p>
<p>The XCP calibration method was already introduced in the chapter about exchanging CTOs. This </p>
<p>type of calibration exists in every XCP driver and forms the basis for calibrating objects in the </p>
<p>ECU. However, no synchronization exists between sending a calibration command and an event </p>
<p>in the ECU.</p>
<p>In contrast to this, the use of STIM is not based on exchanging CTOs, rather on the use of DTOs </p>
<p>with communication that is synchronized to an event in the Slave. The Master must therefore </p>
<p>know to which events in the Slave it can even synchronize at all. This information must also exist </p>
<p>in the A2L. </p>
<p><b>Figure 28: Event for DAQ and STIM</b></p>
<p>If the Master sends data to the Slave by STIM, the XCP Slave must be informed of the location in </p>
<p>the packets at which the calibration parameters can be found. The same mechanisms are used </p>
<p>here as are used for the DAQ lists.</p>
<h1 style="page-break-before:always; "></h1>
<p>42</p>
<p>1 Fundamentals of the XCP protocol</p>
<p><b>1.3.4 XCP Packet Addressing for DAQ and STIM </b></p>
<p>Addressing of the XCP packets was already discussed at the beginning of this chapter. Now that </p>
<p>the concepts of DAQ, ODT and STIM have been introduced, XCP packet addressing will be pre-</p>
<p>sented in greater detail. </p>
<p>During transmission of CTOs, the use of a PID is fully sufficient to uniquely identify a packet; </p>
<p>however,  this  is  no  longer  sufficient  for  transmitting  measured  values.  The  following  figure </p>
<p>offers an overview of the possible addressing that could occur with the DTOs:</p>
<p><b>XCP DTO Packet</b></p>
<p>PID</p>
<p>TS</p>
<p>FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>PID</p>
<p>PID</p>
<p>PID</p>
<p>DAQ</p>
<p>DAQ</p>
<p>TS</p>
<p>Identification Field</p>
<p>Timestamp Field</p>
<p>Data Field</p>
<p><b>Figure 29:  </b></p>
<p><b>Structure of the  </b></p>
<p><b>XCP packet for DTO </b></p>
<p><b>transmissions</b></p>
<p><b>Transmission type: “absolute ODT numbers”</b></p>
<p>Absolute means that the ODT numbers are unique throughout the entire communication – i.e. </p>
<p>across all DAQ lists. In turn, this means that the use of absolute ODT numbers assumes a trans-</p>
<p>formation step that utilizes a so-called “FIRST_PID for the DAQ list.</p>
<p>If a DAQ list starts with the PID j, then the PID of the first packet has the value j, the second </p>
<p>packet has the PID value j + 1, the third packet has the PID value j + 2, etc. Naturally, the Slave </p>
<p>must ensure here that the sum of FIRST_PID + relative ODT number remains below the PID of the </p>
<p>next DAQ list.</p>
<p>DAQ list: 0 </p>
<p>≤ PID ≤ k</p>
<p>DAQ list: k + 1 </p>
<p>≤ PID ≤ m</p>
<p>DAQ list: m + 1 ≤ PID ≤ n</p>
<p>etc.</p>
<h1 style="page-break-before:always; "></h1>
<p>43</p>
<p>1.3 Exchanging DTOs – Synchronous Data Exchange </p>
<p>In this case, the identification field is very simple:</p>
<p>Identification Field</p>
<p>absolute ODT number</p>
<p>PID</p>
<p><b>Figure 30: </b></p>
<p><b>Identification field </b></p>
<p><b>with absolute  </b></p>
<p><b>ODT numbers</b></p>
<p><b>Transmission type: “relative ODT numbers and absolute DAQ lists numbers”</b></p>
<p>In this case, both the DAQ lists number and the ODT number can be transmitted in the Identi-</p>
<p>fication Field. However, there is still space left over in the number of bytes that is available for </p>
<p>the information:</p>
<p>Identification Field</p>
<p>PID</p>
<p>DAQ</p>
<p>absolute DAQ List number</p>
<p>relative ODT number</p>
<p><b>Figure 31: </b></p>
<p><b>ID field with  </b></p>
<p><b>relative ODT and </b></p>
<p><b>absolute DAQ  </b></p>
<p><b>numbers (one byte)</b></p>
<p>In the figure, one byte is available for the DAQ number and one byte for the ODT number.</p>
<p>The maximum number of DAQ lists can be transmitted using two bytes: </p>
<p>Identification Field</p>
<p>PID</p>
<p>DAQ</p>
<p>absolute DAQ list number</p>
<p>relative ODT number</p>
<p><b>Figure 32: </b></p>
<p><b>ID field with  </b></p>
<p><b>relative ODT and </b></p>
<p><b>absolute DAQ  </b></p>
<p><b>numbers (two bytes)</b></p>
<h1 style="page-break-before:always; "></h1>
<p>44</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>If it is not possible to send three bytes, it is also possible to work with four bytes by using a fill </p>
<p>byte:</p>
<p>Identification Field</p>
<p>PID</p>
<p>FILL</p>
<p>DAQ</p>
<p>absolute DAQ list number</p>
<p>for alignement</p>
<p>relative ODT number</p>
<p><b>Figure 33: </b></p>
<p><b>ID field with relative </b></p>
<p><b>ODT and absolute DAQ </b></p>
<p><b>numbers as well as fill </b></p>
<p><b>byte (total of four bytes)</b></p>
<p>How does the XCP Master now learn which method the Slave is using? First, by the entry in the </p>
<p>A2L and second by the request to the Slave to determine which communication version it has </p>
<p>implemented.</p>
<p>The response to the GET_DAQ_PROCESSOR_INFO request also sets the DAQ_KEY_BYTE that the </p>
<p>Slave uses to inform the Master which transmission type is being used. If not only DAQ is being </p>
<p>used, but also STIM, the Master must use the same method for STIM that the Slave uses for DAQ.</p>
<p><b>1.3.5 Bypassing = DAQ + STIM </b></p>
<p>Bypassing can be implemented by joint use of DAQ and STIM (see Figure 8) and it represents </p>
<p>a  special  form  of  a  rapid  prototyping  solution.  For  a  deeper  understanding,  however,  further </p>
<p>details are necessary, so this method is not explained until chapter 4.5 “Bypassing”.</p>
<h1 style="page-break-before:always; "></h1>
<p>45</p>
<p>1.4 XCP Transport Layers</p>
<p><b>1.4 XCP Transport Layers </b></p>
<p>A main requirement in designing the protocol was that it must support different transport lay-</p>
<p>ers. At the time this document was defined, the following layers had been defined: XCP on CAN, </p>
<p>FlexRay,  Ethernet,  SxI  and  USB.  The  bus  systems  CAN,  LIN  and  FlexRay  are  explained  on  the  </p>
<p>Vector E-Learning platform, as well as an introduction to AUTOSAR. For details see the website </p>
<p>www.vector-elearning.com.</p>
<p><b>1.4.1 CAN </b></p>
<p>XCP  was  developed  as  a  successor  protocol  of  the  CAN  Calibration  Protocols  (CCP)  and  must </p>
<p>therefore absolutely satisfy the requirements of the CAN bus. The communication over the CAN </p>
<p>bus is defined by the associated description file. Usually the DBC format is used, but in some </p>
<p>isolated cases the AUTOSAR format ARXML is already being used. </p>
<p>A CAN message is identified by a unique CAN identifier. The communication matrix is defined in </p>
<p>the description file: Who sends which message and how are the eight useful bytes of the CAN bus </p>
<p>being used? The following figure illustrates the process: </p>
<p><b>Data</b></p>
<p><b>Frame</b></p>
<p>ID=0x12</p>
<p>Sender</p>
<p>Receiver</p>
<p>ID=0x34</p>
<p>ID=0x52</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Sender</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Sender</p>
<p>Sender</p>
<p>Receiver</p>
<p>Sender</p>
<p>Sender</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Receiver</p>
<p>Receiver</p>
<p>ID=0x67</p>
<p>ID=0xB4</p>
<p>ID=0x3A5</p>
<p><b>CAN</b></p>
<p><b>Node A</b></p>
<p><b>CAN</b></p>
<p><b>Node B</b></p>
<p><b>CAN</b></p>
<p><b>Node C</b></p>
<p><b>CAN</b></p>
<p><b>Node D</b></p>
<p><b>Figure 34: </b></p>
<p><b>Definition of which </b></p>
<p><b>bus nodes send </b></p>
<p><b>which messages</b></p>
<p>The message with ID 0x12 is sent by CAN node A and all other nodes on the bus receive this mes-</p>
<p>sage.  In  the  framework  of  acceptance  testing,  CAN  nodes  C  and  D  conclude  that  they  do  not </p>
<p>need the message and they reject it. CAN node B, on the other hand, determines that its higher-</p>
<p>level layers need the message and they provide them via the Rx buffer. The CAN nodes are inter-</p>
<p>linked as follows:</p>
<h1 style="page-break-before:always; "></h1>
<p>46</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>Host</p>
<p>Tx</p>
<p>Buffer</p>
<p>Rx</p>
<p>Buffer</p>
<p>CAN Interface</p>
<p><b>CAN Node A</b></p>
<p><b>CAN</b></p>
<p>Host</p>
<p>Receive</p>
<p>CAN Interface</p>
<p><b>CAN Node C</b></p>
<p>Host</p>
<p>Receive</p>
<p>Acceptance</p>
<p>Test</p>
<p>Rx</p>
<p>Buffer</p>
<p>Send</p>
<p>Tx</p>
<p>Buffer</p>
<p>CAN Interface</p>
<p><b>CAN Node D</b></p>
<p>Host</p>
<p>Tx</p>
<p>Buffer</p>
<p>Rx</p>
<p>Buffer</p>
<p>CAN Interface</p>
<p><b>CAN Node B</b></p>
<p>Acceptance</p>
<p>Test</p>
<p>Send</p>
<p>Rx</p>
<p>Buffer</p>
<p>Tx</p>
<p>Buffer</p>
<p>Receive</p>
<p>Receive</p>
<p>Acceptance</p>
<p>Test</p>
<p>Send</p>
<p>Send</p>
<p>Acceptance</p>
<p>Test</p>
<p><b>Figure 35: </b></p>
<p><b>Representation </b></p>
<p><b>of a CAN network</b></p>
<p>The XCP messages are not described in the communication matrix! If measured values are sent </p>
<p>from  the  Slave  via  dynamic  DAQ  lists,  e.g.  with  the  help  of  XCP,  the  messages  are  assembled </p>
<p>according to the signals selected by the user. If the signal selection changes, the message con-</p>
<p>tents change as well. Nonetheless, there is a relationship between the communication matrix </p>
<p>and XCP: CAN identifiers are needed to transmit the XCP messages over CAN. To minimize the </p>
<p>number of CAN identifiers used, the XCP communication is limited to the use of just two CAN </p>
<p>identifiers  that  are  not  being  used  in  the  DBC  for  “normal”  communication.  One  identifier  is </p>
<p>needed to send information from the Master to the Slave; the other is used by the Slave for the </p>
<p>response to the Master.</p>
<p>The excerpt from the CANape Trace window shows the CAN identifiers that are used under the </p>
<p>“ID” column. In this example, just two different identifiers are used: 554 as the ID for the mes-</p>
<p>sage from Master to Slave (direction Tx) and 555 for sending messages from the Slave to the </p>
<p>Master (direction Rx). </p>
<h1 style="page-break-before:always; "></h1>
<p>47</p>
<p>1.4 XCP Transport Layers</p>
<p><b>Figure 36: Example of XCP-on-CAN communication</b></p>
<p>In this example, the entire XCP communication is handled by the two CAN identifiers 554 and </p>
<p>555. These two IDs may not be allocated for other purposes in this network. </p>
<p>The CAN bus transmits a maximum of eight useful bytes per message. In the case of XCP, how-</p>
<p>ever, we need information on the command used or the sent response. This is provided in the </p>
<p>first byte of the CAN useful data. This means that seven bytes are available per CAN message for </p>
<p>transporting useful data. </p>
<p><b>Figure 37: Representation of an XCP-on-CAN message</b></p>
<p>XCP Packet</p>
<p>XCP Tail</p>
<p>Fill</p>
<p><b>XCP on CAN Message (Frame)</b></p>
<p>Control Field</p>
<p>for CAN</p>
<p>Control Field</p>
<p> empty for CAN</p>
<p>XCP Header</p>
<p>empty for CAN</p>
<p>PID</p>
<p>FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>In CANape, you will find an XCP-on-CAN demo with the virtual ECU XCPsim. You can learn about </p>
<p>more details of the standard in ASAM XCP on CAN Part 3 Transport Layer Specification.</p>
<h1 style="page-break-before:always; "></h1>
<p>48</p>
<p>1 Fundamentals of the XCP protocol</p>
<p><b>1.4.2 CAN FD</b></p>
<p>CAN  FD  (CAN  with  flexible  data  rate)  is  an  extension  of  the  CAN  protocol  developed  by </p>
<p>  </p>
<p>Robert Bosch GmbH. Its primary difference to CAN involves extending the useful data from 8 to </p>
<p> 64 bytes. CAN FD also offers the option of sending the useful data at a higher data rate. After </p>
<p>the  arbitration  phase,  the  data  bytes  are  sent  at  a  higher  transmission  rate  than  during  the </p>
<p>arbitration phase. This covers the need for greater bandwidth in automotive networks while pre-</p>
<p>serving valuable experience gained from CAN development.</p>
<p>The XCP-on-CAN-FD specification was defined in the XCP-on-CAN description of the XCP stan-</p>
<p>dard, Version 1.2.0 (June 2013). </p>
<p> </p>
<p><b>Figure 38: Illustration of a CAN FD frame</b></p>
<p>Despite the largely similar modes of operation, this protocol requires extensions and modifica-</p>
<p>tions to the hardware and software. Among other things, CAN FD introduces three new bits to </p>
<p>the control field:</p>
<p>&gt;  Extended Data Length (EDL)</p>
<p>&gt;  Bit Rate Switch (BRS) </p>
<p>&gt;  Error State Indicator (ESI)</p>
<h1 style="page-break-before:always; "></h1>
<p>49</p>
<p>1.4 XCP Transport Layers</p>
<p>A recessive EDL bit (High level) distinguishes frames in extended CAN-FD format from those in </p>
<p>standard CAN format, because they are identified by a dominant EDL bit (low level). Similarly, a </p>
<p>recessive BRS bit causes the transmission of the data field to be switched to the higher bit rate. </p>
<p>The ESI bit identifies the error state of a CAN FD node. Another four bits make up what is known </p>
<p>as the Data Length Code (DLC), which represents the extended useful data length as a possible </p>
<p>value of 12, 16, 20, 24, 32, 48 and 64 bytes. </p>
<p>The use of XCP on CAN FD assumes that a second transmission rate has been defined for the use-</p>
<p>ful data in the A2L file. This is fully transparent to the user, who gets a complete A2L parameter-</p>
<p>ization. A measurement configuration in the XCP master considers the maximum packet length, </p>
<p>and the user does not need to make any other settings. </p>
<p>CAN  FD  is  supported  in  CANape,  Version  12.0  and  higher.  Every  CAN  hardware  product  from </p>
<p> Vector which begins with “VN” supports the CAN FD transport protocol.</p>
<h1 style="page-break-before:always; "></h1>
<p>50</p>
<p>1 Fundamentals of the XCP protocol</p>
<p><b>1.4.3 FlexRay</b></p>
<p>A basic idea in the development of FlexRay was to implement a redundant system with deter-</p>
<p>ministic time behavior. The connection redundancy was achieved by using two channels: chan-</p>
<p>nel  A  and  channel  B.  If  multiple  FlexRay  nodes  (=  ECUs)  are  redundantly  interconnected  and </p>
<p>one branch fails, the nodes can switch over to the other channel to make use of the connection </p>
<p>redundancy. </p>
<p><b>Figure 39: Nodes K and L are redundantly interconnected</b></p>
<p>CH A</p>
<p>CH B</p>
<p>Node K</p>
<p>Node L</p>
<p>Node M</p>
<p>Node N</p>
<p>Node O</p>
<p>Deterministic behavior is achieved by transmitting data within defined time slots. Also defined </p>
<p>here is which node sends which content in which time slot. These time slots are combined to </p>
<p>form one cycle. The cycles repeat here, as long as the bus is active. The assembly of the time </p>
<p>slots and their transport contents (who sends what at which time) is known as Scheduling. </p>
<p>Frame: a</p>
<p>Frame: b</p>
<p>Frame: x</p>
<p>Frame: a</p>
<p>Frame: b</p>
<p>Frame: x</p>
<p>t1</p>
<p>Slot 1</p>
<p>Slot 2</p>
<p>Slot 3</p>
<p>Slot 1</p>
<p>Slot 2</p>
<p>...</p>
<p>Real-time</p>
<p>t2</p>
<p>t3</p>
<p>t4</p>
<p>t5</p>
<p>t6</p>
<p>Communication Cycle</p>
<p>Next Communication Cycle</p>
<p>x</p>
<p>Slot</p>
<p>1</p>
<p>3</p>
<p>Tx</p>
<p>Rx</p>
<p>a</p>
<p>Direction</p>
<p>Frame</p>
<p>Slot</p>
<p>1</p>
<p>3</p>
<p>Tx</p>
<p>Rx</p>
<p>a</p>
<p>b</p>
<p>Direction</p>
<p>Frame</p>
<p>Node K</p>
<p>Node L</p>
<p>Node M</p>
<p>Slot</p>
<p>1</p>
<p>3</p>
<p>Tx</p>
<p>Rx</p>
<p>x</p>
<p>Direction</p>
<p>Frame</p>
<p>a</p>
<p><b>Figure 40: Communication by slot definition</b></p>
<h1 style="page-break-before:always; "></h1>
<p>51</p>
<p>1.4 XCP Transport Layers</p>
<p>In the first communication cycle, node K sends frame a in slot 1. The scheduling is also stored in </p>
<p>the software of nodes L and M. Therefore, the contents of frame a are passed to the next higher </p>
<p>communication levels. </p>
<p>Scheduling is consolidated in  a  description  file.  This is not  a DBC  file,  as  in the  case  of  CAN, </p>
<p>rather it is a FIBEX file. FIBEX stands for “Field Bus Exchange Format” and could also be used </p>
<p>for other bus systems. However, its current use is practically restricted to the description of the </p>
<p>FlexRay bus. FIBEX is an XML format and the XCP-on-FlexRay specification relates to FIBEX Ver-</p>
<p>sion 1.1.5 and FlexRay specification Version 2.1.</p>
<p><b>ECU</b></p>
<p><b>6</b></p>
<p><b>0</b></p>
<p><b>1</b></p>
<p><b>2</b></p>
<p><b>3</b></p>
<p><b>4</b></p>
<p><b>5</b></p>
<p><b>63</b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> 7</p>
<p><b>Slot</b></p>
<p><b>Static Segment</b></p>
<p> 1</p>
<p>Node K</p>
<p>A</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>B</p>
<p>Node M</p>
<p>A</p>
<p>c  [rep : </p>
<p>4 ]</p>
<p>B</p>
<p> </p>
<p> 3</p>
<p>Node L</p>
<p>A</p>
<p>a </p>
<p>[rep : </p>
<p>1 ]</p>
<p>B</p>
<p>d </p>
<p>[rep : </p>
<p>1 ]</p>
<p><b>Dynamic Segment</b></p>
<p> 4</p>
<p>A</p>
<p>n  [rep : </p>
<p>1 ]</p>
<p>B</p>
<p>m </p>
<p>[rep : </p>
<p>1 ]</p>
<p> 5</p>
<p>Node M</p>
<p>A</p>
<p>r  [rep : </p>
<p>1 ]</p>
<p>B</p>
<p> </p>
<p> 6</p>
<p>Node L</p>
<p>A</p>
<p>B</p>
<p>o  [rep : </p>
<p>1 ]</p>
<p>A</p>
<p> u </p>
<p>[rep : </p>
<p>4 ]</p>
<p>B</p>
<p>Node O</p>
<p>Node N</p>
<p>Node L</p>
<p>A</p>
<p>B</p>
<p>Node O</p>
<p>A</p>
<p> </p>
<p>B</p>
<p>Node L</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>x </p>
<p>[rep : </p>
<p>2 ]</p>
<p> </p>
<p>a </p>
<p>[rep : </p>
<p>1 ]</p>
<p>d </p>
<p>[rep : </p>
<p>1 ]</p>
<p>n  [rep : </p>
<p>1 ]</p>
<p>m </p>
<p>[rep : </p>
<p>1 ]</p>
<p>r  [rep : </p>
<p>1 ]</p>
<p> </p>
<p>o  [rep : </p>
<p>1 ]</p>
<p>t  [rep : </p>
<p>2 ]</p>
<p> </p>
<p> </p>
<p>w </p>
<p>[rep : </p>
<p>4 ]</p>
<p>y </p>
<p>[rep : </p>
<p>4 ]</p>
<p> </p>
<p>a </p>
<p>[rep : </p>
<p>1 ]</p>
<p>d </p>
<p>[rep : </p>
<p>1 ]</p>
<p>n  [rep : </p>
<p>1 ]</p>
<p>m </p>
<p>[rep : </p>
<p>1 ]</p>
<p>r  [rep : </p>
<p>1 ]</p>
<p> </p>
<p>o  [rep : </p>
<p>1 ]</p>
<p>p </p>
<p>[rep : </p>
<p>4 ]</p>
<p> </p>
<p>v </p>
<p>[rep : </p>
<p>8 ]</p>
<p> </p>
<p> </p>
<p>a </p>
<p>[rep : </p>
<p>1 ]</p>
<p>d </p>
<p>[rep : </p>
<p>1 ]</p>
<p>n  [rep : </p>
<p>1 ]</p>
<p>m </p>
<p>[rep : </p>
<p>1 ]</p>
<p>r  [rep : </p>
<p>1 ]</p>
<p> </p>
<p>o  [rep : </p>
<p>1 ]</p>
<p>t  [rep : </p>
<p>2 ]</p>
<p> </p>
<p>c</p>
<p> </p>
<p>a </p>
<p>[rep : </p>
<p>1 ]</p>
<p>d </p>
<p>[rep : </p>
<p>1 ]</p>
<p>n  [rep : </p>
<p>1 ]</p>
<p>m </p>
<p>[rep : </p>
<p>1 ]</p>
<p>r  [rep : </p>
<p>1 ]</p>
<p> </p>
<p>o  [rep : </p>
<p>1 ]</p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>a </p>
<p>[rep : </p>
<p>1 ]</p>
<p>d </p>
<p>[rep : </p>
<p>1 ]</p>
<p>n  [rep : </p>
<p>1 ]</p>
<p>m </p>
<p>[rep : </p>
<p>1 ]</p>
<p>r  [rep : </p>
<p>1 ]</p>
<p> </p>
<p>o  [rep : </p>
<p>1 ]</p>
<p>t  [rep : </p>
<p>2 ]</p>
<p> </p>
<p> </p>
<p>w </p>
<p>[rep : </p>
<p>4 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>x </p>
<p>[rep : </p>
<p>2 ]</p>
<p> </p>
<p>a </p>
<p>[rep : </p>
<p>1 ]</p>
<p>d </p>
<p>[rep : </p>
<p>1 ]</p>
<p>n  [rep : </p>
<p>1 ]</p>
<p>m </p>
<p>[rep : </p>
<p>1 ]</p>
<p>r  [rep : </p>
<p>1 ]</p>
<p> </p>
<p>o  [rep : </p>
<p>1 ]</p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Cycles</b></p>
<p><b>Channel</b></p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>y </p>
<p>[rep : </p>
<p>4 ]</p>
<p> </p>
<p>a </p>
<p>[rep : </p>
<p>1 ]</p>
<p>d </p>
<p>[rep : </p>
<p>1 ]</p>
<p>n  [rep : </p>
<p>1 ]</p>
<p>m </p>
<p>[rep : </p>
<p>1 ]</p>
<p>r  [rep : </p>
<p>1 ]</p>
<p> </p>
<p>o  [rep : </p>
<p>1 ]</p>
<p>p </p>
<p>[rep : </p>
<p>4 ]</p>
<p> </p>
<p> </p>
<p>c  [rep : </p>
<p>4 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p> u </p>
<p>[rep : </p>
<p>4 ]</p>
<p>x </p>
<p>[rep : </p>
<p>2 ]</p>
<p>t  [rep : </p>
<p>2 ]</p>
<p><b>...</b></p>
<p>b </p>
<p>[rep : </p>
<p>1 ]</p>
<p>x </p>
<p>[rep : </p>
<p>2 ]</p>
<p>Node K</p>
<p> 2</p>
<p><b>Figure 41: Representation of a FlexRay communication matrix </b></p>
<p>Another format for describing bus communication has been defined as a result of the develop-</p>
<p>ment of AUTOSAR solutions: the AUTOSAR Description File, which is available in XML format. The </p>
<p>definition of XCP-on-FlexRay was taken into account in the AUTOSAR 4.0 specification. However, </p>
<p>at the time of publication of this book this specification has not yet been officially approved and </p>
<p>therefore it will not be discussed further.  </p>
<p>Due to other properties of the FlexRay bus, it is not sufficient to just give the slot number as </p>
<p>a reference to the contents. One reason is that multiplexing is supported: whenever a cycle is </p>
<p>repeated,  the  transmitted  contents  are  not  necessarily  the  same.  Multiplexing  might  specify </p>
<p>that a certain piece of information is only sent in the slot in every second pass. </p>
<h1 style="page-break-before:always; "></h1>
<p>52</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>Instead of indicating the pure slot number, “FlexRay Data Link Layer Protocol Data Unit Identi-</p>
<p>fiers” (FLX_LPDU_ID) are used, which can be understood as a type of generalized Slot ID. Four </p>
<p>pieces of information are needed to describe such an LPDU:</p>
<p>&gt;  FlexRay Slot Identifier (FLX_SLOT_ID)</p>
<p>&gt;  Cycle Counter Offset (OFFSET)</p>
<p>&gt;  Cycle Counter Repetition (CYCLE_REPETITION)</p>
<p>&gt;  FlexRay Channel (FLX_CHANNEL)</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>.</p>
<p> .</p>
<p>  .</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>.</p>
<p> .</p>
<p>  .</p>
<p><b>LPDU_ID</b></p>
<p>Slot ID</p>
<p>Channel A</p>
<p>Channel B</p>
<p>Cycle ID</p>
<p><b>Figure 42: </b></p>
<p><b>Representation of  </b></p>
<p><b>the FlexRay LPDUs</b></p>
<p>Scheduling also has effects on the use of XCP on FlexRay, because it defines what is sent pre-</p>
<p>cisely. This cannot be readily defined in XCP; not until the measurement runtime does the user </p>
<p>define which measured values are sent by assembling signals. This means that it is only possible </p>
<p>to choose which aspect of XCP communication can be used in which LPDU: CTO or DTO from Mas-</p>
<p>ter to Slave or from Slave to Master.</p>
<p>The following example illustrates this process: the XCP Master may send a command (CMD) in </p>
<p>slot n and Slave A gives the response (RES) in slot n + 2. XCP-on-FlexRay messages are always </p>
<p>defined using LPDUs.</p>
<p>The A2L description file is needed for access to internal ECU parameters; the objects with their </p>
<p>addresses in the ECU are defined in this file. In addition, the FIBEX file is necessary, so that </p>
<p>the XCP Master knows which LPDUs it may send and to which LPDUs the XCP Slaves send their </p>
<p>responses.  Communication  between  XCP  Master  and  XCP  Slave(s)  can  only  function  through </p>
<p>combination of the two files, i.e. by having an A2L file reference a FIBEX file.</p>
<h1 style="page-break-before:always; "></h1>
<p>53</p>
<p>1.4 XCP Transport Layers</p>
<p>Excerpt of an A2L with XCP-on-FlexRay parameter setting:</p>
<p> </p>
<p> </p>
<p>…</p>
<p>/begin XCP_ON_FLX</p>
<p> </p>
<p> </p>
<p>… </p>
<p>„XCPsim.xml“</p>
<p>„Cluster_1“</p>
<p> </p>
<p> </p>
<p>…</p>
<p>In this example, “XCPsim.xml” is the reference from the A2L file to the FIBEX file. </p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>.</p>
<p> .</p>
<p>  .</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>...</p>
<p>.</p>
<p> .</p>
<p>  .</p>
<p><b>XCP-dedicated LPDU_IDs</b></p>
<p>Channel A</p>
<p>Channel B</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>.</p>
<p>Cycle ID</p>
<p>Slot ID</p>
<p><b>Figure 43: </b></p>
<p><b>Allocation of  </b></p>
<p><b>XCP communication </b></p>
<p><b>to LPDUs</b></p>
<p>You can read more details about XCP on FlexRay in CANape’s online Help. Supplied with CANape </p>
<p>is the FIBEX Viewer, which lets users conveniently view the scheduling. It is easy to allocate the </p>
<p>XCP messages to the LPDUs by making driver settings for the XCP-on-FlexRay device in CANape.</p>
<p>The protocol is explained in detail in ASAM XCP on FlexRay Part 3 Transport Layer Specification. </p>
<p>You will find an XCP-on-FlexRay demo in CANape with the virtual ECU XCPsim. The demo requires </p>
<p>real Vector FlexRay hardware.</p>
<p><b>1.4.4 Ethernet</b></p>
<p>XCP on Ethernet can be used with either TCP/IP or UDP/IP. TCP is a protected transport protocol </p>
<p>on Ethernet, in which the handshake method is used to detect any loss of a packet. In case of </p>
<p>packet loss, TCP organizes a repetition of the packet. UDP does not offer this protection mech-</p>
<p>anism. If a packet is lost, UDP does not offer any mechanisms for repeated sending of the lost </p>
<p>packet on the protocol level. </p>
<p>Not only can XCP on Ethernet be used with real ECUs, it can also be used for measurement and </p>
<p>calibration of virtual ECUs. Here, a virtual ECU is understood as the use of code that would other-</p>
<p>wise run in the ECU as an executable program (e.g. DLL) on the PC. Entirely different resources </p>
<p>are available here compared to an ECU (CPU, memory, etc.). </p>
<h1 style="page-break-before:always; "></h1>
<p>54</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>But first the actual protocol will be discussed. IP packets always contain the addresses of the </p>
<p>sender and receiver. The simplest way to visualize an IP packet is as a type of letter that contains </p>
<p>the addresses of the recipient and the sender. The addresses of individual nodes must always be </p>
<p>unique. A unique address comprises the IP address and port number. </p>
<p><b>Figure 44: XCP packet with TCP/IP or UDP/IP</b></p>
<p>XCP Header</p>
<p>XCP Packet</p>
<p>LEN</p>
<p>CTR</p>
<p><b>XCP on Ethernet (TCP/IP and UDP/IP) Message (Frame)</b></p>
<p>Length (LEN)</p>
<p>Control Field</p>
<p>for Ethernet</p>
<p>(TCP/ IP and UDP/IP)  </p>
<p>Control Field</p>
<p>empty for Ethernet</p>
<p>(TCP&amp;IP and UDP&amp;IP)</p>
<p>XCP Tail</p>
<p>empty for Ethernet</p>
<p>(TCP/IP and UDP/IP)</p>
<p>PID FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>The header consists of a Control Field with two words in Intel format (= four bytes). These words </p>
<p>contain  the  length  (LEN)  and  a  counter  (CTR).  LEN  indicates  the  number  of  bytes  in  the  XCP </p>
<p>packet. The CTR is used to detect the packet loss. UDP/IP is not a protected protocol. If a packet </p>
<p>is lost, this is not recognized by the protocol layer. Packet loss is monitored by counter infor-</p>
<p>mation. When the Master sends its first message to the Slave, it generates a counter number </p>
<p>that is incremented with each additional transmission of a frame. The Slave responds with the </p>
<p>same pattern: It increments its own counter with each frame that it sends. The counters of the </p>
<p>Slave and the Master operate independently of one another. UDP/IP is well suited for sending </p>
<p>measured values. If a packet is lost, then the measured values it contains are lost, resulting in </p>
<p>a measurement gap. If this occurs infrequently, the loss might just be ignored. But if the mea-</p>
<p>sured data is to be used as the basis for fast control, it might be advisable to use TCP/IP.</p>
<p>An Ethernet packet can transport multiple XCP packets, but an XCP packet may never exceed the </p>
<p>limits of a UDP/IP packet. In the case of XCP on Ethernet, there is no “Tail”, i.e. an empty con-</p>
<p>trol field.</p>
<p>You will find more detailed information on the protocol in ASAM XCP on Ethernet Part 3 Trans-</p>
<p>port Layer Specification. In CANape, you will also find an XCP on Ethernet demo with the virtual </p>
<p>ECU XCPsim or with virtual ECUs in the form of DLLs, which have been implemented by Simulink </p>
<p>models and the Simulink Coder.</p>
<h1 style="page-break-before:always; "></h1>
<p>55</p>
<p>1.4 XCP Transport Layers</p>
<p><b>1.4.5 SxI </b></p>
<p>SxI is a collective term for SPI or SCI. Since they are not buses, but instead are controller inter-</p>
<p>faces which are only suited for point-to-point connections, there is no addressing in this type </p>
<p>of  transmission.  The  communication  between  any  two  nodes  runs  either  synchronously  or </p>
<p>asynchronously.</p>
<p><b>Figure 45: XCP-on-SxI packet</b></p>
<p>XCP Header</p>
<p>XCP Packet</p>
<p>LEN</p>
<p>CTR</p>
<p>FILL</p>
<p>CS</p>
<p>XCP Tail</p>
<p><b>XCP on Sxl Message (Frame)</b></p>
<p>Length (LEN)</p>
<p>Checksum (CS)</p>
<p>Control Field</p>
<p>for SxI </p>
<p>Control Field</p>
<p>for SxI</p>
<p>PID FILL</p>
<p>DAQ</p>
<p>TIMESTAMP</p>
<p>DATA</p>
<p>The XCP header consists of a control field with two pieces of information: the length LEN and </p>
<p>the counter. The length of these parameters may be in bytes or words (Intel format). LEN indi-</p>
<p>cates the number of bytes of the XCP packet. The CTR is used to detect the loss of a packet. This </p>
<p>is monitored in the same way as for XCP on Ethernet: with counter information. Under certain </p>
<p>circumstances it may be necessary to add fill bytes to the packet, e.g. if SPI is used in WORD or </p>
<p>DWORD mode or to avoid the message being shorter than the minimal packet length. These fill </p>
<p>bytes are appended in the control field.</p>
<p>You will find more detailed  information  on  the protocol  in  ASAM  XCP  on  SxI Part  3 Transport </p>
<p>Layer Specification.</p>
<p><b>1.4.6 USB </b></p>
<p>Currently, XCP on USB has no practical significance. Therefore, no further mention will be made </p>
<p>of this topic; rather we refer you to ASAM documents that describe the standard: ASAM XCP on </p>
<p>USB Part 3 Transport Layer Specification.</p>
<p><b>1.4.7 LIN </b></p>
<p>At this time, ASAM has not yet defined an XCP-on-LIN standard. However, a solution exists from </p>
<p>Vector (XCP-on-LIN driver and CANape as XCP-on-LIN Master), which violates neither the LIN nor </p>
<p>the XCP specification and is already being used on some customer projects. For more detailed </p>
<p>information, please contact Vector.</p>
<h1 style="page-break-before:always; "></h1>
<p>56</p>
<p>1 Fundamentals of the XCP protocol</p>
<p><b>1.5 XCP Services</b></p>
<p>This chapter contains a listing and explanation of other services that can be realized over XCP. </p>
<p>They are all based on the already described mechanisms of communication with the help of CTOs </p>
<p>and DTOs. Some XCP services have already been explained, e.g. synchronous data acquisition/</p>
<p>stimulation and read/write access to device memory. </p>
<p>The  XCP  specification  does  indeed  uniquely  define  the  different  services;  at  the  same  time  it </p>
<p>indicates  whether  the  service  always  needs  to  be  implemented  or  whether  it  is  optional.  For </p>
<p>example, an XCP Slave must support “Connect” for the Master to set up a connection. On the </p>
<p>other hand, flashing over XCP is not absolutely necessary and the XCP Slave does not need to </p>
<p>support it. This simply depends on the requirements of the project and the software. All of the </p>
<p>services described in this chapter are optional. </p>
<p><b>1.5.1 Memory Page Swapping </b></p>
<p>As already explained in the description of calibration concepts, parameters are normally located </p>
<p>in flash memory and are copied to RAM as necessary. Some calibration concepts offer the option </p>
<p>of swapping memory segment pages from RAM and Flash. XCP describes a somewhat more gen-</p>
<p>eral,  generic  approach,  in  which  a  memory  segment  may  contain  multiple  swappable  pages. </p>
<p>Normally, this consists of a RAM page and a flash page. But multiple RAM pages or the lack of a </p>
<p>flash page are conceivable as well. </p>
<p>For a better understanding of the XCP commands for page swapping, the concepts of sector, seg-</p>
<p>ment and page will be explained once again at this point.</p>
<p>Segment 0</p>
<p>Page 0</p>
<p>Sector 2</p>
<p>Sector 1</p>
<p>Sector 0</p>
<p>Segmemt 0</p>
<p>Segment 1</p>
<p>Page 0</p>
<p>Segment 1</p>
<p>Page 1</p>
<p>Segment 1</p>
<p>Page 2</p>
<p>Segmemt 1</p>
<p>ECU access</p>
<p>address</p>
<p>XCP access</p>
<p><b>Figure 46: </b></p>
<p><b>Memory </b></p>
<p><b>representation</b></p>
<h1 style="page-break-before:always; "></h1>
<p>57</p>
<p>1.5 XCP Services</p>
<p>From  an  XCP  perspective,  the  memory  of  a  Slave  consists  of  a  continuous  memory  that  is </p>
<p>addressed with a 40-bit width. The physical layout of the memory is based on sectors. Know-</p>
<p>ledge of the flash sectors is absolutely necessary in flashing, because the flash memory can only </p>
<p>be erased a block at a time. </p>
<p>The logical structure is based on what are known as segments; they describe where calibration </p>
<p>data is located in memory. The start address and parameters of a segment do not have to be </p>
<p>aligned with the start addresses and parameters of the physical sectors. Each segment can be </p>
<p>subdivided into multiple pages. The pages of a segment describe the same parameters at the </p>
<p>same addresses. The values of these parameters and read/write rights can be controlled indi-</p>
<p>vidually for each page. </p>
<p>The allocation of an algorithm to a page within a segment must always be unique. Only one page </p>
<p>may be active in a segment at any given time. This page is known as the “active page for the </p>
<p>ECU in this segment.” The particular page that the ECU and the XCP driver actively access can be </p>
<p>individually switched. No interdependency exists between these settings. Similar to the nam-</p>
<p>ing convention for the ECU, the active page for XCP access is referred to as the “active page for </p>
<p>XCP access in this segment”. </p>
<p>In turn, this applies to each individual segment. Segments must be listed in the A2L file and </p>
<p>each segment gets a number that is used to reference the segment. Within an XCP Slave, the </p>
<p>SEGMENT_NUMBER must always begin at 0 and it is then incremented in consecutive numbers. </p>
<p>Each segment has at least one page. The pages are also referenced by numbers. The first page </p>
<p>is PAGE 0. One byte is available for the number, so that a maximum of 255 pages can be defined </p>
<p>per segment. </p>
<p>The Slave must initialize all pages for all segments. The master uses the command GET_CAL_PAGE </p>
<p>to  ask  the  Slave  which  page  is  currently  active  for  the  ECU  and  which  page  for  XCP  access.  It </p>
<p>can certainly be the case that mutual blocking may be necessary for the accesses. For exam-</p>
<p>ple, the XCP Slave may not access a page, if this page is currently active for the ECU. As men-</p>
<p>tioned, there may be a dependency – but not necessarily. It is a question of how the Slave has </p>
<p>been implemented. </p>
<p>If  the  Slave  supports  the  optional  commands  GET_CAL_PAGE  and  SET_CAL_PAGE,  then  it  also </p>
<p>supports what is known as page swapping. These two commands let the Master poll which pages </p>
<p>are currently being used and if necessary it can swap pages for the ECU and XCP access. The XCP </p>
<p>Master has full control over swapping of pages. The XCP Slave cannot initiate swapping by itself. </p>
<p>But naturally the Master must respect any restrictions of the Slave implementation. </p>
<p>What is the benefit of swapping?</p>
<p>First, swapping permits very quick changing of entire parameter sets – essentially a before-and-</p>
<p>after  comparison.  Second,  the  plant  remains  in  a  stable  state,  while  the  calibrator  performs </p>
<p>extensive parameter changes on another page in the ECU. This prevents the plant from going </p>
<p>into a critical or unstable state, e.g. due to incomplete datasets during parameter setting. </p>
<h1 style="page-break-before:always; "></h1>
<p>58</p>
<p>1 Fundamentals of the XCP protocol</p>
<p><b>1.5.2 Saving Memory Pages – Data Page Freezing </b></p>
<p>When a calibrator calibrates parameters on a page, there is the conceptual ability in XCP to save </p>
<p>the data directly in the ECU. This involves saving the data of a RAM page to a page in nonvola-</p>
<p>tile memory. If the nonvolatile memory is flash, it must be taken into account that the segment </p>
<p>start address and the segment size might not necessarily agree with the flash sectors, which </p>
<p>represents a problem in erasing and rewriting the flash memory (see ASAM XCP Part 2 Protocol </p>
<p>Layer Specification).</p>
<p><b>1.5.3 Flash Programming </b></p>
<p>Flashing means writing data in an area of flash memory. This requires precise knowledge of how </p>
<p>the memory is laid out. A flash memory is subdivided into multiple sectors (physical sections), </p>
<p>which are described by a start address and a length. To distinguish them from one another, they </p>
<p>each get a consecutive identification number. One byte is available for this number, resulting in </p>
<p>a maximum of 255 sectors. </p>
<p>SECTOR_NUMBER [0, 1, 2 … 255]</p>
<p>The information about the flash sectors is also part of the A2L data set.</p>
<p><b>Figure 47: </b></p>
<p><b>Representation </b></p>
<p><b>of driver settings  </b></p>
<p><b>for the flash area</b></p>
<h1 style="page-break-before:always; "></h1>
<p>59</p>
<p>1.5 XCP Services</p>
<p>Flashing can be implemented using what are referred to as “flash kernels”. A flash kernel is exe-</p>
<p>cutable code that is sent to the Slave’s RAM area before the actual flashing; the kernel then han-</p>
<p>dles communication with the XCP Master. It might contain the algorithm that is responsible for </p>
<p>erasing the flash memory. For security and space reasons, very frequently this code is not per-</p>
<p>manently stored in the ECU’s flash memory. Under some circumstances, a converter might be </p>
<p>used, e.g. if checksum or similar computations need to be performed.</p>
<p>Flashing with XCP roughly subdivides the overall flash process into three areas:</p>
<p>&gt;   Preparation (e.g. for version control and therefore to check whether the new contents</p>
<p> </p>
<p>can even be flashed)</p>
<p>&gt;  Execution (the new contents are sent to the ECU) </p>
<p>&gt;  Post-processing (e.g. checksum checking etc.)</p>
<p>In  the  XCP  standard,  the  primary  focus  is  directed  to  the  actual  execution  of  flashing.  Any-</p>
<p>one  who  compares  this  operation  to  flashing  over  diagnostic  protocols  will  discover  that  the </p>
<p>process-specific  elements,  such  as  serial  number  handling  with  meta-data,  are  supported  in </p>
<p>a rather spartan fashion in XCP. Flashing in the development phase was clearly the main focus </p>
<p>in its definition and not the complex process steps that are necessary in end-of-line flashing.</p>
<p>Therefore,  what  is  important  in  the  preparation  phase  is  to  determine  whether  the  new  con-</p>
<p>tents are even relevant to the ECU. There are no special commands for version control. Rather </p>
<p>the practice has been to support those commands specific to the project. </p>
<p>The following XCP commands are available:</p>
<p>PROGRAM_START: Beginning of the flash procedure</p>
<p>This command indicates the beginning of the flash process. If the ECU is in a state that does not </p>
<p>permit flashing (e.g. vehicle speed &gt; 0), the XCP Slave must acknowledge with an ERRor. The </p>
<p>actual flash process may not  begin  until the  PROGRAM_START has been successfully  acknowl-</p>
<p>edged by the Slave.</p>
<p>PROGRAM_CLEAR: Call the current flash memory erasing routine </p>
<p>Before flash memory can be overwritten with new contents, it must first be cleared. The call of </p>
<p>the erasing routine via this command must be implemented in the ECU or be made available to </p>
<p>the ECU with the help of the flash kernel.</p>
<p>PROGRAM_FORMAT: Select the data format for the flash data </p>
<p>The XCP Master uses this command to define the format (e.g. compressed or encrypted) in which </p>
<p>the data are transmitted to the Slave. If the command is not sent, the default setting is non-</p>
<p>compressed and non-encrypted transmission.</p>
<p>PROGRAM: Transfer the data to the XCP Slave</p>
<p>For the users who are very familiar with flashing via diagnostics: this command corresponds to </p>
<p>TRANSFERDATA in diagnostics. Using this command, data is transmitted to the XCP Slave, which </p>
<p>is then stored in flash memory.</p>
<h1 style="page-break-before:always; "></h1>
<p>60</p>
<p>1 Fundamentals of the XCP protocol</p>
<p>PROGRAM_VERIFY: Request to check the new flash contents</p>
<p>The Master can request that the Slave perform an internal check to determine whether the new </p>
<p>contents are OK. </p>
<p>PROGRAM_RESET: Reset request to the Slave</p>
<p>Request by the Master to the Slave to execute a Reset. Afterwards, the connection to the Slave </p>
<p>is always terminated and a new CONNECT must be sent.</p>
<p><b>1.5.4 Automatic Detection of the Slave </b></p>
<p>The XCP protocol lets the Master poll the Slave about its protocol-specific properties. A number </p>
<p>of commands are available for this.</p>
<p>GET_COMM_MODE_INFO</p>
<p>The response to this command gives the Master information about the various communication </p>
<p>options of the Slave, e.g. whether it supports block transfer or interleaved mode or which mini-</p>
<p>mum time intervals the Master must maintain between Requests in these modes. </p>
<p>GET_STATUS</p>
<p>The response to this request returns all current status information of the Slave. Which resources </p>
<p>(calibration,  flashing,  measurement,  etc.)  are  supported?  Are  any  types  of  memory  activities </p>
<p>(DAQ  list  configuration,  etc.)  still  running  currently?  Are  DTOs  (DAQ,  STIM)  being  exchanged </p>
<p>right now?</p>
<p>GET_DAQ_PROCESSOR_INFO</p>
<p>The Master gets general information, which it needs to know about the Slave limitations: num-</p>
<p>ber of predefined DAQ lists, available DAQ lists and events, etc.</p>
<p>GET_DAQ_RESOLUTION_INFO</p>
<p>Other information about the DAQ capabilities of the Slave is exchanged via this command: max-</p>
<p>imum number of parameters for an ODT for DAQ and for STIM, granularity of the ODT entries, </p>
<p>number of bytes in time stamp transmission, etc.</p>
<p>GET_DAQ_EVENT_INFO</p>
<p>When this command is used, the call is made once per ECU event. Information is transmitted </p>
<p>here on whether the event can be used for DAQ, STIM or DAQ/STIM, whether the event occurs </p>
<p>periodically and if so which cycle time it has, etc.</p>
<h1 style="page-break-before:always; "></h1>
<p>61</p>
<p>1.5 XCP Services</p>
<p><b>1.5.5 Block Transfer Mode for Upload, Download and Flashing </b></p>
<p>In  the  “normal”  communication  mode,  each  command  from  the  Master  is  acknowledged  by  a </p>
<p>response of the Slave. However, in some cases it may be desirable, for performance reasons, to </p>
<p>use what is referred to as the block transfer mode. </p>
<p>Time</p>
<p>Master</p>
<p>Slave</p>
<p>Response k</p>
<p>Request k+1</p>
<p>Request k</p>
<p>Part1</p>
<p>Part3</p>
<p>Part2</p>
<p>MIN_ST</p>
<p>MAX_BS</p>
<p><b>Figure 48: </b></p>
<p><b>Representation  </b></p>
<p><b>of the block  </b></p>
<p><b>transfer mode</b></p>
<p>The use of such a method accelerates the procedure when transmitting large amounts of data </p>
<p>(UPLOAD, SHORT_UPLOAD, DOWNLOAD, SHORT_DOWNLOAD and PROGRAM). The Master can find </p>
<p>out whether the Slave supports this method with the request GET_COMM_MODE_INFO. You will </p>
<p>find more on this in ASAM XCP Part 2 Protocol Layer Specification.</p>
<h1 style="page-break-before:always; "></h1>
<p>62</p>
<p>1 Fundamentals of the XCP protocol</p>
<p><b>1.5.6 Cold Start Measurement (start of measurement during power-on) </b></p>
<p>Even with the capabilities of XCP described to this point, it would be impossible to implement </p>
<p>an event-driven measurement that can in practice be executed early in the ECU’s start phase. </p>
<p>The reason is that the measurement must be configured before the actual measurement takes </p>
<p>place. If one attempts to do this, the ECU’s start phase has long been over by the time the first </p>
<p>measured values are transmitted. The approach that is used to overcome this problem is based </p>
<p>on a simple idea. </p>
<p>It  involves  separating  the  configuration  and  the  measurement  in  time.  After  the  configura-</p>
<p>tion phase, the measurement is not started immediately; rather the ECU is shut down. After a </p>
<p>reboot,  the  XCP  Slave  accesses  the  existing  configuration  directly  and  immediately  begins  to </p>
<p>send the first messages. The difficulties associated with this are obvious: the configuration of </p>
<p>the DAQ lists is stored in RAM, and therefore the information no longer exists after a reboot. </p>
<p>To enable what is known as the RESUME mode to enable a Cold Start Measurement, a nonvolatile </p>
<p>memory is needed in the XCP Slave which preserves its data even when it is not being supplied </p>
<p>with power. EEPROMs are used in this method. In this context, it is irrelevant whether it is a real </p>
<p>EEPROM or one that is emulated by a flash memory.</p>
<p>You  will  find  more  details  in  ASAM  XCP  Part  1  Overview  Specification  in  the  chapter  1.4.2.2 </p>
<p>“Advanced Features”.</p>
<h1 style="page-break-before:always; "></h1>
<p>63</p>
<p>1.5 XCP Services</p>
<p><b>1.5.7 Security Mechanisms with XCP </b></p>
<p>An unauthorized user should be prevented as much as possible from being able to make a con-</p>
<p>nection to an ECU. The “seed &amp; key” method is available for checking whether or not a connec-</p>
<p>tion  attempt  is  authorized.  The  three  different  access  types  can  be  protected  by  seed  &amp;  key: </p>
<p>measurement / stimulation, calibration and flashing.</p>
<p>The “seed &amp; key” method operates as follows: in the connect request by the Master, the Slave </p>
<p>sends a random number (= seed) to the Master. Now, the Master must use an algorithm to gen-</p>
<p>erate  a  response  (=  key).  The  key  is  sent  to  the  Slave.  The  Slave  also  computes  the  expected </p>
<p>response and compares the key of the Master with its own result. If the two results agree, both </p>
<p>the Master and Slave have used the same algorithm. Then the Slave accepts the connection to </p>
<p>the Master. If there is no agreement, the Slave declines communication with the Master.</p>
<p>Normally, the algorithm is available as a DLL in the Master. So, if a user has the “seed &amp; key” </p>
<p>DLL and the A2L file, nothing stands in the way of accessing the ECU’s memory. When the ECU </p>
<p>is approaching a production launch, the XCP driver is often deactivated. A unique sequence of </p>
<p>individual  diagnostic  commands  is  usually  used  to  restore  XCP  access  to  the  ECU.  This  makes </p>
<p>the  XCP  driver  largely  available  even  in  production  vehicles,  but  it  is  normally  deactivated  to </p>
<p>protect  against  unauthorized  manipulation  of  the  ECU  (see  ASAM  XCP  Part  2  Protocol  Layer </p>
<p>Specification). </p>
<p>Whether or not seed &amp; key or deactivation of the XCP driver is used in a project is implementa-</p>
<p>tion-specific and independent of the XCP specification. </p>
<h1 style="page-break-before:always; "></h1>
<p>64</p>
<h1 style="page-break-before:always; "></h1>
<p>65</p>
<p>2 ECU Description File A2L</p>
<p><b>2 ECU Description File A2L</b></p>
<h1 style="page-break-before:always; "></h1>
<p>66</p>
<p>2 ECU Description File A2L</p>
<p>One reason why an A2L file is needed has already been named: to allocate symbolic names to </p>
<p>addresses. For example, if a software developer has implemented a PID controller and assigned </p>
<p>the names P1, I1 and D1 in his application for the proportional, integral and differential compo-</p>
<p>nents, then the calibrator should be able to access these parameters with their symbolic names. </p>
<p>Let us take the following figure as an example:</p>
<p><b>Figure 49: </b></p>
<p><b>Parameters in  </b></p>
<p><b>a calibration window</b></p>
<p>The user can conveniently modify values using symbolic names. Another example is provided by </p>
<p>viewing signal variables that are measured from the ECU:</p>
<p><b>Figure 50: Signal response over time </b></p>
<p> </p>
<p>In the legend, the user can read the logical names of the signals. The addresses at which the </p>
<p>parameters were located in the ECU are of secondary importance in the offline analysis of val-</p>
<p>ues. Naturally, the correct address is needed to request the values in the ECU, but the numeric </p>
<p>value of the address itself is of no importance to the user. The user uses the logical name for </p>
<p>selection and visualization purposes. That is, the user selects the object by its name and the XCP </p>
<p>Master looks for the associated address and data type in the A2L.</p>
<h1 style="page-break-before:always; "></h1>
<p>67</p>
<p>2 ECU Description File A2L</p>
<p>Another attribute of a parameter might be the definition of a minimum or maximum value. The </p>
<p>value of the object would then have to lie within these limits. Imagine that you as the software </p>
<p>developer define a parameter that has a direct effect on a power output stage. You must now </p>
<p>prevent the user – whatever the user’s reasons might be – from configuring the output stage </p>
<p>that  would  result  in  catastrophic  damage.  You  can  accomplish  this  by  defining  minimum  and </p>
<p>maximum values in the A2L to limit the permitted values. </p>
<p>Rules for conversion between physical and raw values are also defined in the A2L. You can visu-</p>
<p>alize a simple example of such a conversion rule in a sensor that has an 8-bit value. The numeric </p>
<p>values output by the sensor lie between 0 and 255, but you wish to see the value as a percent-</p>
<p>age value. Mapping of the sensor value [0 … 255] to [0 … 100 %] is performed with a conver-</p>
<p>sion rule, which in turn is stored in the A2L. If an object is measured, which exists as a raw value </p>
<p>in the ECU and is also transmitted as such, the measurement and calibration tool uses the stored </p>
<p>formula and visualizes the physical value.</p>
<p>Besides scalar parameters, characteristic curves and maps are frequently used. Some might uti-</p>
<p>lize a proximity sensor such as a Hall sensor, which determines distance as a function of mag-</p>
<p>netic field strength and you may wish to use this distance value in your algorithm. The magnetic </p>
<p>field and distance value do not run linear to one another. This nonlinearity of values would make </p>
<p>formulation of the algorithm unnecessarily difficult. With the help of a characteristic curve, you </p>
<p>can first linearize the values before you input the values into your algorithm as input variables.</p>
<p>Another application area for characteristic maps is their use as substitutes for complex compu-</p>
<p>tations. For example, if there is a relationship y = f(x) and the function f is associated with a lot </p>
<p>of computing effort, it is often simpler to simply compute the values over the potential range of </p>
<p>x in advance and store the results in the form of a table (= characteristic curve). If the value x </p>
<p>is now in the ECU, the value y does not need to be computed at the controller’s runtime, rather </p>
<p>the map returns the result y to the input variable x. It may be necessary to interpolate between </p>
<p>two values, but that would be the extent of the calculations. </p>
<p>How is this characteristic curve stored in memory? Are all x values input first and then all y val-</p>
<p>ues?  Or  does  storage  follow  the  pattern:  x1,  y1;  x2,  y2;  x3,  y3  …?  Since  various  options  are </p>
<p>available, the type of memory storage is defined in a storage scheme in the A2L. </p>
<p>The convenience for the user comes from the ability to work with symbolic names for parame-</p>
<p>ters, the direct look at the physical values and access to complex elements such as characteris-</p>
<p>tic maps, without having to concern oneself with complex storage schemes.</p>
<p>Another advantage is offered by the communication parameters. They are also defined in the </p>
<p>A2L.  In  the  communication  between  the  measurement  and  calibration  tool  and  the  ECU,  the </p>
<p>parameter set from the A2L is used. The A2L contains everything that the measurement and cal-</p>
<p>ibration tool needs to communicate with the ECU. </p>
<h1 style="page-break-before:always; "></h1>
<p>68</p>
<p>2 ECU Description File A2L</p>
<p><b>2.1 Setting Up an A2L File for an XCP Slave </b></p>
<p>The A2L file is an ASCII-readable file, which describes the following with the help of keywords:</p>
<p>&gt;   Interface-specific  parameters  between  measurement  and  calibration  tool  and  A2L  file  (the </p>
<p>description is located at the beginning of the A2L file and is located in what is referred to as </p>
<p>the AML tree),</p>
<p>&gt;   Communication to the ECU,</p>
<p>&gt;   Storage scheme for characteristic curves and maps (keyword RECORD_LAYOUT),</p>
<p>&gt;   Conversion rules for converting raw values to physical values (keyword COMPU_METHOD),</p>
<p>&gt;   Measurement parameters (keyword MEASUREMENT),</p>
<p>&gt;   Calibration parameters (keyword CHARACTERISTIC) and</p>
<p>&gt;   Events that are relevant for triggering a measurement keyword EVENT),</p>
<p>A summary of parameters and measurement parameters is made with the help of groups (keyword </p>
<p>GROUP).</p>
<p>Example of a measurement parameter with the name “Shifter_B3”:</p>
<p>    /begin MEASUREMENT Shifter_B3 “Single bit signal (bit from a byte shifting)”</p>
<p>      UBYTE HighLow 0 0 0 1</p>
<p>      READ_WRITE</p>
<p>      BIT_MASK 0x8</p>
<p>      BYTE_ORDER MSB_LAST</p>
<p>      ECU_ADDRESS 0x124C02</p>
<p>      ECU_ADDRESS_EXTENSION 0x0</p>
<p>      FORMAT “%.3”</p>
<p>      /begin IF_DATA CANAPE_EXT</p>
<p>        100</p>
<p>        LINK_MAP “byteShift” 0x124C02 0x0 0 0x0 1 0x87 0x0</p>
<p>        DISPLAY 0 0 20</p>
<p>      /end IF_DATA</p>
<p>    /end MEASUREMENT</p>
<p>Example of a parameter map with the name KF1:</p>
<p>    /begin CHARACTERISTIC KF1 “8*8 BYTE no axis”</p>
<p>      MAP 0xE0338 __UBYTE_Z 0 Factor100 0 2.55</p>
<p>      ECU_ADDRESS_EXTENSION 0x0</p>
<p>      EXTENDED_LIMITS 0 2.55</p>
<p>      BYTE_ORDER MSB_LAST</p>
<p>      BIT_MASK 0xFF</p>
<p>      /begin AXIS_DESCR</p>
<p>        FIX_AXIS NO_INPUT_QUANTITY BitSlice.CONVERSION 8 0 7</p>
<p>        EXTENDED_LIMITS 0 7</p>
<p>        READ_ONLY</p>
<p>        BYTE_ORDER MSB_LAST</p>
<p>        FORMAT “%.0”</p>
<h1 style="page-break-before:always; "></h1>
<p>69</p>
<p>2.2 Manually Creating an A2L File </p>
<p>        FIX_AXIS_PAR_DIST 0 1 8</p>
<p>      /end AXIS_DESCR</p>
<p>      /begin AXIS_DESCR</p>
<p>        FIX_AXIS NO_INPUT_QUANTITY BitSlice.CONVERSION 8 0 7</p>
<p>        EXTENDED_LIMITS 0 7</p>
<p>        READ_ONLY</p>
<p>        BYTE_ORDER MSB_LAST</p>
<p>        FORMAT “%.0”</p>
<p>        FIX_AXIS_PAR_DIST 0 1 8</p>
<p>      /end AXIS_DESCR</p>
<p>      /begin IF_DATA CANAPE_EXT</p>
<p>        100</p>
<p>        LINK_MAP “map3_8_8_uc” 0xE0338 0x0 0 0x0 1 0x87 0x0</p>
<p>        DISPLAY 0 0 255</p>
<p>      /end IF_DATA</p>
<p>      FORMAT “%.3”</p>
<p>    /end CHARACTERISTIC</p>
<p>The ASCII text is not easy to understand. You will find a description of its structure in ASAM XCP </p>
<p>Part 2 Protocol Layer Specification in chapter 2.</p>
<p>The sections below describe how to create an A2L. Let us focus on the actual contents of an A2L </p>
<p>and their meanings and leave the details of the A2L description language to an editor. The A2L </p>
<p>Editor that is supplied with CANape is used here. </p>
<p><b>2.2 Manually Creating an A2L File </b></p>
<p>The A2L mainly describes the contents of the memory of the XCP Slave. The contents depend on </p>
<p>the application in the Slave, which was developed as C code. After the compiler/linker run of </p>
<p>the application code, important elements of an A2L file already exist in the linker-map file: the </p>
<p>names of the objects, their data types and memory addresses. Still lacking are the parameters </p>
<p>for communication between XCP Master and Slave. Other information is usually needed such as </p>
<p>minimum and maximum values of parameters, conversion rules, storage schemes for character-</p>
<p>istic maps etc.</p>
<p>Let us begin by creating an empty A2L and the communication parameters: If you wish to cre-</p>
<p>ate an A2L that describes an ECU with an XCP-on-CAN interface, for example, you create a new </p>
<p>device in CANape and select XCP on CAN as the interface. Then you can supplement this with </p>
<p>other communication-specific information (e.g. CAN identifiers). After saving the file, you have </p>
<p>an A2L that contains the entire communication content of the A2L. Still lacking are the defini-</p>
<p>tions of the actual measurement and calibration parameters. </p>
<h1 style="page-break-before:always; "></h1>
<p>70</p>
<p>2 ECU Description File A2L</p>
<p>In the A2L Editor (available as part of CANape or as a separate tool), the linker-map file is asso-</p>
<p>ciated to the A2L. In a selection dialog, the user can now select those parameters from the map </p>
<p>file which it needs in the A2L: scalar measurement and calibration parameters, characteristic </p>
<p>curves and maps. The user can gradually add the desired parameters to the A2L step by step and </p>
<p>group them. Other object-specific information is also added using the editor. </p>
<p>What should be done when you modify your code, recompile it and link it? It is highly proba-</p>
<p>ble that the addresses of objects will change. Essentially, it is not necessary to generate a new </p>
<p>A2L. If you wish to have objects just added to the code also be available in the A2L, you must of </p>
<p>course add them to the A2L. Address updating is always necessary in the A2L. This is done with </p>
<p>the editor; it searches for the relevant entry in the linker-map file based on the name of the A2L </p>
<p>object, reads out the address and updates it in the A2L.</p>
<p>If  your  application  changes  very  dynamically  –  objects  are  renamed,  data  types  are  adapted, </p>
<p>parameters are deleted and others added – then the manual work method is impractical. To gen-</p>
<p>erate an A2L from a C code, other tools are available for automatic processing. </p>
<p>On the Vector homepage you will find information on the “ASAP2 Tool-Set” with which you can </p>
<p>automate the generation of A2Ls from the source code in a batch process.</p>
<p><b>2.3 A2L Contents versus ECU Implementation</b></p>
<p>When an XCP Master tool reads in an A2L that does not fully match the ECU, misunderstandings </p>
<p>in the communication might occur. For example, another value related to time stamp resolution </p>
<p>might be in the A2L file that differs from the value implemented in the ECU. If this is the case, </p>
<p>the problem must be detected and solved. The user gets support from the Master, who can poll </p>
<p>the Slave via the protocol to determine what was really implemented in the Slave. </p>
<p>XCP offers a number of functions that were developed for automatic detection of the Slave. Of </p>
<p>course, this assumes that automatic detection is implemented in the Slave. If the Master polls </p>
<p>the Slave and the Slave’s responses do not agree with the parameter set of the A2L description </p>
<p>file, the Master must decide which settings to use. In CANape, the information that is read out </p>
<p>by the Slave is given a higher priority than the information from the A2L.</p>
<h1 style="page-break-before:always; "></h1>
<p>71</p>
<p>2.3 A2L Contents versus ECU Implementation</p>
<p>Here is an overview of possible commands that are used to find out something about the XCP </p>
<p>implementation in the Slave:</p>
<p>GET_DAQ_PROCESSOR_INFO</p>
<p>Returns general information on the DAQ lists: MAX_DAQ, MAX_EVENT_CHANNEL, MIN_DAQ</p>
<p>GET_DAQ_RESOLUTION_INFO </p>
<p>Maximum parameter of an ODT entry for DAQ/STIM, time interval information</p>
<p>GET_DAQ_EVENT_INFO (Event_channel_number)</p>
<p>Returns information for a specific time interval: Name and resolution of the time interval, num-</p>
<p>ber of DAQ lists that may be assigned to this time interval …</p>
<p>GET_DAQ_LIST_INFO (DAQ_List_Number)</p>
<p>Returns information on the selected DAQ list: MAX_ODT, MAX_ODT_ENTRIES exist as predefined </p>
<p>DAQ lists …</p>
<h1 style="page-break-before:always; "></h1>
<p>72</p>
<h1 style="page-break-before:always; "></h1>
<p>73</p>
<p>3 Calibration Concepts</p>
<p><b>3 Calibration Concepts</b></p>
<h1 style="page-break-before:always; "></h1>
<p>74</p>
<p>3 Calibration Concepts</p>
<p>ECU parameters are constant parameters that are adapted and optimized during the develop-</p>
<p>ment of the ECU or an ECU variant. This is an iterative process, in which the optimal value of a </p>
<p>parameter is found by repeated measurements and changes. </p>
<p>The  calibration  concept  answers  the  question  of  how  parameters  in  the  ECU  can  be  changed </p>
<p>during an ECU’s development and calibration phases. There is not one calibration concept that </p>
<p>exists, rather several. Which concept is utilized usually depends very much on the capabilities </p>
<p>and resources of the microcontroller that is used. </p>
<p>Normally, parameters are stored in the production ECU’s flash memory. The underlying program </p>
<p>variables are defined as constants in the software. To make parameters modifiable at runtime </p>
<p>during an ECU’s development, additional RAM memory is needed.</p>
<p>A calibration concept is concerned with such questions as these: How do the parameters initially </p>
<p>find their way from flash to RAM? How is the microcontroller’s access to RAM rerouted? What </p>
<p>does the solution look like when there are more parameters than can be simultaneously stored </p>
<p>in RAM? How are the parameters copied back into flash? Are changes to the parameters persis-</p>
<p>tent, i.e. are they preserved when the ECU is turned off?</p>
<p>A distinction is made between transparent and non-transparent calibration concepts. Transpar-</p>
<p>ent means that the calibration tool does not need to be concerned with the above questions, </p>
<p>because all necessary mechanisms are implemented in the ECU. </p>
<p>Several methods are briefly introduced in the following.</p>
<p><b>3.1 Parameters in Flash</b></p>
<p>The software developer defines in the source code whether a parameter is a variable or a con-</p>
<p>stant, i.e. whether a parameter is stored in flash or in RAM memory.</p>
<p>C code example: </p>
<p>const float factor = 0.5; </p>
<p>The “factor” parameter represents a constant with the value 0.5. During compiling and linking </p>
<p>of the code, memory space is provided in flash for the “factor” object. The object is allocated </p>
<p>an address that lies in the data area of the flash memory. The value 0.5 is found at the relevant </p>
<p>address in the hex file and the address appears in the linker-map file.</p>
<p>The simplest conceivable calibration concept involves modifying the value in C code, generating </p>
<p>a new hex file and flashing. However, this method is very laborious, because every value change </p>
<p>must be made in code, resulting in the need for a compiler/linker run with subsequent flashing. </p>
<p>An alternative approach would be to only modify the value in the hex file and then reflash this </p>
<p>file. Every calibration tool is capable of doing this. It is referred to as “offline calibration” of the </p>
<p>hex file, which is a very commonly used method.</p>
<h1 style="page-break-before:always; "></h1>
<p>75</p>
<p>3.1 Parameters in Flash</p>
<p>Under some circumstances, with certain compilers it may be necessary to explicitly ensure that </p>
<p>parameters are always also stored in flash memory and not integrated in the code, for exam-</p>
<p>ple and therefore do not appear at all in the linker-map file. Usually, one does not want to leave </p>
<p>to chance where a constant is created in flash memory. The necessary means for accomplish-</p>
<p>ing this are almost always compiler-specific pragma instructions. To prevent the compiler from </p>
<p>embedding them in the code, it is generally sufficient to use the “volatile” attribute for con-</p>
<p>stant parameters. A typical definition of a flash constant appears as in the following example:</p>
<p> </p>
<p>C code example: </p>
<p>#pragma section “FLASH_Parameter”</p>
<p>volatile const float factor = 0.5; </p>
<p>It is normally not possible to calibrate parameters in flash online. Indeed, most microcontrollers </p>
<p>are able to program their flash themselves, which is necessary for the purposes of re-program-</p>
<p>ming in the field. Nonetheless, flash memory always has the property of being organized into </p>
<p>larger blocks (sectors), which can only be erased as a whole. It is practically impossible to flash </p>
<p>just individual parameters, because the ECU normally does not have the resources to buffer the </p>
<p>rest of the sector and reprogram it. In addition, this process would take too much time.</p>
<p>Some ECUs have the ability to store data in what is known as an EEPROM memory. In contrast to </p>
<p>flash memories, EEPROM memories can erase and program each memory cell individually. The </p>
<p>amount of available EEPROM memory is always considerably less than the available flash mem-</p>
<p>ory and it is usually limited to just a few kilobytes. EEPROM memory is often used to store pro-</p>
<p>grammable  parameters  in  the  service  shop  or  to  implement  a  persistence  mechanism  in  the </p>
<p>ECU, e.g. for the odometer. Online calibration would be conceivable here, but it is seldom used, </p>
<p>because access to EEPROM cells is relatively slow and during the booting process EEPROM param-</p>
<p>eters are usually copied over to RAM memory, where it is possible to access them directly. ECUs </p>
<p>which  have  no  EEPROM  memory  often  implement  what  is  known  as  an  EEPROM  emulation.  In </p>
<p>this method, multiple small flash sectors are used in alternation to record parameter changes, </p>
<p>so that the last valid value can always be determined. Online calibration would also be conceiv-</p>
<p>able with this method.</p>
<p>In both cases, the relevant memory accesses would then be intercepted in the software com-</p>
<p>ponents  of  the  XCP  driver  and  implemented  with  the  software  routines  of  the  EEPROM  or  the </p>
<p>EEPROM emulation. The Vector XCP Professional driver offers the software hooks needed for this.</p>
<h1 style="page-break-before:always; "></h1>
<p>76</p>
<p>3 Calibration Concepts</p>
<p><b>3.2 Parameters in RAM</b></p>
<p>The most frequently used approach to modifying parameters at runtime (“online calibration”) is </p>
<p>to create the parameters in the available RAM memory. </p>
<p>C code example: </p>
<p>#pragma section “RAM_Parameter”</p>
<p>volatile float factor = 0.5; </p>
<p>This defines the parameter “factor” as a RAM variable with the initial value 0.5. During compil-</p>
<p>ing and linking of the code, memory space is reserved for the object “factor” in RAM and the </p>
<p>associated RAM address appears in the linker-map file. The initial value 0.5 is stored in flash </p>
<p>memory and at the relevant location in the hex file. The addresses of the initial values in flash </p>
<p>memory are defined by parameterization of the linker, but they do not appear in the linker-map </p>
<p>file. </p>
<p>During booting of the ECU, all RAM variables are initialized once with their initial values from </p>
<p>flash memory. This is usually executed in the start-up code of the compiler producer and the </p>
<p>application programmer does not need to be concerned with it. The application uses the val-</p>
<p>ues of parameters located in RAM and they can be modified via normal XCP memory accesses. </p>
<p>From  the  perspective  of  the  ECU  software,  calibration  parameters  in  RAM  are  always  still </p>
<p>unchangeable, i.e. the application itself does not change them. Many compilers discover this </p>
<p>fact  by  code  analysis  and  simply  optimize  the  necessary  RAM  memory  space  away.  Normally, </p>
<p>it is therefore also necessary to prevent the compiler from optimizing by using the “volatile” </p>
<p>attribute.</p>
<p>From the perspective of the calibration tool, the RAM area in which the parameters are located </p>
<p>is referred to as calibration RAM (memory that can be calibrated). </p>
<p>FLASH</p>
<p>RAM</p>
<p>Parameters</p>
<p>Calibration RAM</p>
<p><b>Figure 51: </b></p>
<p><b>Initial parameter </b></p>
<p><b>setting in RAM</b></p>
<p>The calibration RAM does not need to consist of a fully contiguous RAM area. It may also be dis-</p>
<p>tributed into multiple areas or even in any desired way. Nonetheless, it offers significant advan-</p>
<p>tages for organizing the parameters in just a few contiguous RAM areas and isolating them from </p>
<p>other RAM parameters such as changing state variables and intermediate results. This is espe-</p>
<p>cially important if offline calibration of the calibration RAM with a hex file should be enabled. </p>
<p>At the user’s request, the calibration tool must be able to load the parameters that were mod-</p>
<p>ified offline into the ECU during the transition from offline calibration to online calibration. </p>
<h1 style="page-break-before:always; "></h1>
<p>77</p>
<p>3.2 Parameters in RAM</p>
<p>This case occurs very frequently. For example, when calibrators reconnect with their ECU on the </p>
<p>next work day, they want to resume work at the point at which they stopped the evening before. </p>
<p>However, booting of the ECU causes the flashed contents to be copied to the RAM as an initial </p>
<p>dataset.  To  let  users  resume  with  work  accomplished  on  the  previous  day,  the  parameter  set </p>
<p>file saved the previous evening in the ECU’s RAM must be loaded. This loading process may be </p>
<p>time optimized by limiting the number of necessary transmissions to a minimum. It is advanta-</p>
<p>geous here if the tool can quickly and reliably determine – by forming a checksum over larger </p>
<p>contiguous areas – whether there are differences. If there are no differences between the cal-</p>
<p>ibration RAM contents in the ECU and the file modified using the tool, this area does not need </p>
<p>to be transferred. If the memory area with the calibration parameters is not clearly defined, or </p>
<p>if it includes parameters that are modified by the ECU software, a checksum calculation always </p>
<p>shows a difference and the parameter values are transmitted, either from the ECU to the XCP </p>
<p>Master or in a reverse direction. Depending on the transmission speed and amount of data, this </p>
<p>transmission could take several minutes. </p>
<p>Another advantage of clearly defined memory segments is that the memory area for initial val-</p>
<p>ues in flash memory can be used for offline calibration. The contents of the flash memory are </p>
<p>defined using flashable hex files. If the calibration tool knows the location of parameters in the </p>
<p>hex file, it can modify their values and implement new initial values in the ECU by flashing the </p>
<p>modified hex file. </p>
<p>The calibration tool not only needs to know the location of parameters in RAM, but also the ini-</p>
<p>tial values in flash. A prerequisite is that the RAM memory segment must be initialized by copy-</p>
<p>ing from an identically laid out memory segment in flash, as is the usual practice in most com-</p>
<p>pilers/linkers. If the addresses of parameters in RAM are in the A2L file, it is only necessary to </p>
<p>let the tool know the offset to the start address of the calibration RAM, which it must add to get </p>
<p>to the start address of the relevant flash area. This offset then applies to each individual param-</p>
<p>eter in the A2L. </p>
<p>The calibration tool can then either generate flashable hex files for this area itself, or it can </p>
<p>place them directly on the original hex files of the linker to modify the initial values of param-</p>
<p>eters in the hex file.</p>
<h1 style="page-break-before:always; "></h1>
<p>78</p>
<p>3 Calibration Concepts</p>
<p><b>3.3 Flash Overlay</b></p>
<p>Many microcontrollers offer options for overlaying memory areas in flash with internal or exter-</p>
<p>nal RAM. This process is referred to as flash emulation or flash overlay. A lot is possible, from </p>
<p>the use of a Memory Management Unit all the way to dedicated mechanisms that precisely serve </p>
<p>this purpose. In this case the parameters are created as parameters in flash just as in calibra-</p>
<p>tion concept 1. This method offers enormous advantages compared to the described calibration </p>
<p>concept 2 “Parameters in RAM”:</p>
<p>&gt;   No  distinction  is  made  between  flash  and  RAM  addresses.  The  flash  addresses  are  always </p>
<p>located in the A2L file, the hex file and linker-map file. This produces clear relationships, the </p>
<p>hex file is directly flashable and the A2L file matches it exactly.</p>
<p>&gt;   The overlay can be activated or deactivated as a whole, which enables lightning-quick swap-</p>
<p>ping between values in flash and those in RAM. They are referred to as the RAM page and the </p>
<p>flash page of a memory segment. XCP supports control of memory page swapping with special </p>
<p>commands. </p>
<p>&gt;   The memory pages might be swapped separately, e.g. for XCP access and ECU access, i.e. XCP </p>
<p>could access a memory page while the ECU software works with the other page. This permits </p>
<p>such operations as downloading of the offline calibration data to RAM, while the ECU is still </p>
<p>working with the flash data; this avoids potential inconsistencies that could be problematic </p>
<p>on a running ECU.</p>
<p>&gt;   The overlay with RAM does not need to be complete and it can be adapted to the application </p>
<p>case. It is possible to work with less RAM than with flash. More on this later.</p>
<p>A typical procedure for connecting the calibration tool to the ECU with the subsequent down-</p>
<p>load of values that were calibrated offline appears as follows:</p>
<p>Connects to the ECU </p>
<p>CONNECT</p>
<p>Connects XCP Master to RAM page </p>
<p>SET_CAL_PAGE XCP to RAM</p>
<p>Checksum calculation </p>
<p>CALC_CHECKSUM</p>
<p>When a difference has been detected in the checksum calculation over the RAM area, first the </p>
<p>user is normally asked how to proceed. Should the contents of ECU RAM be sent to the Master, or </p>
<p>should the contents of a file on the Master page be sent to the ECU’s RAM? If the user decides to </p>
<p>write the offline changes to the ECU, the subsequent process appears as follows:</p>
<p>ECU should use the dataset of the flash page  </p>
<p>SET_CAL_PAGE ECU to FLASH</p>
<p>Copy file from Master to the RAM page  </p>
<p>DOWNLOAD …</p>
<p>ECU should use the dataset of the RAM page </p>
<p>SET_CAL_PAGE ECU to RAM</p>
<p>Afterwards,  the  memory  page  is  always  switched  over  to  RAM,  so  that  parameters  can  be  </p>
<p>modified. But the user can also explicitly indicate which memory page should be active in the </p>
<p>ECU. For example, the behavior of the RAM parameter set can be compared to that of the flash </p>
<p>parameter set, or in an emergency it can be switched back to a proven parameter set in flash at </p>
<p>lightning speed.</p>
<h1 style="page-break-before:always; "></h1>
<p>79</p>
<p>3.4 Dynamic Flash Overlay Allocation</p>
<p><b>3.4 Dynamic Flash Overlay Allocation</b></p>
<p>The concepts for calibration RAM described so far are unproblematic if sufficient RAM is avail-</p>
<p>able for all parameters. But what if the total number of parameters does not fit into the avail-</p>
<p>able RAM area? </p>
<p>Here, it is advisable to overlay flash with RAM dynamically and do not overlay the affected flash </p>
<p>memory with RAM until the actual write access to a parameter. This procedure can occur with a </p>
<p>certain granularity and – depending on the implementation – it may be transparent to the cal-</p>
<p>ibration tool from the XCP perspective. If the XCP driver detects a write access to flash in the </p>
<p>ECU which would lead to a change, a part of calibration RAM is used to copy over the relevant </p>
<p>part of flash and activate the overlay mechanism for this part. This involves allocating the RAM, </p>
<p>i.e. in a fixed layout and it is identified as utilized. However, the resources of the calibration </p>
<p>RAM  are  limited.  During  the  calibration  process,  RAM  area  that  has  already  been  allocated  is </p>
<p>no longer released, so the available calibration RAM dwindles with further requests. If the RAM </p>
<p>resources are used up and a new allocation is required, the user is informed of the exhausted </p>
<p>RAM resources. The user is offered the option of flashing or saving the changes made up to that </p>
<p>point.  This  frees  up  the  allocated  RAM  area  again  and  the  user  can  once  again  calibrate.  The </p>
<p>variant  in  which  the  ECU  autonomously  flashes  the  previously  changed  parameters  is  usually </p>
<p>ruled out here for the reasons already cited in calibration concept “Parameter in Flash”.</p>
<p>In some cases, the download of a parameter set created offline might not be executable due </p>
<p>to insufficient RAM resources. The only alternative is to flash it. The user can always cancel the </p>
<p>changes from the tool and this releases the allocated RAM blocks again.</p>
<p>In this concept, page swapping between the RAM and flash pages is also possible without any </p>
<p>limitations.</p>
<p>The parameters should be organized together in flash according to function, so that the avail-</p>
<p>able RAM blocks can be used as efficiently as possible. The software developer then specifies </p>
<p>that the parameters, which belong together thematically, also lie in a contiguous memory area. </p>
<p>After copying to RAM, the parameters needed for tuning the particular function are fully ready </p>
<p>for use. </p>
<h1 style="page-break-before:always; "></h1>
<p>80</p>
<p>3 Calibration Concepts</p>
<p><b>3.5 RAM Pointer Based Calibration Concept per AUTOSAR</b></p>
<p>This concept does not require the use of an AUTOSAR operating system; it can even be used in a </p>
<p>different environment – e.g. without an operating system. The concept exhibits a key similar-</p>
<p>ity to the previous concept. The primary difference is that the substitution of flash for RAM is </p>
<p>not implemented by hardware mechanisms, but by software mechanisms instead. The calibra-</p>
<p>tion  parameters  are  always  referenced  by  pointers  from  the  ECU  software.  Flash  or  RAM  con-</p>
<p>tents are accessed by changing this pointer. The flash parameters to be modified are copied to </p>
<p>a defined block with available RAM. This method can be implemented fully transparently from </p>
<p>the XCP perspective, just as in the previous method. As an alternative, the user of the calibra-</p>
<p>tion tool can explicitly select the parameters to be modified by preselecting the desired param-</p>
<p>eters. The advantage of this is that resource utilization and loading are visible to the user and </p>
<p>the user is not surprised by a lack of memory in the midst of working.</p>
<p><b>3.5.1 Single Pointer Concept</b></p>
<p>The pointer table is located in RAM. When booting the ECU, all pointers indicate the parame-</p>
<p>ter values in flash. The location and parameters of the calibration RAM are indeed known, but </p>
<p>it  does  not  yet  contain  any  parameter  values  after  booting.  Initially,  the  application  works </p>
<p>entirely from flash. </p>
<p>FLASH</p>
<p>RAM</p>
<p>Pointertable</p>
<p>Parameters</p>
<p><b>Figure 52: </b></p>
<p><b>Initial situation  </b></p>
<p><b>after booting</b></p>
<p>When the user selects a parameter from the A2L file for the first time after booting and wishes </p>
<p>to write access it, this triggers a copying operation within the ECU first. The XCP Slave deter-</p>
<p>mines that the address to which the access should be made is located in the flash area, and it </p>
<p>copies the parameter value to the calibration RAM. A change is also made in the pointer table </p>
<p>to ensure that the application no longer gets the parameter value from flash, but instead from </p>
<p>the RAM area: </p>
<h1 style="page-break-before:always; "></h1>
<p>81</p>
<p>3.5 RAM Pointer Based Calibration Concept per AUTOSAR</p>
<p>FLASH</p>
<p>RAM</p>
<p>Pointertable</p>
<p>Parameters</p>
<p><b>Figure 53: </b></p>
<p><b>Pointer change and </b></p>
<p><b>copying to RAM</b></p>
<p>The application continues to get the parameter value via the pointer table. But since the pointer </p>
<p>indicates the RAM address, the value is retrieved from there. As a result, the user can change </p>
<p>the parameter value via XCP and observe the effects of the change in the measurement. The dis-</p>
<p>advantage of this method is that an entry in a pointer table must be available for each parame-</p>
<p>ter and in turn the method is associated with substantial additional RAM memory requirements </p>
<p>for the pointer table. </p>
<p>The next figure illustrates the problem. Three parameters of a PID controller (P, I and D) are con-</p>
<p>tained in an ECU’s flash area. The RAM addresses and parameter values in RAM are also already </p>
<p>changed in the pointer table.</p>
<p><b>Figure 54: Pointer table for individual parameters</b></p>
<p><b>Flash</b></p>
<p>0x11</p>
<p>0x22</p>
<p>0x33</p>
<p>0x0000100A </p>
<p>0x000012BC </p>
<p>0x00007234 </p>
<p><b>Parameter</b></p>
<p><b>P</b></p>
<p><b>I</b></p>
<p><b>D</b></p>
<p><b>Pointertable</b></p>
<p>0x000A100A</p>
<p>0x000A100B</p>
<p>0x000A100C</p>
<p><b>RAM</b></p>
<p>0x44</p>
<p>0x55</p>
<p>0x66</p>
<p>0x000A100A</p>
<p>0x000A100B</p>
<p>0x000A100C</p>
<p>Addr.</p>
<p>Addr.</p>
<p>Addr.</p>
<p>Content</p>
<p>Content</p>
<p>Calibration concepts are very important, because RAM resources are scarce. Large RAM pointer </p>
<p>tables would make a concept self-defeating. </p>
<p>To  avoid  having  to  create  a  pointer  for  each  individual  parameter  and  having  the  method  be </p>
<p>used as such, the parameters can be combined into structures. This requires just one pointer </p>
<p>per structure. When the user selects a parameter, not only is this parameter copied to RAM, but </p>
<p>so is the entire associated structure. The granularity of the structures is of key importance here. </p>
<p>With large structures only a few pointers are necessary. In turn, this means that with the deci-</p>
<p>sion for a specific parameter, a rather large associated structure is copied to the RAM area and </p>
<p>this can cause the limits of calibration RAM space to be reached quickly. </p>
<h1 style="page-break-before:always; "></h1>
<p>82</p>
<p>3 Calibration Concepts</p>
<p>Example: </p>
<p>The calibration RAM should be 400 bytes in size. Four structures are defined in the software with </p>
<p>the following parameters:</p>
<p>Structure A: 250 bytes</p>
<p>Structure B: 180 bytes</p>
<p>Structure C: 120 bytes</p>
<p>Structure D: 100 bytes</p>
<p>When the user selects a parameter from structure A, the 250 bytes are copied from flash to the </p>
<p>calibration RAM, and the user has XCP access to all parameters located in structure A. If the cali-</p>
<p>bration task is limited to the parameters of this structure, the calibration RAM is fully sufficient. </p>
<p>However, if the user selects another parameter located in a different structure, e.g. structure </p>
<p>C, these 120 bytes must also be copied to the calibration RAM. Since the calibration RAM can  </p>
<p>handle 400 bytes, the user can access all parameters of structures A and C simultaneously.</p>
<p>If another selected parameter is not located in structure C, but rather in structure B, the 180 </p>
<p>bytes of structure B would have to be copied to RAM in addition to the 250 bytes of structure A. </p>
<p>However, since the space in RAM is inadequate for this, the user indeed has access to the param-</p>
<p>eters of structure A, but not to the data of structure B, because the ECU cannot execute the copy </p>
<p>command.</p>
<p>You can learn more about how this approach works in CANape. Start CANape with the  “AUTOSAR </p>
<p>Single  Pointered  Demo”  project.  You  will  find  more  information  on  its  use  in  CANape  on  the </p>
<p>“Introduction” page of the project.</p>
<p>You will find a source code example under the “Demos” category at the Vector Download Center. </p>
<p>A code example on how to use the calibration concept is contained in the “XCP Sample Imple-</p>
<p>mentation” under &lt;Installation DIR&gt;\Samples\CAN\CAN MPC55xx\XCPDemo. </p>
<p><b>3.5.2 Double Pointer Concept</b></p>
<p>A disadvantage of the single pointer concept is that memory page swapping is not easy to imple-</p>
<p>ment. The calibration tool could simply describe the pointer table completely for page swap-</p>
<p>ping, but this is not feasible in a short period of time without resulting in temporary inconsis-</p>
<p>tencies  and  side  effects.  A  tool-transparent  implementation  would  double  the  memory  space </p>
<p>requirement for the pointer table, because when swapping the memory page into flash, a copy </p>
<p>of the previous pointer table would have to be created with RAM pointers.</p>
<p>For applications with large pointer tables, a transparent implementation or a fully consistent </p>
<p>swapping, there is the option of extending the method to a double pointer concept. To explain </p>
<p>how this is done, we return once again to the initial RAM setting. </p>
<h1 style="page-break-before:always; "></h1>
<p>83</p>
<p>3.6 Flash Pointer Based Calibration Concept </p>
<p>Figure 55 represents the pointer table. It lies in RAM. As already mentioned, this table must be </p>
<p>copied from flash into RAM. As a result, this table lies in flash memory. If another pointer is now </p>
<p>used (a table pointer), which points to either the pointer table in RAM or in flash, one arrives </p>
<p>at a double pointer solution. </p>
<p>FLASH</p>
<p>RAM</p>
<p>RAM</p>
<p>Pointertable</p>
<p>Tablepointer</p>
<p>FLASH</p>
<p>Pointertable</p>
<p><b>Figure 55: </b></p>
<p><b>Double pointer concept</b></p>
<p>The parameter values are initially accessed via the table pointer. If the table pointer indicates </p>
<p>the pointer table in RAM, the application essentially accesses the actual parameters via the con-</p>
<p>tents of the RAM pointer table. The low access speed and the creation of more program code are </p>
<p>disadvantages of this solution.</p>
<p><b>3.6 Flash Pointer Based Calibration Concept </b></p>
<p>This method was patented several years ago by the company ZF Friedrichshafen under the name </p>
<p>“InCircuit2”  and  bears  a  strong  resemblance  to  the  pointer-based  concept  of  AUTOSAR.  Here </p>
<p>too,  the  application  in  the  ECU  accesses  parameter  data  using  a  pointer  table.  However,  this </p>
<p>pointer table is not located in RAM, but in flash instead. Changes to the pointer table can there-</p>
<p>fore  only  be  made  by  flash  programming.  A  tool-transparent  implementation  is  not  possible. </p>
<p>The  advantage  lies  in  the  RAM  memory  that  is  saved  since  it  no  longer  contains  the  pointer </p>
<p>table.</p>
<p>You can find out how this approach works in CANape. Start CANape with the “InCircuit2” project. </p>
<p>You will find more information on its use in CANape on the “Introduction” page of the project.</p>
<h1 style="page-break-before:always; "></h1>
<p>84</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>85</p>
<p>4 Application Areas of XCP </p>
<p><b>4 Application Areas of XCP</b></p>
<h1 style="page-break-before:always; "></h1>
<p>86</p>
<p>4 Application Areas of XCP</p>
<p>When ECU calibrators think about the use of XCP, they are usually fixated on use of the proto-</p>
<p>col in the ECU.</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>Slave</p>
<p>PC</p>
<p><b>XCP</b></p>
<p>Measurement/</p>
<p>Calibration </p>
<p>Hardware*</p>
<p>* Debug Interfaces, Memory Emulator, ...</p>
<p>HIL/SIL Systems</p>
<p>EXE/DLL</p>
<p>Prototype or</p>
<p>ECU Hardware</p>
<p>Simulink</p>
<p>Master</p>
<p><b>Figure 56:  </b></p>
<p><b>Application areas and </b></p>
<p><b>application cases</b></p>
<p>In a survey of development processes, one encounters many different solution approaches for </p>
<p>the development of electronics and software. HIL (Hardware in the Loop), SIL (Software in the </p>
<p>Loop)  and  Rapid  Prototyping  are  keywords  here  and  they  describe  different  scenarios.  They </p>
<p>always have a “plant” and a “controller” in common. </p>
<p><b>Figure 57: Plants and controllers</b></p>
<p>Offset</p>
<p>Manipulated </p>
<p>Variable</p>
<p>Disturbance </p>
<p>Variable</p>
<p>Controlled Variable</p>
<p>(Actual Value)</p>
<p>Reference Variable</p>
<p>(Set Value)</p>
<p>Controller</p>
<p>Plant</p>
<p>In  the  context  of  automotive  development,  the  controller  is  represented  by  the  ECU  and  the </p>
<p>plant is the physical system to be controlled such as the transmission, engine, side mirrors, etc.</p>
<p>The rough subdivision is made between different development approaches according to whether </p>
<p>the controller or the plant runs in real or simulated mode. Some combinations will be described </p>
<p>in greater detail. </p>
<h1 style="page-break-before:always; "></h1>
<p>87</p>
<p>4.1 MIL: Model in the Loop </p>
<p><b>4.1 MIL: Model in the Loop </b></p>
<p><b>Plant Model</b></p>
<p><b>Controller Model</b></p>
<p>Simulink</p>
<p><b>Figure 58: </b></p>
<p><b>Model in the Loop  </b></p>
<p><b>in Simulink</b></p>
<p>In this development environment, both the controller and the plant are simulated as a model. In </p>
<p>the example shown, both models run in Simulink as the runtime environment. The capabilities </p>
<p>of the Simulink runtime environment are available to you for analyzing the behavior. </p>
<p>To realize the convenience of a measurement and calibration tool like CANape in an early devel-</p>
<p>opment phase, an XCP Slave can be integrated in the controller model. In an authoring step, </p>
<p>the Slave generates the A2L that matches the model and the user already has the full range of </p>
<p>convenient operating features with visualization of process flows in graphic windows, access to </p>
<p>characteristic curves and maps and much more.</p>
<p>Plant Model</p>
<p>Controller Model</p>
<p>Simulink</p>
<p><b>Simulink</b></p>
<p><b>XCP Server</b></p>
<p><b>CANape</b></p>
<p>A2L</p>
<p><b>Figure 59: </b></p>
<p><b>CANape as  </b></p>
<p><b>measurement and  </b></p>
<p><b>calibration tool with </b></p>
<p><b>Simulink models</b></p>
<p>Neither  a  code  generation  step  nor  instrumentation  of  the  model  is  necessary  for  this.  Time </p>
<p>stamps  are  also  included  with  transmissions  over  XCP.  CANape  completely  adapts  to  the  time </p>
<p>behavior  of  the  Simulink  runtime  environment  here.  Whether  the  model  is  running  faster  or </p>
<p>slower than in real time is of no consequence. For example, if the functional developer uses the </p>
<p>Simulink Debugger in the model to step through the model, CANape still takes the time trans-</p>
<p>mitted via XCP as the reference time. </p>
<h1 style="page-break-before:always; "></h1>
<p>88</p>
<p>4 Application Areas of XCP</p>
<p><b>4.2 SIL: Software in the Loop </b></p>
<p><b>Plant Model</b></p>
<p><b>Controller Model</b></p>
<p><b>Controller Model</b></p>
<p><b>Windows DLL</b></p>
<p>Simulink</p>
<p>Code generation</p>
<p><b>Figure 60: </b></p>
<p><b>Software in the  </b></p>
<p><b>Loop with Simulink </b></p>
<p><b>environment</b></p>
<p>In  this  development  step,  code  is  generated  from  the  model  of  the  controller,  which  is  then </p>
<p>used in a PC-based runtime environment. Naturally, the controller may also have been devel-</p>
<p>oped without any sort of model-based approach. The plant continues to be simulated. XCP can </p>
<p>be  used  to  measure  and  calibrate  the  controller.  If  the  controller  originates  from  a  Simulink </p>
<p>model, a code generation step (Simulink Coder with the target “CANape”) is used to generate </p>
<p>the C code for a DLL and the associated A2L. If the Controller development is conducted based </p>
<p>on manually written code, it is embedded in a C++ project that is delivered with CANape.</p>
<p>After compiling and linking, the DLL is used in the CANape context. With the support of the XCP </p>
<p>connection, the algorithms in the DLL can be measured and calibrated exactly as if the applica-</p>
<p>tion were already integrated in an ECU.</p>
<p>Plant Model</p>
<p>Controller Model</p>
<p>Controller Model</p>
<p>Windows DLL</p>
<p>Simulink</p>
<p>Code generation</p>
<p><b>CANape</b></p>
<p>A2L</p>
<p><b>Figure 61:  </b></p>
<p><b>CANape as SIL  </b></p>
<p><b>development platform</b></p>
<h1 style="page-break-before:always; "></h1>
<p>89</p>
<p>4.3 HIL: Hardware in the Loop</p>
<p><b>4.3 HIL: Hardware in the Loop </b></p>
<p>Many different kinds of HIL systems are available. They range from very simple, cost-effective </p>
<p>systems all the way to very large and expensive expansion stages. The following figure shows </p>
<p>the rough concept:</p>
<p>Plant Model</p>
<p>HIL Platform</p>
<p>ECU</p>
<p>I/O</p>
<p>Controller Model</p>
<p><b>Figure 62: </b></p>
<p><b>HIL solution</b></p>
<p>The controller algorithm runs in a microcontroller platform (e.g. the ECU), while the plant con-</p>
<p>tinues to be simulated. Depending on the parameters and the complexity of the plant and the </p>
<p>necessary I/O, requirements of the HIL platform and the associated costs can rise steeply. Since </p>
<p>the ECU runs in real time, the model of the plant must also be computed in real time.</p>
<p>To now introduce XCP for optimization appears trivial, because another ECU is being added. The </p>
<p>whole system looks like this:</p>
<p><b>CANape</b></p>
<p>A2L</p>
<p>Plant Model</p>
<p>HIL Platform</p>
<p>ECU</p>
<p>I/O</p>
<p>Controller Model</p>
<p><b>Figure 63:</b></p>
<p><b>HIL with CANape  </b></p>
<p><b>as measurement  </b></p>
<p><b>and calibration tool</b></p>
<p>From CANape, the user has access to the algorithms in the ECU over XCP. </p>
<h1 style="page-break-before:always; "></h1>
<p>90</p>
<p>4 Application Areas of XCP</p>
<p>The Vector Tool CANoe is also used by many customers as a HIL system. With CANoe, a HIL sys-</p>
<p>tem might look like this:</p>
<p>CANoe RT User PC</p>
<p>Ethernet</p>
<p>CANoe RT Server</p>
<p>Digital I/O</p>
<p>Analog I/O</p>
<p>CAN</p>
<p>LIN</p>
<p>MOST</p>
<p>FlexRay</p>
<p><b>CANape</b></p>
<p>A2L</p>
<p>ECU</p>
<p>XCP</p>
<p>Plant Model</p>
<p><b>Figure 64: </b></p>
<p><b>CANoe as HIL system</b></p>
<p>The ability to access XCP data directly from CANoe for testing purposes results in the following </p>
<p>variant as well:</p>
<p>CANoe RT User PC</p>
<p>Ethernet</p>
<p>CANoe RT Server</p>
<p>Digital I/O</p>
<p>Analog I/O</p>
<p>CAN</p>
<p>LIN</p>
<p>MOST</p>
<p>FlexRay</p>
<p>A2L</p>
<p>ECU</p>
<p>XCP</p>
<p>Plant Model</p>
<p><b>Figure 65: </b></p>
<p><b>CANoe as HIL  </b></p>
<p><b>system with XCP </b></p>
<p><b>access to the ECU</b></p>
<p>Here the model of the plant runs on the CANoe real-time server. At the same time, XCP access </p>
<p>to the ECU is also realized from CANoe. This gives a tool simultaneous access to the plant and </p>
<p>the controller. </p>
<h1 style="page-break-before:always; "></h1>
<p>91</p>
<p>4.4 RCP: Rapid Control Prototyping </p>
<p>To round out the picture, yet another HIL solution option should be mentioned. The plant might </p>
<p>also run as a DLL in CANape. This gives the user full access to the plant and to the controller </p>
<p>over XCP. </p>
<p><b>Figure 66: CANape as HIL solution</b></p>
<p>A2L</p>
<p>ECU</p>
<p>ECU</p>
<p>Plant</p>
<p>XCP</p>
<p>Plant Model</p>
<p>Windows DLL</p>
<p><b>CANape</b></p>
<p>A2L</p>
<p>XCP</p>
<p><b>4.4 RCP: Rapid Control Prototyping </b></p>
<p>In this development phase, the control algorithm runs on real-time hardware instead of an ECU. </p>
<p>This situation often occurs when the necessary ECU hardware is not yet available. Several plat-</p>
<p>forms come in question as suitable hardware: from simple evaluation boards all the way to spe-</p>
<p>cial automotive-level hardware solutions, depending on which additional requirements need to </p>
<p>be fulfilled. Here too, integration with XCP helps in setting up an OEM-independent tool chain.</p>
<p><b>Figure 67: RCP solution</b></p>
<p>A2L</p>
<p>XCP</p>
<p>I/O</p>
<p>EVA Board</p>
<p><b>CANape</b></p>
<p>Controller Model</p>
<p>Plant</p>
<p>The  concepts  “Rapid”  and  “Prototyping”  describe  the  task  very  well.  The  aim  is  to  develop  a </p>
<p>functional prototype as quickly as possible, to use and test it in the runtime environment. This </p>
<p>just requires simple work steps throughout the entire process.</p>
<h1 style="page-break-before:always; "></h1>
<p>92</p>
<p>4 Application Areas of XCP</p>
<p>In  the  literature,  the  RCP  approach  is  frequently  subdivided  into  two  areas:  fullpassing  and </p>
<p>bypassing.</p>
<p>As depicted in Figure 67, the entire controller runs on separate real-time hardware. This method </p>
<p>is known as fullpassing, because the entire controller runs on the controller hardware. It must </p>
<p>have the necessary I/O to be able to interface with the plant. Very often, it is only possible to </p>
<p>fulfill technical requirements for the I/O with suitable power electronics. </p>
<p>It is not only the I/O that represents a challenge; often functional elements of the ECU software </p>
<p>(e.g.  network  management)  are  needed  to  enable  functionality  in  a  more  complex  network. </p>
<p>However, if a complete ECU is used for Rapid Control Prototyping instead of a general control-</p>
<p>ler platform, the complexity of the flash process, the size of the overall software, etc. all work </p>
<p>against the requirement for “Rapid” development. </p>
<p>In summary: the use of an entire ECU as the runtime environment for the controller offers the </p>
<p>advantage that the necessary hardware and software infrastructure for the plant exists. The dis-</p>
<p>advantage lies in the high degree of complexity.</p>
<p>The  concept  of  bypassing  was  developed  to  exploit  the  advantages  of  the  ECU  infrastructure </p>
<p>without being burdened by the disadvantages of high complexity. </p>
<p><b>4.5 Bypassing </b></p>
<p>In Figure 68, the ECU is connected to the plant. The necessary I/O and software components are </p>
<p>available in the ECU. In the bypassing hardware, an algorithm A1 runs, which occurs in Version </p>
<p>A of the ECU. A1 is a new variant of the algorithm and should now be tried out on the real plant.</p>
<p> </p>
<p><b>Figure 68: Basic principle of bypassing</b></p>
<p>I/O</p>
<p>XCP</p>
<p>ECU</p>
<p>Bypassing Hardware</p>
<p>Bypassing</p>
<p>Hardware</p>
<p><b>CANape</b></p>
<p>Controller Model</p>
<p>A2L</p>
<p>ECU</p>
<p>A2L</p>
<p>Plant</p>
<p>XCP</p>
<h1 style="page-break-before:always; "></h1>
<p>93</p>
<p>4.5 Bypassing </p>
<p>The bypassing hardware (a VN8900 device in the figure) and the ECU are interconnected over </p>
<p>XCP. One goal here is to get the data needed for algorithm A1 from the ECU by DAQ; another </p>
<p>goal is to stimulate the results of A1 back into the ECU. The following figure illustrates the sche-</p>
<p>matic flow:</p>
<p><b>2.</b></p>
<p><b>3.</b></p>
<p>Bypassing Hardware</p>
<p>ECU</p>
<p>Algorithm A1</p>
<p>Algorithm A</p>
<p><b>1.</b></p>
<p><b>XCP</b></p>
<p><b>4.</b></p>
<p>Bypassing</p>
<p>Coordinator</p>
<p><b>Figure 69: </b></p>
<p><b>Bypassing flow</b></p>
<p>Depicted in the ECU is a blue function block in which the algorithm A runs. To ensure that A1 can </p>
<p>now be used, the data enters algorithm A as an input variable and it is measured from the ECU </p>
<p>by DAQ. In step 1, the bypassing coordinator accepts the data and in step 2 it passes the data to </p>
<p>algorithm A1. A1 is computed by the bypassing hardware and in step 3 the result is passed back </p>
<p>to the bypassing coordinator; in step 4, it is transmitted to the ECU by STIM. The data is written </p>
<p>to the “location” at which the next function block in the Slave expects its input variables. This </p>
<p>makes it possible to use the value computed by algorithm A1 and not from A in the ECU’s over-</p>
<p>all control process. This method permits using a combination of the rapid substitution of algo-</p>
<p>rithms on the bypassing hardware that incorporates the I/O and the ECU’s basic software. </p>
<h1 style="page-break-before:always; "></h1>
<p>94</p>
<p>4 Application Areas of XCP</p>
<p>Of course, the performance limits of an XCP-on-CAN driver also affect bypassing. If short bypass-</p>
<p>ing times are needed, access to the ECU by DAQ and STIM may also be performed via the con-</p>
<p>troller’s debugging or trace interfaces. The Vector VX1000 measurement and calibration hard-</p>
<p>ware converts the data into an XCP-on-Ethernet data stream from the controller interface. In </p>
<p>this process, up to one megabyte of data can be transported into the ECU.</p>
<p>Plant</p>
<p>XCP</p>
<p>ECU</p>
<p>Bypassing Hardware</p>
<p>Bypassing</p>
<p>Hardware</p>
<p><b>CANape</b></p>
<p>Controller Model</p>
<p>A2L</p>
<p>I/O</p>
<p>XCP</p>
<p>Debugging and Trace Interface</p>
<p>Measurement &amp; Calibration</p>
<p>Hardware VX1000</p>
<p><b>Figure 70: Bypassing with real-time bypassing hardware and fast ECU access</b></p>
<h1 style="page-break-before:always; "></h1>
<p>95</p>
<p>4.6 Shortening Iteration Cycles with Virtual ECUs</p>
<p><b>4.6 Shortening Iteration Cycles with Virtual ECUs </b></p>
<p>Stimulation with data is necessary to optimize the algorithm in the ECU with the help of XCP. </p>
<p>This can be done in the ECU in the framework of test drives. But there is yet another solution </p>
<p>that is available with XCP, in which the algorithm does not run on an ECU; rather it runs on the </p>
<p>PC in the form of executable code or as a model in Simulink in the form of a “virtual ECU.” This </p>
<p>virtual ECU does not need to run in real time, because in this case no connection to a real system </p>
<p>exists. It can run significantly faster – depending on the PC’s computing power. </p>
<p>The algorithm is stimulated by a previously logged measurement file, which contains all signals </p>
<p>that are needed as input signals for the algorithm. The connection to CANape is set up over XCP. </p>
<p>The user can perform the parameterization and measurement configuration. Afterwards, exe-</p>
<p>cution is started. Here the data from the test drive is fed into the algorithm as stimulation and </p>
<p>the desired measurement parameters from the application are simultaneously measured out and </p>
<p>saved to a measurement file.  </p>
<p>New</p>
<p>MDF</p>
<p>Application</p>
<p>Para-</p>
<p>meter</p>
<p>MDF</p>
<p>test drive</p>
<p><b>CANape</b></p>
<p>1. Set parameters</p>
<p>2. Start</p>
<p>3. Send test drive data</p>
<p>4. Measurement data</p>
<p>5. Analyze</p>
<p>Slave</p>
<p><b>Simulink/</b></p>
<p><b>DLL</b></p>
<p><b>Figure 71:  </b></p>
<p><b>Short calibration </b></p>
<p><b>cycles with  </b></p>
<p><b>virtual ECUs</b></p>
<h1 style="page-break-before:always; "></h1>
<p>96</p>
<p>4 Application Areas of XCP</p>
<p>After the calculation has been completed, a new measurement file is available to the user for </p>
<p>analysis of ECU behavior. The length of time of the new measurement file precisely matches the </p>
<p>length of the input measurement file. If the duration of a test drive is one hour, the algorithm </p>
<p>on the PC might calculate the entire test drive in just a few seconds. Then a measurement result </p>
<p>exists, which corresponds to a test of one hour duration. Based on the data analysis, the user </p>
<p>makes decisions about parameterization and the iteration cycle is repeated. </p>
<p> </p>
<p>Parameterization</p>
<p>via XCP</p>
<p>Start</p>
<p>Send measurement</p>
<p>data</p>
<p>New software version</p>
<p><b>CANape</b></p>
<p><b>Application as EXE or DLL on PC</b></p>
<p>Set values in</p>
<p>workspace  </p>
<p>Start</p>
<p>Calculate model</p>
<p>End model calculation</p>
<p>Send measurement </p>
<p>values from the model</p>
<p>Receive new</p>
<p>measurement data</p>
<p>Analyze the</p>
<p>new data </p>
<p><b>Figure 72: </b></p>
<p><b>Process flow  </b></p>
<p><b>with virtual ECUs</b></p>
<p>To  shorten  the  iteration  cycles,  the  algorithm  is  always  stimulated  with  the  same  data.  That </p>
<p>makes  the  results  with  different  parameters  much  more  comparable,  because  the  results  are </p>
<p>only influenced by the parameters that differ.</p>
<p>This process can of course be automated. The integrated script language of CANape performs an </p>
<p>analysis of the measurement results, from which parameter calibration settings are derived and </p>
<p>automatically executed. It is also possible to have the process controlled by an external optimi-</p>
<p>zation tool such as MATLAB over the CANape automation interface.  </p>
<h1 style="page-break-before:always; "></h1>
<p>97</p>
<p>4.6 Shortening Iteration Cycles with Virtual ECUs</p>
<h1 style="page-break-before:always; "></h1>
<p>98</p>
<h1 style="page-break-before:always; "></h1>
<p>99</p>
<p>5 Example of an XCP Implementation</p>
<p><b>5 Example of an XCP Implementation</b></p>
<h1 style="page-break-before:always; "></h1>
<p>100</p>
<p>5 Example of an XCP Implementation</p>
<p>To make it possible for an ECU to communicate over XCP, it is necessary to integrate an XCP driver </p>
<p>in the ECU’s application. The example described below is of the XCP driver which you can down-</p>
<p>load free of charge at the Download Center of the Vector website (www.vector.com/xcp-driver). </p>
<p>This  packet  also  contains  some  sample  implementations  for  various  transport  layers  and  tar-</p>
<p>get platforms. The driver consists of the protocol-Layer with the basic functionality needed for  </p>
<p>measurement  and  calibration.  It  does  not  include  features  such  as  Cold  Start  Measurement, </p>
<p>Stimulation or flashing. You can purchase a full implementation as a product that is integrated </p>
<p>in the Vector CANbedded or AUTOSAR environment.</p>
<p>The XCP protocol layer is placed over the XCP transport layer, which in turn is based on the actual </p>
<p>bus  communication.  The  implementation  of  the  XCP  protocol  layer  only  consists  of  a  single  C </p>
<p>file and a few H files (xcpBasix.c, xcpBasic.h, xcp_def.h and xcp_cfg.h). The examples include </p>
<p>implementations for various transport layers, e.g. Ethernet and RS232. In the case of CAN, the </p>
<p>transport layer is normally very simple and the various XCP message types are mapped directly </p>
<p>to CAN messages. There are then separate fixed identifiers for the Tx and Rx directions.</p>
<p>The software interface between the transport and protocol layers is very simple. It contains just </p>
<p>a few functions:</p>
<p>&gt;   When the Slave receives an XCP message over the bus, it first arrives in the communication </p>
<p>driver, which routes the message to the XCP transport layer. The transport layer informs the </p>
<p>protocol layer about the message with the function call XcpCommand().</p>
<p>&gt;   If the XCP protocol layer wishes to send a message (e.g. a response to an XCP command from </p>
<p>the Master or a DAQ message), the message is routed to the transport layer by a call of the </p>
<p>ApplXcpSend() function.</p>
<p>&gt;   The transport layer informs the protocol layer that the message was successfully sent by the </p>
<p>function call XcpSendCallBack().</p>
<h1 style="page-break-before:always; "></h1>
<p>101</p>
<p>5 Example of an XCP Implementation</p>
<p>Application</p>
<p>XCP Protocol Layer </p>
<p>XCP Transport Layer</p>
<p>Physical Layer</p>
<p><b>Bus</b></p>
<p>XcpEvent</p>
<p>XcpInit</p>
<p>XcpBackground</p>
<p>ApplXcpGetPointer</p>
<p>XcpCommand</p>
<p>ApplXcpSend</p>
<p>XcpSendCallback</p>
<p>Application - XCP Transport</p>
<p>Layer Interface </p>
<p><b>Figure 73:</b></p>
<p><b>Incorporating </b></p>
<p><b>the XCP Slave  </b></p>
<p><b>in the ECU code</b></p>
<p>The interface between the application and the protocol layer can only be implemented via four </p>
<p>functions:</p>
<p>&gt;   The application activates the XCP driver with the help of XcpInit(). This call is made once in </p>
<p>the starting process.</p>
<p>&gt;   With  XcpEvent(),  the  application  informs  the  XCP  driver  that  a  certain  event  has  occurred </p>
<p>(e.g. “End of a computational cycle reached”).</p>
<p>&gt;   The  call  XcpBackground()  lets  the  XCP  driver  execute  certain  activities  in  background  (e.g. </p>
<p>calculation of a checksum).</p>
<p>&gt;   Since  the  addresses  in  A2L  files  are  always  defined  as  40-bit  values  (32-bit  address,  8-bit </p>
<p>address extension), the XCP driver uses the function ApplXcpGetPointer() to obtain a pointer </p>
<p>from a A2L-conformant address.</p>
<p>These interfaces are sufficient to integrate basic functionalities for measurement and calibra-</p>
<p>tion. Other interfaces are only needed for extended functions such as page swapping, identifi-</p>
<p>cation or seed &amp; key. They are described in detail in documentation for the driver.</p>
<h1 style="page-break-before:always; "></h1>
<p>102</p>
<p>5 Example of an XCP Implementation</p>
<p><b>5.1 Description of Functions </b></p>
<p><b>void XcpInit (void)</b></p>
<p>Task: </p>
<p> </p>
<p>Initialize the XCP driver</p>
<p>Description: </p>
<p> </p>
<p>The application activates the XCP driver with XcpInit(). This command must be executed exactly </p>
<p>once before any sort of XCP driver function may be called.</p>
<p><b>void XcpEvent (BYTE event)</b></p>
<p>Task:</p>
<p>The application informs the XCP driver about which event occurred. A unique event number is </p>
<p>assigned to each event here.  </p>
<p>Description:</p>
<p>In setting up the measurement configuration in the measurement and calibration tool, the user </p>
<p>selects which measured values should be synchronously acquired with which events. The infor-</p>
<p>mation on measured values and events originates from the A2L. The desired measurement con-</p>
<p>figuration is communicated to the XCP driver in the form of DAQ lists. </p>
<p>Example of an event definition in an engine controller:</p>
<p>XcpEvent (1); </p>
<p>// Event 1 stands for the 10-ms task</p>
<p>XcpEvent (2); </p>
<p>// Event 2 stands for the 100-ms task</p>
<p>XcpEvent (5); </p>
<p>// Event 5 stands for the 1-ms task</p>
<p>XcpEvent (8); </p>
<p>// Event 8 is used for ignition angle synchronous measurements</p>
<p><b>BYTE XcpBackground (void)</b></p>
<p>Task:</p>
<p>Execute background activities of the XCP driver. </p>
<p>Description:</p>
<p>This function should be called periodically in a background or idle task. It is used by the XCP </p>
<p>driver, for example, to compute the checksum, because the computation of a longer checksum </p>
<p>in XcpCommand() could take an unacceptably long time. With each call of XcpBackground(), a </p>
<p>partial checksum of 256 bytes is computed. The duration of a checksum computation therefore </p>
<p>depends on the call frequency of XcpBackground(). There are no other requirements for the call </p>
<p>frequency or periodicity. The return value 1 indicates that a checksum computation is currently </p>
<p>running. </p>
<h1 style="page-break-before:always; "></h1>
<p>103</p>
<p>5.1 Description of Functions </p>
<p><b>void XcpCommand (DWORD* pCommand)</b></p>
<p>Task:</p>
<p>Interpret an XCP command.</p>
<p>Description:</p>
<p>This function must be called each time the transport layer receives a XCP frame. The parameter </p>
<p>is a pointer to the frame. </p>
<p><b>void ApplXcpSend (BYTE len, BYTE *msg)</b></p>
<p>Task:</p>
<p>Transfer a frame to be sent to the transport layer.</p>
<p>Description:</p>
<p>With this call, the protocol layer sends a message to the transport layer for transmission to the </p>
<p>Master.  The  call  XcpSendCallBack  implements  a  handshake  method  between  the  protocol  and </p>
<p>transport layers. </p>
<p><b>BYTE XcpSendCallBack (void)</b></p>
<p>Task:</p>
<p>The protocol layer uses this callback to inform the transport layer that the last message that was </p>
<p>transferred to ApplXcpSend() was successfully transmitted.</p>
<p>Description:</p>
<p>The protocol layer does not call an ApplXcpSend() command until XcpSendCallBack() indicates </p>
<p>that  the  prior  message  was  successfully  transmitted.  XcpSendCallBack()  returns  the  value  0 </p>
<p>(FALSE) if the XCP driver is in idle. If there are more frames to be sent, ApplXcpSend() is called </p>
<p>directly from XcpSendCallBack().  </p>
<p><b>BYTE *ApplXcpGetPointer (BYTE addr_ext, DWORD addr)</b></p>
<p>Task:</p>
<p>Convert an A2L-conformant address to a pointer.</p>
<p>Description:</p>
<p>The function maps the 40-bit A2L-conformant addressing (32-bit address + 8-bit address exten-</p>
<p>sion) that is sent by the XCP Master to a valid pointer. The address extension can be used, for </p>
<p>example, to distinguish different address areas or memory types.</p>
<h1 style="page-break-before:always; "></h1>
<p>104</p>
<p>5 Example of an XCP Implementation</p>
<p><b>5.2 Parameterization of the Driver </b></p>
<p>In many respects, the XCP driver is scalable and parameterizable to properly handle the wide </p>
<p>variety of functional content, transport protocols and target platforms. All settings are made in </p>
<p>the parameter file xcp_cfg.h. In the simplest case, they appear as follows:</p>
<p>/* Define protocol parameters */</p>
<p>#define kXcpMaxCTO     8      /* Maximum CTO Message Length */</p>
<p>#define kXcpMaxDTO     8      /* Maximum DTO Message Length */</p>
<p>#define C_CPUTYPE_BIGENDIAN   /* byte order Motorola */</p>
<p>/* Enable memory checksum */</p>
<p>#define XCP_ENABLE_CHECKSUM</p>
<p>#define kXcpChecksumMethod XCP_CHECKSUM_TYPE_ADD14</p>
<p>/* Enable calibration */</p>
<p>#define XCP_ENABLE_CALIBRATION</p>
<p>#define XCP_ENABLE_SHORT_UPLOAD</p>
<p>/* Enable data acquisition */</p>
<p>#define XCP_ENABLE_DAQ                   </p>
<p>#define kXcpDaqMemSize (512) /* Memory space reserved for DAQ */</p>
<p>#define XCP_ENABLE_SEND_QUEUE</p>
<p>For a CAN transport layer, the appropriate CTO and DTO parameters of eight bytes are set. The </p>
<p>driver must know whether it is running on a platform with Motorola or Intel byte order, in this </p>
<p>case a Motorola-CPU (Big Endian). The remaining parameters activate the functionalities: mea-</p>
<p>surement, calibration and checksum computation. The algorithm for checksum computation is </p>
<p>configured (here summing of all bytes into a DWORD) and the parameter of the available mem-</p>
<p>ory is indicated for the measurement (here 512 bytes). The memory is primarily needed to store </p>
<p>the DAQ lists and to buffer the data during the measurement. The parameter therefore deter-</p>
<p>mines the maximum possible number of measurement signals. In the driver documentation you </p>
<p>will find more detailed information on estimating the necessary parameters.</p>
<h1 style="page-break-before:always; "></h1>
<p>105</p>
<p>5.2 Parameterization of the Driver</p>
<h1 style="page-break-before:always; "></h1>
<p>106</p>
<p>The Authors</p>
<p><b>The Authors</b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b>Andreas Patzer</b></p>
<p>Mr. Patzer graduated in Electrical Engineering from the Technical University of </p>
<p>Karlsruhe. In his studies he specialized in measurement and control engineering </p>
<p>and information and industrial engineering. In 2003, he joined Vector Informatik </p>
<p>GmbH in Stuttgart. Andreas Patzer has supported XCP projects from the very start, </p>
<p>since XCP was standardized by ASAM e.V. in the same year he was hired.  </p>
<p>He currently manages the Customer Relations and Services area as a team leader </p>
<p>for the Measurement &amp; Calibration product line. </p>
<h1 style="page-break-before:always; "></h1>
<p>107</p>
<p>The Authors</p>
<p> </p>
<p><b>Rainer Zaiser</b></p>
<p>Mr. Zaiser has a degree in Electrical Engineering from the University of Stuttgart. </p>
<p>After graduating, he came directly to Vector Informatik GmbH in autumn 1988, </p>
<p>where he has helped to create many of the standards that have become established </p>
<p>in the automotive industry such as DBC, MDF, CCP, A2L and to a large extent XCP.  </p>
<p>From the start, he headed up the Measurement &amp; Calibration and Network </p>
<p>Interfaces product lines.</p>
<h1 style="page-break-before:always; "></h1>
<p>108</p>
<p>Table of Abbreviations and Acronyms</p>
<p><b>Table of Abbreviations and Acronyms </b></p>
<p>A2L  </p>
<p>File extension for an ASAM 2MC language file</p>
<p>AML  </p>
<p>ASAM 2 Meta Language</p>
<p>ASAM  </p>
<p>Association for Standardisation of Automation and Measuring Systems</p>
<p>BYP  </p>
<p>Bypassing</p>
<p>CAL  </p>
<p>Calibration</p>
<p>CAN  </p>
<p>Controller Area Network</p>
<p>CCP  </p>
<p>CAN Calibration Protocol</p>
<p>CMD  </p>
<p>Command</p>
<p>CS  </p>
<p>Checksum</p>
<p>CTO  </p>
<p>Command Transfer Object</p>
<p>CTR  </p>
<p>Counter</p>
<p>DAQ  </p>
<p>Data Acquisition, Data Acquisition Packet</p>
<p>DTO  </p>
<p>Data Transfer Object</p>
<p>ECU  </p>
<p>Electronic Control Unit</p>
<p>ERR  </p>
<p>Error Packet</p>
<p>EV  </p>
<p>Event Packet</p>
<p>FIBEX </p>
<p>Field Bus Exchange Format </p>
<p>LEN  </p>
<p>Length</p>
<p>MCD  </p>
<p>Measurement Calibration and Diagnostics</p>
<p>MTA  </p>
<p>Memory Transfer Address</p>
<p>ODT  </p>
<p>Object Descriptor Table</p>
<p>PAG  </p>
<p>Paging</p>
<p>PGM  </p>
<p>Programming</p>
<p>PID  </p>
<p>Packet Identifier</p>
<p>RES  </p>
<p>Command Response Packet</p>
<p>SERV  </p>
<p>Service Request Packet</p>
<p>SPI  </p>
<p>Serial Peripheral Interface</p>
<p>STD  </p>
<p>Standard</p>
<p>STIM  </p>
<p>Data Stimulation Packet</p>
<p>TCP/IP  </p>
<p>Transfer Control Protocol / Internet Protocol</p>
<p>TS  </p>
<p>Time Stamp</p>
<p>UDP/IP  </p>
<p>Unified Data Protocol / Internet Protocol</p>
<p>USB  </p>
<p>Universal Serial Bus</p>
<p>XCP  </p>
<p>Universal Measurement and Calibration Protocol</p>
<p>Download </p>
<p>Sending of data from Master to Slave </p>
<p>Upload </p>
<p>Sending of data from Slave to Master</p>
<h1 style="page-break-before:always; "></h1>
<p>109</p>
<p>Literature &amp; Web Addresses </p>
<p><b>Literature </b></p>
<p>XCP is specified by ASAM (Association for Standardisation of Automation and Measuring Systems).</p>
<p> </p>
<p>You will find details on the protocol and on ASAM at: <b>www.asam.net</b></p>
<p><b>Web Addresses </b></p>
<p>Standardization committees:</p>
<p>&gt;   ASAM, XCP protocol-specific documents, A2L specification, <b>www.asam.net</b></p>
<p>Supplier of development software:</p>
<p>&gt;   MathWorks, information on MATLAB, Simulink and Simulink Coder, <b>www.mathworks.com </b></p>
<p>&gt;   Vector  Informatik  GmbH,  demo  version  of  CANape,  free  of  charge  and  openly  available  XCP </p>
<p>driver (basic version), comprehensive  information  on  the topics of ECU  calibration,  testing </p>
<p>and simulation, <b>www.vector.com</b></p>
<h1 style="page-break-before:always; "></h1>
<p>110</p>
<p>Table of Figures</p>
<p><b>Table of Figures </b></p>
<p>Figure 1: Fundamental communication with a runtime environment </p>
<p>8</p>
<p>Figure 2: The Interface Model of ASAM </p>
<p>9</p>
<p>Figure 3: An XCP Master can simultaneously communicate with multiple Slaves </p>
<p>10</p>
<p>Figure 4: Subdivision of the XCP protocol into protocol layer and transport layer </p>
<p>14</p>
<p>Figure 5: XCP Slaves can be used in many different runtime environments </p>
<p>15</p>
<p>Figure 6: XCP packet </p>
<p>19</p>
<p>Figure 7: Overview of XCP Packet Identifier (PID) </p>
<p>19</p>
<p>Figure 8: XCP communication model with CTO/DTO </p>
<p>20</p>
<p>Figure 9: Message identification </p>
<p>21</p>
<p>Figure 10: Time stamp </p>
<p>21</p>
<p>Figure 11: Data field in the XCP packet </p>
<p>22</p>
<p>Figure 12: The three modes of the XCP protocol: Standard, Block and Interleaved mode </p>
<p>24 </p>
<p>Figure 13: Overview of the CTO packet structure </p>
<p>25</p>
<p>Figure 14: Trace example from a calibration process </p>
<p>30</p>
<p>Figure 15: Transfer of a parameter set file to an ECU’s RAM </p>
<p>31</p>
<p>Figure 16: Hex window </p>
<p>32</p>
<p>Figure 17: Address information of the parameter “Triangle” from the A2L file </p>
<p>33</p>
<p>Figure 18: Polling communication in the CANape Trace window </p>
<p>34</p>
<p>Figure 19: Events in the ECU </p>
<p>35</p>
<p>Figure 20: Event definition in an A2L </p>
<p>35</p>
<p>Figure 21: Allocation of “Triangle” to possible events in the A2L </p>
<p>36</p>
<p>Figure 22: Selecting events (measurement mode) for each measurement parameter </p>
<p>36</p>
<p>Figure 23: Excerpt from the CANape Trace window of a DAQ measurement </p>
<p>37</p>
<p>Figure 24: ODT: Allocation of RAM addresses to DAQ DTO </p>
<p>38</p>
<p>Figure 25: DAQ list with three ODTs </p>
<p>39</p>
<p>Figure 26: Static DAQ lists </p>
<p>39</p>
<p>Figure 27: Dynamic DAQ lists </p>
<p>40</p>
<p>Figure 28: Event for DAQ and STIM </p>
<p>41</p>
<p>Figure 29: Structure of the XCP packet for DTO transmissions </p>
<p>42</p>
<p>Figure 30: Identification field with absolute ODT numbers </p>
<p>43</p>
<p>Figure 31: ID field with relative ODT and absolute DAQ numbers (one byte) </p>
<p>43</p>
<p>Figure 32: ID field with relative ODT and absolute DAQ numbers (two bytes) </p>
<p>43</p>
<p>Figure 33: ID field with relative ODT and absolute DAQ numbers as well as fill byte </p>
<p> </p>
<p>(total of four bytes) </p>
<p>44</p>
<p>Figure 34: Definition of which bus nodes send which messages </p>
<p>45</p>
<p>Figure 35: Representation of a CAN network </p>
<p>46</p>
<p>Figure 36: Example of XCP-on-CAN communication </p>
<p>47</p>
<p>Figure 37: Representation of an XCP-on-CAN message </p>
<p>47</p>
<p>Figure 38: Illustration of a CAN FD frame </p>
<p>48</p>
<p>Figure 39: Nodes K and L are redundantly interconnected </p>
<p>50</p>
<p>Figure 40: Communication by slot definition </p>
<p>50</p>
<p>Figure 41: Representation of a FlexRay communication matrix </p>
<p>51</p>
<p>Figure 42: Representation of the FlexRay LPDUs </p>
<p>52</p>
<p>Figure 43: Allocation of XCP communication to LPDUs </p>
<p>53</p>
<p>Figure 44: XCP packet with TCP/IP or UDP/IP </p>
<p>54</p>
<h1 style="page-break-before:always; "></h1>
<p>111</p>
<p>Table of Figures</p>
<p>Figure 45: XCP-on-SxI packet </p>
<p>55</p>
<p>Figure 46: Memory representation </p>
<p>56</p>
<p>Figure 47: Representation of driver settings for the flash area </p>
<p>58</p>
<p>Figure 48: Representation of the block transfer mode </p>
<p>61</p>
<p>Figure 49: Parameters in a calibration window </p>
<p>66</p>
<p>Figure 50: Signal response over time </p>
<p>66</p>
<p>Figure 51: Initial parameter setting in RAM </p>
<p>76</p>
<p>Figure 52: Initial situation after booting </p>
<p>80</p>
<p>Figure 53: Pointer change and copying to RAM </p>
<p>81</p>
<p>Figure 54: Pointer table for individual parameters </p>
<p>81</p>
<p>Figure 55: Double pointer concept </p>
<p>83</p>
<p>Figure 56: Application areas and application cases </p>
<p>86</p>
<p>Figure 57: Plants and controllers </p>
<p>86</p>
<p>Figure 58: Model in the Loop in Simulink </p>
<p>87</p>
<p>Figure 59: CANape as measurement and calibration tool with Simulink models </p>
<p>87</p>
<p>Figure 60: Software in the Loop with Simulink environment </p>
<p>88</p>
<p>Figure 61: CANape as SIL development platform </p>
<p>88</p>
<p>Figure 62: HIL solution </p>
<p>89</p>
<p>Figure 63: HIL with CANape as measurement and calibration tool </p>
<p>89</p>
<p>Figure 64: CANoe as HIL system </p>
<p>90</p>
<p>Figure 65: CANoe as HIL system with XCP access to the ECU </p>
<p>90</p>
<p>Figure 66: CANape as HIL solution </p>
<p>91</p>
<p>Figure 67: RCP solution </p>
<p>91</p>
<p>Figure 68: Basic principle of bypassing </p>
<p>92</p>
<p>Figure 69: Bypassing flow </p>
<p>93</p>
<p>Figure 70: Bypassing with real-time bypassing hardware and fast ECU access </p>
<p>94</p>
<p>Figure 71: Short calibration cycles with virtual ECUs </p>
<p>95</p>
<p>Figure 72: Process flow with virtual ECUs </p>
<p>96</p>
<p>Figure 73: Incorporating the XCP Slave in the ECU code </p>
<p>101</p>
<h1 style="page-break-before:always; "></h1>
<p>112</p>
<p>Appendix – XCP Solutions at Vector</p>
<p><b>Appendix – XCP Solutions at Vector </b></p>
<p>Vector made a significant effort in giving shape to the XCP standard. Its extensive know-how </p>
<p>and vast experience were utilized to provide comprehensive XCP support:</p>
<p><b>Tools</b></p>
<p>&gt;   The  primary  use  area  of <b> CANape </b> is  in  optimal  parameterization  (calibration)  of  electronic </p>
<p>control units (ECUs). During the system’s runtime, you calibrate parameter values and simul-</p>
<p>taneously acquire measured signals. The physical interface between CANape and the ECU is </p>
<p>over XCP (for all standardized transport protocols) or CCP. </p>
<p>&gt;   Complete tool chain for generating and managing the necessary A2L description files (<b>ASAP2 </b></p>
<p><b>Tool-Set </b>and <b>CANape </b>with the <b>ASAP2 Editor </b>that is also available as a stand-alone tool).</p>
<p>&gt;   You use <b>CANoe.XCP </b>to access internal ECU values for testing and analysis tasks.</p>
<p><b>ECU interfaces</b></p>
<p>The <b>VX1000 </b>measurement and calibration hardware offers the option of equipping ECUs with </p>
<p>an XCP-on-Ethernet interface. This involves connecting a Plug on Device (POD) to the ECU for </p>
<p>direct access to the controller, e.g. over DAP, JTAG, Nexus, etc. The POD transmits the data to a </p>
<p>base module, which operates as an XCP Slave and provides the data to the XCP Master on the PC </p>
<p>over XCP on Ethernet. This makes it unnecessary to have an XCP Slave in the ECU. The user ben-</p>
<p>efits from a high measurement data throughput rate of up to 30 Mbyte/sec and short measure-</p>
<p>ment intervals of less than 15 µs.</p>
<p><b>Embedded Software</b></p>
<p>Communication modules with separate transport layers for CAN, FlexRay and Ethernet:</p>
<p>&gt;   <b>XCP Basic </b>– free download at www.vector.com/xcp-driver, only contains basic XCP functions. </p>
<p>Configuration of the XCP protocol and modification of the transport layer are performed man-</p>
<p>ually in the source code. You need to integrate XCP Basic in your project yourself.</p>
<p>&gt;   <b>XCP Professional </b>– contains useful extensions to the ASAM specification and enables tool-</p>
<p>based configuration. Available for Vector CANbedded basic software.</p>
<p>&gt;   <b>MICROSAR XCP </b>– contains the functional features of XCP Professional and is based on AUTO-</p>
<p>SAR specifications. Available for Vector MICROSAR basic software.</p>
<p><b>Services</b></p>
<p>&gt; <b> Consultation </b>for using XCP in your projects </p>
<p>&gt; <b> Integration </b>of XCP in your ECU</p>
<p><b>Training</b></p>
<p>&gt;</p>
<p>   You can learn about the underlying mechanisms and models of the protocol in the “<b>XCP Funda-</b></p>
<p><b>mentals Seminar</b>”.</p>
<p>&gt;   In  the  “<b>CANape  with  XCP  on  FlexRay  Workshop</b>”  you  learn  about  FlexRay  fundamentals </p>
<p>and  the  special  aspects  of  XCP  on  FlexRay  are  explained,  in  particular  dynamic  bandwidth </p>
<p>management.</p>
<h1 style="page-break-before:always; "></h1>
<p>113</p>
<p>Appendix – XCP Solutions at Vector</p>
<p><b>Special XCP support by CANape</b></p>
<p>CANape was the first MCD tool to support the XCP 1.0 specification and was also the first XCP on </p>
<p>FlexRay Master on the market.</p>
<p>A special technical feature of XCP on FlexRay is dynamic bandwidth management. Here, CANape </p>
<p>identifies  the  available  bandwidth  provided  for  XCP  in  the  FlexRay  ClusterP  and  it  allocates </p>
<p>this bandwidth to the momentary application data traffic dynamically and very efficiently. The </p>
<p>available bandwidth is thereby optimally used for XCP communication. </p>
<p>Moreover, CANape has a DLL interface. It enables support of XCP on any desired (user-defined) </p>
<p>transport  layer.  This  lets  you  integrate  any  desired  test  instrumentation  or  proprietary  pro-</p>
<p>tocols in CANape. A code generator supports you in creating the XCP-specific share of such a </p>
<p>driver.</p>
<h1 style="page-break-before:always; "></h1>
<p>114</p>
<p>Index</p>
<p><b>Index</b></p>
<p><b>A</b></p>
<p>A2L </p>
<p>9, 10, 25, 33, 35, 39, 40, 41, 52, </p>
<p> </p>
<p>53, 57, 58, 63, 65, 66, 67, 68, 69, </p>
<p> </p>
<p>70, 88, 102, 103, 108</p>
<p>Address extension </p>
<p>29, 33, 38, 101, 103</p>
<p>AML </p>
<p>25, 68, 108</p>
<p>ASAM </p>
<p>7, 8, 9, 55, 108</p>
<p>ASAP2 Tool-Set </p>
<p>70</p>
<p><b>B</b></p>
<p>Bandwith optimization </p>
<p>34</p>
<p>Bus load </p>
<p>34</p>
<p>BYP </p>
<p>108</p>
<p>Bypassing </p>
<p>44, 92, 93, 94</p>
<p><b>C</b></p>
<p>CAN </p>
<p>7, 8, 14, 24, 29, 33, 38, 45, 46, 47, </p>
<p> </p>
<p>51, 69, 94, 108</p>
<p>CAN FD </p>
<p>48 </p>
<p>CANape </p>
<p>95</p>
<p>CANoe </p>
<p>95</p>
<p>CANoe.XCP </p>
<p>95</p>
<p>CCP </p>
<p>7, 8, 39, 45, 108</p>
<p>CMD </p>
<p>20, 25, 52, 108</p>
<p>Compiling </p>
<p>95</p>
<p>CTO </p>
<p>20, 21, 22, 25, 108</p>
<p>CTR </p>
<p>54, 55, 108</p>
<p>CYCLE_REPETITION </p>
<p>52</p>
<p><b>D</b></p>
<p>DAQ </p>
<p>22, 32, 33, 34, 35, 36, 37, 38, </p>
<p> </p>
<p>39, 40, 41, 42, 43, 44, 60, 62, 71, </p>
<p> </p>
<p>93, 94, 100, 102, 108</p>
<p>DBC </p>
<p>45</p>
<p>DOWNLOAD </p>
<p>30, 31, 61</p>
<p>DTO </p>
<p>20, 21, 22, 33, 37, 38, 42, 108</p>
<p><b>E</b></p>
<p>ECU </p>
<p>9, 68, 90, 92, 93, 108</p>
<p>EEPROM </p>
<p>16, 31, 62</p>
<p>ERR </p>
<p>20, 25, 28, 108</p>
<p>EV </p>
<p>29, 108</p>
<p>Event </p>
<p>35, 39, 41, 60, 62, 71, 102</p>
<p><b>F</b></p>
<p>FIBEX </p>
<p>51, 52, 53</p>
<p>Flash memory </p>
<p>16, 17, 56, 57, 58, 59, 62</p>
<p>FLX_CHANNEL </p>
<p>52</p>
<p>FLX_LPDU_ID </p>
<p>52</p>
<p>FLX_SLOT_ID </p>
<p>52</p>
<p>Fullpassing </p>
<p>92</p>
<p><b>G</b></p>
<p>GET_CAL_PAGE </p>
<p>25, 57</p>
<p>GET_DAQ_PROCESSOR_INFO </p>
<p>44, 60, 71</p>
<p><b>H</b></p>
<p>HIL </p>
<p>86, 89, 90, 91</p>
<p><b>L</b></p>
<p>Linking </p>
<p>74, 88</p>
<p>LPDU </p>
<p>52</p>
<p><b>M</b></p>
<p>MIL </p>
<p>87</p>
<p>MTA </p>
<p>30, 108</p>
<p><b>O</b></p>
<p>ODT </p>
<p>37, 38, 39, 40, 42, 43, 44, 60, </p>
<p> </p>
<p>71, 108</p>
<p>OFFSET </p>
<p>52</p>
<p><b>P</b></p>
<p>PAG </p>
<p>108</p>
<p>Page </p>
<p>95</p>
<p>PGM </p>
<p>108</p>
<p>PID </p>
<p>8, 19, 21, 25, 42, 108</p>
<p>Polling </p>
<p>33, 34, 36</p>
<p><b>R</b></p>
<p>RAM </p>
<p>16, 17, 18, 30, 31, 37, 38, 39, </p>
<p> </p>
<p>58, 62, 74, 76, 79, 80, 82</p>
<p>Reboot </p>
<p>32</p>
<p>RES </p>
<p>20, 21, 28, 52, 108</p>
<h1 style="page-break-before:always; "></h1>
<p>115</p>
<p>Index</p>
<p><b>S</b></p>
<p>Segment </p>
<p>57, 58</p>
<p>SEGMENT_NUMBER </p>
<p>57</p>
<p>SERV </p>
<p>29, 108</p>
<p>SET_CAL_PAGE </p>
<p>25, 57</p>
<p>SHORT_UPLOAD </p>
<p>30, 33, 61</p>
<p>SIL </p>
<p>86, 88</p>
<p>STIM </p>
<p>33, 41, 42, 44, 60, 71, 93, </p>
<p> </p>
<p>94, 95, 108</p>
<p>Stimulation </p>
<p>29, 63, 95</p>
<p><b>T</b></p>
<p>Task </p>
<p>102</p>
<p>TCP/IP </p>
<p>53, 54, 108</p>
<p><b>U</b></p>
<p>UDP/IP </p>
<p>53, 54, 108</p>
<p>USB </p>
<p>55, 108</p>
<p><b>V</b></p>
<p>VN8900 </p>
<p>95</p>
<p>VX </p>
<p>94</p>
<p>VX1000 </p>
<p>95</p>
<h1 style="page-break-before:always; "></h1>
<p><b>Get more Information!</b></p>
<p><b>Visit our Website for:</b></p>
<p>&gt;  News</p>
<p>&gt;  Products</p>
<p>&gt;  Demo Software</p>
<p>&gt;  Support</p>
<p>&gt;  Trainings Classes</p>
<p>&gt;  Addresses</p>
<p>V 2.0 4/2014</p>
<p><b>www.vector.com</b></p>
</body>
</html>
{% endraw %}