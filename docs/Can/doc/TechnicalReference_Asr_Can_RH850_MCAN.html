---
layout: default
title: TechnicalReference_Asr_Can_RH850_MCAN
nav_order: 2
parent: CAN Driver
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR CAN Driver </b></p>
<p>Technical Reference </p>
<p> </p>
<p>Renesas </p>
<p>RH850/P1x-C </p>
<p>MCAN </p>
<p> </p>
<p>Version 1.02.00 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Cengiz Ünver, Peter Herrmann </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>2 </p>
<p>based on template version 3.2 </p>
<p><b>Document Information </b></p>
<p><b>History Core </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Holger Birke </p>
<p>2006-06-21 </p>
<p>1.0 </p>
<p>Initial version </p>
<p>Holger Birke </p>
<p>2006-06-28 </p>
<p>1.1 </p>
<p>Review modifications </p>
<p>Holger Birke </p>
<p>2006-10-26 </p>
<p>1.2 </p>
<p>New feature Tx polling, FullCAN Tx and </p>
<p>support DEM </p>
<p>Holger Birke </p>
<p>2007-01-22 </p>
<p>1.3 </p>
<p>New feature Bus Off Polling </p>
<p>Holger Birke </p>
<p>2007-02-15 </p>
<p>1.4 </p>
<p>Minor Changes </p>
<p>Holger Birke </p>
<p>2007-07-10 </p>
<p>1.5 </p>
<p>ASR2.1 </p>
<p>Holger Birke </p>
<p>2007-08-24 </p>
<p>1.6 </p>
<p>Renaming MICROSAR </p>
<p>Holger Birke </p>
<p>2007-08-28 </p>
<p>1.7 </p>
<p>Remove Driver version </p>
<p>Holger Birke </p>
<p>2007-08-29 </p>
<p>1.8 </p>
<p>Driver version also removed from Chapter </p>
<p>3 </p>
<p>Holger Birke </p>
<p>2007-11-13 </p>
<p>1.9 </p>
<p>Changed API Can_Init(), add API </p>
<p>Can_InitStruct(), add init structure </p>
<p>description (HL2.22) </p>
<p>Holger Birke </p>
<p>2007-12-03 </p>
<p>1.10 </p>
<p>Improve Interrupt description </p>
<p>Holger Birke </p>
<p>2008-02-20 </p>
<p>1.11 </p>
<p>ASR3 </p>
<p>Holger Birke </p>
<p>2008-04-18 </p>
<p>1.12 </p>
<p>Review Reworks (Sh2 review and by </p>
<p>visem) </p>
<p>Holger Birke </p>
<p>2008-07-21 </p>
<p>1.13 </p>
<p>Review Reworks (TMS320) </p>
<p>Holger Birke </p>
<p>2008-08-13 </p>
<p>1.14 </p>
<p>Core 3.3 </p>
<p>Optimization for runtime, ROM and RAM </p>
<p>Holger Birke </p>
<p>2008-08-13 </p>
<p>1.15 </p>
<p>Core 3.5 </p>
<p>rename INTERRUPT &amp; POLLING </p>
<p>Update Tool configuration description </p>
<p>Add Remote Frame rejection description </p>
<p>Holger Birke </p>
<p>2008-10-23 </p>
<p>1.16 </p>
<p>Core 3.6 </p>
<p>add new API handle “Hardware Loop </p>
<p>Check” by application </p>
<p>+ beautifying </p>
<p>Holger Birke </p>
<p>2009-02-06 </p>
<p>1.17 </p>
<p>Core 3.7 </p>
<p>Add individual polling </p>
<p>Holger Birke </p>
<p>2009-05-19 </p>
<p>1.18 </p>
<p>Improve “Generic Precopy” description </p>
<p>(extended ID bit) </p>
<p>Add Compiler and Memory abstraction, </p>
<p>Add possibility to report CAN_E_TIMEOUT </p>
<p>as DET. </p>
<p>Holger Birke </p>
<p>2009-07-15 </p>
<p>1.18.01 </p>
<p>Core 3.09 </p>
<p>Remove Compiler abstraction CAN_ISR. </p>
<p>Change “Hardware Loop Check” naming. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>3 </p>
<p>based on template version 3.2 </p>
<p>Holger Birke </p>
<p>2009-07-28 </p>
<p>1.18.02 </p>
<p>Review reworks </p>
<p>Holger Birke </p>
<p>2009-10-01 </p>
<p>1.18.03 </p>
<p>Core 3.10 </p>
<p>Add RxQueue (high-end) and Generic </p>
<p>Confirmation </p>
<p>Holger Birke </p>
<p>2010-02-04 </p>
<p>1.19 </p>
<p>Core 3.11 </p>
<p>Add “Multiple BasicCAN”, “Support Mixed </p>
<p>ID”, “Optimize for one controller”, “Dynamic </p>
<p>FullCAN Tx ID” and “Size of Hw </p>
<p>HandleType”. </p>
<p>Rename “Hardware Cancellation” </p>
<p>Correct “Services used by CAN” </p>
<p>Holger Birke </p>
<p>2010-04-01 </p>
<p>1.20 </p>
<p>Core 3.12 </p>
<p>Add Critical Section description </p>
<p>Add “Common CAN” </p>
<p>Add Hardware assertion (DET) description </p>
<p>Add Can_GetStatus() + Interrupt category </p>
<p>configuration. </p>
<p>Add ApplCanInterruptDisable/Restore()</p>
<p> </p>
<p>Holger Birke </p>
<p>2010-11-24 </p>
<p>2.00 </p>
<p>Core 4.00 </p>
<p>Update to MICROSAR4 </p>
<p>Add “Overrun notification” </p>
<p>Add “RAM check” </p>
<p>Holger Birke </p>
<p>2011-04-18 </p>
<p>2.00.01 </p>
<p>Review reworks (VJ) </p>
<p>Holger Birke </p>
<p>2011-06-28 </p>
<p>2.00.02 </p>
<p>Rework (add missing config settings to </p>
<p>GENy GUI description) </p>
<p>Add MicroSar – AUTOSAR deviations </p>
<p>Holger Birke </p>
<p>2011-07-29 </p>
<p>2.01 </p>
<p>Core 4.01 </p>
<p>Add “GenericPreTransmit” </p>
<p>Holger Birke </p>
<p>2012-01-13 </p>
<p>2.01.01 </p>
<p>Improve description for “Nested Interrupts” </p>
<p>and “Identical ID cancellation” </p>
<p>Holger Birke </p>
<p>2012-04-02 </p>
<p>2.02.00 </p>
<p>Core 4.02 </p>
<p>Add Platform, CANCell and Manufacturer </p>
<p>as First Page Information </p>
<p>Add Void-Void ISR configuration, support </p>
<p>ASR3.2.1 Identical ID cancellation </p>
<p>Holger Birke </p>
<p>2012-04-02 </p>
<p>2.03.00 </p>
<p>Partial Network part of configuration (no </p>
<p>more preconfig) </p>
<p>Holger Birke </p>
<p>2012-06-29 </p>
<p>2.04.00 </p>
<p>Core 4.03 </p>
<p>Support AR4-R5 (ASR4.0.3) – New API </p>
<p>added </p>
<p>Improve Hardware Loop description </p>
<p>Holger Birke </p>
<p>2012-11-07 </p>
<p>2.05.00 </p>
<p>Core 4.04 </p>
<p>Add Re-initialization description </p>
<p>Instance ID of DET is always 0 </p>
<p>Holger Birke </p>
<p>2012-11-07 </p>
<p>2.05.01 </p>
<p>Improve Hardware Loop description </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>4 </p>
<p>based on template version 3.2 </p>
<p>Holger Birke </p>
<p>2013-10-11 </p>
<p>2.06.00 </p>
<p>Add CAN FD description </p>
<p>(Can_SetBaudrate() API) </p>
<p> </p>
<p><b>History Platforms </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>C. Ünver </p>
<p>2015-04-27 </p>
<p>1.00.00 </p>
<p>Initial version </p>
<p>P. Herrmann </p>
<p>2016-01-28 </p>
<p>1.01.00 </p>
<p>Added MCAN Rev. 3.1.0 changes.  </p>
<p>Additional description concerning the </p>
<p>Bosch  MCAN Errata Sheet. </p>
<p>P. Herrmann </p>
<p>2016-10-06 </p>
<p>1.02.00 </p>
<p>Additional description concerning the </p>
<p>Bosch  MCAN Errata Sheet. </p>
<p> </p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> AUTOSAR_SWS_CAN_DRIVER.pdf </p>
<p>2.4.6 +  </p>
<p>3.0.0 + </p>
<p>4.0.0 </p>
<p>[2] </p>
<p> AUTOSAR_BasicSoftwareModules.pdf </p>
<p>V1.0.0 </p>
<p>[3] </p>
<p> AUTOSAR_SWS BSW Scheduler </p>
<p>V1.1.0 </p>
<p>[4] </p>
<p> AUTOSAR_SWS_CAN_Interface.pdf </p>
<p>3.2.7 +  </p>
<p>4.0.0 + </p>
<p>5.0.0 </p>
<p>[5] </p>
<p> AN-ISC-8-1118 MICROSAR BSW Compatibility Check </p>
<p>V1.0.0 </p>
<p>[6] </p>
<p> M_CAN Controller Area Network Errata Sheet  </p>
<p>REL2015 0701 </p>
<p> </p>
<p><b>1.1 </b></p>
<p><b>Scope of the Document </b></p>
<p>This document describes the functionality, API and configuration of the MICROSAR CAN </p>
<p>driver </p>
<p>as </p>
<p>specified </p>
<p>in </p>
<p>[1].  The </p>
<p>CAN </p>
<p>driver </p>
<p>is </p>
<p>a </p>
<p>hardware </p>
<p>abstraction </p>
<p>layer </p>
<p>with </p>
<p>a </p>
<p>standardized interface to the CAN Interface layer. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector’s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>5 </p>
<p>based on template version 3.2 </p>
<p><b>Contents </b></p>
<p>1.1</p>
<p> </p>
<p>Scope of the Document...................................................................................... 4</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Hardware Overview ...................................................................................................... 8</b></p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Introduction................................................................................................................... 9</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Architecture Overview ...................................................................................... 10</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 12</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Features .......................................................................................................... 12</p>
<p> </p>
<p>4.2</p>
<p> </p>
<p>Initialization ...................................................................................................... 15</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Communication ................................................................................................ 16</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>States / Modes ................................................................................................. 18</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Re-Initialization ................................................................................................ 19</p>
<p> </p>
<p>4.6</p>
<p> </p>
<p>CAN Interrupt Locking ...................................................................................... 19</p>
<p> </p>
<p>4.7</p>
<p> </p>
<p>Main Functions ................................................................................................ 19</p>
<p> </p>
<p>4.8</p>
<p> </p>
<p>Error Handling .................................................................................................. 20</p>
<p> </p>
<p>4.9</p>
<p> </p>
<p>Common CAN .................................................................................................. 24</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>Integration ................................................................................................................... 27</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Scope of Delivery ............................................................................................. 27</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Include Structure .............................................................................................. 28</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Critical Sections ............................................................................................... 28</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>Compiler Abstraction and Memory Mapping ..................................................... 30</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Hardware Specific Hints ............................................................................................. 32</b></p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>API Description ........................................................................................................... 35</b></p>
<p> </p>
<p>7.1</p>
<p> </p>
<p>Interrupt Service Routines provided by CAN .................................................... 35</p>
<p> </p>
<p>7.2</p>
<p> </p>
<p>Services provided by CAN ............................................................................... 36</p>
<p> </p>
<p>7.3</p>
<p> </p>
<p>Services used by CAN ..................................................................................... 60</p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Configuration .............................................................................................................. 62</b></p>
<p> </p>
<p>8.1</p>
<p> </p>
<p>Pre-Compile Parameters .................................................................................. 62</p>
<p> </p>
<p>8.2</p>
<p> </p>
<p>Link-Time Parameters ...................................................................................... 63</p>
<p> </p>
<p>8.3</p>
<p> </p>
<p>Post-Build Parameters ..................................................................................... 63</p>
<p> </p>
<p>8.4</p>
<p> </p>
<p>Configuration with da DaVinci Configurator ...................................................... 64</p>
<p> </p>
<p><b>9</b></p>
<p> </p>
<p><b>AUTOSAR Standard Compliance............................................................................... 65</b></p>
<p> </p>
<p>9.1</p>
<p> </p>
<p>Limitations / Restrictions .................................................................................. 65</p>
<p> </p>
<p>9.2</p>
<p> </p>
<p>Hardware Limitations ....................................................................................... 65</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>6 </p>
<p>based on template version 3.2 </p>
<p>9.3</p>
<p> </p>
<p>Vector Extensions ............................................................................................ 67</p>
<p> </p>
<p><b>10</b></p>
<p> </p>
<p><b>Glossary and Abbreviations ...................................................................................... 68</b></p>
<p> </p>
<p>10.1</p>
<p> </p>
<p>Glossary .......................................................................................................... 68</p>
<p> </p>
<p>10.2</p>
<p> </p>
<p>Abbreviations ................................................................................................... 68</p>
<p> </p>
<p><b>11</b></p>
<p> </p>
<p><b>Contact ........................................................................................................................ 69</b></p>
<p> </p>
<p> </p>
<p><b>Illustrations </b></p>
<p>Figure 3-1</p>
<p> </p>
<p>AUTOSAR 3.x Architecture Overview ....................................................... 10</p>
<p> </p>
<p>Figure 3-2</p>
<p> </p>
<p>AUTOSAR architecture ............................................................................. 11</p>
<p> </p>
<p>Figure 3-3</p>
<p> </p>
<p>Interfaces to adjacent modules of the CAN ............................................... 11</p>
<p> </p>
<p>Figure 5-1</p>
<p> </p>
<p>Include Structure (AUTOSAR) .................................................................. 28</p>
<p> </p>
<p>Figure 7-1</p>
<p> </p>
<p>Select OS Type ......................................................................................... 35</p>
<p> </p>
<p> </p>
<p><b>Tables </b></p>
<p>Table 2-1 </p>
<p> </p>
<p>Supported Hardware Overview ................................................................... 8</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Supported features ................................................................................... 15</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>Hardware mailbox layout .......................................................................... 17</p>
<p> </p>
<p>Table 4-3 </p>
<p> </p>
<p>Errors reported to DET ............................................................................. 20</p>
<p> </p>
<p>Table 4-4</p>
<p> </p>
<p>API from which the Errors are reported ..................................................... 21</p>
<p> </p>
<p>Table 4-5 </p>
<p> </p>
<p>Errors reported to DEM ............................................................................. 22</p>
<p> </p>
<p>Table 4-6 </p>
<p> </p>
<p>Hardware Loop Check .............................................................................. 24</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>Static files ................................................................................................. 27</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>Generated files ......................................................................................... 27</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>Critical Section Codes .............................................................................. 30</p>
<p> </p>
<p>Table 5-4 </p>
<p> </p>
<p>Compiler abstraction and memory mapping .............................................. 31</p>
<p> </p>
<p>Table 7-1 </p>
<p> </p>
<p>MCAN CanIsr_&lt;x&gt;.................................................................................... 36</p>
<p> </p>
<p>Table 7-2 </p>
<p> </p>
<p>Can_InitMemory ....................................................................................... 37</p>
<p> </p>
<p>Table 7-3 </p>
<p> </p>
<p>Can_InitController ..................................................................................... 38</p>
<p> </p>
<p>Table 7-4 </p>
<p> </p>
<p>Can_InitController ..................................................................................... 39</p>
<p> </p>
<p>Table 7-5 </p>
<p> </p>
<p>Can_ChangeBaudrate .............................................................................. 39</p>
<p> </p>
<p>Table 7-6 </p>
<p> </p>
<p>Can_CheckBaudrate ................................................................................ 40</p>
<p> </p>
<p>Table 7-7 </p>
<p> </p>
<p>Can_SetBaudrate ..................................................................................... 41</p>
<p> </p>
<p>Table 7-8 </p>
<p> </p>
<p>Can_InitStruct ........................................................................................... 41</p>
<p> </p>
<p>Table 7-9 </p>
<p> </p>
<p>Can_GetVersionInfo ................................................................................. 42</p>
<p> </p>
<p>Table 7-10 </p>
<p> </p>
<p>Can_GetStatus ......................................................................................... 43</p>
<p> </p>
<p>Table 7-11 </p>
<p> </p>
<p>Can_SetControllerMode ........................................................................... 44</p>
<p> </p>
<p>Table 7-12 </p>
<p> </p>
<p>Can_ResetBusOffStart ............................................................................. 44</p>
<p> </p>
<p>Table 7-13 </p>
<p> </p>
<p>Can_ResetBusOffEnd .............................................................................. 45</p>
<p> </p>
<p>Table 7-14 </p>
<p> </p>
<p>Can_Write................................................................................................. 46</p>
<p> </p>
<p>Table 7-15 </p>
<p> </p>
<p>Can_CancelTx .......................................................................................... 46</p>
<p> </p>
<p>Table 7-16 </p>
<p> </p>
<p>Can_CheckWakeup .................................................................................. 47</p>
<p> </p>
<p>Table 7-17 </p>
<p> </p>
<p>Can_DisableControllerInterrupts ............................................................... 47</p>
<p> </p>
<p>Table 7-18 </p>
<p> </p>
<p>Can_EnableControllerInterrupts................................................................ 48</p>
<p> </p>
<p>Table 7-19 </p>
<p> </p>
<p>Can_MainFunction_Write ......................................................................... 48</p>
<p> </p>
<p>Table 7-20 </p>
<p> </p>
<p>Can_MainFunction_Read ......................................................................... 49</p>
<p> </p>
<p>Table 7-21 </p>
<p> </p>
<p>Can_MainFunction_BusOff ....................................................................... 50</p>
<p> </p>
<p>Table 7-22 </p>
<p> </p>
<p>Can_MainFunction_Wakeup ..................................................................... 50</p>
<p> </p>
<p>Table 7-23 </p>
<p> </p>
<p>Can_MainFunction_Mode ......................................................................... 51</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>7 </p>
<p>based on template version 3.2 </p>
<p>Table 7-24 </p>
<p> </p>
<p>Appl_GenericPrecopy ............................................................................... 51</p>
<p> </p>
<p>Table 7-25 </p>
<p> </p>
<p>Appl_GenericConfirmation ........................................................................ 52</p>
<p> </p>
<p>Table 7-26 </p>
<p> </p>
<p>Appl_GenericConfirmation ........................................................................ 53</p>
<p> </p>
<p>Table 7-27 </p>
<p> </p>
<p>Appl_GenericPreTransmit ......................................................................... 53</p>
<p> </p>
<p>Table 7-28 </p>
<p> </p>
<p>ApplCanTimerStart ................................................................................... 54</p>
<p> </p>
<p>Table 7-29 </p>
<p> </p>
<p>ApplCanTimerLoop ................................................................................... 55</p>
<p> </p>
<p>Table 7-30 </p>
<p> </p>
<p>ApplCanTimerEnd .................................................................................... 55</p>
<p> </p>
<p>Table 7-31 </p>
<p> </p>
<p>ApplCanInterruptDisable ........................................................................... 56</p>
<p> </p>
<p>Table 7-32 </p>
<p> </p>
<p>ApplCanInterruptRestore .......................................................................... 57</p>
<p> </p>
<p>Table 7-33 </p>
<p> </p>
<p>Appl_CanOverrun ..................................................................................... 57</p>
<p> </p>
<p>Table 7-34 </p>
<p> </p>
<p>Appl_CanFullCanOverrun ......................................................................... 58</p>
<p> </p>
<p>Table 7-35 </p>
<p> </p>
<p>Appl_CanCorruptMailbox .......................................................................... 59</p>
<p> </p>
<p>Table 7-36 </p>
<p> </p>
<p>Appl_CanRamCheckFailed ....................................................................... 59</p>
<p> </p>
<p>Table 7-37 </p>
<p> </p>
<p>ApplCanInitPostProcessing ...................................................................... 60</p>
<p> </p>
<p>Table 7-38 </p>
<p> </p>
<p>Services used by the CAN ........................................................................ 61</p>
<p> </p>
<p>Table 10-1 </p>
<p> </p>
<p>Glossary ................................................................................................... 68</p>
<p> </p>
<p>Table 10-2 </p>
<p> </p>
<p>Abbreviations ............................................................................................ 68</p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>8 </p>
<p>based on template version 3.2 </p>
<p><b>2 </b></p>
<p><b>Hardware Overview </b></p>
<p>The  following  table  summarizes  information  about  the  CAN  Driver.  It  gives  you  detailed </p>
<p>information </p>
<p>about </p>
<p>the </p>
<p>derivatives </p>
<p>and </p>
<p>compilers.  As </p>
<p>very </p>
<p>important </p>
<p>information </p>
<p>the </p>
<p>documentations of the hardware manufacturers are listed. The CAN Driver is based upon </p>
<p>these documents in the given version.  </p>
<p> </p>
<p><b>Derivative </b></p>
<p><b>Compiler </b></p>
<p><b>Hardware Manufacturer Document </b></p>
<p><b>Version </b></p>
<p>R7F701325A </p>
<p>R7F701327 </p>
<p>R7F701328 </p>
<p>R7F701329 </p>
<p> </p>
<p>R7F701370A </p>
<p>R7F701370B </p>
<p>R7F701371 </p>
<p>R7F701372 </p>
<p>R7F701372A </p>
<p>R7F701373 </p>
<p>R7F701373A </p>
<p>R7F701374 </p>
<p>R7F701374A </p>
<p>GHS </p>
<p>Compiler </p>
<p>Release </p>
<p>v2015.1.7 </p>
<p>Document Number: RH850/P1x-C Group  </p>
<p>Rev. 0.60, 09/2014 </p>
<p> </p>
<p>RH850/P1x-C Group Rev.0.10 , Nov. 2014 </p>
<p> </p>
<p> </p>
<p>RH850/P1x-C Group User’s Manual: </p>
<p>Hardware Renesas microcontroller RH850 </p>
<p>Family </p>
<p>Rev. 0.60,      </p>
<p>Sep. 2014 </p>
<p> </p>
<p>Nov, 2014 </p>
<p>Rev.0.10 </p>
<p> </p>
<p>Jan, 2016 </p>
<p>Rev.1.00 </p>
<p>Table 2-1  </p>
<p>Supported Hardware Overview </p>
<p><b>Derivative: </b>This can be a single information or a list of derivatives, the CAN Driver can be used on. </p>
<p><b>Compiler: </b>List of Compilers the CAN Driver is working with </p>
<p><b>Hardware Manufacturer Document Name: </b>List of hardware documentation the CAN Driver is based on.  </p>
<p><b>Version: </b>To be able to reference to this hardware documentation its version is very important. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>9 </p>
<p>based on template version 3.2 </p>
<p><b>3 </b></p>
<p><b>Introduction </b></p>
<p>This document describes the functionality, API and configuration of the AUTOSAR BSW </p>
<p>module CAN as specified in [1].  </p>
<p>Since each hardware platform has its own behavior based on the CAN specifications, the </p>
<p>main goal of the CAN driver is to give a standardized interface to support communication </p>
<p>over the CAN bus for each platform in the same way. The CAN driver works closely </p>
<p>together with the higher layer CAN interface. </p>
<p> </p>
<p><b>Supported AUTOSAR Release*: </b></p>
<p>3 and 4 </p>
<p><b>Supported Configuration Variants: </b></p>
<p><b>(Supported AUTOSAR Standard </b></p>
<p><b>Conform Features) </b></p>
<p>Pre-Compile, </p>
<p>Link-Time, </p>
<p>Post-Build Loadable, </p>
<p>Post-Build Selectable (MICROSAR Identity Manager) </p>
<p><b> </b></p>
<p> </p>
<p><b>Vendor ID: </b></p>
<p>CAN_VENDOR_ID </p>
<p>30 decimal </p>
<p>(= Vector-Informatik, </p>
<p>according to HIS) </p>
<p><b>Module ID: </b></p>
<p>CAN_MODULE_ID   </p>
<p>80 decimal </p>
<p>(according to ref. [2]) </p>
<p><b>AR Version: </b></p>
<p>CAN_AR_RELEASE_MAJO</p>
<p>R_VERSION </p>
<p>CAN_AR_RELEASE_MINOR</p>
<p>_VERSION </p>
<p>CAN_AR_RELEASE_REVISI</p>
<p>ON_VERSION </p>
<p>AUTOSAR     Release </p>
<p>Version                </p>
<p>BCD coded </p>
<p><b>SW Version: </b></p>
<p>CAN_SW_MAJOR_VERSIO</p>
<p>N </p>
<p>CAN_SW_MINOR_VERSION </p>
<p>CAN_SW_PATCH_VERSION </p>
<p>MICROSAR         CAN </p>
<p>module Version                </p>
<p>BCD coded </p>
<p>* For the precise AUTOSAR Release 3.x and 4.x please see the release specific documentation.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>10 </p>
<p>based on template version 3.2 </p>
<p><b>3.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The following figure shows where the CAN is located in the AUTOSAR architecture. </p>
<p> </p>
<p>Figure 3-1 </p>
<p>AUTOSAR 3.x Architecture Overview  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>11 </p>
<p>based on template version 3.2 </p>
<p>Figure 3-2 AUTOSAR architecture </p>
<p> </p>
<p> </p>
<p>The next figure shows the interfaces to adjacent modules of the CAN. These interfaces are </p>
<p>described in chapter 7.  </p>
<p>CAN Driver</p>
<p>CAN Interface</p>
<p>... CAN X</p>
<p>EcuM</p>
<p>DET</p>
<p>DEM</p>
<p> </p>
<p>Figure 3-3 </p>
<p>Interfaces to adjacent modules of the CAN </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>12 </p>
<p>based on template version 3.2 </p>
<p><b>4 </b></p>
<p><b>Functional Description </b></p>
<p><b>4.1 </b></p>
<p><b>Features </b></p>
<p>The features listed in this chapter cover the complete functionality specified in [1]. </p>
<p>The  &quot;supported&quot;  and  &quot;not  supported&quot;  features  are  presented  in  the  following  table.  For </p>
<p>further information of not supported features also see chapter 9. </p>
<p> </p>
<p><b>Feature Naming </b></p>
<p><b>Short Description </b></p>
<p><b>CFG5</b></p>
<p><b> </b></p>
<p><b>Initialization </b></p>
<p><b> </b></p>
<p> </p>
<p>   Driver </p>
<p>General driver initialization function </p>
<p>Can_Init() </p>
<p></p>
<p> </p>
<p>   Controller </p>
<p>Controller specific initialization function </p>
<p>Can_InitController(). </p>
<p></p>
<p> </p>
<p><b>Communication </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>   Transmission </p>
<p>Transmitting CAN frames. </p>
<p></p>
<p> </p>
<p>   Transmit confirmation </p>
<p>Callback for successful Transmission. </p>
<p></p>
<p> </p>
<p>   Reception </p>
<p>Receiving CAN frames. </p>
<p></p>
<p> </p>
<p>   Receive indication </p>
<p>Callback for receiving Frame. </p>
<p></p>
<p> </p>
<p><b>Controller Modes </b></p>
<p><b> </b></p>
<p> </p>
<p>   Sleep mode </p>
<p>Controller support sleep mode (power </p>
<p>saving). </p>
<p> </p>
<p>   Wakeup over CAN </p>
<p>Controller support wakeup over CAN. </p>
<p> </p>
<p>   Stop mode </p>
<p>Controller support stop mode (passive to </p>
<p>CAN bus). </p>
<p></p>
<p> </p>
<p>   Bus Off detection </p>
<p>Callback for Bus Off event. </p>
<p></p>
<p> </p>
<p><b>Polling Modes </b></p>
<p><b> </b></p>
<p> </p>
<p>   Tx confirmation </p>
<p>Support polling mode for Transmit </p>
<p>confirmation. </p>
<p></p>
<p> </p>
<p>   Reception </p>
<p>Support polling mode for Reception. </p>
<p></p>
<p> </p>
<p>   Wakeup </p>
<p>Support polling mode for Wakeup event. </p>
<p> </p>
<p>   Bus Off </p>
<p>Support polling mode for Bus Off event. </p>
<p></p>
<p> </p>
<p>   Mode </p>
<p>MICROSAR4x only: Support polling </p>
<p>mode for mode transition. </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Mailbox objects </b></p>
<p><b> </b></p>
<p> </p>
<p>   Tx BasicCAN </p>
<p>Standard mailbox to send CAN frames </p>
<p>(Used by CAN Interface data queue). </p>
<p></p>
<p> </p>
<p>   Multiplexed Tx </p>
<p>Using 3 mailboxes for Tx BasicCAN </p>
<p>mailbox (external priority inversion </p>
<p>avoided). </p>
<p></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>13 </p>
<p>based on template version 3.2 </p>
<p>   Tx FullCAN </p>
<p>Separate mailbox for special Tx message </p>
<p>used. </p>
<p></p>
<p> </p>
<p>      Maximum amount </p>
<p>Available amount of mailboxes. </p>
<p>32 </p>
<p>   Rx FullCAN </p>
<p>Separate mailbox for special Rx </p>
<p>message used. </p>
<p></p>
<p> </p>
<p>      Maximum amount </p>
<p>Available amount of mailboxes. </p>
<p>64 </p>
<p>   Rx BasicCAN </p>
<p>Standard mailbox to receive CAN frame </p>
<p>(depending on hardware, FIFO or </p>
<p>shadow buffer supported). </p>
<p></p>
<p> </p>
<p>      Maximum amount </p>
<p>Available amount of BasicCAN objects. </p>
<p>By default there is one FIFO(0) </p>
<p>supported with a max. amount of 64 </p>
<p>entries. In case of “Multiple BasicCAN” </p>
<p>(see below) support an additional second </p>
<p>FIFO(1) with 64 entries is supported. </p>
<p>2*64 </p>
<p><b>Others </b></p>
<p><b> </b></p>
<p> </p>
<p>   DEM </p>
<p>Support Diagnostic Event Manager (error </p>
<p>notification). </p>
<p></p>
<p> </p>
<p>   DET </p>
<p>Support Development Error Detection </p>
<p>(error notification). </p>
<p></p>
<p> </p>
<p>   Version API </p>
<p>API to read out component version. </p>
<p></p>
<p> </p>
<p>   Maximum supported </p>
<p>Controllers </p>
<p>Maximum amount of supported </p>
<p>controllers (hardware channels). </p>
<p>4 </p>
<p>   Cancellation of Tx objects </p>
<p>Support of Tx Cancellation (out of </p>
<p>hardware). Avoid internal priority </p>
<p>inversion. </p>
<p></p>
<p> </p>
<p>   Identical ID cancellation </p>
<p>Tx Cancellation also for identical IDs.  </p>
<p></p>
<p> </p>
<p>   Standard ID types </p>
<p>Standard Identifier supported (Tx and </p>
<p>Rx). </p>
<p></p>
<p> </p>
<p>   Extended ID types </p>
<p>Extended Identifier supported (Tx and </p>
<p>Rx). </p>
<p></p>
<p> </p>
<p>   Mixed ID types </p>
<p>Standard and Extended Identifier </p>
<p>supported (Tx and Rx). </p>
<p></p>
<p> </p>
<p>   CAN FD Mode1 </p>
<p>FD frames with baudrate switch </p>
<p>supported (Tx and Rx). </p>
<p>- </p>
<p>   CAN FD Mode2 </p>
<p>FD frames up to 64 data bytes supported </p>
<p>(Tx and Rx). </p>
<p></p>
<p>**** </p>
<p>   Hardware Loop Check </p>
<p>     (Timeout monitoring) </p>
<p>To avoid possible endless loops (occur </p>
<p>by hardware issue). </p>
<p></p>
<p> </p>
<p><b>AutoSar extensions </b></p>
<p><b> </b></p>
<p> </p>
<p>   Individual Polling </p>
<p>Support individual polling mode </p>
<p>(selectable for each mailbox separate). </p>
<p> </p>
<p></p>
<p>* </p>
<p>   Multiple Rx Basic CAN </p>
<p>Support Multiple BasicCAN objects.  </p>
<p></p>
<p>* </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>14 </p>
<p>based on template version 3.2 </p>
<p>This gives the possibility to use </p>
<p>additionally Fifo-1 with 64 additional </p>
<p>elements. By optimizing the   acceptance </p>
<p>filtering overruns can be avoided . </p>
<p>   Multiple Tx Basic CAN </p>
<p>Support Multiple Tx BasicCAN objects. </p>
<p>Used to send different Tx groups over </p>
<p>separate mailboxes with different </p>
<p>buffering behavior (see Can Interface). </p>
<p></p>
<p>* </p>
<p> </p>
<p> </p>
<p> </p>
<p>   Rx Queue </p>
<p>Support Rx Queue. This offers the </p>
<p>possibility to buffer received data in </p>
<p>interrupt context but handle it later </p>
<p>asynchronous in the polling task. </p>
<p></p>
<p>* </p>
<p>   Secure Rx Buffer used </p>
<p>Special hardware buffer used to </p>
<p>temporary save received data.  </p>
<p></p>
<p> </p>
<p>   Hardware Loop Check by </p>
<p>Application </p>
<p>“Hardware Loop Check”  can be defined </p>
<p>to be done by application (special API </p>
<p>available) </p>
<p></p>
<p> </p>
<p>   Configurable “Nested CAN </p>
<p>Interrupts” </p>
<p>Nested CAN interrupts allowed, and can </p>
<p>be also switched to none-nested. </p>
<p></p>
<p> </p>
<p>   Report CAN_E_TIMEOUT </p>
<p>DEM   as DET </p>
<p>Report CAN_E_TIMEOUT (Hardware </p>
<p>Loop Check / Timeout monitoring) to DET </p>
<p>instead of DEM. </p>
<p></p>
<p> </p>
<p>   Support Mixed ID </p>
<p>Force CAN driver to handle Mixed ID </p>
<p>(standard and extended ID) at pre-</p>
<p>compile-time to expand the ID type later </p>
<p>on. </p>
<p></p>
<p> </p>
<p>   Optimize for one controller </p>
<p>Activate this for 1 controller systems </p>
<p>when you never will expand to multi-</p>
<p>controller. So that the CAN driver works </p>
<p>more efficient  </p>
<p></p>
<p> </p>
<p>   Dynamic FullCAN Tx ID </p>
<p>(***) </p>
<p>Always write FullCAN Tx ID within </p>
<p>CanWrite() API function. Deactivate this </p>
<p>to optimize code when you do not use </p>
<p>FullCAN Tx objects dynamically. </p>
<p></p>
<p> </p>
<p>   Size of Hw HandleType </p>
<p>Support 8-bit or 16-bit Hardware Handles </p>
<p>depending on the hardware usage. </p>
<p></p>
<p> </p>
<p>   Generic PreCopy </p>
<p>Support a callback function for receiving </p>
<p>any CAN message (following callbacks </p>
<p>could be suppressed) </p>
<p></p>
<p> </p>
<p>   Generic Confirmation </p>
<p>Support a callback function for successful </p>
<p>transmission of any CAN message </p>
<p>(following callbacks could be </p>
<p>suppressed) </p>
<p></p>
<p> </p>
<p>   Get Hardware Status </p>
<p>Support a API to get hardware status </p>
<p>Information (see Can_GetStatus()) </p>
<p></p>
<p> </p>
<p>   Interrupt Category </p>
<p>selection </p>
<p>Support Category 1 or Category 2 </p>
<p>Interrupt Service Routines for OS  </p>
<p></p>
<p> </p>
<p>   Common CAN </p>
<p>Support merge of 2 controllers in </p>
<p>hardware to get more Rx FullCAN </p>
<p></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>15 </p>
<p>based on template version 3.2 </p>
<p>objects </p>
<p>   Overrun Notification </p>
<p>Support DET or Application notification </p>
<p>caused by overrun (overwrite) of an Rx </p>
<p>message. </p>
<p>Please note that ‘Overrun’ is supported </p>
<p>for BasicCAN objects but is not available </p>
<p>for FullCAN objects.  </p>
<p>While not processed  a Message ID Filter </p>
<p>Element referencing a specific FullCAN </p>
<p>object will not match, causing the </p>
<p>acceptance filtering to continue. </p>
<p>Subsequent Message ID Filter Elements </p>
<p>may cause the received message to be </p>
<p>stored into  </p>
<p>- another FullCAN object, or </p>
<p>- a BasicCAN object, or </p>
<p>- the message may be rejected, </p>
<p>depending on the filter configuration. </p>
<p> </p>
<p></p>
<p> </p>
<p>   RAM check </p>
<p>Support CAN mailbox RAM check </p>
<p></p>
<p> </p>
<p>   Multiple ECU </p>
<p>configurations (***) </p>
<p>The feature Multiple ECU is usually used </p>
<p>for nodes that exist more than once in a </p>
<p>car. At power up the application decides </p>
<p>which node should be realized. </p>
<p></p>
<p> </p>
<p>   Generic PreTransmit </p>
<p>Support a callback function with pointer </p>
<p>to Data, right before this data will be </p>
<p>written in Hardware mailbox buffer to </p>
<p>send. (Use this to change data or cancel </p>
<p>transmission) </p>
<p></p>
<p> </p>
<p>Table 4-1  </p>
<p>Supported features </p>
<p></p>
<p> </p>
<p>Feature is supported</p>
<p> </p>
<p></p>
<p> </p>
<p>Feature is not supported </p>
<p>*     </p>
<p>HighEnd Licence only </p>
<p>**</p>
<p>   Project specific (may not be available) </p>
<p>***</p>
<p>  Not supported or cannot be configured for AutoSar version 4 </p>
<p>****</p>
<p> Only available for MicroSar 4 </p>
<p> </p>
<p><b>4.2 </b></p>
<p><b>Initialization </b></p>
<p>Can_Init()</p>
<p> has to be called to initialize the CAN driver at power on and sets controller </p>
<p>independent init values. This function has to be called before </p>
<p>Can_InitController()</p>
<p>. </p>
<p>MicroSar3 only: Use </p>
<p>Can_InitStruct()</p>
<p> to change the used baud rate and filter settings </p>
<p>like </p>
<p>given </p>
<p>in </p>
<p>the </p>
<p>Initialization </p>
<p>structure </p>
<p>from </p>
<p>the </p>
<p>Tool. </p>
<p>The </p>
<p>used </p>
<p>default </p>
<p>set </p>
<p>by </p>
<p>Can_InitMemory()</p>
<p> </p>
<p>is </p>
<p>the </p>
<p>first </p>
<p>structure. </p>
<p>This </p>
<p>API </p>
<p>has </p>
<p>to </p>
<p>be </p>
<p>called </p>
<p>before </p>
<p>Can_InitController()</p>
<p> but after </p>
<p>Can_InitMemory()</p>
<p>. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>16 </p>
<p>based on template version 3.2 </p>
<p>MICROSAR401 only: baud rate settings given by Can_InitController parameter. </p>
<p>Can_InitController()</p>
<p> initializes the controller, given as parameter, and can also be </p>
<p>used to reinitialize. After this call the controller stays in stop-mode until the CAN Interface </p>
<p>changes to start-mode. </p>
<p>Can_InitMemory()</p>
<p> is an additional service function to reinitialize the memory to bring </p>
<p>the  driver  back  to  a  pre-power-on  state  (not  initialized).  Afterwards </p>
<p>Can_Init()</p>
<p>  and </p>
<p>Can_InitController()</p>
<p> have to be called again. It is recommended to use this function </p>
<p>before calling </p>
<p>Can_Init()</p>
<p> to secure that no startup-code specific pre-initialized variables </p>
<p>affect the driver startup behavior. </p>
<p><b>4.3 </b></p>
<p><b>Communication </b></p>
<p>Can_Write()</p>
<p>  is  used  to  send  a  message  over the  mailbox  object  given  as  &quot;Hth&quot;. The </p>
<p>data, DLC and ID is copied into the hardware mailbox object and a send request is set. </p>
<p>After  sending  the  message  the  CAN  Interface </p>
<p>CanIf_TxConfirmation()</p>
<p>  function  is </p>
<p>called.  Right  before  the  data  is  copied  in  mailbox  buffer  the  ID,  DLC  and  data  may  be </p>
<p>changed by </p>
<p>Appl_GenericPreTransmit()</p>
<p> callback. </p>
<p>When  “Generic  Confirmation“ is activated  the  callback </p>
<p>Appl_GenericConfirmation</p>
<p>()  </p>
<p>will be called before </p>
<p>CanIf_TxConfirmation()</p>
<p> and the call to this can be suppressed </p>
<p>by </p>
<p>Appl_GenericConfirmation</p>
<p>()  return value. </p>
<p>For Tx messages the ID  will be copied. (Exception: feature “Dynamic FullCAN Tx ID” is </p>
<p>deactivated, then the FullCAN Tx messages will be only set while initialization) </p>
<p>If the mailbox is currently sending the status busy will be returned. Then the message may </p>
<p>be queued in the CAN interface (if feature is active). </p>
<p>If  cancellation  in  hardware  is  supported  the  lowest  priority  ID  inside  currently  sending </p>
<p>object is canceled, and therefore re-queued in the CAN Interface. </p>
<p>Appl_GenericPreCopy</p>
<p>() </p>
<p>(if </p>
<p>activated) </p>
<p>is </p>
<p>called </p>
<p>and </p>
<p>depend </p>
<p>on </p>
<p>return </p>
<p>value </p>
<p>also </p>
<p>CanIf_RxIndication()</p>
<p>  as  a  CAN  Interface  callback,  is  called  when  a  message  is </p>
<p>received. The receive information like ID, DLC and data are given as parameter. </p>
<p>When Rx Queue is activated the received messages (polling or interrupt context) will be </p>
<p>queued </p>
<p>(same </p>
<p>queue </p>
<p>over </p>
<p>all </p>
<p>channels). </p>
<p>The </p>
<p>Rx </p>
<p>Queue </p>
<p>will </p>
<p>be </p>
<p>read </p>
<p>by </p>
<p>calling </p>
<p>Can_Mainfunction_Read</p>
<p>  ()  and the  Rx  Indication  (like </p>
<p>CanIf_RxIndication</p>
<p>())  will </p>
<p>be  called  out  of  this  context.  Rx  Queue  is  used  for  Interrupt  systems  to  keep  Interrupt </p>
<p>latency time short. </p>
<p> </p>
<p><b>4.3.1 </b></p>
<p><b>Mailbox Layout </b></p>
<p>The  generation  tool  supports  a  flexible  allocation  of  message  buffers.  In  the  following </p>
<p>tables the possible mailbox layout is shown (the range for each mailbox type depends on </p>
<p>the used mailboxes).</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>17 </p>
<p>based on template version 3.2 </p>
<p><b>Hardware </b></p>
<p><b>object </b></p>
<p><b>number </b></p>
<p><b>Hardware </b></p>
<p><b>object </b></p>
<p><b>type </b></p>
<p><b>Amount of </b></p>
<p><b>hardware </b></p>
<p><b>objects </b></p>
<p><b>Description </b></p>
<p>0… N </p>
<p><b>Tx </b></p>
<p><b>FullCAN </b></p>
<p>0 … 31 max.  </p>
<p>(0 … 29 in </p>
<p>case of </p>
<p>multiplexed </p>
<p>transmission) </p>
<p>These objects are used to transmit specific message IDs. </p>
<p>The user must define statically in the generation tool </p>
<p>which CAN message IDs are located in Tx FullCAN </p>
<p>objects. The generation tool assigns the message IDs to </p>
<p>the FullCAN hardware objects. </p>
<p>(N+1)  </p>
<p>… M </p>
<p><b>Tx </b></p>
<p><b>BasicCAN </b></p>
<p>1 or 3          (3 </p>
<p>in case of </p>
<p>multiplexed </p>
<p>transmission) </p>
<p>All other CAN message IDs are transmitted via the Tx </p>
<p>Basic object. If the transmit message object is busy, the </p>
<p>transmit requests are stored in the CAN Interface queue </p>
<p>(if activated). </p>
<p>(M+1)  </p>
<p> … O </p>
<p><b>Unused </b></p>
<p>0 … 95 </p>
<p>These objects are not used. It depends on the  </p>
<p>configuration of receive and transmit objects how many  </p>
<p>unused objects are available. </p>
<p>O…P </p>
<p><b>Rx </b></p>
<p><b>FullCAN </b></p>
<p>0 … 64 </p>
<p>These objects are used to receive specific CAN  </p>
<p>messages. The user defines statically (Generation Tool)  </p>
<p>that a CAN message should be received in a FullCAN  </p>
<p>message object. The Generation Tool distributes the  </p>
<p>messages to the FullCAN objects. </p>
<p>96 </p>
<p><b>Rx </b></p>
<p><b>BasicCAN </b></p>
<p>FIFO-0 with   </p>
<p>max. 64 </p>
<p>entries   </p>
<p>All CAN message IDs, depending on the acceptance filter   </p>
<p>match, are received via the Rx BasicCAN message object   </p>
<p>through Rx FIFO 0. </p>
<p>Each Rx Basic message object consists of 64 message   </p>
<p>buffers.    </p>
<p>128 acceptance filters are available for standard IDs and   </p>
<p>64   acceptance filters are available for extended IDs.    </p>
<p>In case of mixed ID mode 128+64 = 192 filters are   </p>
<p>available.   </p>
<p>Please note that this maximum amount of filters is also   </p>
<p>used for FIFO-1 if available.    </p>
<p>97 </p>
<p><b>Rx </b></p>
<p><b>BasicCAN </b></p>
<p>FIFO-1 with   </p>
<p>max. 64   </p>
<p>entries </p>
<p>All CAN message IDs, depending on the acceptance filter   </p>
<p>match,  are received via the Rx BasicCAN message   </p>
<p>objects through Rx FIFO 1.   </p>
<p>Each Rx Basic message object consists of 64 message   </p>
<p>buffers.    </p>
<p>128 acceptance filters are available for standard IDs and   </p>
<p>64   acceptance filters are available for extended IDs.    </p>
<p>In case of mixed ID mode 128+64 = 192 filters are   </p>
<p>available.   </p>
<p>Please note that this maximum amount of filters is also   </p>
<p>used for FIFO-0. </p>
<p>Table 4-2  </p>
<p>Hardware mailbox layout </p>
<p> </p>
<p>The “CanObjectId” (ECUc parameter) numbering is done in following order: Tx FullCAN, </p>
<p>Tx </p>
<p>BasicCAN, </p>
<p>Unused, </p>
<p>Rx </p>
<p>BasicCAN </p>
<p>(like </p>
<p>shown </p>
<p>above). </p>
<p>“CanObjectId’s” </p>
<p>for </p>
<p>next </p>
<p>controller begin at end of last controller. Gaps in “CanObjectId” for unused mailboxes may </p>
<p>occur.  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>18 </p>
<p>based on template version 3.2 </p>
<p><b>4.3.2 </b></p>
<p><b>Mailbox Processing Order </b></p>
<p>The hardware mailbox will be processed in following order:  </p>
<p><b>Object Type </b></p>
<p><b>Order / priority to send or receive </b></p>
<p>Tx FullCAN </p>
<p>Object ID Low to High </p>
<p>Tx BasicCAN </p>
<p>Object ID Low to High </p>
<p>Rx FullCAN </p>
<p>Object ID Low to High </p>
<p>Rx BasicCAN </p>
<p>FIFO </p>
<p> </p>
<p>In Case of Interrupt Rx FullCANs will be processed before Rx BasicCANs. </p>
<p>In Case of Polling Rx FullCANs will be processed before Rx BasicCANs. </p>
<p>The order between Rx and Tx mailboxes depends on the call order of the polling tasks or </p>
<p>the interrupt context and cannot be guaranteed. </p>
<p>The Rx Queue will work like a FIFO filled with the above mentioned method. </p>
<p> </p>
<p> </p>
<p><b>4.3.3 </b></p>
<p><b>Acceptance Filter for BasicCAN </b></p>
<p>For  each  CAN  channel  a  maximum  amount  of  128  filters  for  standard  and  64  </p>
<p>filters  for extended  ID  configurations  is  available.  Thus  192  filters  are  available  for  </p>
<p>mixed  ID configurations.  </p>
<p> </p>
<p>For  acceptance  filtering  each  list  of  filters  is  executed  from  element  #0  until  the  </p>
<p>first matching  element.  Acceptance  filtering  stops  at  the  first  matching  element.  Each  </p>
<p>filter  element  decides  if  the  received  message  is  stored  within  FIFO-0  (or  FIFO-1  if </p>
<p>available).  </p>
<p> </p>
<p>If  no  message  should  be  received,  select  the  “Multiple  Basic  CAN”  feature  and  set  </p>
<p>the amount  to  0.  Otherwise  the  filter  should  be  set  to  “close”.  Use  feature  “Rx  </p>
<p>BasicCAN Support” to deactivate unused code (for optimization). </p>
<p> </p>
<p><b>4.3.4 </b></p>
<p><b>Remote Frames </b></p>
<p>The CAN driver initializes the CAN controller not to receive remote frames. Therefore no  </p>
<p>additional action is required during runtime by the  CAN driver for remote frame filtering.  </p>
<p>Remote  frames  will  not  have  any  influence  on  communication  because  they  are  not  </p>
<p>received by the CAN hardware. </p>
<p><b>4.4 </b></p>
<p><b>States / Modes </b></p>
<p>You  can  change  the  CAN  cell  mode  via  Can_SetControllerMode().  The  last  requested </p>
<p>transition will be executed. The Upper layer has to take care about valid transitions. </p>
<p>The following modes changes are supported: </p>
<p>CAN_T_START </p>
<p>CAN_T_STOP </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>19 </p>
<p>based on template version 3.2 </p>
<p>  </p>
<p>MICROSAR4 only: Notification of mode change may occur asynchronous by notification </p>
<p>CanIf_ControllerModeIndication() </p>
<p><b>4.4.1 </b></p>
<p><b>Start Mode (Normal Running Mode) </b></p>
<p>This  is  the  mode  where  communication  is  possible.  This  mode  has  to  be  set  after  </p>
<p>Initialization because Controller is first in stop-mode.  </p>
<p>  </p>
<p>The  Bit  Stream  Processor  synchronizes  itself  to  the  data  transfer  on  the  CAN  bus  </p>
<p>by waiting  for  the  occurrence  of  a  sequence  of  11  consecutive  recessive  bits  (=  </p>
<p>Bus_Idle) before it can take part in bus activities and start the message transfer. </p>
<p> </p>
<p><b>4.4.2 </b></p>
<p><b>Stop Mode </b></p>
<p>If stop mode is requested, either by software or by going BusOff, then the CAN module is  </p>
<p>switched  into  INIT  mode.  In  this  mode  message  transfer  from  and  to  the  CAN  bus  </p>
<p>is stopped, the status of the CAN bus transmit output is recessive (HIGH).   </p>
<p>Going to stop mode does not change any configuration register. </p>
<p> </p>
<p><b>4.4.3 </b></p>
<p><b>Bus Off </b></p>
<p>CanIf_ControllerBusOff()</p>
<p> is called when the controller detects a Bus Off event. The </p>
<p>mode  is  automatically  changed  to  stop  mode.  The  upper  layers  have  to  care  about </p>
<p>returning to normal running mode by calling start mode </p>
<p><b>4.5 </b></p>
<p><b>Re-Initialization </b></p>
<p>A call to Can_InitController() cause a re-initialization of a dedicated CAN controller.  </p>
<p>Pending  messages  may  be  processed  before  the  transition  will  be  finished.  A  re- </p>
<p>initialization is only possible out of Stop Mode and does not change to another Mode.  </p>
<p>After re-initialization all CAN communication relevant registers are set to initial conditions. </p>
<p><b>4.6 </b></p>
<p><b>CAN Interrupt Locking </b></p>
<p>Can_DisableControllerInterrupts()</p>
<p> and </p>
<p>Can_EnableControllerInterrupts()</p>
<p> are used to disable and enable the controller </p>
<p>specific Interrupt, Rx, Tx, Wakeup and Bus Off (/ Status) together. These functions can be </p>
<p>called nested. </p>
<p><b>4.7 </b></p>
<p><b>Main Functions </b></p>
<p>Can_MainFunction_Write()</p>
<p>, </p>
<p>Can_MainFunction_Read()</p>
<p>, </p>
<p>Can_MainFunction_BusOff()</p>
<p> and </p>
<p>Can_MainFunction_Wakeup()</p>
<p> are called by </p>
<p>upper layers to poll the events if the specific polling mode is activated. Otherwise these </p>
<p>functions return without any action and the events will be handled in interrupt context. </p>
<p>When individual polling is activated only mailboxes that are configured as to be polled will </p>
<p>be polled in the main functions “</p>
<p>Can_MainFunction_Write()</p>
<p>” and </p>
<p>“</p>
<p>Can_MainFunction_Read()</p>
<p>”, all others are handled in interrupt context. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>20 </p>
<p>based on template version 3.2 </p>
<p>If the Rx Queue feature is activated then the queue is filled in interrupt or polling context, </p>
<p>like configured. But the processing (indications) will be done in </p>
<p>“</p>
<p>Can_MainFunction_Read()</p>
<p>” context. </p>
<p>MICROSAR4 only: Can_MainFunction_Mode() can be called by upper layers to poll </p>
<p>asynchronous mode transition notifications. </p>
<p><b>4.8 </b></p>
<p><b>Error Handling </b></p>
<p><b>4.8.1 </b></p>
<p><b>Development Error Reporting </b></p>
<p>Development errors are reported to DET using the service </p>
<p>Det_ReportError()</p>
<p>, if the </p>
<p>pre-compile parameter CAN_DEV_ERROR_DETECT == STD_ON. </p>
<p>The tables below, shows the API ID and Error ID given as parameter for calling the DET. </p>
<p>Instance ID is always 0 because no multiple Instances are supported. </p>
<p><b>Errors reported to DET: </b></p>
<p><b>Error ID </b></p>
<p><b>Short Description </b></p>
<p>CAN_E_PARAM_POINTER </p>
<p>API gets an illegal pointer as parameter. </p>
<p>CAN_E_PARAM_HANDLE </p>
<p>API gets an illegal handle as parameter </p>
<p>CAN_E_PARAM_DLC </p>
<p>API gets an illegal DLC as parameter </p>
<p>CAN_E_PARAM_CONTROLLER </p>
<p>API gets an illegal controller as parameter </p>
<p>CAN_E_UNINIT </p>
<p>Driver API is used but not initialized </p>
<p>CAN_E_TRANSITION </p>
<p>Transition for mode change is illegal </p>
<p>CAN_E_DATALOST </p>
<p>(value: 0x07, AutoSar extension) </p>
<p>Rx overrun (overwrite) detected </p>
<p>CAN_E_PARAM_BAUDRATE </p>
<p>(value: 0x08, AutoSar extension) </p>
<p>Selected Baudrate is not valid </p>
<p>CAN_E_RXQUEUE </p>
<p>(value: 0x10, AutoSar extension) </p>
<p>Rx Queue overrun  </p>
<p>(Last received message is lost and will not be received.  </p>
<p>Avoid this by increasing the queue size) </p>
<p>CAN_E_TIMEOUT_DET </p>
<p>(value: 0x11, AutoSar extension) </p>
<p>Same as CAN_E_TIMEOUT for DEM but this is notified to DET </p>
<p>due to switch “CAN_DEV_TIMEOUT_DETECT” is set to </p>
<p>STD_ON (see configuration options) </p>
<p> </p>
<p> </p>
<p>Table 4-3  </p>
<p>Errors reported to DET </p>
<p> </p>
<p><b>API from which the errors are reported to DET: </b></p>
<p><b>API ID </b></p>
<p><b>Functions using that ID </b></p>
<p>CAN_VERSION_ID </p>
<p>Can_GetVersionInfo() </p>
<p>CAN_INIT_ID </p>
<p>Can_Init() </p>
<p>CAN_INITCTR_ID </p>
<p>Can_InitController() </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>21 </p>
<p>based on template version 3.2 </p>
<p>CAN_SETCTR_ID </p>
<p>Can_SetControllerMode() </p>
<p>CAN_DIINT_ID </p>
<p>Can_DisableControllerInterrupts() </p>
<p>CAN_ENINT_ID </p>
<p>Can_EnableControllerInterrupts() </p>
<p>CAN_WRITE_ID </p>
<p>Can_Write(), Can_CancelTx() </p>
<p>CAN_TXCNF_ID </p>
<p>CanHL_TxConfirmation() </p>
<p>CAN_RXINDI_ID </p>
<p>CanBasicCanMsgReceived(), CanFullCanMsgReceived() </p>
<p>CAN_CTRBUSOFF_ID </p>
<p>CanHL_ErrorHandling() </p>
<p>CAN_CKWAKEUP_ID </p>
<p>CanHL_WakeUpHandling(), Can_Cbk_CheckWakeup() </p>
<p>CAN_MAINFCT_WRITE_ID </p>
<p>Can_MainFunction_Write() </p>
<p>CAN_MAINFCT_READ_ID </p>
<p>Can_MainFunction_Read() </p>
<p>CAN_MAINFCT_BO_ID </p>
<p>Can_MainFunction_BusOff() </p>
<p>CAN_MAINFCT_WU_ID </p>
<p>Can_MainFunction_Wakeup() </p>
<p>CAN_MAINFCT_MODE_ID </p>
<p>Can_MainFunction_Mode() </p>
<p>CAN_CHANGE_BR_ID </p>
<p>Can_ChangeBaudrate() </p>
<p>CAN_CHECK_BR_ID </p>
<p>Can_CheckBaudrate() </p>
<p>CAN_SET_BR_ID </p>
<p>Can_SetBaudrate() </p>
<p>CAN_HW_ACCESS_ID </p>
<p>(value: 0x20, AUTOSAR extension) </p>
<p>Used when hardware is accessed (call context is unknown) </p>
<p>Table 4-4 </p>
<p>API from which the Errors are reported </p>
<p><b>4.8.1.1 </b></p>
<p><b>Parameter Checking </b></p>
<p>AUTOSAR requires that API functions check the validity of their parameters (Refer to [1]). </p>
<p>These  checks  are  for  development  error  reporting  and  can  be  enabled  and  disabled </p>
<p>separately. Refer to the configuration chapter where the enabling/disabling of the checks is </p>
<p>described.  Enabling/disabling  of  single  checks  is  an  addition  to  the AUTOSAR  standard </p>
<p>which </p>
<p>requires </p>
<p>enable/disable </p>
<p>the </p>
<p>complete </p>
<p>parameter </p>
<p>checking </p>
<p>via </p>
<p>the </p>
<p>parameter </p>
<p>CAN_DEV_ERROR_DETECT</p>
<p>. </p>
<p> </p>
<p><b>4.8.1.2 </b></p>
<p><b>Overrun/Overwrite Notification </b></p>
<p>As AUTOSAR extension the overrun detection may be activated by configuration tool. The </p>
<p>notification can be configured to issue a DET call (MICROSAR 4.x) or an Application call </p>
<p>(<i>Appl_CanOverrun</i>()). </p>
<p> </p>
<p><b>4.8.2 </b></p>
<p><b>Production Code Error Reporting </b></p>
<p>Production </p>
<p>code </p>
<p>related </p>
<p>errors </p>
<p>are </p>
<p>reported </p>
<p>to </p>
<p>DEM </p>
<p>using </p>
<p>the </p>
<p>service </p>
<p>Dem_ReportErrorStatus()</p>
<p>, if the pre-compile parameter </p>
<p>CAN_PROD_ERROR_DETECT </p>
<p>== STD_ON</p>
<p>. </p>
<p>The table below shows the Event ID and Event Status given as parameter for calling the </p>
<p>DEM. This callout may occur in the context of different API calls (see Chapter “4.8.2.1”). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>22 </p>
<p>based on template version 3.2 </p>
<p><b>Event ID </b></p>
<p><b>Event Status </b></p>
<p><b>Short Description </b></p>
<p>CAN_E_TIMEOUT </p>
<p> </p>
<p>DEM_EVENT_STATUS_FAILED </p>
<p>Timeout in “Hardware Loop Check” </p>
<p>occurred, hardware has to be checked </p>
<p>or timeout is too short. </p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 4-5  </p>
<p>Errors reported to DEM </p>
<p><b>4.8.2.1 </b></p>
<p><b>Hardware Loop Check / Timeout Monitoring </b></p>
<p>The feature “Hardware Loop Check” is used to break endless loops caused by hardware </p>
<p>issue. This feature is configurable see Chapter 7 and also Timeout Duration description. </p>
<p>The  Hardware  Loop  Check  will  be  handled  by  CAN  driver  internal  except  when  setting </p>
<p>“</p>
<p>Hardware Loop Check by Application</p>
<p>” is activated. </p>
<p><b>Loop Name / </b></p>
<p><b>source </b></p>
<p><b>Short Description </b></p>
<p>kCanLoopInit  </p>
<p>This channel dependent loop is called in Can_InitController  </p>
<p>and is processed as long as the CAN cell does not enter  </p>
<p>resp. leave the configuration mode.   </p>
<p>While entering the configuration mode, message transfer from  </p>
<p>and to the CAN bus is stopped, the status of the CAN bus  </p>
<p>transmit output is recessive.   </p>
<p>There is a delay from writing to a command register until  </p>
<p>the update of the related status register bits due to clock  </p>
<p>domain crossing (Host and CAN clock). Therefore the  </p>
<p>programmer has to assure that the previous value written to  </p>
<p>INIT has been accepted.  </p>
<p>Due to the high precision clocking requirements of the CAN  </p>
<p>Core, a separate clock without any modulation has to be  </p>
<p>provided as CAN clock. The CAN Core should be programmed to  </p>
<p>have at least 8 clocks per bit time (e.g.: at least 8 MHz  </p>
<p>CAN clock at 1 Mbaud CAN speed). In order to achieve a  </p>
<p>stable function of the M_CAN, the Host clock must always be  </p>
<p>faster than or equal to the CAN clock.   </p>
<p>If the loop cancels, try to reinitialize the controller  </p>
<p>again or reset the hardware.  </p>
<p>After leaving the configuration mode the Bit Stream  </p>
<p>Processor synchronizes itself to the data transfer on the  </p>
<p>CAN bus by waiting for the occurrence of a sequence of 11  </p>
<p>consecutive recessive bits (= Bus_Idle) before it can take  </p>
<p>part in bus activities and start the message transfer. </p>
<p>kCanLoopStart</p>
<p> </p>
<p>MICROSAR3: </p>
<p>- Used while transition in mode ‘START’. </p>
<p>- Call context: Can_SetControllerMode() </p>
<p>- There is a delay from writing to a command register until </p>
<p>the update of the related status register bits due to clock </p>
<p>domain crossing (Host and CAN clock). Therefore the </p>
<p>programmer has to assure that the previous value written to </p>
<p>INIT has been accepted. </p>
<p>- If the loop cancels try to recall Can_SetControllerMode(). </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>23 </p>
<p>based on template version 3.2 </p>
<p><b>Loop Name / </b></p>
<p><b>source </b></p>
<p><b>Short Description </b></p>
<p>  </p>
<p>MICROSAR4: </p>
<p>Used for short time mode transition blocking (short </p>
<p>synchronous timeout). Same value for kCanLoopStart, </p>
<p>kCanLoopStop, kCanLoopSleep and kCanLoopWakeup.  </p>
<p>No Issue when timeout occurs.</p>
<p> </p>
<p>kCanLoopStop</p>
<p> </p>
<p> </p>
<p>MICROSAR3: </p>
<p>- Used while transition in mode ‘STOP’. </p>
<p>- Call context: Can_SetControllerMode() </p>
<p>- There is a delay from writing to a command register until </p>
<p>the update of the related status register bits due to clock </p>
<p>domain crossing (Host and CAN clock). Therefore the </p>
<p>programmer has to assure that the previous value written to </p>
<p>INIT has been accepted. </p>
<p>- If the loop cancels try to recall Can_SetControllerMode(). </p>
<p> </p>
<p>MICROSAR4: </p>
<p>Used for short time mode transition blocking (short </p>
<p>synchronous timeout). Same value for kCanLoopStart, </p>
<p>kCanLoopStop, kCanLoopSleep and kCanLoopWakeup.  </p>
<p>No Issue when timeout occurs.</p>
<p> </p>
<p>kCanLoopSleep</p>
<p> </p>
<p>MICROSAR3: </p>
<p>- Used while transition in mode ‘SLEEP’. </p>
<p>- Call context: Can_SetControllerMode() </p>
<p>- When all pending transmission requests have completed, the </p>
<p>M_CAN waits until bus idle state is detected. </p>
<p>- If the loop cancels try to recall Can_SetControllerMode. </p>
<p> </p>
<p>MICROSAR4: </p>
<p>Used for short time mode transition blocking (short </p>
<p>synchronous timeout). Same value for kCanLoopStart, </p>
<p>kCanLoopStop, kCanLoopSleep and kCanLoopWakeup.  </p>
<p>No Issue when timeout occurs.</p>
<p> </p>
<p>kCanLoopWakeup</p>
<p> </p>
<p>MICROSAR3: </p>
<p>- Used while transition in mode ‘WAKEUP’. </p>
<p>- Call context: Can_SetControllerMode() </p>
<p>- Once the M_CAN is initialized it synchronizes itself to the </p>
<p>CAN bus and is ready for communication.  </p>
<p>- If the loop cancels try to recall Can_SetControllerMode. </p>
<p> </p>
<p>MICROSAR4: </p>
<p>Used for short time mode transition blocking (short </p>
<p>synchronous timeout). Same value for kCanLoopStart, </p>
<p>kCanLoopStop, kCanLoopSleep and kCanLoopWakeup.  </p>
<p>No Issue when timeout occurs.</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>24 </p>
<p>based on template version 3.2 </p>
<p>kCanLoopClock </p>
<p>Stop </p>
<p>When Clock Stop is requested then all pending transfer </p>
<p>requests are completed first.  </p>
<p>When the CAN bus reached idle then Clock Stop will be </p>
<p>acknowledged. </p>
<p>kCanLoopRxFifo   </p>
<p> </p>
<p>This channel dependent loop is called in CanInterruptRxFifo  </p>
<p>and is processed  until the Rx FIFO becomes empty. The loop </p>
<p>is delayed if the controller receives  a burst of messages. </p>
<p>The maximum expected duration is the time needed until   </p>
<p>all  messages  in  the  reception  FIFO  are  confirmed.  If   </p>
<p>the  loop  cancels, reinitialize the Controller. </p>
<p>Table 4-6  </p>
<p>Hardware Loop Check </p>
<p><b>4.8.3 </b></p>
<p><b>CAN RAM Check </b></p>
<p>The CAN driver supports a check of the CAN controller’s mailboxes. The CAN controller </p>
<p>RAM </p>
<p>check </p>
<p>is </p>
<p>called </p>
<p>internally </p>
<p>every </p>
<p>time </p>
<p>a  power </p>
<p>on </p>
<p>is </p>
<p>executed </p>
<p>within </p>
<p>function </p>
<p>Can_InitController(), or a Bus-Wakeup event happen. The CAN driver verifies that no used </p>
<p>mailboxes are corrupt. A mailbox is considered corrupt if a predefined pattern is written to </p>
<p>the  appropriate  mailbox  registers  and  the  read  operation  does  not  return  the  expected </p>
<p>pattern. If a corrupt mailbox is found the function Appl_CanCorruptMailbox() is called. This </p>
<p>function tells the application which mailbox is corrupt.  </p>
<p>After </p>
<p>the </p>
<p>check </p>
<p>of </p>
<p>all </p>
<p>mailboxes </p>
<p>the </p>
<p>CAN </p>
<p>driver </p>
<p>calls </p>
<p>the </p>
<p>call </p>
<p>back </p>
<p>function </p>
<p>Appl_CanRamCheckFailed()  if  at  least  one  corrupt  mailbox  was  found.  The  application </p>
<p>must decide if the CAN driver disables communication or not by means of the  call back </p>
<p>function’s return value. If the application has decided to disable the communication there is </p>
<p>no possibility to enable the communication again until the next call to Can_Init(). </p>
<p>The CAN RAM check functionality itself can be activated via Generation Tool. </p>
<p><b>4.9 </b></p>
<p><b>Common CAN </b></p>
<p>Common  CAN  connect  2  hardware  CAN  channels  to  one  logical  controller.  This  allows </p>
<p>configuring  more  FullCAN  mailboxes.  The  second  hardware  channel  is  used  for  Rx </p>
<p>FullCAN mailboxes. </p>
<p>The  filter  mask  of  the  BasicCAN  should  exclude  the  message  received  by  the  FullCAN </p>
<p>messages of the second CAN Controller. This means each message ID must be received </p>
<p>on  one  CAN  hardware  channel  only.  The  filter  optimization  takes  care  about  this  when </p>
<p>common CAN is activated. </p>
<p>For configuration of Common CAN specific settings in generation tool see chapter </p>
<p>‎</p>
<p>7.6.2. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Only one Transceiver (Driver) has to be used for this two Common CAN hardware </p>
<p>channels (connect TX and RX lines). </p>
<p>Reason: Upper layers only know one Controller for this 2 hardware channel Common </p>
<p>CAN and therefore only one Transceiver can be handled. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>25 </p>
<p>based on template version 3.2 </p>
<p><b>4.9.1 </b></p>
<p><b>Error Interrupt  </b></p>
<p>The  MCAN  error  interrupt  source  is  used  only  partially  by  the  CAN  driver.  Only  </p>
<p>BusOff events are handled and reported to the upper layers by the CAN driver.  </p>
<p>  </p>
<p>Not reported errors are:  </p>
<p>Stuff Error                          More than 5 equal bits in a sequence occurred  </p>
<p>Format Error                        A fixed format part of a received frame has the wrong format  </p>
<p>Acknowledge Error              A  transmitted  message  was  not  acknowledged  by  another </p>
<p>node  </p>
<p>Bit Error                             </p>
<p>Device  wanted  to  send  a  recessive/dominant  level,  but  </p>
<p>the monitored level was dominant/recessive  </p>
<p>CRC Error                         Received CRC did not match the calculated CRC  </p>
<p>Watchdog Interrupt             </p>
<p>Message RAM Watchdog event due to missing READY  </p>
<p>Warning Status                   </p>
<p>Error_Warning status changed  </p>
<p>Error Passive                     </p>
<p>Error_Passive status changed  </p>
<p>Error Logging Overflow      </p>
<p>Overflow of CAN Error Logging Counter occurred  </p>
<p>Bit Error Uncorrected         </p>
<p>Message RAM bit error detected, uncorrected.  </p>
<p>Bit Error Corrected             </p>
<p>Message RAM bit error detected and corrected.   </p>
<p>Timeout Occurred              </p>
<p>Timeout reached  </p>
<p>Timestamp                         </p>
<p>Wraparound Timestamp counter wrapped around  </p>
<p>Rx FIFO 0 Full                    </p>
<p>Rx FIFO 0 Full  </p>
<p>Rx FIFO 0 Watermark        </p>
<p>Reached fill level watermark  </p>
<p>Rx FIFO 1 Full                    </p>
<p>Rx FIFO 1 Full </p>
<p>Rx FIFO 1 Watermark        </p>
<p>Reached fill level watermark  </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>The BusOff recovery sequence cannot be shortened (e.g. by initializing the CAN </p>
<p>device). If the device goes BusOff, it will enter the INIT mode by its own, stopping all </p>
<p>bus activities.  </p>
<p>When leaving the INIT mode the device will wait for 129 occurrences of Bus Idle (129 x </p>
<p>11 consecutive recessive bits) before resuming normal operation.  </p>
<p> </p>
<p> </p>
<p><b>Please note </b></p>
<p>The Timeout Counter is used for CAN driver internal purposes (supervision of possible </p>
<p>transmit confirmations arriving delayed after a cancellation was requested). Thus the </p>
<p>“Timeout Occurred” interrupt may occur occasionally. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>26 </p>
<p>based on template version 3.2 </p>
<p><b>4.9.2 </b></p>
<p><b>Not supported  </b></p>
<p>Neither the Tx Event FIFO nor the Tx Queue is used. All available 32 transmit message  </p>
<p>buffers  per  CAN  channel  are  used  as  dedicated  buffers  and  can  be  used  either  as  </p>
<p>BasicCAN or FullCAN objects (see 4.3.1).  </p>
<p> </p>
<p>The filtering of High Priority messages is not supported.  </p>
<p> </p>
<p>No Range Filters are supported. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>27 </p>
<p>based on template version 3.2 </p>
<p><b>5 </b></p>
<p><b>Integration </b></p>
<p>This chapter gives necessary information for the integration of the MICROSAR CAN into </p>
<p>an application environment of an ECU. </p>
<p><b>5.1 </b></p>
<p><b>Scope of Delivery </b></p>
<p>The delivery of the CAN contains the files, which are described in the chapter’s 5.1.1 and </p>
<p>5.1.2: </p>
<p>Dependent on library or source code delivery the marked (+) files may not be delivered. </p>
<p><b>5.1.1 </b></p>
<p><b>Static Files </b></p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>(+) Can_Local.h </p>
<p>This is an internal header file which should not be included outside this </p>
<p>module </p>
<p>(+) Can.c </p>
<p>This is the source file of the CAN. It contains the implementation of CAN </p>
<p>module functionality. </p>
<p>(+) Can.(lib) </p>
<p>This is the library build out of Can.c, Can.h and Can_Local.h </p>
<p>Can.h </p>
<p>This is the header file of the CAN module (include API declaration) </p>
<p>Can_Hooks.h </p>
<p>This is the header file to define the Hook-functions or macros. (this is a project </p>
<p>specific file and may not exist) </p>
<p>Can_Irq.c </p>
<p>This is the interrupt declaration and callout file (supports interrupt </p>
<p>configuration as link time settings) </p>
<p>Table 5-1  </p>
<p>Static files </p>
<p><b>5.1.2 </b></p>
<p><b>Dynamic Files </b></p>
<p>The dynamic files are generated by the configuration tool [GENy]. </p>
<p> </p>
<p><b>File Name </b></p>
<p><b>Description </b></p>
<p>Can_Cfg.h </p>
<p>Generated header file, contains some type, </p>
<p>prototype and pre-compile settings </p>
<p>Can_Lcfg.c </p>
<p>Generated file contains link time settings. </p>
<p>Can_PBcfg.c </p>
<p>Generated file contains post build settings. </p>
<p>Can_DrvGeneralTypes.h </p>
<p>Generated file contains CAN driver part of </p>
<p>Can_GeneralTypes.h (supported by </p>
<p>Integrator) </p>
<p>Table 5-2  </p>
<p>Generated files </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>28 </p>
<p>based on template version 3.2 </p>
<p><b>5.2 </b></p>
<p><b>Include Structure </b></p>
<p> </p>
<p>Figure 5-1 </p>
<p>Include Structure (AUTOSAR) </p>
<p>Deviation from AUTOSAR specification: </p>
<p></p>
<p> </p>
<p>Additionally the EcuM_Cbk.h is included by Can_Cfg.h (needed for wakeup notification </p>
<p>API). </p>
<p></p>
<p> </p>
<p>ComStack_Types.h included by Can_Cfg.h, because the specified types have to be </p>
<p>known in generated data as well. </p>
<p></p>
<p> </p>
<p>MICROSAR4x only: Os.h will be included by Can_Cfg.h because of used data-types </p>
<p></p>
<p> </p>
<p>Spi.h is not yet used. </p>
<p></p>
<p> </p>
<p>Additionally the file Can_Hooks.h may be included by Can.h. </p>
<p></p>
<p> </p>
<p>MICROSAR403 only: Can_GeneralTypes.h will be included by Can_Cfg.h not by Can.h </p>
<p>direct. </p>
<p> </p>
<p><b>5.3 </b></p>
<p><b>Critical Sections </b></p>
<p>The AUTOSAR standard provides with the BSW Scheduler a BSW module, which handles </p>
<p>entering and leaving critical sections.  </p>
<p>For  more  information  about  the  BSW  Scheduler  please  refer  to  [3].  When  the  BSW </p>
<p>Scheduler is used the CAN Driver provides critical section codes that have to be mapped </p>
<p>by the BSW Scheduler to following mechanism: </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>29 </p>
<p>based on template version 3.2 </p>
<p><b>Critical Section Define </b></p>
<p><b>Description </b></p>
<p>CAN_EXCLUSIVE_AREA_0 </p>
<p>CanNestedGlobalInterruptDisable/Restore() is used within   </p>
<p>Can_MainFunction_Write() to assure that transmit confirmations do not  </p>
<p>conflict with further transmit requests.  </p>
<p>&gt;  Duration is short.  </p>
<p>&gt;  No API call of other BSW inside. </p>
<p>CAN_EXCLUSIVE_AREA_1 </p>
<p>Using inside Can_DisableControllerInterrupts() and  </p>
<p>Can_EnableControllerInterrupts() to secure Interrupt counters for nested  </p>
<p>calls.  </p>
<p><b>&gt; </b></p>
<p>Duration is short.  </p>
<p><b>&gt; </b></p>
<p>No API call of other BSW inside</p>
<p>. </p>
<p> </p>
<p><b>&gt; </b></p>
<p>Disable global interrupts – or – Empty in case </p>
<p>Can_Disable/EnableControllerInterrupts() are called within context </p>
<p>with lower or equal priority than CAN interrupt</p>
<p>.</p>
<p> </p>
<p>CAN_EXCLUSIVE_AREA_2 </p>
<p>Using inside Can_Write() to secure software states of transmit objects. </p>
<p><b>&gt; </b></p>
<p>Only when no Vector CAN Interface is used. </p>
<p><b>&gt; </b></p>
<p>Duration is medium </p>
<p><b>&gt; </b></p>
<p>No API call of other BSW inside. </p>
<p><b>&gt; </b></p>
<p>Disable global interrupts - or - Disable CAN interrupts and do not call </p>
<p>function Can_Write() reentrant. </p>
<p>CAN_EXCLUSIVE_AREA_3 </p>
<p>Using inside Tx confirmation to secure state of transmit object in case of </p>
<p>cancellation (Only used when Vector Interface Version smaller 4.10 </p>
<p>used). </p>
<p><b>&gt; </b></p>
<p>Duration is medium  </p>
<p><b>&gt; </b></p>
<p>Call to CanIf_CancelTxConfirmation() inside (no more calls in CanIf). </p>
<p><b>&gt; </b></p>
<p>Disable global interrupts - or - Disable CAN interrupts and do not call </p>
<p>function Can_Write() within. </p>
<p>CAN_EXCLUSIVE_AREA_4 </p>
<p>Using inside received data handling (Rx Queue treatment) to secure Rx </p>
<p>Queue counter and data. </p>
<p><b>&gt; </b></p>
<p>Duration is short  </p>
<p><b>&gt; </b></p>
<p>No API call of other BSW inside. </p>
<p><b>&gt; </b></p>
<p>Disable Global Interrupts - or - Disable all CAN interrupts. </p>
<p>CAN_EXCLUSIVE_AREA_5 </p>
<p>Using inside wakeup handling to secure state transition. (Only in wakeup </p>
<p>polling mode) </p>
<p><b>&gt; </b></p>
<p>Duration is short  </p>
<p><b>&gt; </b></p>
<p>Call to DET inside. </p>
<p><b>&gt; </b></p>
<p>Disable global interrupts   (do not use CAN interrupt locks here) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>30 </p>
<p>based on template version 3.2 </p>
<p>CAN_EXCLUSIVE_AREA_6 </p>
<p>Using inside Can_SetControllerMode() and BusOff to avoid nested state </p>
<p>transition requests. </p>
<p> </p>
<p><b>&gt; </b></p>
<p>Duration is medium  </p>
<p><b>&gt; </b></p>
<p>No API call of other BSW inside. </p>
<p><b>&gt; </b></p>
<p>Use CAN interrupt locks here, in case the above mentioned APIs are </p>
<p>only called within same tasklevel and CAN interrupt context (no </p>
<p>nesting - like BusOff-handling in interrupt has to be blocked). </p>
<p>or </p>
<p>Disable global interrupts </p>
<p>Table 5-3  </p>
<p>Critical Section Codes </p>
<p><b>5.4 </b></p>
<p><b>Compiler Abstraction and Memory Mapping  </b></p>
<p>The  objects  (e.g.  variables,  functions,  constants)  are  declared  by  compiler  independent </p>
<p>definitions  –  the  compiler  abstraction  definitions.  Each  compiler  abstraction  definition  is </p>
<p>assigned to a memory section. </p>
<p>The  following  table  contains  the  memory  section  names  and  the  compiler  abstraction </p>
<p>definitions  defined  for  the  CAN  Interface  and  illustrates  their  assignment  among  each </p>
<p>other. </p>
<p> </p>
<p><b>Compiler Abstraction </b></p>
<p><b>Definitions </b></p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Memory Mapping </b></p>
<p><b>Sections </b></p>
<p>CAN_ CODE </p>
<p>CAN_STATIC_ CODE </p>
<p>CAN_ CONST  </p>
<p>CAN_ CONST_PBCFG </p>
<p>CAN_VAR_NOINIT </p>
<p>CAN_ VAR_INIT </p>
<p>CAN_ INT_CTRL </p>
<p>CAN_ REG_CANCELL </p>
<p>CAN_ RX_TX_DATA </p>
<p>CAN_ APPL_CODE </p>
<p>CAN_ APPL_CONST </p>
<p>CAN_ APPL_VAR </p>
<p>CAN_START_SEC_CODE </p>
<p>CAN_STOP_SEC_CODE </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_STATIC_CODE </p>
<p>CAN_STOP_SEC_STATIC_CODE </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CONST_8BIT </p>
<p>CAN_STOP_SEC_CONST_8BIT </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CONST_16BIT </p>
<p>CAN_STOP_SEC_CONST_16BIT </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CONST_32BIT </p>
<p>CAN_STOP_SEC_CONST_32BIT </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CONST_UNSPECIFIED </p>
<p>CAN_STOP_SEC_CONST_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_PBCFG </p>
<p>CAN_STOP_SEC_PBCFG </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_PBCFG_ROOT </p>
<p>CAN_STOP_SEC_PBCFG_ROOT </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>31 </p>
<p>based on template version 3.2 </p>
<p>CAN_START_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p>CAN_STOP_SEC_VAR_NOINIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_VAR_INIT_UNSPECIFIED </p>
<p>CAN_STOP_SEC_VAR_INIT_UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>CAN_START_SEC_CODE_APPL </p>
<p>CAN_STOP_SEC_CODE_APPL </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p></p>
<p> </p>
<p> </p>
<p> </p>
<p>Table 5-4  </p>
<p>Compiler abstraction and memory mapping </p>
<p>The  Compiler Abstraction  Definitions  CAN_ APPL_CODE,  CAN_ APPL_VAR  and  CAN_ </p>
<p>APPL_CONST are used to address code, variables and constants which are declared by </p>
<p>other modules and used by the CAN driver. </p>
<p>These definitions are not mapped by the CAN driver but by the memory mapping realized </p>
<p>in the CAN Interface or direct by application. </p>
<p>CAN_ CODE: used for CAN module code. </p>
<p>CAN_ STATIC_CODE: used for CAN module local code. </p>
<p>CAN_ CONST: used for CAN module constants. </p>
<p>CAN_ CONST_PBCFG: used for CAN module constants in Post-Build section. </p>
<p>CAN_ VAR_*: used for CAN module variables. </p>
<p>CAN_ INT_CTRL: is used to access the CAN interrupt controls. </p>
<p>CAN_ REG_CANCELL: is used to access the CAN cell itself. </p>
<p>CAN_ RX_TX_DATA: access to CAN Data buffers.  </p>
<p>CAN_ APPL_*: access to higher layers. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>32 </p>
<p>based on template version 3.2 </p>
<p><b>6 </b></p>
<p><b>Hardware Specific Hints </b></p>
<p><b>6.1.1 </b></p>
<p><b>Usage of interrupt functions  </b></p>
<p>According to the current implementation of MCAN generator there is a fix assignment of  </p>
<p>interrupt  functions  to  the  CAN  Controller.  The  postfix  of  the  interrupt  function  name  </p>
<p>equates the controller number. The following table shows the corresponding assignment  </p>
<p>for the derivative RH850 P1X-C.   </p>
<p>   </p>
<p><b>Critical Section Define </b></p>
<p><b>Description </b></p>
<p>MCAN_0</p>
<p>,  </p>
<p>BaseAddress:  0xFFEF0000  CanIsr_1</p>
<p>  </p>
<p>CanIsr_1  </p>
<p>MCAN_1</p>
<p>,  </p>
<p>BaseAddress:  0xFFD31000  CanIsr_2</p>
<p>  </p>
<p>CanIsr_2  </p>
<p>MCAN_2</p>
<p>,  </p>
<p>BaseAddress:  0xFFEF1000  CanIsr_3</p>
<p>  </p>
<p>CanIsr_3  </p>
<p>Table 5-5   Hardware Controller – Interrupt Functions  </p>
<p> </p>
<p>CanIsr_0 is used for MTT_CAN0 of the RH850 P1X-C. </p>
<p> </p>
<p><b>6.1.2 </b></p>
<p><b>MCAN Errata  </b></p>
<p>The following Errata (please see [6] for further details) are considered by the CAN Driver. </p>
<p>By  default  all  erratas  which  are  appropriate  for  the  configured  MCAN  Revision  are </p>
<p>enabled. If a specific erratum shall be disabled or enabled beyond that it can be configured </p>
<p>via a user configuration file. </p>
<p> Errata </p>
<p>No. </p>
<p>Title </p>
<p>MCAN </p>
<p>Rev. </p>
<p>affected </p>
<p>6 </p>
<p>Change of CAN operation mode during start of transmission. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_006“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>7 </p>
<p>Problem </p>
<p>with </p>
<p>frame </p>
<p>transmission </p>
<p>after </p>
<p>recovery </p>
<p>from </p>
<p>Restricted </p>
<p>Operation Mode. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_007“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>8 </p>
<p>Setting / resetting CCCR.INIT during frame reception. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_008“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>10 </p>
<p>Setting CCCR.CCE while a Tx scan is ongoing. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_010“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6,  </p>
<p>3.0.0, </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>33 </p>
<p>based on template version 3.2 </p>
<p>3.0.1 </p>
<p>11 </p>
<p>Needless activation of interrupt IR.MRAF. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_011“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1, </p>
<p>3.1.0 </p>
<p>12 </p>
<p>Return  of  receiver  from  Bus  Integration  state  after  Protocol  Exception </p>
<p>Event. </p>
<p>Only activated if “</p>
<p>CAN_BOSCH_ERRATUM_012“ is defined as STD_ON.</p>
<p> </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1, </p>
<p>3.1.0 </p>
<p>13  </p>
<p>Message RAM / RAM Arbiter not responding in time. </p>
<p>When  the  M_CAN  wants  to  store  a  received  frame  and  the  Message </p>
<p>RAM / RAM Arbiter does not respond in time, this message cannot be </p>
<p>stored  completely  and  it  is  discarded  with  the  reception  of  the  next </p>
<p>message.  Interrupt  ﬂag  IR.MRAF  is  set.  It  may  happen  that  the  next </p>
<p>received message is stored incomplete.  </p>
<p>In </p>
<p>this </p>
<p>case, </p>
<p>the </p>
<p>respective </p>
<p>Rx </p>
<p>Buffer </p>
<p>or </p>
<p>Rx </p>
<p>FIFO </p>
<p>element </p>
<p>holds </p>
<p>inconsistent data. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>When the M_CAN has been integrated correctly (the Host and  the </p>
<p>CAN clock must be fast enough to handle a worst case </p>
<p>configuration containing the maximum of MCAN Message RAM </p>
<p>elements), this behaviour  can only occur in case of a problem with </p>
<p>the Message RAM itself or the RAM Arbiter.  </p>
<p>The application must assure that the clocking of Host and CAN is </p>
<p>appropriate. The CAN Driver does not care about these   </p>
<p>configuration aspects.  </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1, </p>
<p>3.1.0, </p>
<p>3.2.0 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>34 </p>
<p>based on template version 3.2 </p>
<p>14 </p>
<p>Data  loss  (payload)  in  case  storage  of </p>
<p>a  received  frame  has  not </p>
<p>completed until end of EOF ﬁeld is reached. </p>
<p>The  time  needed  for  acceptance  ﬁltering  and  storage  of  a  received </p>
<p>message depends on the  </p>
<p>- </p>
<p>Host clock frequency,  </p>
<p>- </p>
<p>the number of M_CANs connected to a single Message RAM,  </p>
<p>- </p>
<p>the Message RAM arbitration scheme, and  </p>
<p>- </p>
<p>the number of conﬁgured ﬁlter elements. </p>
<p>In case storage of a received message has not completed until end of </p>
<p>the </p>
<p>received </p>
<p>frame </p>
<p>then </p>
<p>corrupted </p>
<p>data </p>
<p>can </p>
<p>be </p>
<p>contained </p>
<p>in </p>
<p>the </p>
<p>Message RAM.  </p>
<p>Interrupt ﬂag IR.MRAF is not set. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p>If storage of messages cannot be completed the application is </p>
<p>responsible for reducing the maximum number of configured filter </p>
<p>elements for the M_CANs attached to the Message RAM until the </p>
<p>calculated clock frequency is below the Host clock frequency used </p>
<p>with the actual device. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1, </p>
<p>3.1.0, </p>
<p>3.2.0 </p>
<p>1-5 </p>
<p>These  errata  are  in  the  responsibility  of  the  application  and  are  not </p>
<p>considered by the CAN Driver. </p>
<p>2.0.0, </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>9 </p>
<p>Frame transmission in DAR mode. </p>
<p>Not considered by the CAN Driver, frame transmission in DAR mode is </p>
<p>not supported. </p>
<p>2.9.5, </p>
<p>2.9.6, </p>
<p>3.0.0, </p>
<p>3.0.1 </p>
<p>15 </p>
<p>Edge ﬁltering causes mis-synchronization when falling edge at Rx input </p>
<p>pin coincides with end of integration phase. </p>
<p>Not considered by the CAN Driver, Edge Filtering is not supported. </p>
<p>3.1.0, </p>
<p>3.2.0, </p>
<p>3.2.1 </p>
<p>16 </p>
<p>Conﬁguration of NBTP.NTSEG2 = ’0’ not allowed. </p>
<p>Not considered by the CAN Driver, the user is responsible to care about </p>
<p>the according bit timing configuration. </p>
<p>3.1.0, </p>
<p>3.2.0, </p>
<p>3.2.1 </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>35 </p>
<p>based on template version 3.2 </p>
<p><b>7 </b></p>
<p><b>API Description </b></p>
<p><b>7.1 </b></p>
<p><b>Interrupt Service Routines provided by CAN </b></p>
<p>Depend  on  the  settings  in  Tools  component  Hw_Mpc5700Cpu,  the  interrupt  routine  is </p>
<p>given by the driver or by Operating System. (Selection below, not </p>
<p>MICROSAR403</p>
<p>) </p>
<p> </p>
<p>Figure 7-1 </p>
<p>Select OS Type </p>
<p>There  is  the  possibility  to  choose  OS  Type.  Please  select  “None”  for  using  no  OS, </p>
<p>“Autosar” for AUTOSAR OS or “OSEK” for OSEK OS systems. </p>
<p><b>7.1.1 </b></p>
<p><b>OSEK (OS) </b></p>
<p>This means to include osek.h.  </p>
<p>Switch: V_OSTYPE_OSEK </p>
<p><b>7.1.2 </b></p>
<p><b>AutoSar (OS) </b></p>
<p>Os.h header file is used. </p>
<p>Switch: V_OSTYPE_AUTOSAR </p>
<p><b>7.1.3 </b></p>
<p><b>None (OS) </b></p>
<p>Choose “None” for OS Type, to include no Os header files and have no category 2 </p>
<p>interrupt. </p>
<p>Switch: V_OSTYPE_NONE </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>36 </p>
<p>based on template version 3.2 </p>
<p><b>7.1.4 </b></p>
<p><b>Type of Interrupt Function </b></p>
<p>-</p>
<p> </p>
<p>Category 2 (only for OSEK OS or AUTOSAR OS):  </p>
<p>A macro “ISR(CanIsr_x)” will be used to declare ISR function call. The name given </p>
<p>as parameter for interrupt naming (x = Physical CAN Channel number). For macro </p>
<p>definition see OS specification. The OS has full control of the ISR. </p>
<p>switch: C_ENABLE_OSEK_OS_INTCAT2 </p>
<p>-</p>
<p> </p>
<p>Category 1: </p>
<p>Using OS with category 1 interrupts need an Interface layer handling these </p>
<p>interrupts in task context like defined in BSW00326 (AUTOSAR_SRS_General). </p>
<p>switch: C_DISABLE_OSEK_OS_INTCAT2 </p>
<p>-</p>
<p> </p>
<p>Void-Void Interrupt Function: </p>
<p>Like in Category 1 the Interrupt is not handled by OS and the ISR is declared as </p>
<p>void ISR(void) and has to be called by interrupt controller in case of an CAN </p>
<p>interrupt. </p>
<p>switch: C_ENABLE_ISRVOID </p>
<p> </p>
<p> </p>
<p><b>7.1.5 </b></p>
<p><b>CAN ISR API </b></p>
<p><b>Prototype </b></p>
<p>void <b>CanIsr_&lt;x&gt;</b>(void); </p>
<p><b>Parameter </b></p>
<p>--- </p>
<p>--- </p>
<p><b>Return code </b></p>
<p>--- </p>
<p>--- </p>
<p><b>Functional Description </b></p>
<p>Handles interrupts of hardware channel &lt;x&gt; for Rx, Tx, BusOff events. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Number of available functions depends on used MCU derivative. </p>
<p>&gt; </p>
<p>The functions are not designated as interrupt functions. If it is necessary to save/restore all general </p>
<p>purpose registers and to use a different “return from interrupt” instruction the application code has to </p>
<p>implement the compiler specific pragma (e.g. for Wind River™ DIAB™: #pragma interrupt CanIsr_x). </p>
<p>Table 7-1  </p>
<p>MCAN CanIsr_&lt;x&gt; </p>
<p><b>7.2 </b></p>
<p><b>Services provided by CAN </b></p>
<p>The CAN API consists of services, which are realized by function calls. </p>
<p> </p>
<p><b>7.2.1 </b></p>
<p><b>Can_InitMemory </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_InitMemory </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>37 </p>
<p>based on template version 3.2 </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service initializes module global variables, which cannot be initialized in the startup code.  </p>
<p>Use this to re-run the system without performing a new start from power on.  </p>
<p>(E.g.: used to support an ongoing debug session without a complete re-initialization.)  </p>
<p>Must be followed by a call to “Can_Init()”. </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Should be called while power on initialization before „Can_Init()“ on task level. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-2  </p>
<p>Can_InitMemory </p>
<p> </p>
<p><b>7.2.2 </b></p>
<p><b>Can_Init </b></p>
<p><b>Prototype </b></p>
<p><b>void Can_Init( const Can_ConfigType *Config )</b></p>
<p><b> </b></p>
<p><b>Parameter </b></p>
<p><b>Config</b></p>
<p><b> </b></p>
<p>Pointer to the structure including configuration data. </p>
<p>In case of Multiple ECU configuration feature is used, for each Identity one </p>
<p>“Config” structure exists and has to be chosen here </p>
<p><b>Return code </b></p>
<p><b>- </b></p>
<p><b>- </b></p>
<p><b>Functional Description </b></p>
<p>This function initializes global CAN driver variables during ECU start-up. </p>
<p><b>Particularities and Limitations </b></p>
<p><b>&gt; </b></p>
<p>Has to be called during start-up before CAN communication. </p>
<p><b>&gt; </b></p>
<p>Must be called before calling Can_InitController(). </p>
<p><b>&gt; </b></p>
<p>Mulitple ECU configuration pointer for “Config” does only work with none Post-Build variants </p>
<p><b>&gt; </b></p>
<p>Can_InitMemory() has to be called before. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>38 </p>
<p>based on template version 3.2 </p>
<p><b>7.2.3 </b></p>
<p><b>Can_InitController </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_InitController </b>(uint8 Controller, Can_ControllerBaudrateConfigPtrType </p>
<p>Config) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller </p>
<p>Config [in] </p>
<p>Pointer to baud rate configuration structure </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Initialization of controller specific CAN hardware.  </p>
<p>The CAN driver registers and variables are initialized.  </p>
<p>The CAN controller is fully initialized and left back within the state “Stop Mode”, ready to change to </p>
<p>“Running Mode”. </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>Disabled Interrupts.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Must be called during the startup sequence before CAN communication takes place but after calling </p>
<p>„Can_Init()“.  </p>
<p>&gt; </p>
<p>Must not be called while in „Sleep Mode“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR401 only </p>
<p>Table 7-3  </p>
<p>Can_InitController </p>
<p> </p>
<p><b>7.2.4 </b></p>
<p><b>Can_InitController </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_InitController </b>(uint8 Controller, Can_ControllerConfigPtrType </p>
<p>ControllerConfigPtr) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller </p>
<p>Config [in] </p>
<p>Pointer to the configuration data structure. </p>
<p><b>Return code </b></p>
<p>Void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Initialization of controller specific CAN hardware.  </p>
<p>The CAN driver registers and variables are initialized.  </p>
<p>The CAN controller is fully initialized and left back within the state “stop mode”, ready to change to “Running </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>39 </p>
<p>based on template version 3.2 </p>
<p>Mode”. </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>Disabled Interrupts </p>
<p>Call context </p>
<p>&gt; </p>
<p>Must be called during the startup sequence before CAN communication takes place but after calling </p>
<p>„Can_Init()“.  </p>
<p>&gt; </p>
<p>Must not be called while in „Sleep Mode“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR3 only </p>
<p>Table 7-4  </p>
<p>Can_InitController </p>
<p> </p>
<p><b>7.2.5 </b></p>
<p><b>Can_ChangeBaudrate </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Can_ChangeBaudrate </b>(uint8 Controller, const uint16 Baudrate) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller to be changed </p>
<p>Baudrate [in] </p>
<p>Baud rate to be set </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>&gt; </p>
<p>E_NOT_OK Baud rate is not set  </p>
<p>&gt; </p>
<p>E_OK Baud rate is set </p>
<p><b>Functional Description </b></p>
<p>This service shall change the baud rate and reinitialize the CAN controller.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p>The CAN controller must be in “Stop Mode”. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Must be called during the startup sequence before CAN communication takes place but after calling </p>
<p>„Can_Init()“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR403 only &amp; if „CanChangeBaudrateApi“ is activated or „CanSetBaudrateApi“ is </p>
<p>de-activated. </p>
<p>Table 7-5  </p>
<p>Can_ChangeBaudrate </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>40 </p>
<p>based on template version 3.2 </p>
<p><b>7.2.6 </b></p>
<p><b>Can_CheckBaudrate </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Can_CheckBaudrate </b>(uint8 Controller, const uint16 Baudrate) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller to be checked </p>
<p>Baudrate [in] </p>
<p>Baud rate to be checked </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>&gt; </p>
<p>E_NOT_OK Baud rate is not available  </p>
<p>&gt; </p>
<p>E_OK Baud rate is available </p>
<p><b>Functional Description </b></p>
<p>This service shall check if the given baud rate is supported of the CAN controller.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p>The CAN controller must be initialized.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Must not be called nested.  </p>
<p>&gt; </p>
<p>Only available if „CanChangeBaudrateApi“ is activated. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR403 only &amp; „CanChangeBaudrateApi“ is activated </p>
<p>(„CAN_CHANGE_BAUDRATE_SUPPORT == STD_ON“) </p>
<p>Table 7-6  </p>
<p>Can_CheckBaudrate </p>
<p> </p>
<p><b>7.2.7 </b></p>
<p><b>Can_SetBaudrate </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Can_SetBaudrate </b>(uint8 Controller, uint16 BaudRateConfigID) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of controller to be set </p>
<p>BaudRateConfigID [in] </p>
<p>Identity of the configured baud rate (available as Symbolic Name) </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>&gt; </p>
<p>E_NOT_OK Baud rate is not set  </p>
<p>&gt; </p>
<p>E_OK Baud rate is set </p>
<p><b>Functional Description </b></p>
<p>This service shall change the baud rate and reinitialize the CAN controller.  </p>
<p>(Similar to “Can_ChangeBaudrate()” but used when identical baud rates are used for different CAN FD </p>
<p>settings).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>41 </p>
<p>based on template version 3.2 </p>
<p>Call context </p>
<p>&gt; </p>
<p>Must not be called nested.  </p>
<p>&gt; </p>
<p>Only available if „CanSetBaudrateApi“ is activated. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR403 only &amp; „CanSetBaudrateApi“ is activated („CAN_SET_BAUDRATE_API == </p>
<p>STD_ON“) </p>
<p>Table 7-7  </p>
<p>Can_SetBaudrate </p>
<p> </p>
<p><b>7.2.8 </b></p>
<p><b>Can_InitStruct </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_InitStruct </b>(uint8 Controller, uint8 Index) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller to be changed </p>
<p>Index [in] </p>
<p>Index of the initialization structure to be used for baud rate and mask settings </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Set content of the initialization structure (before calling “Can_InitController()”).  </p>
<p>Service function to change the initialization structure setup left behind by the Generation Tool.  </p>
<p>The structure contains information about baud rate and filter settings.  </p>
<p>Subsequent “Can_InitController()” must be called to activate these settings.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p>“Can_Init” was called.  </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Call this function between calling „Can_Init()“ and „Can_InitController()“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR3 only </p>
<p>Table 7-8  </p>
<p>Can_InitStruct </p>
<p> </p>
<p><b>7.2.9 </b></p>
<p><b>Can_GetVersionInfo </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_GetVersionInfo </b>(Can_VersionInfoPtrType VersionInfo) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>42 </p>
<p>based on template version 3.2 </p>
<p><b>Parameter </b></p>
<p>VersionInfo [out] </p>
<p>Pointer to where to store the version information of the CAN driver.  </p>
<p>typedef struct {  </p>
<p>uint16 vendorID;  </p>
<p>uint16 moduleID;  </p>
<p>MICROSAR3 only: uint8 instanceID;  </p>
<p>uint8 sw_major_version; (MICROSAR3 only: BCD coded)  </p>
<p>uint8 sw_minor_version; (MICROSAR3 only: BCD coded)  </p>
<p>uint8 sw_patch_version; (MICROSAR3 only: BCD coded)  </p>
<p>} Std_VersionInfoType; </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Get the version information of the CAN driver.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by Application. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Only available if „CanVersionInfoApi“ is activated. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanVersionInfoApi“ is activated („CAN_VERSION_INFO_API == STD_ON“) </p>
<p>Table 7-9  </p>
<p>Can_GetVersionInfo </p>
<p> </p>
<p><b>7.2.10 </b></p>
<p><b>Can_GetStatus </b></p>
<p><b>Prototype </b></p>
<p>uint8 <b>Can_GetStatus </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller requested for status information </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>&gt; </p>
<p>CAN_STATUS_STOP (Bit coded status information)  </p>
<p>&gt; </p>
<p>CAN_STATUS_INIT  </p>
<p>&gt; </p>
<p>CAN_STATUS_INCONSISTENT, CAN_DEACTIVATE_CONTROLLER </p>
<p>(only with „CanRamCheck“ active) </p>
<p>&gt; </p>
<p>CAN_STATUS_WARNING  </p>
<p>&gt; </p>
<p>CAN_STATUS_PASSIVE  </p>
<p>&gt; </p>
<p>CAN_STATUS_BUSOFF  </p>
<p>&gt; </p>
<p>CAN_STATUS_SLEEP </p>
<p><b>Functional Description </b></p>
<p>Delivers the status of the hardware.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>43 </p>
<p>based on template version 3.2 </p>
<p>Only one of the status bits CAN_STATUS_SLEEP/STOP/BUSOFF/PASSIVE/WARNING is set.  </p>
<p>The CAN_STATUS_INIT bit is always set if a controller is initialized.  </p>
<p>CAN_STATUS_SLEEP has the highest and CAN_STATUS_WARNING the lowest priority.  </p>
<p>CAN_STATUS_INCONSISTENT will be set if one Common CAN channel. Is not “Stop” or “Sleep”.  </p>
<p>CAN_DEACTIVATE_CONTROLLER is set in case the “CanRamCheck” detected an Issue.  </p>
<p>“status” can be analyzed using the provided API macros:  </p>
<p>CAN_HW_IS_OK(status): return “true” in case no warning, passive or bus off occurred.  </p>
<p>CAN_HW_IS_WARNING(status): return “true” in case of waning status.  </p>
<p>CAN_HW_IS_PASSIVE(status): return “true” in case of passive status.  </p>
<p>CAN_HW_IS_BUSOFF(status): return “true” in case of bus off status (may be already false in Notification).  </p>
<p>CAN_HW_IS_WAKEUP(status): return “true” in case of not in sleep mode.  </p>
<p>CAN_HW_IS_SLEEP(status): return “true” in case of sleep mode.  </p>
<p>CAN_HW_IS_STOP(status): return “true” in case of stop mode.  </p>
<p>CAN_HW_IS_START(status): return “true” in case of not in stop mode.  </p>
<p>CAN_HW_IS_INCONSISTENT(status): return “true” in case of an inconsistency between two common CAN </p>
<p>channels.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by network management or Application. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanGetStatus“ is activated („CAN_GET_STATUS == STD_ON“) </p>
<p>Table 7-10  </p>
<p>Can_GetStatus </p>
<p> </p>
<p><b>7.2.11 </b></p>
<p><b>Can_SetControllerMode </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Can_SetControllerMode </b>(uint8 Controller, Can_StateTransitionType </p>
<p>Transition) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller to be set </p>
<p>Transition [in] </p>
<p>Requested transition to destination mode </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_NOT_OK mode change unsuccessful  </p>
<p>&gt; </p>
<p>CAN_OK mode change successful </p>
<p><b>Functional Description </b></p>
<p>Change the controller mode to the following possible destination values:  </p>
<p>CAN_T_START,  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>44 </p>
<p>based on template version 3.2 </p>
<p>CAN_T_STOP,  </p>
<p>CAN_T_SLEEP,  </p>
<p>CAN_T_WAKEUP.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>Interrupts locked by CanInterface </p>
<p>Call context </p>
<p>&gt; </p>
<p>Must not be called within CAN driver context like RX, TX or Bus Off callouts. </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-11  </p>
<p>Can_SetControllerMode </p>
<p> </p>
<p><b>7.2.12 </b></p>
<p><b>Can_ResetBusOffStart </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_ResetBusOffStart </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This is a compatibility function (for a CANbedded protocol stack) used during the start of the  </p>
<p>Bus Off handling to remove the Bus Off state.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called while BusOff event handling (Polling or Interrupt context). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-12  </p>
<p>Can_ResetBusOffStart </p>
<p> </p>
<p><b>7.2.13 </b></p>
<p><b>Can_ResetBusOffEnd </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_ResetBusOffEnd </b>(uint8 Controller) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>45 </p>
<p>based on template version 3.2 </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This is a compatibility function (for a CANbedded protocol stack) used during the end of the  </p>
<p>Bus Off handling to remove the Bus Off state.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called inside „Can_SetControllerMode()“ while Start transition. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-13  </p>
<p>Can_ResetBusOffEnd </p>
<p> </p>
<p><b>7.2.14 </b></p>
<p><b>Can_Write </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Can_Write </b>(Can_HwHandleType Hth, Can_PduInfoPtrType PduInfo) </p>
<p><b>Parameter </b></p>
<p>Hth [in] </p>
<p>Handle of the mailbox intended to send the message </p>
<p>PduInfo [in] </p>
<p>Information about the outgoing message (ID, dataLength, data) </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_NOT_OK transmit unsuccessful  </p>
<p>&gt; </p>
<p>CAN_OK transmit successful  </p>
<p>&gt; </p>
<p>CAN_BUSY transmit could not be accomplished due to controller is busy. </p>
<p><b>Functional Description </b></p>
<p>Send a CAN message over CAN.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>CAN Interrupt locked.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called by the CanInterface with at least disabled CAN interrupts.  </p>
<p>&gt; </p>
<p>(Due to data security reasons the CanInterface should accomplish this and thus it is not needed  further </p>
<p>more in the CAN Driver.) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>46 </p>
<p>based on template version 3.2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-14  </p>
<p>Can_Write </p>
<p> </p>
<p><b>7.2.15 </b></p>
<p><b>Can_CancelTx </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_CancelTx </b>(Can_HwHandleType Hth, PduIdType PduId) </p>
<p><b>Parameter </b></p>
<p>Hth [in] </p>
<p>Handle of the mailbox intended to be cancelled. </p>
<p>PduId [in] </p>
<p>Pdu identifier </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Cancel the TX message in the hardware buffer (if possible) or mark the message as not to be confirmed  </p>
<p>in case of the cancellation is unsuccessful.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanTp or Application. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called by CanTp or Application. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-15  </p>
<p>Can_CancelTx </p>
<p> </p>
<p><b>7.2.16 </b></p>
<p><b>Can_CheckWakeup </b></p>
<p><b>Prototype </b></p>
<p>Std_ReturnType <b>Can_CheckWakeup </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller to be checked for Wake Up events. </p>
<p><b>Return code </b></p>
<p>Std_ReturnType </p>
<p>&gt; </p>
<p>E_OK the given controller caused a Wake Up before.  </p>
<p>&gt; </p>
<p>E_NOT_OK the given controller caused no Wake Up before. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>47 </p>
<p>based on template version 3.2 </p>
<p><b>Functional Description </b></p>
<p>Service function to check the occurrence of Wake Up events for the given controller  </p>
<p>(used as Wake Up callback for higher layers).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CanInterface. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called while Wakeup validation phase. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: In AR4.x named „Can_CheckWakeup“, in AR3.x named „Can_Cbk_CheckWakeup“ (Name </p>
<p>mapped by define) </p>
<p>Table 7-16  </p>
<p>Can_CheckWakeup </p>
<p> </p>
<p><b>7.2.17 </b></p>
<p><b>Can_DisableControllerInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_DisableControllerInterrupts </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the CAN controller to disable interrupts for. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to disable the CAN interrupt for the given controller (e.g. due to data security reasons).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Must not be called while CAN controller is in sleep mode.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within Critical Area handling or out of Application code. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-17  </p>
<p>Can_DisableControllerInterrupts </p>
<p> </p>
<p><b>7.2.18 </b></p>
<p><b>Can_EnableControllerInterrupts </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_EnableControllerInterrupts </b>(uint8 Controller) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>48 </p>
<p>based on template version 3.2 </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the CAN controller to disable interrupts for. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to (re-)enable the CAN interrupt for the given controller (e.g. due to data security reasons).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Must not be called while CAN controller is in sleep mode.  </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within Critical Area handling or out of Application code. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-18  </p>
<p>Can_EnableControllerInterrupts </p>
<p> </p>
<p><b>7.2.19 </b></p>
<p><b>Can_MainFunction_Write </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_Write </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to poll TX events (confirmation, cancellation) for all controllers and all TX mailboxes  </p>
<p>to accomplish the TX confirmation handling (like CanInterface notification).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Must not interrupt the call of “Can_Write()”. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic TX task. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-19  </p>
<p>Can_MainFunction_Write </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>49 </p>
<p>based on template version 3.2 </p>
<p><b>7.2.20 </b></p>
<p><b>Can_MainFunction_Read </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_Read </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to poll RX events for all controllers and all RX mailboxes to accomplish the  </p>
<p>RX indication handling (like CanInterface notification).  </p>
<p>Also used for a delayed read (from task level) of the RX Queue messages which were queued from </p>
<p>interrupt context.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic RX task. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-20  </p>
<p>Can_MainFunction_Read </p>
<p> </p>
<p><b>7.2.21 </b></p>
<p><b>Can_MainFunction_BusOff </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_BusOff </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Polling of Bus Off events to accomplish the Bus Off handling. Service function to poll Bus Off events for all </p>
<p>controllers to accomplish the Bus Off handling  </p>
<p>(like calling of “CanIf_ControllerBusOff()” in case of Bus Off occurrence).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic BusOff task. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>50 </p>
<p>based on template version 3.2 </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-21  </p>
<p>Can_MainFunction_BusOff </p>
<p> </p>
<p><b>7.2.22 </b></p>
<p><b>Can_MainFunction_Wakeup </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_Wakeup </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to poll Wake Up events for all controllers to accomplish the Wake Up handling  </p>
<p>(like calling of “CanIf_SetWakeupEvent()” in case of Wake Up occurrence).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic Wakeup task. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Always </p>
<p>Table 7-22  </p>
<p>Can_MainFunction_Wakeup </p>
<p> </p>
<p><b>7.2.23 </b></p>
<p><b>Can_MainFunction_Mode </b></p>
<p><b>Prototype </b></p>
<p>void <b>Can_MainFunction_Mode </b>(void) </p>
<p><b>Parameter </b></p>
<p>-  </p>
<p> </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to poll Mode changes over all controllers.  </p>
<p>(This is handled asynchronous if not accomplished in “Can_SetControllerMode()”). </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by SchM. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within cyclic mode change task. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>51 </p>
<p>based on template version 3.2 </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: MICROSAR4x only </p>
<p>Table 7-23  </p>
<p>Can_MainFunction_Mode </p>
<p> </p>
<p><b>7.2.24 </b></p>
<p><b>Appl_GenericPrecopy </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Appl_GenericPrecopy </b>(uint8 Controller, Can_IdType ID, uint8 </p>
<p>DataLength, Can_DataPtrType DataPtr) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Controller which received the message </p>
<p>ID [in] </p>
<p>ID of the received message.  </p>
<p>In case of extended or mixed ID systems the highest bit (bit 31) is set to mark </p>
<p>an extended ID.  </p>
<p>FD-bit will not be set at all. </p>
<p>DataLength [in] </p>
<p>Data length of the received message. </p>
<p>pData [in] </p>
<p>Pointer to the data of the received message. </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_OK if the indication of the message should be called afterwards </p>
<p>(notification to higher layer),  </p>
<p>&gt; </p>
<p>CAN_NOT_OK in case of stopping furthermore reception. </p>
<p><b>Functional Description </b></p>
<p>Application callback function which informs about all incoming RX messages including the contained data.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p>“pData” is read only and must not be accessed for further write operations.  </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message reception context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanGenericPrecopy“ is activated („CAN_GENERIC_PRECOPY == STD_ON“). </p>
<p>Table 7-24  </p>
<p>Appl_GenericPrecopy </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>52 </p>
<p>based on template version 3.2 </p>
<p><b>7.2.25 </b></p>
<p><b>Appl_GenericConfirmation </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Appl_GenericConfirmation </b>(PduIdType PduId) </p>
<p><b>Parameter </b></p>
<p>PduId [in] </p>
<p>Handle of the PDU specifying the message. </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_OK Higher layer (CanInterface) confirmation will be called.  </p>
<p>&gt; </p>
<p>CAN_NOT_OK No further higher layer (CanInterface) confirmation will be </p>
<p>called. </p>
<p><b>Functional Description </b></p>
<p>Application callback function which informs about TX messages being sent to the CAN bus.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p>“PduId” is read only and must not be accessed for further write operations.  </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message transmission finished context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanGenericConfirmation“ is activated („CAN_GENERIC_CONFIRMATION == STD_ON“) &amp; </p>
<p>„CanIfTransmitBuffer“ activated (in CanInterface). </p>
<p>Table 7-25  </p>
<p>Appl_GenericConfirmation </p>
<p> </p>
<p><b>7.2.26 </b></p>
<p><b>Appl_GenericConfirmation </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>Appl_GenericConfirmation </b>(uint8 Controller, Can_PduInfoPtrType </p>
<p>DataPtr) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the causing controller. </p>
<p>DataPtr [in] </p>
<p> </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>CAN_OK Higher layer (CanInterface) confirmation will be called. </p>
<p>CAN_NOT_OK No further higher layer (CanInterface) confirmation will be </p>
<p>called. </p>
<p><b>Functional Description </b></p>
<p>Application callback function which informs about TX messages being sent to the CAN bus.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>53 </p>
<p>based on template version 3.2 </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p>If “Generic Confirmation” and “Transmit Buffer” (both set in CanInterface) are active, then the switch  </p>
<p>“Cancel Support Api” is also needed (also set in CanIf), otherwise a compiler error occurs.  </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message transmission finished context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: If </p>
<p>&quot;</p>
<p>CanGenericConfirmation&quot; (&quot;CAN_GENERIC_CONFIRMATION == STD_ON&quot;) and </p>
<p>&quot;CanIfTransmitBuffer&quot; (in CanInterface) is activated. </p>
<p>Table 7-26  </p>
<p>Appl_GenericConfirmation </p>
<p> </p>
<p><b>7.2.27 </b></p>
<p><b>Appl_GenericPreTransmit </b></p>
<p><b>Prototype </b></p>
<p>void <b>Appl_GenericPreTransmit </b>(uint8 Controller, Can_PduInfoPtrType_var DataPtr) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller on which the hardware observation takes place. </p>
<p>DataPtr [in] </p>
<p>Pointer to a Can_PduType structure including ID, DataLength, Pdu and data </p>
<p>pointer. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Application callback function allowing the modification of the data to be transmitted (e.g.: add CRC).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within „Can_Write()“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanGenericPretransmit“ is activated („CAN_GENERIC_PRETRANSMIT == STD_ON“). </p>
<p>Table 7-27  </p>
<p>Appl_GenericPreTransmit </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>54 </p>
<p>based on template version 3.2 </p>
<p><b>7.2.28 </b></p>
<p><b>ApplCanTimerStart </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanTimerStart </b>(CanChannelHandle Controller, uint8 source) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller on which the hardware observation takes place.  </p>
<p>(only if not using “Optimize for one controller”) </p>
<p>source [in] </p>
<p>Source for the hardware observation (see chapter Hardware Loop Check / </p>
<p>Timeout Monitoring). </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to start an observation timer (see chapter Hardware Loop Check / Timeout Monitoring).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>For context information please refer to chapter „Hardware Loop Check“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanHardwareCancelByAppl“ is activated („CAN_HW_LOOP_SUPPORT_API == </p>
<p>STD_ON“). </p>
<p>Table 7-28  </p>
<p>ApplCanTimerStart </p>
<p> </p>
<p><b>7.2.29 </b></p>
<p><b>ApplCanTimerLoop </b></p>
<p><b>Prototype </b></p>
<p>Can_ReturnType <b>ApplCanTimerLoop </b>(CanChannelHandle Controller, uint8 source) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller on which the hardware observation takes place.  </p>
<p>(only if not using “Optimize for one controller”) </p>
<p>source [in] </p>
<p>Source for the hardware observation (see chapter Hardware Loop Check / </p>
<p>Timeout Monitoring). </p>
<p><b>Return code </b></p>
<p>Can_ReturnType </p>
<p>&gt; </p>
<p>CAN_NOT_OK when loop shall be broken (observation stops)  </p>
<p>&gt; </p>
<p>CAN_NOT_OK should only be used in case of a timeout occurs due to a </p>
<p>hardware issue.  </p>
<p>&gt; </p>
<p>After this an appropriate error handling is needed (see chapter Hardware </p>
<p>Loop Check / Timeout Monitoring).  </p>
<p>&gt; </p>
<p>CAN_OK when loop shall be continued (observation continues) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>55 </p>
<p>based on template version 3.2 </p>
<p><b>Functional Description </b></p>
<p>Service function to check (against generated max loop value) whether a hardware loop shall be continued </p>
<p>or broken.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>For context information please refer to chapter „Hardware Loop Check“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanHardwareCancelByAppl“ is activated („CAN_HW_LOOP_SUPPORT_API == </p>
<p>STD_ON“). </p>
<p>Table 7-29  </p>
<p>ApplCanTimerLoop </p>
<p> </p>
<p><b>7.2.30 </b></p>
<p><b>ApplCanTimerEnd </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanTimerEnd </b>(CanChannelHandle Controller, uint8 source) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller on which the hardware observation takes place.  </p>
<p>(only if not using “Optimize for one controller”) </p>
<p>source [in] </p>
<p>Source for the hardware observation (see chapter Hardware Loop Check / </p>
<p>Timeout Monitoring). </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to to end an observation timer (see chapter Hardware Loop Check / Timeout Monitoring).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>For context information please refer to chapter „Hardware Loop Check“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanHardwareCancelByAppl“ is activated („CAN_HW_LOOP_SUPPORT_API == </p>
<p>STD_ON“). </p>
<p>Table 7-30  </p>
<p>ApplCanTimerEnd </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>56 </p>
<p>based on template version 3.2 </p>
<p><b>7.2.31 </b></p>
<p><b>ApplCanInterruptDisable </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanInterruptDisable </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for the CAN interrupt lock. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to support the disabling of CAN Interrupts by the application.  </p>
<p>E.g.: the CAN driver itself should not access the common Interrupt Controller due to application  </p>
<p>specific restrictions (like security level etc.). Or the application like to be informed because of  </p>
<p>an CAN interrupt lock.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called by the CAN Driver within „Can_DisableControllerInterrupts()“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: &quot;CanInterruptLock&quot; is set to APPL or BOTH (&quot;CAN_INTLOCK == CAN_APPL&quot; or </p>
<p>&quot;CAN_INTLOCK == CAN_BOTH&quot;).</p>
<p> </p>
<p> </p>
<p>Table 7-31  </p>
<p>ApplCanInterruptDisable </p>
<p> </p>
<p><b>7.2.32 </b></p>
<p><b>ApplCanInterruptRestore </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanInterruptRestore </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for the CAN interrupt unlock. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>Service function to support the enabling of CAN Interrupts by the application.  </p>
<p>E.g.: the CAN driver itself should not access the common Interrupt Controller due to application  </p>
<p>specific restrictions (like security level etc.). Or the application like to be informed because of  </p>
<p>an CAN interrupt lock.  </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>57 </p>
<p>based on template version 3.2 </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called by the CAN Driver within „Can_EnableControllerInterrupts()“. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanInterruptLock“ is set to APPL or BOTH („CAN_INTLOCK == CAN_APPL“ or </p>
<p>„CAN_INTLOCK == CAN_BOTH“). </p>
<p>Table 7-32  </p>
<p>ApplCanInterruptRestore </p>
<p> </p>
<p><b>7.2.33 </b></p>
<p><b>Appl_CanOverrun </b></p>
<p><b>Prototype </b></p>
<p>void <b>Appl_CanOverrun </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the overrun was detected. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function will be called when an overrun is detected for a BasicCAN mailbox.  </p>
<p>Alternatively a DET call can be selected instead of (“CanOverrunNotification” is set to “DET”). </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message reception or error detection context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanOverrunNotification“ set to APPL („CAN_OVERRUN_NOTIFICATION == CAN_APPL“). </p>
<p>Table 7-33  </p>
<p>Appl_CanOverrun </p>
<p> </p>
<p><b>7.2.34 </b></p>
<p><b>Appl_CanFullCanOverrun </b></p>
<p><b>Prototype </b></p>
<p>void <b>Appl_CanFullCanOverrun </b>(uint8 Controller) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>58 </p>
<p>based on template version 3.2 </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the overrun was detected. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function will be called when an overrun is detected for a FullCAN mailbox.  </p>
<p>Alternatively a DET call can be selected instead of (“CanOverrunNotification” is set to “DET”). </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within CAN message reception or error detection context (Polling or Interrupt). </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanOverrunNotification“ set to APPL („CAN_OVERRUN_NOTIFICATION == CAN_APPL“). </p>
<p>Table 7-34  </p>
<p>Appl_CanFullCanOverrun </p>
<p> </p>
<p><b>7.2.35 </b></p>
<p><b>Appl_CanCorruptMailbox </b></p>
<p><b>Prototype </b></p>
<p>void <b>Appl_CanCorruptMailbox </b>(uint8 Controller, Can_HwHandleType hwObjHandle) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the check failed. </p>
<p>hwObjHandle [in] </p>
<p>Hardware handle of the defect mailbox. </p>
<p><b>Return code </b></p>
<p>void </p>
<p>- </p>
<p><b>Functional Description </b></p>
<p>This function will notify the application (during “Can_InitController()”) about a defect mailbox within the CAN </p>
<p>cell.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Call within controller initialization. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>59 </p>
<p>based on template version 3.2 </p>
<p>&gt; </p>
<p>Availability: „CanRamCheck“ set to „MailboxNotifiation“ („CAN_RAM_CHECK == </p>
<p>CAN_NOTIFY_MAILBOX“). </p>
<p>Table 7-35  </p>
<p>Appl_CanCorruptMailbox </p>
<p> </p>
<p><b>7.2.36 </b></p>
<p><b>Appl_CanRamCheckFailed </b></p>
<p><b>Prototype </b></p>
<p>uint8 <b>Appl_CanRamCheckFailed </b>(uint8 Controller) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the check failed </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>&gt; </p>
<p>action With this „action“ the application can decide how to proceed with the </p>
<p>initialization.  </p>
<p>&gt; </p>
<p>CAN_DEACTIVATE_CONTROLLER – deactivate the controller  </p>
<p>&gt; </p>
<p>CAN_ACTIVATE_CONTROLLER – activate the controller </p>
<p><b>Functional Description </b></p>
<p>This function will notify the application (during “Can_InitController()”) about a defect CAN controller  </p>
<p>due to a previous failed mailbox check.  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API </p>
<p>Call context </p>
<p>&gt; </p>
<p>Call within controller initialization. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: „CanRamCheck“ set to „Active“ or „MailboxNotifiation“ („CAN_RAM_CHECK != </p>
<p>CAN_NONE“). </p>
<p>Table 7-36  </p>
<p>Appl_CanRamCheckFailed </p>
<p> </p>
<p><b>7.2.37 </b></p>
<p><b>ApplCanInitPostProcessing </b></p>
<p><b>Prototype </b></p>
<p>void <b>ApplCanInitPostProcessing </b>(CAN_HW_CHANNEL_CANTYPE_ONLY) </p>
<p><b>Parameter </b></p>
<p>Controller [in] </p>
<p>Number of the controller for which the check failed </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>60 </p>
<p>based on template version 3.2 </p>
<p><b>Functional Description </b></p>
<p>Service function to overwrite the previously set initialization values for the bit timing, taken from the </p>
<p>generated data,  </p>
<p>with customer specific values.  </p>
<p>For your convenience the following access function is supported:  </p>
<p>- CanBtpReg(controller): - the BTP register of the specified CAN channel can be set according to the </p>
<p>register definition  </p>
<p>as specified in the Hardware Manufacturer Document ((see ch. 2).  </p>
<p>Example: CanBtpReg(Controller) = 0x00070F70u;  </p>
<p>or CanBtpReg(0) = 0x00070F70u; (when using ‘Optimize for one controller’).  </p>
<p><b>Particularities and Limitations </b></p>
<p>Called by CAN driver. </p>
<p>None </p>
<p> </p>
<p><b>Caution</b> </p>
<p>None AUTOSAR API  </p>
<p>It is the responsibility of the application to assure that the register values are consistent with the </p>
<p>release of the underlying derivative. </p>
<p>Call context </p>
<p>&gt; </p>
<p>Called within controller initialization. </p>
<p>&gt; </p>
<p>This function is Synchronous </p>
<p>&gt; </p>
<p>This function is Non-Reentrant </p>
<p>&gt; </p>
<p>Availability: Only available if ‚C_ENABLE_INIT_POST_PROCESS‘ is defined via a user-config file. </p>
<p>Table 7-37  </p>
<p>ApplCanInitPostProcessing </p>
<p> </p>
<p> </p>
<p><b>7.3 </b></p>
<p><b>Services used by CAN </b></p>
<p>In the following table services provided by other components, which are used by the CAN </p>
<p>are listed. For details about prototype and functionality refer to the documentation of the </p>
<p>providing component. </p>
<p> </p>
<p><b>Component </b></p>
<p><b>API </b></p>
<p>DET </p>
<p><b>Det_ReportError </b></p>
<p>(see “Development Error Reporting”) </p>
<p>DEM </p>
<p><b>Dem_ReportErrorStatus </b></p>
<p>(see “Production Code Error Reporting”) </p>
<p>EcuM </p>
<p><b>EcuM_CheckWakeup </b></p>
<p>This function is called when Wakeup over CAN bus occur. </p>
<p><b>EcuM_GeneratorCompatibilityError </b></p>
<p>This function is called during the initialization, of the CAN Driver if </p>
<p>the Generator Version Check or the CRC Check fails. (see [5]) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>61 </p>
<p>based on template version 3.2 </p>
<p><b>Component </b></p>
<p><b>API </b></p>
<p>Application (optional non AUTOSAR) </p>
<p><b>Appl_GenericPrecopy </b></p>
<p><b>Appl_GenericConfirmation </b></p>
<p><b>Appl_GenericPreTransmit </b></p>
<p><b>ApplCanTimerStart/Loop/End </b></p>
<p><b>Appl_CanRamCheckFailed, Appl_CanCorruptMailbox </b></p>
<p><b>ApplCanInterruptDisable/Restore </b></p>
<p><b>Appl_CanOverrun, </b></p>
<p>For detailed description see Chapter 7.2 </p>
<p>CANIF </p>
<p><b>CanIf_CancelTxNotification </b>(non AUTOSAR) </p>
<p>A special Software cancellation callback only used within Vector </p>
<p>CAN driver CAN Interface bundle. </p>
<p><b>CanIf_TxConfirmation </b></p>
<p>Notification for a successful transmission. (see [4]) </p>
<p><b>CanIf_CancelTxConfirmation </b></p>
<p>Notification for a successful Tx cancellation. (see [4]) </p>
<p><b>CanIf_RxIndication </b></p>
<p>Notification for a message reception. (see [4]) </p>
<p><b>CanIf_ControllerBusOff </b></p>
<p>Bus Off notification function. (see [4]) </p>
<p><b>CanIf_ControllerModeIndication </b></p>
<p>MICROSAR4x only: Notification for mode sucessfully changed. </p>
<p>Os (MICROSAR4x) </p>
<p><b>OS_TICKS2MS_&lt;counterShortName&gt;()</b></p>
<p> </p>
<p>Os macro to get timebased ticks from counter. </p>
<p><b>GetElapsedValue </b></p>
<p>Get elapsed tick count. </p>
<p><b>GetCounterValue </b></p>
<p>Get tick count start. </p>
<p>Table 7-38  </p>
<p>Services used by the CAN </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>62 </p>
<p>based on template version 3.2 </p>
<p><b>8 </b></p>
<p><b>Configuration </b></p>
<p>For CAN driver the attributes can be configured with configuration Tool “CFG5” </p>
<p>The CAN driver supports pre-compile, link-time and post-build configuration. </p>
<p>For  post-build  systems,  re-flashing  the  generated  data  can  change  some  configuration </p>
<p>settings. </p>
<p>For post-build and link-time configurations pre-compile settings are configured at compile </p>
<p>time and therefore unchangeable at link or post-build time. </p>
<p>The </p>
<p>following </p>
<p>parameters </p>
<p>are </p>
<p>set </p>
<p>by </p>
<p>CFG5 </p>
<p>configuration </p>
<p>(see </p>
<p>Chapter </p>
<p>“DaVinci </p>
<p>Configurator”). </p>
<p><b>8.1 </b></p>
<p><b>Pre-Compile Parameters </b></p>
<p>Some settings have to be available before compilation: </p>
<p><b>&gt; </b></p>
<p>MCAN Core Release </p>
<p>#define C_ENABLE_MPC5700_MCAN_MAJOR_CREL      </p>
<p> </p>
<p> </p>
<p>1/2/3/… </p>
<p><b>&gt; </b></p>
<p>MCAN Step of Core Release </p>
<p>#define C_ENABLE_MPC5700_MCAN_MAJOR_CREL_STEP    0/1/2/3/… </p>
<p><b>&gt; </b></p>
<p>MCAN Sub Step of Core Release </p>
<p>#define C_ENABLE_MPC5700_MCAN_MAJOR_CREL_SSTEP  0/1/2/3/… </p>
<p><b>&gt; </b></p>
<p>Non ISO Operation </p>
<p>#define CAN_FD_NISO     0 = ISO 11898-1:2015 / 1 = Bosch CAN FD Spec. V1.0 </p>
<p><b>&gt; </b></p>
<p>&gt;  Version API (Can_GetVersionInfo() activation) </p>
<p>#define CAN_VERSION_INFO_API   STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>DET (development error detection) </p>
<p>#define CAN_DEV_ERROR_DETECT   STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Hardware Loop Check (timeout monitoring) </p>
<p>#define CAN_HARDWARE_CANCELLATION   STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Polling modes: Tx confirmation, Reception, Wakeup, BusOff </p>
<p>#define CAN_TX_PROCESSING       CAN_INTERRUPT/ CAN_POLLING </p>
<p>#define CAN_RX_PROCESSING       CAN_INTERRUPT/ CAN_POLLING </p>
<p>#define CAN_BUSOFF_PROCESSING   CAN_INTERRUPT/ CAN_POLLING </p>
<p>#define CAN_WAKEUP_PROCESSING   CAN_INTERRUPT/ CAN_POLLING </p>
<p>#define CAN_INDIVIDUAL_PROCESSING   STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Multiplexed Tx (external PIA – by usage of multiple Tx mailboxes) </p>
<p>#define CAN_MULTIPLEXED_TRANSMISSION   STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Configuration Variant (define the configuration type when using post build variant) </p>
<p>#define CAN_ENABLE_SELECTABLE_PB </p>
<p><b>&gt; </b></p>
<p>Use Generic Precopy Function (None AUTOSAR feature) </p>
<p>#define CAN_GENERIC_PRECOPY   STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Use Generic Confirmation Function (None AUTOSAR feature) </p>
<p>#define CAN_GENERIC_CONFIRMATION   STD_ON/STD_OFF </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>63 </p>
<p>based on template version 3.2 </p>
<p><b>&gt; </b></p>
<p>Use Rx Queue Function (None AUTOSAR feature) </p>
<p>#define CAN_RX_QUEUE   STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Used ID type (standard/extended or mixed ID format) </p>
<p>#define CAN_EXTENDED_ID   STD_ON/STD_OFF </p>
<p>#define CAN_MIXED_ID      STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Usage of Rx and Tx Full and BasicCAN objects (deactivate only when not using and to save ROM and </p>
<p>runtime consumption) </p>
<p>#define CAN_RX_FULLCAN_OBJECTS    STD_ON/STD_OFF </p>
<p>#define CAN_TX_FULLCAN_OBJECTS     STD_ON/STD_OFF </p>
<p>#define CAN_RX_BASICCAN_OBJECTS   STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Use Multiple BasicCAN objects </p>
<p>#define CAN_MULTIPLE_BASICCAN    STD_ON/STD_OFF</p>
<p> </p>
<p><b>&gt; </b></p>
<p>Optimizations </p>
<p>#define CAN_ONE_CONTROLLER_OPTIMIZATION    STD_ON/STD_OFF </p>
<p>#define CAN_DYNAMIC_FULLCAN_ID     STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Usage of nested CAN interrupts </p>
<p>#define CAN_NESTED_INTERRUPTS     STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Use Multiple ECU configurations </p>
<p>#define CAN_MULTI_ECU_CONFIG     STD_ON/STD_OFF </p>
<p><b>&gt; </b></p>
<p>Use RAM Check (verify mailbox buffers) </p>
<p>#define CAN_RAM_CHECK       </p>
<p> </p>
<p>CAN_NONE/CAN_NOTIFY_ISSUE/CAN_NOTIFY_MAILBOX </p>
<p><b>&gt; </b></p>
<p>Use Overrun detection </p>
<p>#define CAN_OVERRUN_NOTIFICATION       CAN_NONE/ CAN_DET/ CAN_APPL </p>
<p><b>&gt; </b></p>
<p>Select MicroSar version </p>
<p>#define CAN_MICROSAR_VERSION         CAN_MSR30/ CAN_MSR40/ CAN_MSR403 </p>
<p><b>&gt; </b></p>
<p>Tx Cancellation of Identical IDs </p>
<p>#define CAN_IDENTICAL_ID_CANCELLATION     STD_ON/STD_OFF </p>
<p><b>8.2 </b></p>
<p><b>Link-Time Parameters </b></p>
<p>The library version of the CAN driver uses the following generated settings: </p>
<p><b>&gt; </b></p>
<p>Maximum amount of used controllers and Tx mailboxes (has to be set for post-build </p>
<p>variants at link-time) </p>
<p><b>&gt; </b></p>
<p>Rx Queue size </p>
<p><b>&gt; </b></p>
<p>Controller mapping (mapping of logical channel to hardware node). </p>
<p><b>&gt; </b></p>
<p>CAN hardware base address. </p>
<p><b>8.3 </b></p>
<p><b>Post-Build Parameters </b></p>
<p>Following settings are post-build data that can be changed for re-flashing: </p>
<p><b>&gt; </b></p>
<p>Amount and usage of FullCAN Rx and Tx mailboxes </p>
<p><b>&gt; </b></p>
<p>Used database (message information like ID, DLC) </p>
<p><b>&gt; </b></p>
<p>Filters for BasicCAN Rx mailbox </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>64 </p>
<p>based on template version 3.2 </p>
<p><b>&gt; </b></p>
<p>Baud-rate settings </p>
<p><b>&gt; </b></p>
<p>Module Start Address (only for post-build systems: The memory location for re-</p>
<p>flashed data has to be defined) </p>
<p><b>&gt; </b></p>
<p>Configuration ID (only for post-build systems: This number is used to identify the </p>
<p>post-build data </p>
<p><b>&gt; </b></p>
<p>CAN hardware Fifo depth  </p>
<p><b>&gt; </b></p>
<p>CAN hardware clock and bit timing settings </p>
<p><b>8.4 </b></p>
<p><b>Configuration with da DaVinci Configurator </b></p>
<p>See Online help within DaVinci Configurator and BSWMD file for parameter settings. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>65 </p>
<p>based on template version 3.2 </p>
<p><b>9 </b></p>
<p><b>AUTOSAR Standard Compliance </b></p>
<p><b>9.1 </b></p>
<p><b>Limitations / Restrictions </b></p>
<p><b>Category </b></p>
<p><b>Description </b></p>
<p><b>Version </b></p>
<p>Functional </p>
<p>No multiple AUTOSAR CAN driver allowed in the system </p>
<p>3.0.6  </p>
<p>Functional </p>
<p>No support for L-PDU callout (AUTOSAR 3.2.1), but support ‘Generic </p>
<p>Precopy’ instead </p>
<p>3.2.1 </p>
<p>Functional </p>
<p>No support for multiple read and write period configuration </p>
<p>3.2.1 </p>
<p>API </p>
<p>“</p>
<p>Symbolic Name Values” may change their values after precompile </p>
<p>phase so do not use it for Link Time or Post Build variants. </p>
<p>It’s recommended that higher layer generator use Values (ObjectIDs) </p>
<p>from EcuC file. Vector CAN Interface does so.</p>
<p> </p>
<p>3.0.6 </p>
<p> </p>
<p>For the acceptance filtering a maximum of 64 filters per CAN channel </p>
<p>is supported in case of GENy is used as Generation Tool. </p>
<p> </p>
<p> </p>
<p><b>9.2 </b></p>
<p><b>Hardware Limitations  </b></p>
<p><b>8.2.1  Tx side  </b></p>
<p>MCAN Tx Event FIFO is not supported.  </p>
<p>MCAN Tx Queue is not supported.  </p>
<p>All available buffers per CAN (32) are configured as dedicated Tx buffers.  </p>
<p><b>8.2.2  Rx side  </b></p>
<p>SREQ00014271 “message reception shall use overwrite mode” is not fulfilled for FullCAN  </p>
<p>messages due to hardware behaviour.  </p>
<p><b>8.2.3  Used resources  </b></p>
<p>Please  note  that  the  theoretical  possible  maximum  configuration  for  the  RH850P1xC  </p>
<p>derivative  requires  more  RAM  space  in  the  Shared  Message  RAM  than  there  is   </p>
<p>actual available.  </p>
<p>For each CAN channel the following elements can be configured. If the required size for a  </p>
<p>distinct  configuration  exceeds  the  maximum  available  RAM  space  in  hardware  then  </p>
<p>the configuration tool issues an error during generation time and you are requested totailor  </p>
<p>down your configuration until it fits into the available Shared Message RAM.   </p>
<p>Resource usage for one CAN channel: </p>
<p>Area </p>
<p>Address range </p>
<p>Max  size  </p>
<p>(byte) </p>
<p>Max.  number  of  </p>
<p>elements </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>66 </p>
<p>based on template version 3.2 </p>
<p>Std Filter </p>
<p>0x0000 – 0x01FF </p>
<p>512   </p>
<p>128 </p>
<p>Ext Filter </p>
<p>0x0200 – 0x03FF </p>
<p>512 </p>
<p>64 </p>
<p>Rx FIFO 0 </p>
<p>0x0400 – 0x07FF </p>
<p>1024 </p>
<p>64 </p>
<p>Rx FIFO 1 </p>
<p>0x0800 – 0x0BFF </p>
<p>1024   </p>
<p>64 </p>
<p>Rx Buffer </p>
<p>0x0C00 – 0x0FFF </p>
<p>1024   </p>
<p>64 </p>
<p>TxEvt FIFO </p>
<p>0x1000 – 0x10FF </p>
<p>256 </p>
<p>32 </p>
<p>Tx buffer   </p>
<p>0x1100 – 0x12FF </p>
<p>512 </p>
<p>32 </p>
<p>                                   0x1300                       4864 bytes total </p>
<p> </p>
<p>Thus a maximum of “4864 * NumberOfChannels” can theoretically be configured but less </p>
<p>RAM is physically available. You are requested to reduce the areas according to your </p>
<p>needs.  </p>
<p>Please note that the “Tx Buffer region” and the “TTCAN region” (for channels with TTCAN  </p>
<p>support) for each channel is restricted to a dedicated address.   </p>
<p>This is not consistent for all hardware releases, please refer to your hardware  </p>
<p>manufacturer documentation (see ch. 2 “Hardware Overview”). </p>
<p> </p>
<p><b>9.2.1 </b></p>
<p><b>Initialization of the CAN Message RAM  </b></p>
<p>The internal SRAM features Error Correcting Code (ECC). Because these ECC bits can  </p>
<p>contain random data after the device is turned on, all SRAM locations must be initialized  </p>
<p>before being read by application code. Initialization is done by executing 64-bit writes to  </p>
<p>the  entire  SRAM  block.  The  value  written  does  not  matter  at  this  point,  so  the   </p>
<p>Store Multiple Word instruction will be used to write 16 general-purpose registers with  </p>
<p>each loop iteration.  </p>
<p> </p>
<p>By default the CAN driver tries to accomplish this initialization. Due to the need of using </p>
<p>assembler  code  notation  it  might  happen  that  specific  options  for  a  distinct  compiler </p>
<p>(assembler) are not appropriate. If so, you can feel free to disable the CAN driver internal </p>
<p>initialization (see below on how to) and use your own initialization instead of.   </p>
<p> </p>
<p>To  disable  the  CAN  driver  internal  initialization  use  a  “User  Config  File”  containing  </p>
<p>the following preprocessor definition:  </p>
<p> </p>
<p>#define CAN_ECC_INIT      STD_OFF  </p>
<p> </p>
<p>Put your initialization into execution just before calling Can_Init(). The MCAN clock must  </p>
<p>be available at this point of time.  </p>
<p> </p>
<p>Please  refer  to  your  hardware  manufacturer  documentation  (see  ch. 2 “Hardware  </p>
<p>Overview”) for the address layout. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>67 </p>
<p>based on template version 3.2 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>9.3 </b></p>
<p><b>Vector Extensions </b></p>
<p>Refer to Chapter 4.1 “Features” listed under “</p>
<p><b>AUTOSAR extensions” </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>68 </p>
<p>based on template version 3.2 </p>
<p><b>10  Glossary and Abbreviations </b></p>
<p><b>10.1 </b></p>
<p><b>Glossary </b></p>
<p> </p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>GENy </p>
<p>Generation tool for CANbedded and MICROSAR components </p>
<p>High End (license) </p>
<p>Product license to support an extended feature set (see Feature table) </p>
<p>Table 10-1  </p>
<p>Glossary </p>
<p> </p>
<p><b>10.2 </b></p>
<p><b>Abbreviations </b></p>
<p> </p>
<p><b>Abbreviation </b></p>
<p><b>Description </b></p>
<p>API </p>
<p>Application Programming Interface </p>
<p> </p>
<p>AUTOSAR </p>
<p>Automotive Open System Architecture </p>
<p>BSW </p>
<p>Basis Software </p>
<p>DEM </p>
<p>Diagnostic Event Manager </p>
<p>DET </p>
<p>Development Error Tracer </p>
<p>ECU </p>
<p>Electronic Control Unit </p>
<p>HIS </p>
<p>Hersteller Initiative Software </p>
<p>ISR </p>
<p>Interrupt Service Routine </p>
<p>MICROSAR </p>
<p>Microcontroller Open System Architecture (the Vector AUTOSAR solution) </p>
<p>3,3x = AUTOSAR version 3 </p>
<p>401 = AUTOSAR version 4.0.1 </p>
<p>403 = AUTOSAR version 4.0.3 </p>
<p>4x = AUTOSAR version 4.x.x </p>
<p>SWS </p>
<p>Software Specification </p>
<p>Common CAN </p>
<p>Connect two physical peripheral channels to one CAN bus (to increase </p>
<p>the amount of FullCAN) </p>
<p>Hardware Loop </p>
<p>Check </p>
<p>Timeout monitoring for possible endless loops. </p>
<p>Table 10-2  </p>
<p>Abbreviations </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference Microsar CAN Driver </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.02.00 </p>
<p>69 </p>
<p>based on template version 3.2 </p>
<p><b>11  Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p>&gt;   News </p>
<p>&gt;   Products </p>
<p>&gt;   Demo software </p>
<p>&gt;   Support </p>
<p>&gt;   Training data </p>
<p>&gt;   Addresses </p>
<p> </p>
<p><b>www.vector.com </b></p>
<p> </p>
</body>
</html>
{% endraw %}