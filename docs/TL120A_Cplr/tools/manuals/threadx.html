---
layout: default
title: threadx
nav_order: 246
parent: Cplr (TL120A)
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p><b>MULTI: Developing for ThreadX</b></p>
<p><b>Green Hills Software</b></p>
<p><b>30 West Sola Street</b></p>
<p><b>Santa Barbara, California 93101</b></p>
<p><b>USA</b></p>
<p><b>Tel: 805-965-6044</b></p>
<p><b>Fax: 805-965-6343</b></p>
<p><b>www.ghs.com</b></p>
<h1 style="page-break-before:always; "></h1>
<p><b>LEGAL NOTICES AND DISCLAIMERS</b></p>
<p>GREEN HILLS SOFTWARE MAKES NO REPRESENTATIONS OR WARRANTIES WITH RESPECT TO THE</p>
<p>CONTENTS HEREOF AND SPECIFICALLY DISCLAIMS ANY IMPLIED WARRANTIES OF MERCHANTABILITY</p>
<p>OR FITNESS FOR ANY PARTICULAR PURPOSE. Further, Green Hills Software reserves the right to revise this</p>
<p>publication and to make changes from time to time in the content hereof without obligation of Green Hills Software to</p>
<p>notify any person of such revision or changes.</p>
<p>Copyright Â© 1983-2015 by Green Hills Software. All rights reserved. No part of this publication may be reproduced, stored</p>
<p>in a retrieval system, or transmitted, in any form or by any means, electronic, mechanical, photocopying, recording, or</p>
<p>otherwise, without prior written permission from Green Hills Software.</p>
<p>Green Hills, the Green Hills logo, CodeBalance, GMART, GSTART, INTEGRITY, MULTI, and Slingshot are registered</p>
<p>trademarks of Green Hills Software. AdaMULTI, Built with INTEGRITY, EventAnalyzer, G-Cover, GHnet, GHnetLite,</p>
<p>Green Hills Probe, Integrate, ISIM, u-velOSity, PathAnalyzer, Quick Start, ResourceAnalyzer, Safety Critical Products,</p>
<p>SuperTrace Probe, TimeMachine, TotalDeveloper, DoubleCheck, and velOSity are trademarks of Green Hills Software.</p>
<p>All other company, product, or service names mentioned in this book may be trademarks or service marks of their respective</p>
<p>owners.</p>
<p>For a partial listing of Green Hills Software and periodically updated patent marking information, please visit</p>
<p>http://www.ghs.com/copyright_patent.html.</p>
<p>PubID: threadx-544152</p>
<p>Branch: http://toolsvc/branches/release-branch-70-bto</p>
<p>Date: October 21, 2015</p>
<h1 style="page-break-before:always; "></h1>
<p><b>Contents</b></p>
<p><b>Preface</b></p>
<p><b>vii</b></p>
<p>About</p>
<p>This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>viii</p>
<p>MULTI for ThreadX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>ix</p>
<p>The MULTI Document Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>ix</p>
<p>Conventions Used in the MULTI Document Set . . . . . . . . . . . . . . . . . . . . . .</p>
<p>x</p>
<p><b>Part I. Using MULTI with ThreadX</b></p>
<p><b>1</b></p>
<p><b>1. Running MULTI for ThreadX</b></p>
<p><b>3</b></p>
<p>ThreadX and Green Hills Tools Compatibility . . . . . . . . . . . . . . . . . . . .</p>
<p>4</p>
<p>Debugging ThreadX Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>4</p>
<p>Manipulating ThreadX Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>5</p>
<p>Alignment Restrictions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>6</p>
<p>Timeout Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>6</p>
<p>The ThreadX Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>6</p>
<p>Checking Thread Stack Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>9</p>
<p>Configuring Stack Use Checking . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>9</p>
<p>Analyzing ThreadX Memory Allocation . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>10</p>
<p>The MULTI EventAnalyzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>10</p>
<p>Performance Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>10</p>
<p><b>2. Threads</b></p>
<p><b>13</b></p>
<p>The Thread List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>14</p>
<p>Multithreaded Debugging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>14</p>
<p>Contents of the Thread List Window . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>15</p>
<p>The Thread Ready List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>17</p>
<p>The Thread Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>19</p>
<p><i>iii</i></p>
<p><i>Green Hills Software</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The Current Thread Information Window . . . . . . . . . . . . . . . . . . . . . .</p>
<p>23</p>
<p>The Thread Stack Check List Window . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>24</p>
<p>The Stack Check Information Window . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>25</p>
<p><b>3. Message Queues</b></p>
<p><b>27</b></p>
<p>The Queue List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>28</p>
<p>The Queue Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>29</p>
<p><b>4. Semaphores</b></p>
<p><b>33</b></p>
<p>The Semaphore List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>34</p>
<p>The Semaphore Information Window . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>35</p>
<p><b>5. Mutexes</b></p>
<p><b>37</b></p>
<p>The Mutex List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>38</p>
<p>The Mutex Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>39</p>
<p><b>6. Event Flags Groups</b></p>
<p><b>43</b></p>
<p>The Event Flags List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>44</p>
<p>The Event Flags Information Window . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>45</p>
<p><b>7. Memory Block Pools</b></p>
<p><b>49</b></p>
<p>The Block Pool List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>50</p>
<p>The Block Pool Information Window . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>52</p>
<p>The Block Pool Contents Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>55</p>
<p><b>8. Memory Byte Pools</b></p>
<p><b>57</b></p>
<p>The Byte Pool List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>58</p>
<p>The Byte Pool Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>59</p>
<p>The Byte Pool Contents Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>62</p>
<p><b>9. Application Timers</b></p>
<p><b>65</b></p>
<p>The Timer List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>66</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>iv</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The Timer Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>68</p>
<p><b>Part II. Using the MULTI EventAnalyzer for</b></p>
<p><b>ThreadX</b></p>
<p><b>71</b></p>
<p><b>10. Introduction to the MULTI EventAnalyzer for</b></p>
<p><b>ThreadX</b></p>
<p><b>73</b></p>
<p>Basic Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>75</p>
<p>The Effect of Event Logging on Run-Time Performance . . . . . . . . . .</p>
<p>78</p>
<p>Basic Logging Instrumentation . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>78</p>
<p>Quantity of Event Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>78</p>
<p><b>11. Collecting Event Logging Data</b></p>
<p><b>79</b></p>
<p>Control and Filtering of Event Logging . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>80</p>
<p>User-Defined Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>82</p>
<p>Modify the Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>83</p>
<p>Modify the Configuration File . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>83</p>
<p>Retrieving Event Logging Data from the Target . . . . . . . . . . . . . . . . .</p>
<p>84</p>
<p>Modifying the Target Event Log Location . . . . . . . . . . . . . . . . . . . . . .</p>
<p>85</p>
<p><b>12. Viewing Event Data</b></p>
<p><b>87</b></p>
<p>Launching the EventAnalyzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>88</p>
<p>The EventAnalyzer Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>89</p>
<p>Selecting Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>93</p>
<p>Selecting a Point in Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>93</p>
<p>Selecting a Range of Time . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>94</p>
<p>Zooming to a Range Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>94</p>
<p>Creating a Reference Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>94</p>
<p>Jumping to a Time Selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>95</p>
<p>Viewing Event Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>96</p>
<p>Using the Legend . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>96</p>
<p>View Event, and Status and Thread Details . . . . . . . . . . . . . . . . .</p>
<p>98</p>
<p>Viewing Context Switch Details . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>100</p>
<p><i>v</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Search for Event, Status, and Context Switches . . . . . . . . . . . .</p>
<p>101</p>
<p>Changing the Hidden Task List . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>103</p>
<p>Generating Reports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>104</p>
<p>Configuration Menu Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>104</p>
<p>Changing the Canvas Name . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>104</p>
<p>Time Unit Settings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>104</p>
<p><b>13. EventAnalyzer Configuration Files</b></p>
<p><b>107</b></p>
<p>Thread Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>109</p>
<p>Defining Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>110</p>
<p>Specifying Extra Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>110</p>
<p>Event</p>
<p>Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>113</p>
<p>Unknown Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>114</p>
<p>Miscellaneous Configuration Options . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>114</p>
<p>Event Overlap Icon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>114</p>
<p>Status Line Position . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>115</p>
<p>Tick Value Display . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>115</p>
<p>Warning for Unused Extra Data . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>116</p>
<p>Warning for Missing Extra Data . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>116</p>
<p>Reserved Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>116</p>
<p><b>14. ThreadX Services Reference</b></p>
<p><b>119</b></p>
<p>Memory Block Pool Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>120</p>
<p>Memory Byte Pool Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>121</p>
<p>Event Flags Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>122</p>
<p>Interrupt Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>123</p>
<p>Mutex Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>123</p>
<p>Message Queue Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>124</p>
<p>Semaphore Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>125</p>
<p>Thread Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>126</p>
<p>Application Timer Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>128</p>
<p><b>Index</b></p>
<p><b>129</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>vi</i></p>
<p><i>Contents</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Preface</b></p>
<p><b>Contents</b></p>
<p>About</p>
<p>This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>viii</p>
<p>MULTI for ThreadX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>ix</p>
<p>The MULTI Document Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>ix</p>
<p>Conventions Used in the MULTI Document Set . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>x</p>
<h1 style="page-break-before:always; "></h1>
<p>This preface discusses the purpose of the manual, the MULTI documentation set,</p>
<p>and typographical conventions used.</p>
<p><b>About This Book</b></p>
<p>This book describes settings, filenames, and procedures that apply specifically to</p>
<p>developing with MULTI for ThreadX. For more comprehensive documentation of</p>
<p>MULTI features, consult the other books in the documentation set, as described in</p>
<p>âThe MULTI Document Setâ on page ix.</p>
<p>This book is divided into two parts:</p>
<p>â¢</p>
<p><i>Part I: Using MULTI with ThreadX</i> explains how to debug ThreadX applications</p>
<p>and describes specialized windows for viewing ThreadX kernel components.</p>
<p>See Part I. Using MULTI with ThreadX on page 1.</p>
<p>â¢</p>
<p><i>Part II: Using the MULTI EventAnalyzer for ThreadX</i> describes how to collect</p>
<p>and view event logging data in the EventAnalyzer. See Part II. Using the</p>
<p>MULTI EventAnalyzer for ThreadX on page 71.</p>
<p><b>Note</b></p>
<p>New or updated information may have become available while this book</p>
<p>was in production. For additional material that was not available at press</p>
<p>time, or for revisions that may have become necessary since this book</p>
<p>was printed, please check your installation directory for release notes,</p>
<p><b>README</b> files, and other supplementary documentation.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>viii</i></p>
<p><i>Preface</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>MULTI for ThreadX</b></p>
<p>ThreadX is a high-performance real-time embedded kernel developed by Express</p>
<p>Logic, Inc. The MULTI Integrated Development Environment works seamlessly</p>
<p>with ThreadX to provide detailed kernel-aware and thread-aware debugging for</p>
<p>developers, including full C, C++, and Embedded C++ source and</p>
<p>assembly-language debugging.</p>
<p>All eight ThreadX kernel components are recognized by MULTI:</p>
<p>â¢</p>
<p>Threads</p>
<p>â¢</p>
<p>Message queues</p>
<p>â¢</p>
<p>Semaphores</p>
<p>â¢</p>
<p>Mutexes</p>
<p>â¢</p>
<p>Event flags groups</p>
<p>â¢</p>
<p>Memory block pools</p>
<p>â¢</p>
<p>Memory byte pools</p>
<p>â¢</p>
<p>Application timers</p>
<p>Each kernel component type has at least two associated MULTI windows: a<i> list</i></p>
<p><i>window</i> that summarizes all created kernel components of that component type and</p>
<p>an<i> information window</i> that shows detailed information about a specific component.</p>
<p>The thread, block pool, and byte pool kernel components also have additional</p>
<p>associated windows that provide further information. All of these windows are</p>
<p>described in detail in the following chapters.</p>
<p><b>The MULTI Document Set</b></p>
<p>The primary documentation for using MULTI is provided in the following books:</p>
<p>â¢</p>
<p><i>MULTI: Getting Started</i> â Provides an introduction to the MULTI Integrated</p>
<p>Development Environment and leads you through a simple tutorial.</p>
<p>â¢</p>
<p><i>MULTI: Licensing</i> â Describes how to obtain, install, and administer MULTI</p>
<p>licenses.</p>
<p>â¢</p>
<p><i>MULTI: Managing Projects and Configuring the IDE</i> â Describes how to</p>
<p>create and manage projects and how to configure the MULTI IDE.</p>
<p><i>ix</i></p>
<p><i>Green Hills Software</i></p>
<p><i>MULTI for ThreadX</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><i>MULTI: Building Applications</i> â Describes how to use the compiler driver</p>
<p>and the tools that compile, assemble, and link your code. Also describes the</p>
<p>Green Hills implementation of supported high-level languages.</p>
<p>â¢</p>
<p><i>MULTI: Configuring Connections</i> â Describes how to configure connections</p>
<p>to your target.</p>
<p>â¢</p>
<p><i>MULTI: Debugging</i> â Describes how to set up your target debugging interface</p>
<p>for use with MULTI and how to use the MULTI Debugger and associated tools.</p>
<p>â¢</p>
<p><i>MULTI: Debugging Command Reference</i> â Describes how to use Debugger</p>
<p>commands and provides a comprehensive reference of Debugger commands.</p>
<p>â¢</p>
<p><i>MULTI: Scripting</i> â Describes how to create MULTI scripts. Also contains</p>
<p>information about the MULTI-Python integration.</p>
<p>For a comprehensive list of the books provided with your MULTI installation, see</p>
<p>the<b> Help</b> â<b> Manuals</b> menu accessible from most MULTI windows.</p>
<p>All books are available in one or more of the following formats:</p>
<p>â¢</p>
<p>Print.</p>
<p>â¢</p>
<p>Online help, accessible from most MULTI windows via the<b> Help</b> â<b> Manuals</b></p>
<p>menu.</p>
<p>â¢</p>
<p>PDF, available in the<b> manuals</b> subdirectory of your MULTI or compiler</p>
<p>installation.</p>
<p><b>Conventions Used in the MULTI Document Set</b></p>
<p>All Green Hills documentation assumes that you have a working knowledge of your</p>
<p>host operating system and its conventions, including its command line and graphical</p>
<p>user interface (GUI) modes.</p>
<p>Green Hills documentation uses a variety of notational conventions to present</p>
<p>information and describe procedures. These conventions are described below.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>x</i></p>
<p><i>Preface</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Example</b></p>
<p><b>Indication</b></p>
<p><b>Convention</b></p>
<p><b>C:\MyProjects</b></p>
<p>Filename or pathname</p>
<p><b>bold</b> type</p>
<p><b>setup</b> command</p>
<p>Command</p>
<p><b>-G</b> option</p>
<p>Option</p>
<p>The<b> Breakpoints</b> window</p>
<p>Window title</p>
<p>The<b> File</b> menu</p>
<p>Menu name or menu choice</p>
<p><b>Working Directory:</b></p>
<p>Field name</p>
<p>The<b> Browse</b> button</p>
<p>Button name</p>
<p><b>-o<i> filename</b></i></p>
<p>Replaceable text</p>
<p><i>italic</i> type</p>
<p>A task may be called a<i> process</i></p>
<p>or a<i> thread</i></p>
<p>A new term</p>
<p><i>MULTI: Debugging</i></p>
<p>A book title</p>
<p>Type</p>
<p>help<i> command_name</i></p>
<p>Text you should enter as presented</p>
<p>monospace</p>
<p>type</p>
<p>The<b> wait</b> [-global] command</p>
<p>blocks command processing,</p>
<p>where</p>
<p>-global</p>
<p>blocks</p>
<p>command processing for all</p>
<p>MULTI processes.</p>
<p>A word or words used in a</p>
<p>command or example</p>
<p>int a = 3;</p>
<p>Source code</p>
<p>&gt; print Test</p>
<p>Test</p>
<p>Input/output</p>
<p>GHS_System()</p>
<p>A function</p>
<p><b>debugbutton</b> [<i>name</i>]...</p>
<p>The preceding argument or option</p>
<p>can be repeated zero or more times.</p>
<p>ellipsis (...)</p>
<p>(in command line</p>
<p>instructions)</p>
<p>&gt; print Test</p>
<p>Test</p>
<p>Represents a prompt. Your actual</p>
<p>prompt may be a different symbol</p>
<p>or string. The &gt; prompt helps to</p>
<p>distinguish input from output in</p>
<p>examples of screen displays.</p>
<p>greater than sign ( &gt; )</p>
<p><b>call<i></b> func</i> |<i> expr</i></p>
<p>One (and only one) of the</p>
<p>parameters or options separated by</p>
<p>the pipe or pipes should be</p>
<p>specified.</p>
<p>pipe ( | )</p>
<p>(in command line</p>
<p>instructions)</p>
<p><i>xi</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Conventions Used in the MULTI Document Set</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Example</b></p>
<p><b>Indication</b></p>
<p><b>Convention</b></p>
<p>.macro<i> name</i> [<i>list</i>]</p>
<p>Optional argument, command,</p>
<p>option, and so on. You can either</p>
<p>include or omit the enclosed</p>
<p>elements. The square brackets</p>
<p>should not appear in your actual</p>
<p>command.</p>
<p>square brackets ( [ ] )</p>
<p>(in command line</p>
<p>instructions)</p>
<p>The following command description demonstrates the use of some of these</p>
<p>typographical conventions.</p>
<p><b>gxyz</b> [<i>-option</i>]...<i> filename</i></p>
<p>The formatting of this command indicates that:</p>
<p>â¢</p>
<p>The command<b> gxyz</b> should be entered as shown.</p>
<p>â¢</p>
<p>The option</p>
<p><i>-option</i></p>
<p>should either be replaced with one or more appropriate</p>
<p>options or be omitted.</p>
<p>â¢</p>
<p>The word</p>
<p><i>filename</i></p>
<p>should be replaced with the actual filename of an</p>
<p>appropriate file.</p>
<p>The square brackets and the ellipsis should not appear in the actual command you</p>
<p>enter.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>xii</i></p>
<p><i>Preface</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Part I</b></p>
<p><b>Using MULTI with ThreadX</b></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 1</b></p>
<p><b>Running MULTI for ThreadX</b></p>
<p><b>Contents</b></p>
<p>ThreadX and Green Hills Tools Compatibility . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>4</p>
<p>Debugging ThreadX Applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>4</p>
<p>Manipulating ThreadX Windows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>5</p>
<p>The ThreadX Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>6</p>
<p>Checking Thread Stack Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>9</p>
<p>Analyzing ThreadX Memory Allocation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>10</p>
<p>The MULTI EventAnalyzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>10</p>
<p>Performance Issues . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>10</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter provides a basic overview of how to use MULTI to debug ThreadX</p>
<p>applications.</p>
<p><b>ThreadX and Green Hills Tools Compatibility</b></p>
<p>MULTI and the Green Hills Compilers are compatible with ThreadX 5.5 and later.</p>
<p>For a project built with ThreadX, if you customize system libraries, remove the</p>
<p>following files from your<b> libsys.gpj</b> subproject:</p>
<p>â¢</p>
<p><b>ind_thrd.c</b></p>
<p>â¢</p>
<p><b>ind_lock.c</b></p>
<p>â¢</p>
<p><b>ind_except.c</b></p>
<p>ThreadX-specific versions of the routines contained in these files are included with</p>
<p>ThreadX.</p>
<p><b>Debugging ThreadX Applications</b></p>
<p>When you debug a ThreadX application with MULTI, a ThreadX icon (</p>
<p>) appears</p>
<p>in the MULTI Debugger toolbar:</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>4</i></p>
<p><i>Chapter 1. Running MULTI for ThreadX</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Click the ThreadX icon to open the<b> ThreadX Information</b> window, the main</p>
<p>control window for MULTI kernel-aware debugging for ThreadX. See âThe ThreadX</p>
<p>Information Windowâ on page 6 for more information about using this window.</p>
<p>To learn more about MULTI for ThreadX, use MULTI to create a product</p>
<p>demonstration program. You must have a licensed copy of ThreadX installed on</p>
<p>your system to build a ThreadX program.</p>
<p><b>Manipulating ThreadX Windows</b></p>
<p>The following information applies to all ThreadX windows except the<b> Thread List</b></p>
<p>window.</p>
<p>â¢</p>
<p>Clicking the blue<b> Freeze</b> button ( ) located near the top right corner of the</p>
<p>window freezes the window and changes the button into a snowflake (</p>
<p>).</p>
<p><i>5</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Manipulating ThreadX Windows</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Clicking the snowflake makes the window active again. An active window is</p>
<p>updated each time the target is stopped. See âPerformance Issuesâ on page 10</p>
<p>for more information about the<b> Freeze</b> button.</p>
<p>â¢</p>
<p>Entering<b> Ctrl</b>+<b>d</b> when a window is in view freezes the window and creates a</p>
<p>duplicate, active copy of it.</p>
<p>â¢</p>
<p>Clicking a button for a particular component displays more details about that</p>
<p>component.</p>
<p>â¢</p>
<p>Double-clicking any item in a list displays information about it. If no useful</p>
<p>information exists for an item, double-clicking the item may have no effect.</p>
<p><b>Alignment Restrictions</b></p>
<p>It is best to ensure 4-byte alignment and sizes for most component options that refer</p>
<p>to addresses or size in memory. To ensure correct</p>
<p>alignment, ThreadX pads certain</p>
<p>size parameters to be multiples of 4 bytes or adjusts beginning or ending pointers</p>
<p>to be 4-byte aligned.</p>
<p>This alignment restriction can sometimes explain differences between what is</p>
<p>specified when a component is created and what is displayed when it is viewed.</p>
<p>For example, a memory block pool created with a pool size of 258 bytes is not able</p>
<p>to make use of any more than 256 bytes. Similarly, creating a block pool with a</p>
<p>block size of 10 bytes results in an actual block size of 12 bytes.</p>
<p><b>Timeout Values</b></p>
<p>References to thread time slices and suspended thread timeout values, as well as to</p>
<p>application timer values inside ThreadX windows, refer only to the timeout values</p>
<p>contained in the underlying data structures. These entries do not necessarily count</p>
<p>down as time elapses. Counting down every one of these values on each timer tick</p>
<p>would compromise the real-time performance of ThreadX.</p>
<p><b>The ThreadX Information Window</b></p>
<p>The<b> ThreadX Information</b> window is the main control window for MULTI</p>
<p>kernel-aware debugging for ThreadX. To open this window, click the ThreadX</p>
<p>button (</p>
<p>) in the MULTI Debugger window.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>6</i></p>
<p><i>Chapter 1. Running MULTI for ThreadX</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> ThreadX Information</b> window shows useful system parameters such as</p>
<p>individual component counts, the name of the current thread, the version ID string,</p>
<p>and the status of the system clock and stack pointer. Buttons in the window open</p>
<p>other windows that contain lists for each component type or detailed information</p>
<p>about the current thread. Each field and button is described more specifically in the</p>
<p>table below.</p>
<p>Shows the number of created threads in the system, which</p>
<p>corresponds to the system variable</p>
<p>_tx_thread_created_count</p>
<p>.</p>
<p>Clicking the<b> Threads</b> button opens the<b> Thread List</b> window (see</p>
<p>âThe Thread List Windowâ on page 14 ).</p>
<p><b>Threads</b></p>
<p>Shows the number of created message queues in the system, which</p>
<p>corresponds to the system variable</p>
<p>_tx_queue_created_count</p>
<p>.</p>
<p>Clicking the<b> Message Queues</b> button opens the<b> Queue List</b> window</p>
<p>(see âThe Queue List Windowâ on page 28 ).</p>
<p><b>Message Queues</b></p>
<p>Shows the number of created semaphores in the system, which</p>
<p>corresponds to the system variable</p>
<p>_tx_semaphore_created_count</p>
<p>. Clicking the<b> Semaphores</b></p>
<p>button opens the<b> Semaphore List</b> window (see âThe Semaphore</p>
<p>List Windowâ on page 34).</p>
<p><b>Semaphores</b></p>
<p><i>7</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The ThreadX Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Shows the number of created event flags groups in the system, which</p>
<p>corresponds to the system variable</p>
<p>_tx_event_flags_created_count</p>
<p>. Clicking the<b> Event Flag</b></p>
<p><b>Groups</b> button opens the<b> Event Flags List</b> window (see âThe Event</p>
<p>Flags List Windowâ on page 44).</p>
<p><b>Event Flag Groups</b></p>
<p>Shows the number of created mutexes in the system, which</p>
<p>corresponds to the system variable</p>
<p>_tx_mutex_created_count</p>
<p>.</p>
<p>Mutex objects are available starting with ThreadX version 4.0.</p>
<p>Clicking the<b> Mutexes</b> button opens the<b> Mutex List</b> window (see</p>
<p>âThe Mutex List Windowâ on page 38).</p>
<p><b>Mutexes</b></p>
<p>Shows the number of created block pools in the system, which</p>
<p>corresponds to the system variable</p>
<p>_tx_block_pool_created_count</p>
<p>. Clicking the<b> Block Pools</b></p>
<p>button opens the<b> Block Pool List</b> window (see âThe Block Pool List</p>
<p>Windowâ on page 50).</p>
<p><b>Block Pools</b></p>
<p>Shows the number of created byte pools in the system, which</p>
<p>corresponds to the system variable</p>
<p>_tx_byte_pool_created_count</p>
<p>. Clicking the<b> Byte Pools</b> button</p>
<p>opens the<b> Byte Pool List</b> window (see âThe Byte Pool List Windowâ</p>
<p>on page 58 ).</p>
<p><b>Byte Pools</b></p>
<p>Shows the number of created application timers in the system, which</p>
<p>corresponds to the system variable</p>
<p>_tx_timer_created_count</p>
<p>.</p>
<p>Clicking the<b> Application Timers</b> button opens the<b> Timer List</b></p>
<p>window (see âThe Timer List Windowâ on page 66).</p>
<p><b>Application Timers</b></p>
<p>Opens the<b> Thread Stack Check List</b> window, which displays stack</p>
<p>information for all threads in the system (see âThe Thread Stack</p>
<p>Check List Windowâ on page 24).</p>
<p><b>Stack Check List</b></p>
<p>Opens the<b> Thread Ready List</b> window, which shows a list of all</p>
<p>threads that are at the same priority level as the currently executing</p>
<p>thread and are ready to execute (see âThe Thread Ready List</p>
<p>Windowâ on page 17).</p>
<p><b>Ready List</b></p>
<p>Shows the current executing thread, which corresponds to the thread</p>
<p>pointed to by the system variable</p>
<p>_tx_thread_current_ptr</p>
<p>. If</p>
<p>the system is not within a thread, then</p>
<p>(System)</p>
<p>is displayed.</p>
<p>Clicking the<b> Current Thread</b> button opens the<b> Current Thread</b></p>
<p><b>Information</b> window (a<b> Thread Information</b> window on the thread</p>
<p>that was executing when the system was stopped). See âThe Current</p>
<p>Thread Information Windowâ on page 23 and âThe Thread</p>
<p>Information Windowâ on page 19 for more information.</p>
<p><b>Current Thread</b></p>
<p>Shows the version ID string of the system. This value corresponds</p>
<p>to the string pointed to by the system variable</p>
<p>_tx_version_id</p>
<p>.</p>
<p><b>Version ID</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>8</i></p>
<p><i>Chapter 1. Running MULTI for ThreadX</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Shows in timer ticks the system clock status. This value corresponds</p>
<p>to the system variable</p>
<p>_tx_timer_system_clock</p>
<p>.</p>
<p><b>System Clock</b></p>
<p>Shows the value of the system stack pointer. This value corresponds</p>
<p>to the system variable</p>
<p>_tx_thread_system_stack_ptr</p>
<p>.</p>
<p><b>System SP</b></p>
<p><b>Checking Thread Stack Usage</b></p>
<p>Stack overflow is a common problem that MULTI helps diagnose.</p>
<p>The<b> Stack Use</b> field in any thread window shows how much stack is currently in</p>
<p>use by each thread and how much stack space is available for each thread. This</p>
<p>information can help you to identify threads that are using more stack space than</p>
<p>anticipated and to adjust their stack sizes to guard against overflow before problems</p>
<p>occur.</p>
<p>MULTI for ThreadX also provides peak stack checking. You can check peak stack</p>
<p>use for a single thread by viewing the<b> Stack Check Information</b> window (see âThe</p>
<p>Stack Check Information Windowâ on page 25) or for all threads by viewing the</p>
<p><b>Thread Stack Check List</b> window (see âThe Thread Stack Check List Windowâ</p>
<p>on page 24). In either case, MULTI displays the peak stack usage as determined</p>
<p>by the highest point in the stack that has changed since the thread was created. Peak</p>
<p>stack use checking occurs by executing code on the target itself, which is usually</p>
<p>much faster than uploading large portions of target memory to the host.</p>
<p><b>Configuring Stack Use Checking</b></p>
<p>MULTI Debugger-based stack use checking is enabled by default in ThreadX. In</p>
<p>ThreadX versions 3 and 4, stack use checking can be disabled by compiling</p>
<p>tx_tc.c</p>
<p>with the preprocessor symbol TX_DISABLE_STACK_CHECKING defined. In</p>
<p>ThreadX version 5, stack use checking can be disabled by rebuilding the ThreadX</p>
<p>library with the TX_DISABLE_STACK_FILLING configuration option.</p>
<p>When stack use checking is enabled, the</p>
<p>tx_thread_create</p>
<p>service fills a thread's</p>
<p>stack with an</p>
<p>0xEF</p>
<p>data pattern that is used by the MULTI Debugger to calculate</p>
<p>stack usage. This function can be bypassed , which results in threads being created</p>
<p>more quickly.</p>
<p><i>9</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Checking Thread Stack Usage</i></p>
<h1 style="page-break-before:always; "></h1>
<p>ThreadX version 5 also contains a separate run-time stack checking feature. That</p>
<p>feature can be enabled or disabled separately from the MULTI Debugger-based</p>
<p>stack use checking.</p>
<p><b>Analyzing ThreadX Memory Allocation</b></p>
<p>MULTI for ThreadX contains enhanced views of memory block pools and byte</p>
<p>pools to help developers find problems with dynamic memory allocation.</p>
<p>To view this enhanced information, click<b> In Use</b> in a<b> Block Pool Information</b></p>
<p>window or<b> Byte Pool Information</b> window. This opens a<b> Contents</b> window that</p>
<p>lists the pool's memory blocks or fragments by their location in memory and indicates</p>
<p>whether each is</p>
<p>In Use</p>
<p>or</p>
<p>Available</p>
<p>. For byte pools, the window also displays</p>
<p>the size of each byte pool fragment. These memory contents windows make it easy</p>
<p>to observe the effects of dynamic memory allocation and to detect the causes of</p>
<p>byte pool fragmentation. See âThe Block Pool Contents Windowâ on page 55 or</p>
<p>âThe Byte Pool Contents Windowâ on page 62 for more information.</p>
<p><b>The MULTI EventAnalyzer</b></p>
<p>The MULTI EventAnalyzer can display ThreadX event information that allows</p>
<p>users of ThreadX to analyze the complex, real-time interactions occurring in their</p>
<p>target systems. For more information about configuring and using the EventAnalyzer,</p>
<p>please refer to the second part of this book, âUsing the MULTI EventAnalyzer for</p>
<p>ThreadXâ.</p>
<p><b>Performance Issues</b></p>
<p>All ThreadX windows except<b> Stack Check</b> windows are automatically updated</p>
<p>each time the target is halted, hits a breakpoint, or stops for any other reason. Thus,</p>
<p>the more ThreadX windows you have displayed, the more target data is uploaded</p>
<p>to the host system each time the target stops, and the slower your debugging</p>
<p>performance may be. To maximize debugging performance, close any unnecessary</p>
<p>ThreadX windows.</p>
<p>Another way to speed debugging is to use the blue<b> Freeze</b> button ( ) located near</p>
<p>the upper right-hand corner of each ThreadX window to selectively freeze windows</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>10</i></p>
<p><i>Chapter 1. Running MULTI for ThreadX</i></p>
<h1 style="page-break-before:always; "></h1>
<p>that do not need updating. Click the button to freeze the window. The button is</p>
<p>replaced by a snowflake (</p>
<p>). Click the snowflake to make the window active again.</p>
<p>An active window updates every time the target stops; frozen windows are not</p>
<p>updated with target data. To force an update of all active windows, use the<b> update</b></p>
<p>command in the MULTI Debugger.</p>
<p><i>11</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Performance Issues</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 2</b></p>
<p><b>Threads</b></p>
<p><b>Contents</b></p>
<p>The Thread List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>14</p>
<p>The Thread Ready List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>17</p>
<p>The Thread Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>19</p>
<p>The Current Thread Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>23</p>
<p>The Thread Stack Check List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>24</p>
<p>The Stack Check Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>25</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes windows that display detailed information about the threads</p>
<p>in your application.</p>
<p><b>The Thread List Window</b></p>
<p>The<b> Thread List</b> window shows a list of all threads in the kernel, in the order in</p>
<p>which they were created.</p>
<p>To display this window, click the<b> Threads</b> button in the main<b> ThreadX Information</b></p>
<p>window.</p>
<p>The list is generated by following a linked list, starting with the thread pointed to</p>
<p>by the global variable</p>
<p>_tx_thread_created_ptr</p>
<p>and continuing with the</p>
<p>tx_thread_created_next field of each thread control block TX_THREAD. A total</p>
<p>of</p>
<p>_tx_thread_created_count</p>
<p>threads are shown.</p>
<p>When a thread is deleted, it disappears from the<b> Thread List</b> window and from the</p>
<p>Debugger's target list.</p>
<p><b>Multithreaded Debugging</b></p>
<p>The<b> Thread List</b> window can be used for freeze-mode multithreaded debugging.</p>
<p>To display a thread in the MULTI Debugger, single-click it in the Debugger's target</p>
<p>list, or double-click it in the<b> Thread List</b> window.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>14</i></p>
<p><i>Chapter 2. Threads</i></p>
<h1 style="page-break-before:always; "></h1>
<p>For further information about working with the<b> Thread List</b> window, refer to the</p>
<p>documentation about freeze-mode debugging and OS-awareness in the<i> MULTI:</i></p>
<p><i>Debugging</i> book.</p>
<p><b>Contents of the Thread List Window</b></p>
<p>The<b> Thread List</b> window displays up to seven columns:<b> Name</b>,<b> Thread ID</b>,<b> State</b>,</p>
<p><b>Priority</b>,<b> Stack Use</b>,<b> Run Count</b>, and<b> Suspended On</b>. Each of these columns is</p>
<p>described below.</p>
<p><b>Note</b></p>
<p>Not all columns are shown by default; right-click the column header to</p>
<p>open a menu that will allow you to display or hide any of the available</p>
<p>columns.</p>
<p>Displays the name of the thread, as given in the call to</p>
<p>tx_thread_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry displays the address of the thread control block</p>
<p>TX_THREAD. This entry corresponds to the tx_thread_name field of</p>
<p>TX_THREAD.</p>
<p><b>Name</b></p>
<p>Displays the address of the thread control block TX_THREAD, as given</p>
<p>in the call to</p>
<p>tx_thread_create</p>
<p>.</p>
<p><b>Thread ID</b></p>
<p>Indicates the current execution state of the thread. This entry corresponds</p>
<p>to the tx_thread_state field of TX_THREAD. The thread can be in one</p>
<p>of five states:</p>
<p>â¢</p>
<p>Executing</p>
<p>â The thread is executing.</p>
<p>â¢</p>
<p>Ready</p>
<p>â The thread is ready and will execute when it is the highest</p>
<p>priority thread.</p>
<p>â¢</p>
<p>Suspended</p>
<p>â The thread cannot run because it is waiting. Threads</p>
<p>can wait for time, message queues, event flags, semaphores,</p>
<p>mutexes, and memory, or can be placed in a suspended state upon</p>
<p>thread creation.</p>
<p>â¢</p>
<p>Terminated</p>
<p>â The thread was terminated by a</p>
<p>tx_thread_terminate</p>
<p>call.</p>
<p>â¢</p>
<p>Completed</p>
<p>â The thread has returned from its entry function.</p>
<p><b>State</b></p>
<p><i>15</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Contents of the Thread List Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives information about the priority of the thread. The first number is</p>
<p>the priority level of the thread, which corresponds to the</p>
<p>tx_thread_priority field in TX_THREAD. The second number, in</p>
<p>parentheses, is the preemption threshold of the thread and corresponds</p>
<p>to the tx_thread_preempt_threshold field in TX_THREAD.</p>
<p><b>Priority</b></p>
<p>Indicates the amount of stack currently in use by the thread. Two numbers</p>
<p>separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The first number indicates</p>
<p>the amount of stack the thread has used and is derived from the difference</p>
<p>between the tx_thread_stack_end field in TX_THREAD and the current</p>
<p>thread stack pointer. The second number indicates the total amount of</p>
<p>stack space allocated to the thread and is the difference between the</p>
<p>tx_thread_stack_end and tx_thread_stack_start fields in TX_THREAD.</p>
<p><b>Stack Use</b></p>
<p>Indicates how many times the thread has been scheduled. When this</p>
<p>field is increasing, the thread is being scheduled and run. A run counter</p>
<p>that stays the same may indicate a thread that is unable to run for some</p>
<p>reason. This field corresponds to the tx_thread_run_count field of</p>
<p>TX_THREAD.</p>
<p><b>Run Count</b></p>
<p>Indicates the type (</p>
<p>Queue</p>
<p>,</p>
<p>Semaphore</p>
<p>,</p>
<p>Mutex</p>
<p>,</p>
<p>Event Flags Group</p>
<p>,</p>
<p>Block Pool</p>
<p>,</p>
<p>Byte Pool</p>
<p>,</p>
<p>Sleep</p>
<p>, or</p>
<p>Suspend Call</p>
<p>) of the component</p>
<p>on which the thread is suspended and its name (as given when that</p>
<p>component was created; if a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, the address of the control block is displayed).</p>
<p>The name portion of this field is derived from the appropriate name field</p>
<p>of the component pointed to by the tx_thread_suspend_control_block</p>
<p>field of TX_THREAD. The component type portion of this field is</p>
<p>derived from the tx_thread_state field of TX_THREAD.</p>
<p>This field shows</p>
<p>N/A</p>
<p>if the execution state is anything other than</p>
<p>Suspended</p>
<p>.</p>
<p><b>Suspended On</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>16</i></p>
<p><i>Chapter 2. Threads</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Thread Ready List Window</b></p>
<p>The<b> Thread Ready List</b> window shows a list of all threads that are at the same</p>
<p>priority level as the currently executing thread and are ready to execute.</p>
<p>To display this window, click the<b> Ready List</b> button in the<b> ThreadX Information</b></p>
<p>window.</p>
<p>The list is generated by following a linked list, starting with the thread pointed to</p>
<p>by the global variable</p>
<p>_tx_thread_current_ptr</p>
<p>and continuing with the</p>
<p>tx_thread_ready_next field of each thread control block TX_THREAD.</p>
<p>When a thread is deleted, it disappears from this list.</p>
<p>You can double-click any thread in the<b> Thread Ready List</b> to display a<b> Thread</b></p>
<p><b>Information</b> window (see âThe Thread Information Windowâ on page 19).</p>
<p>The<b> Thread Ready List</b> has four columns:<b> Name</b>,<b> State</b>,<b> Time Slice</b>, and<b> Stack</b></p>
<p><b>Use</b>. Each of these is described below.</p>
<p>Displays the name of the thread, as given in the call to</p>
<p>tx_thread_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry displays the address of the thread control block</p>
<p>TX_THREAD. This entry corresponds to the tx_thread_name field of</p>
<p>TX_THREAD.</p>
<p><b>Name</b></p>
<p>Indicates the current execution state of the thread. The thread can be in</p>
<p>one of two states:</p>
<p>â¢</p>
<p>Executing</p>
<p>â The thread is executing.</p>
<p>â¢</p>
<p>Ready</p>
<p>â The thread is ready and will execute when it is the</p>
<p>highest priority thread.</p>
<p><b>State</b></p>
<p><i>17</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Thread Ready List Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Displays the timer ticks remaining and the timer ticks given to the</p>
<p>thread. Two numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed.</p>
<p>The first number indicates the remaining timer ticks in the slice and</p>
<p>corresponds to the tx_thread_time_slice field of TX_THREAD. The</p>
<p>second number indicates how many timer ticks the thread will receive</p>
<p>when it is subsequently scheduled after it exhausts its current time slice.</p>
<p>This number is the time_slice parameter passed to</p>
<p>tx_thread_create</p>
<p>and corresponds to the tx_thread_new_time_slice field of</p>
<p>TX_THREAD.</p>
<p><b>Time Slice</b></p>
<p>Indicates the amount of stack currently in use by the thread. Two</p>
<p>numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The first number</p>
<p>indicates the amount of stack the thread has used and is derived from</p>
<p>the difference between the tx_thread_stack_end field in TX_THREAD</p>
<p>and the current thread stack pointer. The second number indicates the</p>
<p>total amount of stack space allocated to the thread and is derived from</p>
<p>the difference between the tx_thread_stack_end and</p>
<p>tx_thread_stack_start fields in TX_THREAD.</p>
<p><b>Stack Use</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>18</i></p>
<p><i>Chapter 2. Threads</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Thread Information Window</b></p>
<p>The<b> Thread Information</b> window shows detailed information about an individual</p>
<p>thread.</p>
<p>To display this window, double-click a thread in the<b> Thread Ready List</b> window,</p>
<p>right-click a thread in the<b> Thread List</b> window, or view a variable of type</p>
<p>TX_THREAD in the MULTI Debugger window. The information in this window</p>
<p>is derived from various fields within the thread control block TX_THREAD.</p>
<p>If a thread is deleted while a<b> Thread Information</b> window for it exists, the window</p>
<p>does not disappear; the window continues to show the contents of the thread control</p>
<p>block.</p>
<p>Each of the fields and buttons in the<b> Thread Information</b> window is described</p>
<p>next.</p>
<p><i>19</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Thread Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Displays the name of the thread, as given in the call to</p>
<p>tx_thread_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this field displays</p>
<p>(None)</p>
<p>. This field corresponds to the</p>
<p>tx_thread_name field of TX_THREAD.</p>
<p><b>Thread Name</b></p>
<p>Gives the name of the function in which the thread is currently</p>
<p>executing. If no debugging information is available for that location,</p>
<p>this field may be displayed as an offset from a known label or as an</p>
<p>address in hexadecimal format. This field is derived from one of the</p>
<p>following:</p>
<p>1.</p>
<p>The system program counter (PC), if the thread is currently</p>
<p>executing.</p>
<p>2.</p>
<p>A PC value as stored on the stack, if the thread is not currently</p>
<p>executing.</p>
<p>Clicking the<b> Current PC</b> button displays the current PC location.</p>
<p><b>Current PC</b></p>
<p>Identifies the current stack pointer of the thread, displayed as a</p>
<p>hexadecimal address. For threads that are not currently executing, this</p>
<p>field corresponds to the tx_thread_stack_ptr field of TX_THREAD.</p>
<p>For the currently executing thread, this field displays the processor's</p>
<p>stack pointer register. Clicking the<b> Current SP</b> button displays a</p>
<p>memory view of the thread's stack.</p>
<p><b>Current SP</b></p>
<p>Indicates the amount of stack currently in use by the thread. Two</p>
<p>numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The first number</p>
<p>indicates the amount of stack the thread has used and is derived from</p>
<p>the difference between the tx_thread_stack_end field in TX_THREAD</p>
<p>and the current thread stack pointer. The second number indicates the</p>
<p>total amount of stack space allocated to the thread and is derived from</p>
<p>the difference between the tx_thread_stack_end and</p>
<p>tx_thread_stack_start fields in TX_THREAD.</p>
<p><b>Stack Use</b></p>
<p>Displays the stack range as two hexadecimal addresses. This field is</p>
<p>derived from the tx_thread_stack_start and tx_thread_stack_end fields</p>
<p>in TX_THREAD.</p>
<p><b>Stack Extent</b></p>
<p>Gives information about the priority of the thread. The first number is</p>
<p>the priority level of the thread, which corresponds to the</p>
<p>tx_thread_priority field in TX_THREAD. The second number, in</p>
<p>parentheses, is the preemption threshold of the thread and corresponds</p>
<p>to the tx_thread_preempt_threshold field in TX_THREAD.</p>
<p><b>Priority (PT)</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>20</i></p>
<p><i>Chapter 2. Threads</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Displays the timer ticks remaining and the timer ticks given to the</p>
<p>thread. Two numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed.</p>
<p>The first number indicates the remaining timer ticks in the slice and</p>
<p>corresponds to the tx_thread_time_slice field of TX_THREAD. The</p>
<p>second number indicates how many timer ticks the thread will receive</p>
<p>when it is subsequently scheduled after it exhausts its current time slice.</p>
<p>This number is the time_slice parameter passed to tx_thread_create and</p>
<p>corresponds to the tx_thread_new_time_slice field of TX_THREAD.</p>
<p><b>Time Slice</b></p>
<p>Indicates the current execution state of the thread. This entry is derived</p>
<p>from the tx_thread_state field of TX_THREAD and by comparing the</p>
<p>global variable</p>
<p>_tx_thread_current_ptr</p>
<p>with the address of</p>
<p>TX_THREAD. The thread can be in one of five states:</p>
<p>â¢</p>
<p>Executing</p>
<p>â The thread is executing.</p>
<p>â¢</p>
<p>Ready</p>
<p>â The thread is ready and will execute when it is the</p>
<p>highest priority thread.</p>
<p>â¢</p>
<p>Suspended</p>
<p>â The thread cannot run because it is waiting. Threads</p>
<p>can wait for time, message queues, event flags, semaphores,</p>
<p>mutexes, and memory, or can be placed or created in a suspended</p>
<p>state.</p>
<p>â¢</p>
<p>Terminated</p>
<p>â The thread was terminated by a</p>
<p>tx_thread_terminate</p>
<p>call.</p>
<p>â¢</p>
<p>Completed</p>
<p>â The thread has returned from its entry function.</p>
<p><b>Execution State</b></p>
<p>Names the component type (</p>
<p>Queue</p>
<p>,</p>
<p>Semaphore</p>
<p>,</p>
<p>Mutex</p>
<p>,</p>
<p>Event Flags</p>
<p>Group</p>
<p>,</p>
<p>Block Pool</p>
<p>,</p>
<p>Byte Pool</p>
<p>,</p>
<p>Sleep</p>
<p>, or</p>
<p>Suspend Call</p>
<p>) on</p>
<p>which the thread is suspended. This field is derived from the</p>
<p>tx_thread_state field of TX_THREAD and shows</p>
<p>N/A</p>
<p>if the execution</p>
<p>state is anything other than</p>
<p>Suspended</p>
<p>.</p>
<p><b>Suspended on</b></p>
<p>Indicates the name of the component on which the thread is suspended,</p>
<p>as given when that component was created. If a</p>
<p>0</p>
<p>(null pointer) was</p>
<p>passed as the</p>
<p>name_ptr</p>
<p>argument, this field displays the address of</p>
<p>the control block. This field is derived from the appropriate name field</p>
<p>of the component pointed to by the tx_thread_suspend_control_block</p>
<p>field of TX_THREAD and shows</p>
<p>N/A</p>
<p>if the execution state is anything</p>
<p>other than</p>
<p>Suspended</p>
<p>. Clicking the<b> Name</b> button displays a view of</p>
<p>the component on which the thread is suspended.</p>
<p><b>Name</b></p>
<p><i>21</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Thread Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Indicates the number of ticks specified in whatever action caused the</p>
<p>suspend. After these ticks elapse, the thread will no longer be suspended.</p>
<p>If the suspension was caused by an attempt to access another kernel</p>
<p>component, a suitable error value will be returned from the service call.</p>
<p>This field shows</p>
<p>Forever</p>
<p>if</p>
<p>TX_WAIT_FOREVER</p>
<p>was specified as the</p>
<p>wait value in the service call that caused the thread to be suspended.</p>
<p>This field corresponds to the tx_timer_internal_remaining_ticks field</p>
<p>of the tx_thread_timer structure within TX_THREAD and shows</p>
<p>N/A</p>
<p>if the execution state is anything other than</p>
<p>Suspended</p>
<p>.</p>
<p><b>Timeout</b></p>
<p>Shows particular information about why a thread is suspended on a</p>
<p>queue, event flags group, or byte pool.</p>
<p>â¢</p>
<p>For a queue, this field displays</p>
<p>Receive</p>
<p>or</p>
<p>Send</p>
<p>.</p>
<p>â¢</p>
<p>For an event flags group, this field shows the particular flags being</p>
<p>requested, as well as TX_AND, TX_AND_CLEAR, TX_OR, or</p>
<p>TX_OR_CLEAR, as appropriate.</p>
<p>â¢</p>
<p>For byte pool allocation requests, this field shows the number of</p>
<p>bytes requested.</p>
<p>This field is derived from the tx_thread_suspend_option and</p>
<p>tx_thread_suspend_info fields of TX_THREAD, except in the case of</p>
<p>queues, when it is derived from the tx_queue_enqueued field of</p>
<p>TX_QUEUE. This field shows</p>
<p>N/A</p>
<p>if the thread is not suspended on a</p>
<p>queue, event flags group, or byte pool access.</p>
<p><b>Condition</b></p>
<p>Gives the name of the function called upon thread startup. If no</p>
<p>debugging information is available for that location, then this field may</p>
<p>be displayed as an offset from a known label or as an address in</p>
<p>hexadecimal format. This field corresponds to the</p>
<p>tx_thread_entry_function field of TX_THREAD. Clicking the<b> Entry</b></p>
<p><b>Point</b> button displays the entry point function.</p>
<p><b>Entry Point</b></p>
<p>Gives a count of how many times a thread has been scheduled. When</p>
<p>this field is increasing, the thread is being scheduled and run. A run</p>
<p>count that stays the same may indicate a thread that is unable to run for</p>
<p>some reason. This field corresponds to the tx_thread_run_count field</p>
<p>of TX_THREAD.</p>
<p><b>Run Count</b></p>
<p>Shows the address of the thread control block, which is a variable of</p>
<p>type TX_THREAD. See the ThreadX header file<b> tx_api.h</b> for the</p>
<p>definition of this type. Clicking the<b> Control Block</b> button opens a<b> Data</b></p>
<p><b>Explorer</b> window on the thread control block. The<b> Data Explorer</b></p>
<p>window displays useful information that is not included in the<b> Thread</b></p>
<p><b>Information</b> window (for more information, see the documentation</p>
<p>about the Data Explorer in the<i> MULTI: Debugging</i> book).</p>
<p><b>Control Block</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>22</i></p>
<p><i>Chapter 2. Threads</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Displays the<b> Stack Check Information</b> window, which shows the peak</p>
<p>stack usage of the thread. If stack checking is not enabled, this button</p>
<p>has no effect. See âChecking Thread Stack Usageâ on page 9 and</p>
<p>âThe Stack Check Information Windowâ on page 25 for more</p>
<p>information about stack checking.</p>
<p><b>Stack Check</b></p>
<p>Displays the<b> Thread List</b> window, which contains a list of all threads</p>
<p>in the system (see âThe Thread List Windowâ on page 14).</p>
<p><b>Thread List</b></p>
<p><b>The Current Thread Information Window</b></p>
<p>The<b> Current Thread Information</b> window includes the same fields and buttons</p>
<p>as the<b> Thread Information</b> window. The<b> Current Thread Information</b> window,</p>
<p>however, displays information corresponding to the currently executing thread</p>
<p>rather than a specifically selected thread. The information in this window is derived</p>
<p>from the</p>
<p>_tx_thread_current_ptr</p>
<p>global variable. See âThe Thread Information</p>
<p>Windowâ on page 19 for a description of the fields in the<b> Current Thread</b></p>
<p><b>Information</b> window.</p>
<p><i>23</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Current Thread Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Thread Stack Check List Window</b></p>
<p>The<b> Thread Stack Check List</b> window shows all threads in the system together</p>
<p>with their maximum stack usage, arranged in the order the threads were created.</p>
<p>To open this window, click<b> Stack Check List</b> in the<b> ThreadX Information</b> window.</p>
<p>The list is generated by following a linked list, starting with the thread pointed to</p>
<p>by the global variable</p>
<p>_tx_thread_created_ptr</p>
<p>and continuing with the</p>
<p>tx_thread_created_next field of each thread control block TX_THREAD. A total</p>
<p>of</p>
<p>_tx_thread_created_count</p>
<p>threads are shown.</p>
<p>This list is frozen immediately upon its creation because it causes code to be executed</p>
<p>on the target system, which may not always be desirable. For information about</p>
<p>refreshing this window, and all others, see âPerformance Issuesâ on page 10. See</p>
<p>âChecking Thread Stack Usageâ on page 9 for more information about using this</p>
<p>list.</p>
<p>From the<b> Thread Stack Check List</b> window, you can double-click any listed task</p>
<p>to display a<b> Thread Information</b> window (see âThe Thread Information Windowâ</p>
<p>on page 19).</p>
<p>The<b> Thread Stack Check List</b> has three columns:<b> Name</b>,<b> Peak Use</b>, and<b> Current</b></p>
<p><b>Use</b>. Each of these is described next.</p>
<p>Displays the name of the thread, as given in the call to</p>
<p>tx_thread_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry displays the address of the thread</p>
<p>control block TX_THREAD. This field corresponds to the</p>
<p>tx_thread_name field of TX_THREAD.</p>
<p><b>Name</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>24</i></p>
<p><i>Chapter 2. Threads</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Indicates the maximum amount of stack ever used by a thread.</p>
<p>Two numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The</p>
<p>first number indicates the amount of stack the thread has used. The</p>
<p>second number indicates the total amount of stack space allocated</p>
<p>to the thread. This value is determined by examining the stack and</p>
<p>finding the highest point on the stack that was changed from its</p>
<p>original value of</p>
<p>0xef</p>
<p>.</p>
<p><b>Peak Use</b></p>
<p>Gives the amount of stack currently in use by the thread. Two</p>
<p>numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The first</p>
<p>number indicates the amount of stack the thread has used, and the</p>
<p>second number indicates the total amount of stack space allocated</p>
<p>to the thread.</p>
<p><b>Current Use</b></p>
<p><b>The Stack Check Information Window</b></p>
<p>The<b> Stack Check Information</b> window shows the maximum stack usage of a</p>
<p>thread.</p>
<p>To open this window, click the<b> Stack Check</b> button in the<b> Thread Information</b></p>
<p>window. The<b> Stack Check Information</b> window is frozen immediately upon its</p>
<p>creation because it causes code to be executed on the target system, which may not</p>
<p>always be desirable. For information about refreshing this window, and all others,</p>
<p>see âPerformance Issuesâ on page 10. See âChecking Thread Stack Usageâ</p>
<p>on page 9 for more information about stack checking.</p>
<p>If a thread is deleted while a<b> Stack Check Information</b> window for that thread</p>
<p>exists, the window does not automatically disappear; the window continues to</p>
<p>display stack check information.</p>
<p>The two fields of the<b> Stack Check Information</b> window are described below.</p>
<p>Gives the name of thread, as given in the call to tx_thread_create. If</p>
<p>a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry</p>
<p>displays the address of the thread control block TX_THREAD. This</p>
<p>field corresponds to the tx_thread_name field of TX_THREAD.</p>
<p><b>Thread Name</b></p>
<p><i>25</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Stack Check Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Indicates the maximum amount of stack ever used by the thread. This</p>
<p>is determined by examining the stack and finding the highest point</p>
<p>on the stack that was changed from its original value of</p>
<p>0xef</p>
<p>. Two</p>
<p>numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The first</p>
<p>number indicates the amount of stack the thread has used, and the</p>
<p>second number indicates the total amount of stack space allocated to</p>
<p>the thread.</p>
<p><b>Peak Stack Use</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>26</i></p>
<p><i>Chapter 2. Threads</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 3</b></p>
<p><b>Message Queues</b></p>
<p><b>Contents</b></p>
<p>The Queue List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>28</p>
<p>The Queue Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>29</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes windows that display detailed information about the message</p>
<p>queues in your application.</p>
<p><b>The Queue List Window</b></p>
<p>The<b> Queue List</b> window shows a list of all message queues in the system, arranged</p>
<p>in the order in which they were created. To display this window, click the<b> Message</b></p>
<p><b>Queues</b> button in the<b> ThreadX Information</b> window.</p>
<p>The information in the list is generated by following a linked list, starting with the</p>
<p>message queue pointed to by the global variable</p>
<p>_tx_queue_created_ptr</p>
<p>and</p>
<p>continuing with the tx_queue_created_next field of each queue control block</p>
<p>TX_QUEUE. A total of</p>
<p>_tx_queue_created_count</p>
<p>message queues are shown.</p>
<p>When a queue is deleted, it is removed from this list.</p>
<p>You can double-click any message queue in the<b> Queue List</b> window to display a</p>
<p><b>Queue Information</b> window (see âThe Queue Information Windowâ on page 29).</p>
<p>The<b> Queue List</b> window has four columns:<b> Name</b>,<b> Msg Size</b>,<b> Full</b>, and<b> Suspended</b>.</p>
<p>Each of these is described below.</p>
<p>Displays the name of the queue, as given in the call to tx_queue_create.</p>
<p>If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry</p>
<p>displays the address of the queue control block TX_QUEUE. This</p>
<p>entry corresponds to the tx_queue_name field of TX_QUEUE.</p>
<p><b>Name</b></p>
<p>Indicates the size of each message in the queue. Message sizes range</p>
<p>from one to sixteen 32-bit words (ULONGs). Valid message sizes are</p>
<p>1, 2, 4, 8, and 16 words. This entry corresponds to the</p>
<p>tx_queue_message_size field of TX_QUEUE.</p>
<p><b>Msg Size</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>28</i></p>
<p><i>Chapter 3. Message Queues</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Shows the number of messages currently stored in the queue awaiting</p>
<p>a call to</p>
<p>tx_queue_receive</p>
<p>. Two numbers separated by a forward</p>
<p>slash (</p>
<p>/</p>
<p>) are displayed. The first number indicates the number of</p>
<p>messages currently stored in the queue, and the second number</p>
<p>indicates the total number of messages. These numbers are derived</p>
<p>from the tx_queue_enqueued and tx_queue_available_storage fields</p>
<p>of TX_QUEUE.</p>
<p><b>Full</b></p>
<p>Shows the number of threads currently suspended on attempted</p>
<p>accesses to the message queue, or displays</p>
<p>None</p>
<p>if no threads are</p>
<p>suspended. This field corresponds to the tx_queue_suspended_count</p>
<p>field of TX_QUEUE.</p>
<p><b>Suspended</b></p>
<p><b>The Queue Information Window</b></p>
<p>The<b> Queue Information</b> window shows detailed information about an individual</p>
<p>message queue.</p>
<p>To display this window, double-click any queue in the<b> Queue List</b> window, or view</p>
<p>a variable of type TX_QUEUE in the MULTI Debugger window. The information</p>
<p>in the<b> Queue Information</b> window is derived from various fields within the queue</p>
<p>control block TX_QUEUE.</p>
<p><i>29</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Queue Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>If a message queue is deleted while a<b> Queue Information</b> window for it exists, the</p>
<p>window does not automatically disappear; the window continues to show the contents</p>
<p>of the queue control block.</p>
<p>Each of the fields and buttons in the<b> Queue Information</b> window is described</p>
<p>below.</p>
<p>Displays the name of the queue, as given in the call to</p>
<p>tx_queue_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this field displays</p>
<p>(None)</p>
<p>. This field</p>
<p>corresponds to the tx_queue_name field of TX_QUEUE.</p>
<p><b>Queue Name</b></p>
<p>Indicates the size of each message in the queue. Message sizes range</p>
<p>from one to sixteen 32-bit words (ULONGs). Valid message sizes</p>
<p>are 1, 2, 4, 8, and 16 words. This field corresponds to the</p>
<p>tx_queue_message_size field of TX_QUEUE.</p>
<p><b>Message Size</b></p>
<p>Shows the number of messages currently stored in the queue awaiting</p>
<p>a call to</p>
<p>tx_queue_receive</p>
<p>. Two numbers separated by a forward</p>
<p>slash (</p>
<p>/</p>
<p>) are displayed. The first number indicates the number of</p>
<p>messages currently stored in the queue, and the second number</p>
<p>indicates the total number of messages. The number of available</p>
<p>messages (the total number of messages minus the number of</p>
<p>messages stored in the queue) is also shown after this pair of</p>
<p>numbers. All of these numbers are derived from the</p>
<p>tx_queue_enqueued and tx_queue_available_storage fields of</p>
<p>TX_QUEUE.</p>
<p><b>Filled</b></p>
<p>Gives the address of the next message that will be read with</p>
<p>tx_queue_receive. This field corresponds to the tx_queue_read field</p>
<p>of TX_QUEUE.</p>
<p><b>Read</b></p>
<p>Gives the address where the next message sent with tx_queue_send</p>
<p>will be stored. This field corresponds to the tx_queue_write field of</p>
<p>TX_QUEUE.</p>
<p><b>Write</b></p>
<p>Gives the address of the beginning of the message queue storage</p>
<p>area. This field corresponds to the tx_queue_start field of</p>
<p>TX_QUEUE.</p>
<p><b>Start</b></p>
<p>Gives the address of the end of the message queue storage area. This</p>
<p>field corresponds to the tx_queue_end field of TX_QUEUE.</p>
<p><b>Queue End</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>30</i></p>
<p><i>Chapter 3. Message Queues</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Displays the address of the queue control block, which is a variable</p>
<p>of type TX_QUEUE. See the ThreadX header file<b> tx_api.h</b> for the</p>
<p>definition of this type. Clicking the<b> Control Block</b> button opens a</p>
<p><b>Data Explorer</b> window on the queue control block. The<b> Data</b></p>
<p><b>Explorer</b> window displays useful information that is not included</p>
<p>in the<b> Queue Information</b> window (for more information, see the</p>
<p>documentation about the Data Explorer in the<i> MULTI: Debugging</i></p>
<p>book).</p>
<p><b>Control Block</b></p>
<p>Indicates the number of threads currently suspended on an attempt</p>
<p>to access the queue. This field corresponds to the</p>
<p>tx_queue_suspended_count field of TX_QUEUE. If the queue is</p>
<p>empty, the threads listed are suspended on calls to tx_queue_receive.</p>
<p>If the queue is full, the threads listed are suspended on calls to</p>
<p>tx_queue_send.</p>
<p><b>Suspended Threads</b></p>
<p>Gives information about any threads currently suspended on an</p>
<p>attempt to access the queue. Each column in the list is described</p>
<p>below.</p>
<p>Double-click any listed thread to display a<b> Thread Information</b></p>
<p>window for that thread (see âThe Thread Information Windowâ</p>
<p>on page 19).</p>
<p>â¢</p>
<p><b>Name</b> â Gives the name of the thread. If a</p>
<p>0</p>
<p>(null pointer) was</p>
<p>passed as the</p>
<p>name_ptr</p>
<p>argument to tx_thread_create, this</p>
<p>entry displays the address of its thread control block.</p>
<p>â¢</p>
<p><b>Timeout</b> â Indicates the number of timer ticks before the</p>
<p>thread will abort the attempted queue access with a return value</p>
<p>of</p>
<p>TX_QUEUE_EMPTY</p>
<p>or</p>
<p>TX_QUEUE_FULL</p>
<p>. This entry shows</p>
<p>Forever</p>
<p>if</p>
<p>TX_WAIT_FOREVER</p>
<p>was passed as the<b> wait_option</b></p>
<p>to tx_queue_receive or tx_queue_send.</p>
<p>â¢</p>
<p><b>Stack Use</b> â Shows the amount of stack currently in use by</p>
<p>the thread.</p>
<p><b>Suspended Threads</b></p>
<p><b>List</b></p>
<p>Displays the<b> Queue List</b> window, which contains a list of all message</p>
<p>queues in the system (see âThe Queue List Windowâ on page 28).</p>
<p><b>Queue List</b></p>
<p><i>31</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Queue Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 4</b></p>
<p><b>Semaphores</b></p>
<p><b>Contents</b></p>
<p>The Semaphore List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>34</p>
<p>The Semaphore Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>35</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes windows that display detailed information about the</p>
<p>semaphores in your application.</p>
<p><b>The Semaphore List Window</b></p>
<p>The<b> Semaphore List</b> window shows a list of all semaphores in the system, arranged</p>
<p>in the order in which they were created. To display this window, click the</p>
<p><b>Semaphores</b> button in the<b> ThreadX Information</b> window.</p>
<p>The list is generated by following a linked list, starting with the semaphore pointed</p>
<p>to by the global variable</p>
<p>_tx_semaphore_created_ptr</p>
<p>and continuing with the</p>
<p>tx_semaphore_created_next field of each semaphore control block</p>
<p>TX_SEMAPHORE. A total of</p>
<p>_tx_semaphore_created_count</p>
<p>semaphores</p>
<p>are shown.</p>
<p>When a semaphore is deleted, it disappears from this list.</p>
<p>You can double-click any semaphore in the<b> Semaphore List</b> window to display a</p>
<p><b>Semaphore Information</b> window (see âThe Semaphore Information Windowâ</p>
<p>on page 35).</p>
<p>The<b> Semaphore List</b> has three columns:<b> Name</b>,<b> Count</b>, and<b> Suspended</b>. Each of</p>
<p>these is described next.</p>
<p>Displays the name of the semaphore, as given in the call to</p>
<p>tx_semaphore_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry displays the address of the semaphore</p>
<p>control block TX_SEMAPHORE. This entry corresponds to the</p>
<p>tx_semaphore_name field of TX_SEMAPHORE.</p>
<p><b>Name</b></p>
<p>Gives the count of the semaphore. Semaphore counts range from</p>
<p>0</p>
<p>to</p>
<p>0xffffffff</p>
<p>. This entry corresponds to the tx_semaphore_count field</p>
<p>of TX_SEMAPHORE.</p>
<p><b>Count</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>34</i></p>
<p><i>Chapter 4. Semaphores</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Indicates the number of threads currently suspended on an attempt to</p>
<p>get the semaphore with a call to</p>
<p>tx_semaphore_get</p>
<p>, or displays</p>
<p>None</p>
<p>if no threads are suspended. This entry corresponds to the</p>
<p>tx_semaphore_suspended_count field of TX_SEMAPHORE.</p>
<p><b>Suspended</b></p>
<p><b>The Semaphore Information Window</b></p>
<p>The<b> Semaphore Information</b> window shows detailed information about an</p>
<p>individual semaphore.</p>
<p>To display this window, double-click a semaphore in the<b> Semaphore List</b> window,</p>
<p>or view a variable of type TX_SEMAPHORE in the MULTI Debugger window.</p>
<p>The information in the<b> Semaphore Information</b> window is derived from various</p>
<p>fields within the semaphore control block TX_SEMAPHORE.</p>
<p>If a semaphore is deleted while a<b> Semaphore Information</b> window for it exists,</p>
<p>the window does not automatically disappear; the window continues to show the</p>
<p>contents of the semaphore control block.</p>
<p>Each field and button of the<b> Semaphore Information</b> window is described below.</p>
<p>Displays the name of the semaphore, as given in the call to</p>
<p>tx_semaphore_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as</p>
<p>the</p>
<p>name_ptr</p>
<p>argument, this field displays</p>
<p>(None)</p>
<p>. This field</p>
<p>corresponds to the tx_semaphore_name field of</p>
<p>TX_SEMAPHORE.</p>
<p><b>Semaphore Name</b></p>
<p><i>35</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Semaphore Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives the count of the semaphore. Semaphore counts range</p>
<p>from</p>
<p>0</p>
<p>to</p>
<p>0xffffffff</p>
<p>. This field corresponds to the</p>
<p>tx_semaphore_count field of TX_SEMAPHORE.</p>
<p><b>Semaphore Count</b></p>
<p>Displays the address of the semaphore control block, which is</p>
<p>a variable of type TX_SEMAPHORE. See the ThreadX header</p>
<p>file<b> tx_api.h</b> for the definition of this type. Clicking the<b> Control</b></p>
<p><b>Block</b> button opens a<b> Data Explorer</b> window on the semaphore</p>
<p>control block. The<b> Data Explorer</b> window displays useful</p>
<p>information that is not included in the<b> Semaphore Information</b></p>
<p>window (for more information, see the documentation about</p>
<p>the Data Explorer in the<i> MULTI: Debugging</i> book).</p>
<p><b>Control Block</b></p>
<p>Indicates the number of threads currently suspended on an</p>
<p>attempt to get the semaphore with a call to</p>
<p>tx_semaphore_get</p>
<p>. This field corresponds to the</p>
<p>tx_semaphore_suspended_count field of TX_SEMAPHORE.</p>
<p><b>Suspended Threads</b></p>
<p>Gives information regarding threads that are currently suspended</p>
<p>on an attempt to get the semaphore. Each column in the list is</p>
<p>described below. Double-click any listed thread to display a</p>
<p><b>Thread Information</b> window (see âThe Thread Information</p>
<p>Windowâ on page 19).</p>
<p>â¢</p>
<p><b>Name</b> â Gives the name of the thread. If a</p>
<p>0</p>
<p>(null pointer)</p>
<p>was passed as the</p>
<p>name_ptr</p>
<p>argument to</p>
<p>tx_thread_create</p>
<p>, this entry displays the address of</p>
<p>the thread control block.</p>
<p>â¢</p>
<p><b>Timeout</b> â Indicates the number of timer ticks before the</p>
<p>thread will abort the attempted semaphore get. This entry</p>
<p>shows</p>
<p>Forever</p>
<p>if</p>
<p>TX_WAIT_FOREVER</p>
<p>was passed as the</p>
<p><b>wait_option</b> to</p>
<p>tx_semaphore_get</p>
<p>.</p>
<p>â¢</p>
<p><b>Stack Use</b> â Shows the amount of stack currently in use</p>
<p>by the thread.</p>
<p><b>Suspended Threads List</b></p>
<p>Displays the<b> Semaphore List</b> window, which contains a list of</p>
<p>all semaphores in the system (see âThe Semaphore List</p>
<p>Windowâ on page 34).</p>
<p><b>Semaphore List</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>36</i></p>
<p><i>Chapter 4. Semaphores</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 5</b></p>
<p><b>Mutexes</b></p>
<p><b>Contents</b></p>
<p>The Mutex List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>38</p>
<p>The Mutex Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>39</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes windows that display detailed information about the mutexes</p>
<p>in your application.</p>
<p><b>The Mutex List Window</b></p>
<p>The<b> Mutex List</b> window shows a list of all mutexes in the system, arranged in the</p>
<p>order in which they were created. To display this window, click the<b> Mutexes</b> button</p>
<p>in the<b> ThreadX Information</b> window.</p>
<p>The<b> Mutex List</b> is generated by following a linked list, starting with the mutex</p>
<p>pointed to by the global variable</p>
<p>_tx_mutex_created_ptr</p>
<p>and continuing with</p>
<p>the tx_mutex_created_next field of each mutex control block TX_MUTEX. A total</p>
<p>of</p>
<p>_tx_mutex_created_count</p>
<p>mutexes are shown.</p>
<p>When a mutex is deleted, it is removed from this list.</p>
<p>You can double-click any mutex in the<b> Mutex List</b> window to display a<b> Mutex</b></p>
<p><b>Information</b> window (see âThe Mutex Information Windowâ on page 39).</p>
<p>The<b> Mutex List</b> has four columns:<b> Name</b>,<b> Owner</b>,<b> Count</b>, and<b> Suspended</b>. Each</p>
<p>of these is described next.</p>
<p>Displays the name of the mutex, as given in the call to tx_mutex_create.</p>
<p>If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry</p>
<p>displays the address of the mutex control block TX_MUTEX. This</p>
<p>entry corresponds to the tx_mutex_name field of TX_MUTEX.</p>
<p><b>Name</b></p>
<p>Gives the name of the thread that currently owns the mutex, or displays</p>
<p>(None)</p>
<p>if the ownership count is zero. If a</p>
<p>0</p>
<p>(null pointer) was passed</p>
<p>as the</p>
<p>name_ptr</p>
<p>argument to tx_thread_create when the owner thread</p>
<p>was created, this entry displays the address of the thread control block.</p>
<p>This entry is derived from the tx_mutex_owner field of TX_MUTEX.</p>
<p><b>Owner</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>38</i></p>
<p><i>Chapter 5. Mutexes</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives the mutex ownership count. This entry corresponds to the</p>
<p>tx_mutex_ownership_count field of TX_MUTEX.</p>
<p><b>Count</b></p>
<p>Indicates the number of threads currently suspended on attempts to</p>
<p>get the mutex, or displays</p>
<p>None</p>
<p>if no threads are suspended. This field</p>
<p>corresponds to the tx_mutex_suspended_count field of TX_MUTEX.</p>
<p><b>Suspended</b></p>
<p><b>The Mutex Information Window</b></p>
<p>The<b> Mutex Information</b> window shows detailed information about an individual</p>
<p>mutex.</p>
<p>To display this window, double-click a mutex in the<b> Mutex List</b> window, or view</p>
<p>a variable of type TX_MUTEX in the MULTI Debugger window. The information</p>
<p>in this window is derived from various fields within the mutex control block</p>
<p>TX_MUTEX.</p>
<p>If a mutex is deleted while a<b> Mutex Information</b> window for it exists, the window</p>
<p>does not automatically disappear; the window continues to show the contents of</p>
<p>the mutex control block.</p>
<p>Each of the fields and buttons in the<b> Mutex Information</b> window is described</p>
<p>below.</p>
<p><i>39</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Mutex Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Displays the name of the mutex, as given in the call to</p>
<p>tx_mutex_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this field displays</p>
<p>(None)</p>
<p>. This field corresponds to the</p>
<p>tx_mutex_name field of TX_MUTEX.</p>
<p><b>Mutex Name</b></p>
<p>Gives the name of the thread that currently owns the mutex, or</p>
<p>displays</p>
<p>(None)</p>
<p>if the ownership count is zero. If a</p>
<p>0</p>
<p>(null pointer)</p>
<p>was passed as the</p>
<p>name_ptr</p>
<p>argument to tx_thread_create when the</p>
<p>owner thread was created, this field displays the address of the thread</p>
<p>control block. This field is derived from the tx_mutex_owner field</p>
<p>of TX_MUTEX.</p>
<p><b>Owner</b></p>
<p>Indicates the number of times the thread owner has called</p>
<p>tx_mutex_get</p>
<p>without a corresponding</p>
<p>tx_mutex_put</p>
<p>. If the</p>
<p>ownership count is zero, no thread owns the mutex. This field</p>
<p>corresponds to the tx_mutex_ownership_count field of TX_MUTEX.</p>
<p><b>Ownership Count</b></p>
<p>Indicates whether the mutex supports priority inheritance. This field</p>
<p>corresponds to the tx_mutex_inherit field of TX_MUTEX.</p>
<p><b>Priority Inheritance</b></p>
<p>Gives the original priority information (before any priority inheritance</p>
<p>occurred) of the owner thread. Two numbers are displayed. The first</p>
<p>number is the original priority level of the thread, which corresponds</p>
<p>to the tx_mutex_original_priority field of TX_MUTEX. The second</p>
<p>number, in parentheses, is the original preemption threshold of the</p>
<p>thread and corresponds to the tx_mutex_original_threshold field of</p>
<p>TX_MUTEX.</p>
<p><b>Original Priority (PT)</b></p>
<p>Displays the address of the mutex control block, which is a variable</p>
<p>of type TX_MUTEX. See the ThreadX header file<b> tx_api.h</b> for the</p>
<p>definition of this type. Clicking the<b> Control Block</b> button opens a</p>
<p><b>Data Explorer</b> window on the mutex control block. The<b> Data</b></p>
<p><b>Explorer</b> window displays useful information that is not included in</p>
<p>the<b> Mutex Information</b> window (for more information, see the</p>
<p>documentation about the Data Explorer in the<i> MULTI: Debugging</i></p>
<p>book).</p>
<p><b>Control Block</b></p>
<p>Indicates the number of threads currently suspended on calls to</p>
<p>tx_mutex_get</p>
<p>. This field corresponds to the</p>
<p>tx_mutex_suspended_count field of TX_MUTEX.</p>
<p><b>Suspended Threads</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>40</i></p>
<p><i>Chapter 5. Mutexes</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives information about threads that are currently suspended on an</p>
<p>attempt to acquire the mutex with</p>
<p>tx_mutex_get</p>
<p>. Each column in</p>
<p>the list is described below. Double-click any listed thread to display</p>
<p>a<b> Thread Information</b> window (see âThe Thread Information</p>
<p>Windowâ on page 19).</p>
<p>â¢</p>
<p><b>Name</b> â Gives the name of the thread. If a</p>
<p>0</p>
<p>(null pointer) was</p>
<p>passed as the</p>
<p>name_ptr</p>
<p>argument to tx_thread_create, this entry</p>
<p>displays the address of the thread control block.</p>
<p>â¢</p>
<p><b>Timeout</b> â Indicates the number of timer ticks before the thread</p>
<p>will abort the attempted mutex access with a return value of</p>
<p>TX_NOT_AVAILABLE</p>
<p>. This entry shows</p>
<p>Forever</p>
<p>if</p>
<p>TX_WAIT_FOREVER</p>
<p>was passed as the<b> wait_option</b> to</p>
<p>tx_mutex_receive or tx_mutex_send.</p>
<p>â¢</p>
<p><b>Stack Use</b> â Shows the amount of stack currently in use by the</p>
<p>thread.</p>
<p><b>Suspended Threads</b></p>
<p><b>List</b></p>
<p>Displays the<b> Mutex List</b> window, which contains a list of all mutexes</p>
<p>in the system (see âThe Mutex List Windowâ on page 38).</p>
<p><b>Mutex List</b></p>
<p><i>41</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Mutex Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 6</b></p>
<p><b>Event Flags Groups</b></p>
<p><b>Contents</b></p>
<p>The Event Flags List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>44</p>
<p>The Event Flags Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>45</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes windows that display detailed information about the event</p>
<p>flags in your application.</p>
<p><b>The Event Flags List Window</b></p>
<p>The<b> Event Flags List</b> window shows a list of all event flags groups in the system,</p>
<p>arranged in the order in which they were created. To display this window, click the</p>
<p><b>Event Flag Groups</b> button in the<b> ThreadX Information</b> window.</p>
<p>The<b> Event Flags List</b> is generated by following a linked list, starting with the event</p>
<p>flags group pointed to by the global variable</p>
<p>_tx_event_flags_created_ptr</p>
<p>and continuing with the tx_event_flags_group_created_next field of each event</p>
<p>flags group control block TX_EVENT_FLAGS_GROUP. A total of</p>
<p>_tx_event_flags_created_count</p>
<p>event flags groups are shown.</p>
<p>When an event flags group is deleted, it is removed from this list.</p>
<p>You can double-click any event flags group in the<b> Event Flags List</b> to display an</p>
<p><b>Event Flags Information</b> window (see âThe Event Flags Information Windowâ</p>
<p>on page 45).</p>
<p>The<b> Event Flags List</b> has three columns:<b> Name</b>,<b> Flags</b>, and<b> Suspended</b>. Each of</p>
<p>these is described next.</p>
<p>Displays the name of the event flags group, as given in the call to</p>
<p>tx_event_flags_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry displays the address of the event flags</p>
<p>group control block TX_EVENT_FLAGS_GROUP. This entry</p>
<p>corresponds to the tx_event_flags_group_name field of</p>
<p>TX_EVENT_FLAGS_GROUP.</p>
<p><b>Name</b></p>
<p>Gives the status of the current event flags in hexadecimal format. Each</p>
<p>event flags group contains 32 binary event flags. This entry corresponds</p>
<p>to the tx_event_flags_group_current field of</p>
<p>TX_EVENT_FLAGS_GROUP.</p>
<p><b>Flags</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>44</i></p>
<p><i>Chapter 6. Event Flags Groups</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Indicates the number of threads currently suspended while waiting for</p>
<p>event flags to satisfy conditions specified in a call to</p>
<p>tx_event_flags_get</p>
<p>, or displays</p>
<p>None</p>
<p>if no threads are suspended.</p>
<p>This entry corresponds to the tx_event_flags_group_suspended_count</p>
<p>field of TX_EVENT_FLAGS_GROUP.</p>
<p><b>Suspended</b></p>
<p><b>The Event Flags Information Window</b></p>
<p>The<b> Event Flags Information</b> window shows detailed information about an</p>
<p>individual event flags group.</p>
<p>To display this window, double-click an event flags group in the<b> Event Flags List</b>,</p>
<p>or view a variable of type TX_EVENT_FLAGS_GROUP in the MULTI Debugger</p>
<p>window. The information in this window is derived from various fields within the</p>
<p>event flags group control block TX_EVENT_FLAGS_GROUP.</p>
<p>If an event flags group is deleted while an<b> Event Flags Information</b> window for</p>
<p>it exists, the window does not automatically disappear; the window continues to</p>
<p>show the contents of the event flags group control block.</p>
<p>The information provided in the<b> Event Flags Information</b> window is described</p>
<p>below.</p>
<p>Displays the name of the event flags group, as given in the call to</p>
<p>tx_event_flags_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this field displays</p>
<p>(None)</p>
<p>. This field</p>
<p>corresponds to the tx_event_flags_group_name field of</p>
<p>TX_EVENT_FLAGS_GROUP.</p>
<p><b>Event Flags Name</b></p>
<p><i>45</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Event Flags Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Indicates the status of the current event flags in hexadecimal format.</p>
<p>Each event flags group contains 32 binary event flags. This field</p>
<p>corresponds to the tx_event_flags_group_current field of</p>
<p>TX_EVENT_FLAGS_GROUP.</p>
<p><b>Current Event Flags</b></p>
<p>Displays the address of the event flags group control block, which is</p>
<p>a variable of type TX_EVENT_FLAGS_GROUP. See the ThreadX</p>
<p>header file<b> tx_api.h</b> for the definition of this type. Clicking the</p>
<p><b>Control Block</b> button opens a<b> Data Explorer</b> window on the event</p>
<p>flags group control block. The<b> Data Explorer</b> window displays useful</p>
<p>information that is not included in the<b> Event Flags Information</b></p>
<p>window (for more information, see the documentation about the Data</p>
<p>Explorer in the<i> MULTI: Debugging</i> book).</p>
<p><b>Control Block</b></p>
<p>Indicates the number of threads currently suspended while waiting</p>
<p>for event flags to satisfy conditions specified in a call to</p>
<p>tx_event_flags_get</p>
<p>. This field corresponds to the</p>
<p>tx_event_flags_group_suspended_count field of</p>
<p>TX_EVENT_FLAGS_GROUP.</p>
<p><b>Suspended Threads</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>46</i></p>
<p><i>Chapter 6. Event Flags Groups</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives information about threads that are currently suspended while</p>
<p>waiting for event flags to satisfy conditions specified in a call to</p>
<p>tx_event_flags_get</p>
<p>. Each column in the list is described below.</p>
<p>Double-click any listed thread to display a<b> Thread Information</b></p>
<p>window (see âThe Thread Information Windowâ on page 19).</p>
<p>â¢</p>
<p><b>Name</b> â Gives the name of the thread. If a</p>
<p>0</p>
<p>(null pointer) was</p>
<p>passed as the</p>
<p>name_ptr</p>
<p>argument to tx_thread_create, this entry</p>
<p>displays the address of the thread control block.</p>
<p>â¢</p>
<p><b>Flags Selected</b> â Identifies the event flags that will satisfy the</p>
<p>waiting thread's conditions. Two values are displayed. The first</p>
<p>value, given in hexadecimal format, shows the flags that the</p>
<p>thread requested. The second value contains one or two</p>
<p>characters that show whether the thread is waiting for all or any</p>
<p>of the event flags and whether the event flags will be cleared</p>
<p>once the thread's requested event flags are satisfied. The first of</p>
<p>these characters can be an</p>
<p>&amp;</p>
<p>or</p>
<p>|</p>
<p>character, where</p>
<p>&amp;</p>
<p>means that</p>
<p>the thread is waiting for all of its requested event flags and</p>
<p>|</p>
<p>means that the thread will be satisfied by any one of its event</p>
<p>flags being set. The second character is a</p>
<p>C</p>
<p>if the event flags</p>
<p>specified by the thread will be cleared (set to zero) after they</p>
<p>satisfy a thread's request. Otherwise, the second character is</p>
<p>blank.</p>
<p>â¢</p>
<p><b>Timeout</b> â Indicates the number of timer ticks before the thread</p>
<p>will abort waiting for the event flags group to satisfy the thread's</p>
<p>specified conditions. This entry shows</p>
<p>Forever</p>
<p>if</p>
<p>TX_WAIT_FOREVER</p>
<p>was passed as the<b> wait_option</b> to</p>
<p>tx_event_flags_get.</p>
<p>â¢</p>
<p><b>Stack Use</b> â Shows the amount of stack currently in use by the</p>
<p>thread.</p>
<p><b>Suspended Threads</b></p>
<p><b>List</b></p>
<p>Displays the<b> Event Flags List</b> window, which contains a list of all</p>
<p>event flags groups in the system (see âThe Event Flags List Windowâ</p>
<p>on page 44).</p>
<p><b>Event Flags List</b></p>
<p><i>47</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Event Flags Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 7</b></p>
<p><b>Memory Block Pools</b></p>
<p><b>Contents</b></p>
<p>The Block Pool List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>50</p>
<p>The Block Pool Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>52</p>
<p>The Block Pool Contents Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>55</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes windows that display detailed information about the memory</p>
<p>block pools in your application.</p>
<p><b>The Block Pool List Window</b></p>
<p>The<b> Block Pool List</b> window shows a list of all memory block pools in the system,</p>
<p>arranged in the order in which they were created. To display this window, click the</p>
<p><b>Block Pools</b> button in the<b> ThreadX Information</b> window.</p>
<p>The<b> Block Pools List</b> is generated by following a linked list, starting with the</p>
<p>memory block pool pointed to by the global variable</p>
<p>_tx_block_pool_created_ptr</p>
<p>and continuing with the</p>
<p>tx_block_pool_created_next field of each memory block pool control block</p>
<p>TX_BLOCK_POOL. A total of</p>
<p>_tx_block_pool_created_count</p>
<p>pools are</p>
<p>shown.</p>
<p>When a memory block pool is deleted, it is removed from this list.</p>
<p>You can double-click any memory block pool in the<b> Block Pool List</b> window to</p>
<p>display a<b> Block Pool Information</b> window (see âThe Block Pool Information</p>
<p>Windowâ on page 52).</p>
<p>The<b> Block Pool List</b> has four columns:<b> Name</b>,<b> Block Size</b>,<b> Full</b>, and<b> Suspended</b>.</p>
<p>Each of these is described next.</p>
<p>Displays the name of the memory block pool, as given in the call to</p>
<p>tx_block_pool_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry displays the address of the memory</p>
<p>block pool control block TX_BLOCK_POOL. This entry corresponds</p>
<p>to the tx_block_pool_name field of TX_BLOCK_POOL.</p>
<p><b>Name</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>50</i></p>
<p><i>Chapter 7. Memory Block Pools</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives the size, in bytes, of each memory block in the pool. Block</p>
<p>sizes displayed here are rounded up by the ThreadX kernel to an</p>
<p>even multiple of 4 bytes in order to allow suitable alignment for the</p>
<p>one pointer of overhead. This entry corresponds to the</p>
<p>tx_block_pool_block_size field of TX_BLOCK_POOL.</p>
<p><b>Block Size</b></p>
<p>Indicates the number of memory blocks currently allocated. Two</p>
<p>numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The first</p>
<p>number indicates the number of blocks currently allocated, and the</p>
<p>second number indicates the total number of memory blocks. This</p>
<p>entry is derived from the tx_block_pool_available and</p>
<p>tx_block_pool_total fields of TX_BLOCK_POOL.</p>
<p><b>Full</b></p>
<p>Indicates the number of threads currently suspended on an attempt</p>
<p>to allocate a block with a call to</p>
<p>tx_block_allocate</p>
<p>, or displays</p>
<p>None</p>
<p>if no threads are suspended. This entry corresponds to the</p>
<p>tx_block_pool_suspended_count field of TX_BLOCK_POOL.</p>
<p><b>Suspended</b></p>
<p><i>51</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Block Pool List Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Block Pool Information Window</b></p>
<p>The<b> Block Pool Information</b> window shows detailed information about an</p>
<p>individual memory block pool.</p>
<p>To display this window, double-click a memory block pool in the<b> Block Pool List</b></p>
<p>window, or view a variable of type TX_BLOCK_POOL in the MULTI Debugger</p>
<p>window. The information in the<b> Block Pool Information</b> window is derived from</p>
<p>various fields within the memory block pool control block TX_BLOCK_POOL.</p>
<p>If a memory block pool is deleted while a<b> Block Pool Information</b> window for it</p>
<p>exists, the window does not automatically disappear; the window continues to show</p>
<p>the contents of the memory block pool control block.</p>
<p>To view detailed information about the memory blocks in a pool, click the<b> In Use</b></p>
<p>button to display the<b> Block Pool Contents</b> window (see âThe Block Pool Contents</p>
<p>Windowâ on page 55).</p>
<p>The fields and buttons in the<b> Block Pool Information</b> window are described next.</p>
<p>Displays the name of the memory block pool, as given in the call to</p>
<p>tx_block_pool_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this field displays</p>
<p>(None)</p>
<p>. This field</p>
<p>corresponds to the tx_block_pool_name field of TX_BLOCK_POOL.</p>
<p><b>Block Pool Name</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>52</i></p>
<p><i>Chapter 7. Memory Block Pools</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives the size, in bytes, of each memory block in the pool. Block</p>
<p>sizes displayed here are rounded up by the ThreadX kernel to an even</p>
<p>multiple of 4 bytes to allow suitable alignment for the one pointer of</p>
<p>overhead. This field corresponds to the tx_block_pool_block_size</p>
<p>field of TX_BLOCK_POOL.</p>
<p><b>Block Size</b></p>
<p>Shows the number of memory blocks currently allocated. Two</p>
<p>numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The first</p>
<p>number indicates the number of blocks currently allocated, and the</p>
<p>second number indicates the total number of memory blocks. The</p>
<p>number of available blocks (the total number of memory blocks minus</p>
<p>the number of blocks allocated) is also shown after this pair of</p>
<p>numbers. All of these numbers are derived from the</p>
<p>tx_block_pool_available and tx_block_pool_total fields of</p>
<p>TX_BLOCK_POOL. Clicking the<b> In Use</b> button displays a<b> Block</b></p>
<p><b>Pool Contents</b> window that shows which specific blocks are allocated</p>
<p>(see âThe Block Pool Contents Windowâ on page 55).</p>
<p><b>In Use</b></p>
<p>Points to the first available memory block, or zero if the block pool</p>
<p>is completely allocated. The address displayed is actually 4 bytes</p>
<p>before the memory block that will be allocated upon a call to</p>
<p>tx_block_allocate</p>
<p>. These 4 bytes of overhead contain a pointer.</p>
<p>Available memory blocks are kept in a singly-linked list starting with</p>
<p>the first available block. In allocated blocks, the pointer points to the</p>
<p>memory block pool control block, which allows blocks to be released</p>
<p>on a call to</p>
<p>tx_block_release</p>
<p>without specifying the block pool</p>
<p>from which the block was allocated. This field corresponds to the</p>
<p>tx_block_pool_available_list field of TX_BLOCK_POOL.</p>
<p><b>First Available</b></p>
<p>Shows the number of bytes in the memory block pool storage area.</p>
<p>This field corresponds to the tx_block_pool_size field of</p>
<p>TX_BLOCK_POOL.</p>
<p><b>Pool Size</b></p>
<p>Gives the address of the memory block pool control block, which is</p>
<p>a variable of type TX_BLOCK_POOL. See the ThreadX header file</p>
<p><b>tx_api.h</b> for the definition of this type. Clicking the<b> Control Block</b></p>
<p>button opens a<b> Data Explorer</b> window on the memory block pool</p>
<p>control block. The<b> Data Explorer</b> window displays useful information</p>
<p>that is not included in the<b> Block Pool Information</b> window (for more</p>
<p>information, see the documentation about the Data Explorer in the</p>
<p><i>MULTI: Debugging</i> book).</p>
<p><b>Control Block</b></p>
<p>Indicates the number of threads currently suspended on an attempt</p>
<p>to allocate a block from the memory pool with a call to</p>
<p>tx_block_allocate</p>
<p>. This field corresponds to the</p>
<p>tx_block_pool_suspended_count field of TX_BLOCK_POOL.</p>
<p><b>Suspended Threads</b></p>
<p><i>53</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Block Pool Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives information about threads that are currently suspended on an</p>
<p>attempt to allocate a block from the memory pool. Each column in</p>
<p>the list is described below. Double-click any listed thread to display</p>
<p>a<b> Thread Information</b> window (see âThe Thread Information</p>
<p>Windowâ on page 19).</p>
<p>â¢</p>
<p><b>Name</b> â Gives the name of the thread. If a</p>
<p>0</p>
<p>(null pointer) was</p>
<p>passed as the</p>
<p>name_ptr</p>
<p>argument to tx_thread_create, this entry</p>
<p>displays the address of the thread control block.</p>
<p>â¢</p>
<p><b>Timeout</b> â Indicates the number of timer ticks before the thread</p>
<p>will abort the</p>
<p>tx_block_allocate</p>
<p>call with a return value of</p>
<p>TX_NO_MEMORY</p>
<p>. This entry shows</p>
<p>Forever</p>
<p>if</p>
<p>TX_WAIT_FOREVER</p>
<p>was passed as the<b> wait_option</b> to</p>
<p>tx_block_allocate.</p>
<p>â¢</p>
<p><b>Stack Use</b> â Shows the amount of stack currently in use by the</p>
<p>thread.</p>
<p><b>Suspended Threads</b></p>
<p><b>List</b></p>
<p>Displays the<b> Block Pool List</b> window, which contains a list of all</p>
<p>memory block pools in the system (see âThe Block Pool List Windowâ</p>
<p>on page 50).</p>
<p><b>Block Pool List</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>54</i></p>
<p><i>Chapter 7. Memory Block Pools</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Block Pool Contents Window</b></p>
<p>The<b> Block Pool Contents</b> window shows a list of all blocks in a memory block</p>
<p>pool. To display this window, click the<b> In Use</b> button in the<b> Block Pool Information</b></p>
<p>window.</p>
<p>The information in the<b> Block Pool Contents</b> window is derived from various fields</p>
<p>within the memory block pool control block TX_BLOCK_POOL.</p>
<p>You can double-click any memory block listed in the<b> Block Pool Contents</b> window</p>
<p>to view the contents of memory at that location.</p>
<p>The fields and buttons of the<b> Block Pool Contents</b> window are described below.</p>
<p>Displays the name of the memory block pool, as given in the call to</p>
<p>tx_block_pool_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry displays the address of the memory block</p>
<p>pool control block TX_BLOCK_POOL. This entry corresponds to the</p>
<p>tx_block_pool_name field of TX_BLOCK_POOL. Clicking the<b> Block</b></p>
<p><b>Pool Name</b> button displays the<b> Block Pool Information</b> window for the</p>
<p>memory block pool (see âThe Block Pool Information Windowâ</p>
<p>on page 52).</p>
<p><b>Block Pool Name</b></p>
<p><i>55</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Block Pool Contents Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives information about the memory blocks in the block pool. Each column</p>
<p>in the list is described below. Double-clicking any listed memory block</p>
<p>displays the contents of memory at that location.</p>
<p>â¢</p>
<p><b>Address</b> â Gives the address in memory where the block resides.</p>
<p>The 4 bytes preceding this address contain a pointer. If this pointer</p>
<p>points to the memory block pool control block, the block is in use.</p>
<p>Otherwise, the block is available.</p>
<p>â¢</p>
<p><b>Status</b> â Displays either</p>
<p>In Use</p>
<p>or</p>
<p>Available</p>
<p>depending on the</p>
<p>value of the pointer preceding the memory block, as described above.</p>
<p><b>Memory Block</b></p>
<p><b>List</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>56</i></p>
<p><i>Chapter 7. Memory Block Pools</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 8</b></p>
<p><b>Memory Byte Pools</b></p>
<p><b>Contents</b></p>
<p>The Byte Pool List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>58</p>
<p>The Byte Pool Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>59</p>
<p>The Byte Pool Contents Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>62</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes windows that display detailed information about the memory</p>
<p>byte pools in your application.</p>
<p><b>The Byte Pool List Window</b></p>
<p>The<b> Byte Pool List</b> window shows a list of all memory byte pools in the system,</p>
<p>arranged in the order in which they were created. To display this window, click the</p>
<p><b>Byte Pools</b> button in the<b> ThreadX Information</b> window.</p>
<p>The list is generated by following a linked list, starting with the memory byte pool</p>
<p>pointed to by the global variable</p>
<p>_tx_byte_pool_created_ptr</p>
<p>and continuing</p>
<p>with the _tx_byte_pool_created_next field of each memory byte pool control block</p>
<p>TX_BYTE_POOL. A total of</p>
<p>_tx_byte_pool_created_count</p>
<p>pools are shown.</p>
<p>When a memory byte pool is deleted, it is removed from this list.</p>
<p>You can double-click any memory byte pool in the<b> Byte Pool List</b> to display a<b> Byte</b></p>
<p><b>Pool Information</b> window (see âThe Byte Pool Information Windowâ on page 59).</p>
<p>The<b> Byte Pool List</b> has three columns:<b> Name</b>,<b> Full</b>, and<b> Suspended</b>. Each of these</p>
<p>is described next.</p>
<p>Displays the name of the memory byte pool, as given in the call to</p>
<p>tx_byte_pool_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry displays the address of the memory</p>
<p>byte pool control block TX_BYTE_POOL. This entry corresponds to</p>
<p>the tx_byte_pool_name field of TX_BYTE_POOL.</p>
<p><b>Name</b></p>
<p>Shows the number of bytes currently allocated from the pool. Two</p>
<p>numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The first number</p>
<p>indicates the number of bytes currently allocated, and the second number</p>
<p>indicates the total number of bytes. These numbers are derived from</p>
<p>the tx_byte_pool_available and tx_byte_pool_size fields of</p>
<p>TX_BYTE_POOL.</p>
<p><b>Full</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>58</i></p>
<p><i>Chapter 8. Memory Byte Pools</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Shows the number of threads currently suspended on an attempt to</p>
<p>allocate memory from the pool with a call to</p>
<p>tx_byte_allocate</p>
<p>, or</p>
<p>displays</p>
<p>None</p>
<p>if no threads are suspended. This entry corresponds to</p>
<p>the tx_byte_pool_suspended_count field of TX_BYTE_POOL.</p>
<p><b>Suspended</b></p>
<p><b>The Byte Pool Information Window</b></p>
<p>The<b> Byte Pool Information</b> window shows detailed information about an individual</p>
<p>memory byte pool.</p>
<p>To display this window, double-click a byte pool in the<b> Byte Pool List</b>, or view a</p>
<p>variable of type TX_BYTE_POOL in the MULTI Debugger window. The</p>
<p>information in this window is derived from various fields within the memory byte</p>
<p>pool control block TX_BYTE_POOL.</p>
<p>If a memory byte pool is deleted while a<b> Byte Pool Information</b> window for it</p>
<p>exists, the window does not automatically disappear; the window continues to show</p>
<p>the contents of the memory byte pool control block.</p>
<p>To view detailed information about the fragments in a byte pool, click the<b> In Use</b></p>
<p>button to display the<b> Byte Pool Contents</b> window (see âThe Byte Pool Contents</p>
<p>Windowâ on page 62).</p>
<p><i>59</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Byte Pool Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The fields and buttons of the<b> Byte Pool Information</b> window are described in the</p>
<p>table below.</p>
<p>Gives the name of the memory byte pool, as given in the call to</p>
<p>tx_byte_pool_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this field displays</p>
<p>(None)</p>
<p>. This field</p>
<p>corresponds to the tx_byte_pool_name field of TX_BYTE_POOL.</p>
<p><b>Byte Pool Name</b></p>
<p>Shows the number of bytes currently allocated. Two numbers</p>
<p>separated by a forward slash (</p>
<p>/</p>
<p>) are displayed. The first number</p>
<p>indicates the number of bytes currently allocated, and the second</p>
<p>number indicates the total number of bytes. The number of available</p>
<p>bytes (the total number of bytes minus the number of bytes</p>
<p>allocated) is shown after this pair of numbers. Note that the available</p>
<p>byte count does not compensate for the two pointers of overhead</p>
<p>that each memory fragment requires. The numbers in this field are</p>
<p>derived from the tx_byte_pool_available and tx_byte_pool_size</p>
<p>fields of TX_BYTE_POOL. Clicking the<b> In Use</b> button displays a</p>
<p><b>Byte Pool Contents</b> window that shows all allocated and</p>
<p>unallocated fragments in the byte pool (see âThe Byte Pool</p>
<p>Information Windowâ on page 59).</p>
<p><b>In Use</b></p>
<p>Indicates the number of fragments in the memory byte pool. This</p>
<p>value is derived from the tx_byte_pool_fragments field of</p>
<p>TX_BYTE_POOL.</p>
<p><b>Fragments</b></p>
<p>Points to the first unallocated memory fragment that will be searched</p>
<p>during tx_byte_allocate. The address is set to the last fragment that</p>
<p>was released. This field corresponds to the tx_byte_pool_search</p>
<p>field of TX_BYTE_POOL.</p>
<p><b>Search Address</b></p>
<p>Points to the start of the byte pool and corresponds to the</p>
<p>tx_byte_pool_start field of TX_BYTE_POOL.</p>
<p><b>Memory Start</b></p>
<p>Gives the address of the memory byte pool control block, which is</p>
<p>a variable of type TX_BYTE_POOL. See the ThreadX header file</p>
<p><b>tx_api.h</b> for the definition of this type. Clicking the<b> Control Block</b></p>
<p>button opens a<b> Data Explorer</b> window on the memory byte pool</p>
<p>control block. The<b> Data Explorer</b> window displays useful</p>
<p>information that is not included in the<b> Byte Pool Information</b></p>
<p>window (for more information, see the documentation about the</p>
<p>Data Explorer in the<i> MULTI: Debugging</i> book).</p>
<p><b>Control Block</b></p>
<p>Indicates the number of threads currently suspended on an attempt</p>
<p>to allocate memory from the memory pool with a call to</p>
<p>tx_byte_allocate. This field corresponds to the</p>
<p>tx_byte_pool_suspended_count field of TX_BYTE_POOL.</p>
<p><b>Suspended Threads</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>60</i></p>
<p><i>Chapter 8. Memory Byte Pools</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives information about threads that are currently suspended on an</p>
<p>attempt to allocate memory from the memory pool. Each column</p>
<p>in the list is described below. Double-click any listed thread to</p>
<p>display a<b> Thread Information</b> window (see âThe Thread</p>
<p>Information Windowâ on page 19).</p>
<p>â¢</p>
<p><b>Name</b> â Gives the name of the thread. If a</p>
<p>0</p>
<p>(null pointer)</p>
<p>was passed as the</p>
<p>name_ptr</p>
<p>argument to tx_thread_create,</p>
<p>this entry displays the address of its thread control block.</p>
<p>â¢</p>
<p><b>Request</b> â Indicates the number of bytes requested in the</p>
<p>memory_size argument to tx_byte_allocate. Sometimes a</p>
<p>request causes a thread to suspend even though enough memory</p>
<p>appears to be available. This can occur if the two pointers</p>
<p>necessary in each memory fragment have not been allowed</p>
<p>for or if the pool is too fragmented to satisfy the request.</p>
<p>â¢</p>
<p><b>Timeout</b> â Indicates the number of timer ticks before the</p>
<p>thread will abort the</p>
<p>tx_byte_allocate</p>
<p>call with a return</p>
<p>value of</p>
<p>TX_NO_MEMORY</p>
<p>. This entry shows</p>
<p>Forever</p>
<p>if</p>
<p>TX_WAIT_FOREVER</p>
<p>was passed as the<b> wait_option</b> to</p>
<p>tx_byte_allocate.</p>
<p>â¢</p>
<p><b>Stack Use</b> â Shows the amount of stack currently in use by</p>
<p>the thread.</p>
<p><b>Suspended Threads List</b></p>
<p>Displays the<b> Byte Pool List</b> window, which contains a list of all</p>
<p>memory byte pools in the system (see âThe Byte Pool List Windowâ</p>
<p>on page 58).</p>
<p><b>Byte Pool List</b></p>
<p><i>61</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Byte Pool Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Byte Pool Contents Window</b></p>
<p>The<b> Byte Pool Contents</b> window shows a list of all fragments in a memory byte</p>
<p>pool.</p>
<p>To display this window, click the<b> In Use</b> button in the<b> Byte Pool Information</b></p>
<p>window. The information in the<b> Byte Pool Contents</b> window is derived from various</p>
<p>fields within the memory byte pool control block TX_BYTE_POOL.</p>
<p>You can double-click any fragment listed in the<b> Byte Pool Contents</b> window to</p>
<p>view the contents of memory at that location.</p>
<p>The information listed in the<b> Byte Pool Contents</b> window is described next.</p>
<p>Displays the name of the memory byte pool, as given in the call</p>
<p>to</p>
<p>tx_byte_pool_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as</p>
<p>the</p>
<p>name_ptr</p>
<p>argument, this entry displays the address of the</p>
<p>memory byte pool control block TX_BYTE_POOL. This entry</p>
<p>corresponds to the tx_byte_pool_name field of TX_BYTE_POOL.</p>
<p>Clicking the<b> Byte Pool Name</b> button displays the<b> Byte Pool</b></p>
<p><b>Information</b> window for the memory byte pool (see âThe Byte</p>
<p>Pool Information Windowâ on page 59).</p>
<p><b>Byte Pool Name</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>62</i></p>
<p><i>Chapter 8. Memory Byte Pools</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Gives information about the fragments in the byte pool. Each</p>
<p>column in this list is described below. Double-clicking any listed</p>
<p>fragment displays the contents of memory at that location.</p>
<p>â¢</p>
<p><b>Address</b> â Gives the address in memory of the fragment.</p>
<p>The location 8 bytes before this address contains a pointer.</p>
<p>If this pointer points to the memory byte pool control block,</p>
<p>the fragment is in use. Otherwise, the fragment is available.</p>
<p>â¢</p>
<p><b>Status</b> â Shows either</p>
<p>In Use</p>
<p>or</p>
<p>Available</p>
<p>depending</p>
<p>on whether the location 4 bytes before the fragment contains</p>
<p>the value</p>
<p>TX_BYTE_BLOCK_FREE</p>
<p>(</p>
<p>Oxffffeeee</p>
<p>).</p>
<p>â¢</p>
<p><b>Size</b> â Indicates the size of the byte pool fragment in bytes.</p>
<p>All byte pools end with a zero-byte fragment that is shown</p>
<p>as</p>
<p>0</p>
<p>(End).</p>
<p><b>Memory Byte List</b></p>
<p><i>63</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Byte Pool Contents Window</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 9</b></p>
<p><b>Application Timers</b></p>
<p><b>Contents</b></p>
<p>The Timer List Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>66</p>
<p>The Timer Information Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>68</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter describes windows that display detailed information about the</p>
<p>application timers in your application.</p>
<p><b>The Timer List Window</b></p>
<p>The<b> Timer List</b> window shows a list of all application timers in the system, arranged</p>
<p>in the order in which they were created. This list can be displayed by clicking the</p>
<p><b>Application Timers</b> button in the<b> ThreadX Information</b> window.</p>
<p>The<b> Timer List</b> is generated by following a linked list, starting with the timer</p>
<p>pointed to by the global variable</p>
<p>_tx_timer_created_ptr</p>
<p>and continuing with</p>
<p>the tx_timer_created_next field of each timer control block TX_TIMER. A total of</p>
<p>_tx_timer_created_count</p>
<p>timers are shown.</p>
<p>When a timer is deleted, it disappears from this list.</p>
<p>You can double-click any timer in the<b> Timer List</b> to display a<b> Timer Information</b></p>
<p>window (see âThe Timer Information Windowâ on page 68).</p>
<p>The<b> Timer List</b> has three columns:<b> Name</b>,<b> Ticks</b>, and<b> Callback</b>. Each of these is</p>
<p>described next.</p>
<p>Displays the name of the timer, as given in the call to</p>
<p>tx_timer_create</p>
<p>.</p>
<p>If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this entry displays</p>
<p>the address of the timer control block TX_TIMER. This entry corresponds</p>
<p>to the tx_timer_name field of TX_TIMER.</p>
<p><b>Name</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>66</i></p>
<p><i>Chapter 9. Application Timers</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Indicates the number of initial timer ticks and the timer reschedule tick value</p>
<p>if the timer is active. If the timer is inactive, this field displays</p>
<p>Inactive</p>
<p>.</p>
<p>For active timers, two numbers separated by a forward slash (</p>
<p>/</p>
<p>) are displayed.</p>
<p>The first number specifies the current number of initial ticks, and the second</p>
<p>number specifies the number of ticks with which the timer will be rescheduled</p>
<p>after it expires. Both numbers range from</p>
<p>0</p>
<p>to</p>
<p>0xffffffff</p>
<p>. A zero value</p>
<p>for the second number specifies a one-shot timer. The current tick value</p>
<p>corresponds to the tx_timer_internal_remaining_ticks field of the</p>
<p>tx_timer_internal structure within TX_TIMER. The reschedule tick value</p>
<p>corresponds to the tx_timer_internal_re_initialize_ticks of the</p>
<p>tx_timer_internal structure within TX_TIMER.</p>
<p><b>Ticks</b></p>
<p>Gives the name of the function called when the timer expires. If no debugging</p>
<p>information is available, this entry may be displayed as an offset from a</p>
<p>known label or as an address in hexadecimal format. This entry corresponds</p>
<p>to the tx_timer_internal_timeout_function of the tx_timer_internal structure</p>
<p>within TX_TIMER.</p>
<p><b>Callback</b></p>
<p><i>67</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Timer List Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Timer Information Window</b></p>
<p>The<b> Timer Information</b> window shows detailed information about an individual</p>
<p>timer.</p>
<p>To display this window, double-click a timer in the<b> Timer List</b> window, or view a</p>
<p>variable of type TX_TIMER in the MULTI Debugger window. The information in</p>
<p>this window is derived from various fields within the timer control block</p>
<p>TX_TIMER.</p>
<p>Each of the fields and buttons in the<b> Timer Information</b> window is described</p>
<p>below.</p>
<p>Displays the name of the timer, as given in the call to</p>
<p>tx_timer_create</p>
<p>. If a</p>
<p>0</p>
<p>(null pointer) was passed as the</p>
<p>name_ptr</p>
<p>argument, this field displays</p>
<p>(None)</p>
<p>. This field</p>
<p>corresponds to the tx_timer_name field of TX_TIMER.</p>
<p><b>Timer Name</b></p>
<p>Indicates the number of initial timer ticks and the timer reschedule</p>
<p>tick value. Two numbers are listed, separated by a forward slash</p>
<p>(</p>
<p>/</p>
<p>). The first number specifies the initial number of ticks when</p>
<p>the timer is created, and the second number specifies the number</p>
<p>of ticks for all timer expirations after the first. Both numbers range</p>
<p>from</p>
<p>0</p>
<p>to</p>
<p>0xffffffff</p>
<p>. A zero value for the second number</p>
<p>specifies a one-shot timer. The initial tick value corresponds to</p>
<p>the tx_timer_internal_remaining_ticks field of the</p>
<p>tx_timer_internal structure within TX_TIMER. The reschedule</p>
<p>tick value corresponds to the tx_timer_internal_re_initialize_ticks</p>
<p>of the tx_timer_internal structure within TX_TIMER.</p>
<p><b>Ticks</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>68</i></p>
<p><i>Chapter 9. Application Timers</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Shows the current state of the timer (</p>
<p>Active</p>
<p>or</p>
<p>Inactive</p>
<p>). This</p>
<p>value is derived from the tx_timer_internal_list_head field of the</p>
<p>tx_timer_internal structure within TX_TIMER. The timer is active</p>
<p>only if tx_timer_internal_list_head is non-zero.</p>
<p><b>State</b></p>
<p>Gives the name of the function called when the timer expires. If</p>
<p>no debugging information is available, then this field may be</p>
<p>displayed as an offset from a known label or as an address in</p>
<p>hexadecimal format. This field corresponds to the</p>
<p>tx_timer_internal_timeout_function of the tx_timer_internal</p>
<p>structure within TX_TIMER. Clicking the<b> Callback</b> button shows</p>
<p>the callback function.</p>
<p><b>Callback</b></p>
<p>Indicates the parameter passed to the callback function when the</p>
<p>timer expires. This field corresponds to the</p>
<p>tx_timer_internal_timeout_param field of the tx_timer_internal</p>
<p>structure within TX_TIMER.</p>
<p><b>Parameter</b></p>
<p>Shows the address of the timer control block, which is a variable</p>
<p>of type TX_TIMER. See the ThreadX header file<b> tx_api.h</b> for</p>
<p>the definition of this type. Clicking the<b> Control Block</b> button</p>
<p>opens a<b> Data Explorer</b> window on the timer control block. The</p>
<p><b>Data Explorer</b> window displays useful information that is not</p>
<p>included in the<b> Timer Information</b> window (for more</p>
<p>information, see the documentation about the Data Explorer in</p>
<p>the<i> MULTI: Debugging</i> book).</p>
<p><b>Control Block</b></p>
<p>Clicking this button displays the<b> Timer List</b> window, which</p>
<p>contains a list of all timers in the system (see âThe Timer List</p>
<p>Windowâ on page 66).</p>
<p><b>Timer List</b></p>
<p><i>69</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The Timer Information Window</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Part II</b></p>
<p><b>Using the MULTI</b></p>
<p><b>EventAnalyzer for</b></p>
<p><b>ThreadX</b></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 10</b></p>
<p><b>Introduction to the MULTI</b></p>
<p><b>EventAnalyzer for ThreadX</b></p>
<p><b>Contents</b></p>
<p>Basic Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>75</p>
<p>The Effect of Event Logging on Run-Time Performance . . . . . . . . . . . . . . . . . .</p>
<p>78</p>
<h1 style="page-break-before:always; "></h1>
<p>The MULTI EventAnalyzer helps developers understand the dynamic behavior of</p>
<p>a target that uses the ThreadX real-time kernel by providing a graphical</p>
<p>representation of system activities as they occur over time. The EventAnalyzer</p>
<p>complements the MULTI Debugger, which displays detailed system information</p>
<p>at a single point in time.</p>
<p>The event logging feature available with the ThreadX kernel allows the system to</p>
<p>record specific event information such as ThreadX service calls, context switches,</p>
<p>interrupts, and user-defined events as they occur. This event data is transferred to</p>
<p>the host system and is viewed and analyzed with the MULTI EventAnalyzer.</p>
<p>The EventAnalyzer displays details about the status of each thread and about events</p>
<p>related to that thread, and includes a variety of controls that enable you to view the</p>
<p>event data.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>74</i></p>
<p><i>Chapter 10. Introduction to the MULTI EventAnalyzer for ThreadX</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Basic Operation</b></p>
<p>When event logging is enabled, the ThreadX kernel logs events and status changes</p>
<p>to a target-resident buffer as they occur. At any point, this memory region can be</p>
<p>retrieved from the target and saved to a data file on the host. The EventAnalyzer</p>
<p>can then display the data graphically.</p>
<p>The EventAnalyzer reads the data file as a series of events and states. The various</p>
<p>threads on the target system can change execution state as the target runs. System</p>
<p>events occur depending on the behavior of the program and of the system.</p>
<p>The main display of the EventAnalyzer (pictured below) provides a graphical</p>
<p>depiction of events, context switches, and status changes as they occur over time.</p>
<p>To view additional details about an event, click any object in the view graph canvas.</p>
<p>Every event displayed by the EventAnalyzer has an &quot;object view&quot; that is displayed</p>
<p>by double-clicking the event icon in the EventAnalyzer canvas or by using the</p>
<p><i>75</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Basic Operation</i></p>
<h1 style="page-break-before:always; "></h1>
<p>right-click menu choice<b> Show Object</b>. The object view displays the extra data along</p>
<p>with other pertinent, event-specific information.</p>
<p>An example of the object view for an event is shown below. Note the extra data</p>
<p>displayed in the<b> More Info</b> field.</p>
<p>The standard ThreadX system events are classified as follows:</p>
<p>â¢</p>
<p><b>Thread context switches</b> â A<i> context switch</i> refers to the moment when the</p>
<p>kernel changes the current thread running on the CPU. This can occur when</p>
<p>one thread preempts another, when the running thread suspends itself, or when</p>
<p>the running thread suspends on a resource. In the EventAnalyzer canvas, a</p>
<p>vertical dashed line represents a thread context switch, and horizontal lines</p>
<p>with differing line styles indicate the status of each thread.</p>
<p>â¢</p>
<p><b>Exceptions and interrupts</b> â An<i> exception</i> is an event that causes the</p>
<p>processor to suspend its current operation immediately and perform some</p>
<p>processing to service the exception. Exceptions caused by external devices are</p>
<p>called hardware interrupts. These can occur asynchronously with respect to the</p>
<p>execution of code. Other exceptions may be caused by the synchronous</p>
<p>execution of code. Some examples of synchronous exceptions are division by</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>76</i></p>
<p><i>Chapter 10. Introduction to the MULTI EventAnalyzer for ThreadX</i></p>
<h1 style="page-break-before:always; "></h1>
<p>zero, memory protection violations, illegal instructions, and unaligned access</p>
<p>exceptions.</p>
<p>â¢</p>
<p><b>Service calls</b> â A<i> service call</i> is an event that occurs when a thread calls a</p>
<p>ThreadX service function, thus causing the kernel to perform an operation on</p>
<p>behalf of the thread. Common examples include operations on semaphores,</p>
<p>sending and receiving messages, and thread manipulation. Because ThreadX</p>
<p>service calls are the interface to the kernel, logging and analysis of these events</p>
<p>is usually the most important function of the EventAnalyzer.</p>
<p>â¢</p>
<p><b>User events</b> â You can insert code into your application to log events and</p>
<p>record specific system data, such as the values of particular variables or</p>
<p>expressions related to those events. For more information, see âUser-Defined</p>
<p>Eventsâ on page 82.</p>
<p>Between the time it is created and destroyed, a thread will be in one of the following</p>
<p>states at any given moment:</p>
<p>â¢</p>
<p>Ready</p>
<p>â The thread is ready for execution, but the ThreadX scheduler is</p>
<p>currently running a higher-priority thread or another same-priority thread. A</p>
<p>typical system might contain several ready threads; however, the scheduler</p>
<p>executes only one thread at a time, based on priority and the order in which</p>
<p>they became ready.</p>
<p>â¢</p>
<p>Executing</p>
<p>â The thread is currently executing on the CPU.</p>
<p>â¢</p>
<p>Suspended</p>
<p>â The thread is not ready for execution.</p>
<p>â¢</p>
<p>Completed</p>
<p>â The thread has returned from its entry function.</p>
<p>â¢</p>
<p>Terminated</p>
<p>â The thread has been terminated (either by itself or another</p>
<p>thread) by a call to</p>
<p>tx_thread_terminate</p>
<p>.</p>
<p>When the status of a thread changes (for example, a</p>
<p>Ready</p>
<p>thread is set</p>
<p>Executing</p>
<p>by the scheduler), this information is logged as a thread status change event.</p>
<p><i>77</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Basic Operation</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The Effect of Event Logging on Run-Time Performance</b></p>
<p>Event logging requires a small amount of system overhead, which is directly</p>
<p>proportional to the number of events logged.</p>
<p>This section discusses factors that may affect the level of intrusion into the target</p>
<p>system. For more information, see Chapter 11, âCollecting Event Logging Dataâ</p>
<p>on page 79.</p>
<p><b>Basic Logging Instrumentation</b></p>
<p>With event logging support present and disabled, the effect on run-time performance</p>
<p>is minimal. When the preprocessor symbol</p>
<p>TX_ENABLE_EVENT_LOGGING</p>
<p>is set</p>
<p>while building the kernel, ThreadX includes the kernel instrumentation necessary</p>
<p>for event logging. Therefore, even when event logging is disabled and no data is</p>
<p>being logged, a small amount of overhead exists due to run-time checks by the</p>
<p>system to determine if logging is enabled.</p>
<p>The ThreadX library can be built without logging support, which removes all event</p>
<p>logging overhead.</p>
<p><b>Quantity of Event Types</b></p>
<p>The optional event logging filter allows you to include or exclude certain types of</p>
<p>events. This allows you to log only the events necessary for meaningful analysis.</p>
<p>Logging more events uses up more of the available target memory.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>78</i></p>
<p><i>Chapter 10. Introduction to the MULTI EventAnalyzer for ThreadX</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 11</b></p>
<p><b>Collecting Event Logging</b></p>
<p><b>Data</b></p>
<p><b>Contents</b></p>
<p>Control and Filtering of Event Logging . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>80</p>
<p>User-Defined Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>82</p>
<p>Retrieving Event Logging Data from the Target . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>84</p>
<p>Modifying the Target Event Log Location . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>85</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter discusses issues relating to configuring your program for event logging.</p>
<p><b>Control and Filtering of Event Logging</b></p>
<p>Event logging is controlled at compile-time via conditional compilation. To</p>
<p>implement event logging, use the following defines when compiling ThreadX or</p>
<p>application source:</p>
<p>â¢</p>
<p>TX_ENABLE_EVENT_LOGGING</p>
<p>â (Main option) Enables event logging for</p>
<p>any or all of the ThreadX source code. If this option is used anywhere, the</p>
<p><b>tx_initialize_high_level.c</b> file must be compiled with it as well.</p>
<p>â¢</p>
<p>TX_NO_EVENT_INFO</p>
<p>â (Sub-option) Suppresses the collection of &quot;extra data&quot;</p>
<p>that ThreadX collects for each event. Each ThreadX event returns a</p>
<p>predetermined set of information about the event, including the Event Name,</p>
<p>the thread ID, the time at which the event occurred, and, in many cases, some</p>
<p>extra data related to the event. Defining this symbol suppresses the collection</p>
<p>of extra data.</p>
<p>â¢</p>
<p>TX_ENABLE_EVENT_FILTERS</p>
<p>â (Sub-option) Enables event filters, allowing</p>
<p>you to control the types of events that are logged.</p>
<p><b>Note</b></p>
<p>By default, ThreadX's event logging code supports 16 thread names in</p>
<p>applications. If you need to track more than 16 threads, change the value</p>
<p>of the</p>
<p>TX_EL_TNIS</p>
<p>macro, which is defined in the<b> tx_el.h</b> include file.</p>
<p>Then rebuild the ThreadX library.</p>
<p>ThreadX provides three routines that can be used to control event logging at run-time</p>
<p>from within the application software. These routines require that event filtering be</p>
<p>enabled as described above.</p>
<p>â¢</p>
<p>void _tx_el_event_log_on(void);</p>
<p>Instructs ThreadX to begin logging</p>
<p>events, by clearing the internal event logging filter.</p>
<p>â¢</p>
<p>void _tx_el_event_log_off(void);</p>
<p>Instructs ThreadX to stop logging</p>
<p>events, by setting all the event flag logging filters.</p>
<p>â¢</p>
<p>void _tx_el_event_filter_set(UINT filter);</p>
<p>Sets the logging event</p>
<p>filter, which specifies the types of events to be excluded from logging. You</p>
<p>will typically want to view only certain types of events. For example, in some</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>80</i></p>
<p><i>Chapter 11. Collecting Event Logging Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>systems, interrupts and status events can occur frequently. Logging all of these</p>
<p>events could return more data than can be reasonably analyzed or overflow the</p>
<p>memory buffer. (The capacity of the target memory limits the quantity of data</p>
<p>that can be retained.) In these cases, suppressing certain event types will allow</p>
<p>enough memory for the desired events.</p>
<p>The event types that can be filtered and their bit mask values (which can be</p>
<p>combined through a bitwise</p>
<p>OR</p>
<p>to filter out more events) are as follows:</p>
<p>â</p>
<p>TX_EL_FILTER_STATUS_CHANGE</p>
<p>(</p>
<p>0x0001</p>
<p>) â Events describing thread</p>
<p>status changes such as when a thread changes from suspended to ready.</p>
<p>â</p>
<p>TX_EL_FILTER_INTERRUPTS</p>
<p>(</p>
<p>0x0002</p>
<p>) â Interrupt or exception events.</p>
<p>In some systems, interrupts can occur at a very high rate, causing a flood</p>
<p>of event data that may make the other data more difficult to visualize or</p>
<p>may generate more events than the logging mechanism can handle. It might</p>
<p>also be the case that these events should be removed in the actual ThreadX</p>
<p>source code modules - typically the interrupt logic is isolated to a few</p>
<p>assembly files in most versions of ThreadX.</p>
<p>â</p>
<p>TX_EL_FILTER_THREAD_CALLS</p>
<p>(</p>
<p>0x0004</p>
<p>) â Events associated with</p>
<p>thread services in ThreadX (e.g.,</p>
<p>tx_thread_resume</p>
<p>,</p>
<p>tx_thread_suspend</p>
<p>, etc.).</p>
<p>â</p>
<p>TX_EL_FILTER_TIMER_CALLS</p>
<p>(</p>
<p>0x0008</p>
<p>) â Events associated with</p>
<p>application timer services in ThreadX (e.g.,</p>
<p>tx_timer_activate</p>
<p>,</p>
<p>tx_timer_deactivate</p>
<p>, etc.).</p>
<p>â</p>
<p>TX_EL_FILTER_EVENT_FLAG_CALLS</p>
<p>(</p>
<p>0x0010</p>
<p>) â Events associated</p>
<p>with event flag services in ThreadX (e.g.,</p>
<p>tx_event_flags_get</p>
<p>,</p>
<p>tx_event_flags_set</p>
<p>, etc.).</p>
<p>â</p>
<p>TX_EL_FILTER_SEMAPHORE_CALLS</p>
<p>(</p>
<p>0x0020</p>
<p>) â Events associated with</p>
<p>semaphore services in ThreadX (e.g.,</p>
<p>tx_semaphore_get</p>
<p>,</p>
<p>tx_semaphore_put</p>
<p>, etc.).</p>
<p>â</p>
<p>TX_EL_FILTER_QUEUE_CALLS</p>
<p>(</p>
<p>0x0040</p>
<p>) â Events associated with</p>
<p>queue services in ThreadX (e.g.,</p>
<p>tx_queue_send</p>
<p>,</p>
<p>tx_queue_receive</p>
<p>,</p>
<p>etc.).</p>
<p>â</p>
<p>TX_EL_FILTER_BLOCK_CALLS</p>
<p>(</p>
<p>0x0080</p>
<p>) â Events associated with</p>
<p>memory block pool services in ThreadX (e.g.,</p>
<p>tx_block_allocate</p>
<p>,</p>
<p>tx_block_release</p>
<p>, etc.).</p>
<p><i>81</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Control and Filtering of Event Logging</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â</p>
<p>TX_EL_FILTER_BYTE_CALLS</p>
<p>(</p>
<p>0x0100</p>
<p>) â Events associated with</p>
<p>memory byte pool services in ThreadX (e.g.,</p>
<p>tx_byte_allocate</p>
<p>,</p>
<p>tx_byte_release</p>
<p>, etc.).</p>
<p>â</p>
<p>TX_EL_FILTER_MUTEX_CALLS</p>
<p>(</p>
<p>0x0200</p>
<p>) â Events associated with</p>
<p>mutex services in ThreadX (e.g.,</p>
<p>tx_mutex_get</p>
<p>,</p>
<p>tx_mutex_prioritize</p>
<p>, etc.).</p>
<p>â</p>
<p>TX_EL_FILTER_ALL_EVENTS</p>
<p>(</p>
<p>0xFFFF</p>
<p>) â Disables collection of all</p>
<p>events.</p>
<p>â</p>
<p>TX_EL_ENABLE_ALL_EVENTS</p>
<p>(</p>
<p>0x0000</p>
<p>) â [default] Enables collection</p>
<p>of all events.</p>
<p><b>Note</b></p>
<p>Filtering events while the application runs is distinct from changing the</p>
<p>visibility attribute of an event in the EventAnalyzer application. The</p>
<p>event filter actually prevents the system from logging particular events;</p>
<p>consequently, those events are not written to the data file. The visibility</p>
<p>attribute merely<i> turns off</i> the selected event in the EventAnalyzer display</p>
<p>canvas, but the event is logged, takes up memory, and will be present in</p>
<p>the data file.</p>
<p><b>User-Defined Events</b></p>
<p>User-defined events allow the target to log events that are specific to your</p>
<p>application. You can use user-defined events to enhance event logging capabilities.</p>
<p>For example, if you need to determine when a particular piece of code executes, a</p>
<p>user event can be logged in the code at that point. Such modifications can be useful</p>
<p>in order to better understand how the target system is operating.</p>
<p>To implement a user-defined event you must:</p>
<p>â¢</p>
<p>Modify the Application</p>
<p>â¢</p>
<p>Modify the Configuration File</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>82</i></p>
<p><i>Chapter 11. Collecting Event Logging Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Modify the Application</b></p>
<p>The API service for logging a user-defined event in ThreadX is as follows:</p>
<p>VOID _tx_el_user_event_insert(UINT sub_type, ULONG info_1,</p>
<p>ULONG info_2, ULONG info_3, ULONG info_4);</p>
<p>The parameters supplied to this service are defined by the application. ThreadX</p>
<p>simply places this information along with the current thread pointer and time-stamp</p>
<p>into the next entry in the event log.</p>
<p>For example, to track the time it takes to process an application buffer, you might</p>
<p>insert code as follows:</p>
<p>/*Buffer is received, record a user-defined event.</p>
<p>* Note that BUFFER_RECEIVED and my_buffer_ptr are defined</p>
<p>* outside of this scope. */</p>
<p>_tx_el_user_event_insert(BUFFER_RECEIVED,</p>
<p>(ULONG) my_buffer_ptr);</p>
<p>/* ... a bunch of processing */</p>
<p>/* Buffer is processed, record a user-defined event. Note</p>
<p>* that BUFFER_PROCESSED is defined outside of this scope.*/</p>
<p>_tx_el_user_event_insert(BUFFER_PROCESSED,</p>
<p>(ULONG) my_buffer_ptr);</p>
<p><b>Modify the Configuration File</b></p>
<p>For an event to appear in the EventAnalyzer, it must be defined in the ThreadX</p>
<p>configuration file (<b>threadx.mc</b>).</p>
<p>The ThreadX configuration file already includes definitions for standard ThreadX</p>
<p>events. User-defined events can be added by using the following syntax:</p>
<p>MEV_Event:4:0:MyUserEvent:userevent:MEV_Extra=&quot;count=%4D&quot;:MEV_Visible</p>
<p>This configuration file entry tells how to display a user-defined event, called</p>
<p>MyUserEvent</p>
<p>in this example. The<b> MEV_Event:4</b> field entries indicate that this</p>
<p>entry describes a user-defined event. The<b> subtype</b> field, which in this example is</p>
<p>0, corresponds to the</p>
<p>sub_type</p>
<p>argument passed to the</p>
<p>_tx_el_user_event_insert</p>
<p>service. The<b> userevent</b> field entry indicate that</p>
<p>the standard user-defined event icon should be used in the EventAnalyzer display.</p>
<p>The display of any extra data is indicated by the</p>
<p>count=%4D</p>
<p>string.</p>
<p><i>83</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Modify the Application</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Other kinds of user-defined events with different extra data formats can be defined</p>
<p>by adding a new event with a different subtype to the<b> threadx.mc</b> file.</p>
<p>For more information about the configuration files, see Chapter 13, âEventAnalyzer</p>
<p>Configuration Filesâ on page 107 To create<i> extra data</i> for events, see âSpecifying</p>
<p>Extra Dataâ on page 110.</p>
<p><b>Note</b></p>
<p>You must restart the EventAnalyzer for changes to your configuration</p>
<p>file to take effect.</p>
<p><b>Retrieving Event Logging Data from the Target</b></p>
<p>See âLaunching the EventAnalyzerâ on page 88 for the typical way of retrieving</p>
<p>and viewing event log data.</p>
<p>To perform the event log data retrieval, postprocessing, and EventAnalyzer actions</p>
<p>separately, follow these steps:</p>
<p>1.</p>
<p>Establish a debugging connection capable of reading the target memory.</p>
<p>2.</p>
<p>Use the MULTI<b> memdump</b> command to retrieve the contents of the event log</p>
<p>and write it to a file on the host computer system. For more information about</p>
<p>this and other commands, see the<i> MULTI: Debugging Command Reference</i></p>
<p>book.</p>
<p>For example, to dump the ThreadX event log into a file called<b> my_events</b> on the</p>
<p>host, enter the following:</p>
<p>memdump raw my_event_dump __ghsbegin_eventlog \</p>
<p>(__ghsend_eventlog-__ghsbegin_eventlog)</p>
<p>The above operation places the contents of the event log into the file,</p>
<p><b>my_event_dump</b>, located on the host. If the Debugger generates an</p>
<p>unknown</p>
<p>symbol</p>
<p>error (because the Debugger cannot find either of the special</p>
<p>__ghsbegin</p>
<p>symbols), examine the application map file or use the MULTI<b> map</b> command to</p>
<p>determine the location and size of the</p>
<p>.eventlog</p>
<p>section. Then use explicit address</p>
<p>and size arguments in the<b> memdump</b> command.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>84</i></p>
<p><i>Chapter 11. Collecting Event Logging Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Once the event log has been placed into a host file, you must convert it into a format</p>
<p>that is compatible with the EventAnalyzer. Do this by using the<b> txundump</b> utility</p>
<p>provided with your distribution. The following shell command converts the raw</p>
<p>event log into the proper format for the EventAnalyzer:</p>
<p>txundump my_event_dump my_events</p>
<p>The resulting<b> my_events.mes</b> file is ready to view with the EventAnalyzer.</p>
<p>Then use the Debugger<b> mev</b> command to launch the EventAnalyzer:</p>
<p>mev my_events</p>
<p><b>Modifying the Target Event Log Location</b></p>
<p>By default, ThreadX uses a statically-allocated buffer to store the event log. The</p>
<p>size of the target buffer limits the number of events that can be acquired during an</p>
<p>event logging session. If the buffer becomes full, the oldest events are overwritten</p>
<p>with new events.</p>
<p>The memory buffer used to hold the event log data is found in the special program</p>
<p>section,</p>
<p>.eventlog</p>
<p>. The size of this section determines the size of the event logging</p>
<p>buffer and can be configured by changing the linker file.</p>
<p>You can store the event log in a more permanent location (for example off-board</p>
<p>memory), by modifying the ThreadX code in<b> tx_el.c</b>.</p>
<p><i>85</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Modifying the Target Event Log Location</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 12</b></p>
<p><b>Viewing Event Data</b></p>
<p><b>Contents</b></p>
<p>Launching the EventAnalyzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>88</p>
<p>The EventAnalyzer Window . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>89</p>
<p>Selecting Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>93</p>
<p>Viewing Event Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>96</p>
<p>Generating Reports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>104</p>
<p>Configuration Menu Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>104</p>
<h1 style="page-break-before:always; "></h1>
<p>Once you have collected event data for your application in a data file, you can view</p>
<p>a graphical representation of the events in the EventAnalyzer. This chapter describes</p>
<p>how to use the features of the EventAnalyzer to navigate the event log and select</p>
<p>and view event data.</p>
<p><b>Launching the EventAnalyzer</b></p>
<p>The simplest way to retrieve and view event logging data is to use one of the</p>
<p>following two methods:</p>
<p>â¢</p>
<p>From the Debugger choose<b> Tools</b> â<b> MULTI EventAnalyzer</b></p>
<p>â¢</p>
<p>From the Debugger, click the EventAnalyzer button (</p>
<p>)</p>
<p>These will automatically dump any event log data from the</p>
<p>.eventlog</p>
<p>section to</p>
<p>a file, postprocess that file, and launch the EventAnalyzer.</p>
<p>If you need to perform the event log data retrieval, postprocessing, and</p>
<p>EventAnalyzer steps separately, see âRetrieving Event Logging Data from the</p>
<p>Targetâ on page 84.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>88</i></p>
<p><i>Chapter 12. Viewing Event Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>The EventAnalyzer Window</b></p>
<p>When you launch the EventAnalyzer, the following window appears:</p>
<p>The EventAnalyzer window contains the following components:</p>
<p>â¢</p>
<p><i>Thread name region</i> â Lists each thread for which events were logged during</p>
<p>the event logging session. The first thread to appear in the data file appears at</p>
<p>the top of the list and the last at the bottom.</p>
<p>â¢</p>
<p><i>Canvas</i> â Displays a line graph covering a time range that contains the</p>
<p>following items:</p>
<p>â</p>
<p><i>Threads</i> â Represented as horizontal line segments with different colors</p>
<p>and line styles. For example, a thread that is</p>
<p>executing</p>
<p>may be</p>
<p>represented by a thick green line. A change in the line color or style</p>
<p>indicates a change in status.</p>
<p><i>89</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The EventAnalyzer Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â</p>
<p><i>Events</i> â Represented by icons along the horizontal line segments.</p>
<p>â</p>
<p><i>Context switches</i> â Represented by vertical line segments between threads.</p>
<p>The canvas reads from left (earliest event) to right (latest event). The colors</p>
<p>and styles of the line segments and the icons can be customized. You can zoom</p>
<p>into the canvas to display events in greater detail or zoom out to display events</p>
<p>over a greater time range. For more information about customizing the interface,</p>
<p>see âUsing the Legendâ on page 96.</p>
<p>â¢</p>
<p><i>Ticks display field</i> â Indicates the elapsed time. To the left of the scale, the</p>
<p>selected time unit of measure is displayed along with the scale reference time.</p>
<p>The scale reference time provides the first several numerals of the scale value</p>
<p>and the remaining numerals are found on the scale itself. For example, if the</p>
<p>ticks display field reads</p>
<p>12.34XX Seconds</p>
<p>and a point on the time scale is</p>
<p>55, the elapsed time at that point in the canvas is 12.3455 seconds. By displaying</p>
<p>numbers in this format, a greater number of axis labels can be displayed in the</p>
<p>same space.</p>
<p>â¢</p>
<p><i>Canvas coordinate fields</i> â Indicate the exact time range currently visible in</p>
<p>the canvas. Reading from left to right, the view fields display the starting time,</p>
<p>the ending time, and the total time span visible. The time unit of measure is</p>
<p>the same as that displayed in the ticks display field.</p>
<p>The starting and ending times refer only to the time currently visible in the</p>
<p>canvas and not necessarily the starting or ending time of the entire data file.</p>
<p>View coordinates may also be entered into any of the view fields. After entering</p>
<p>new coordinates, press<b> Enter</b> to update the canvas. When a new coordinate is</p>
<p>entered into a view range field, the program updates the view ending time to</p>
<p>reflect the newly selected view range.</p>
<p>â¢</p>
<p><i>Selection area coordinate fields</i> â Indicate the exact time or time range</p>
<p>currently selected in the canvas. Reading from left to right, these fields display</p>
<p>the starting time, the ending time and the total time span selected. Selection</p>
<p>coordinates may also be entered into any of the selection fields. After entering</p>
<p>new coordinates, press<b> Enter</b> to update the selection area.</p>
<p>â¢</p>
<p><i>Total time</i> â Displays the time period of the entire data file in the time unit</p>
<p>listed in the ticks display field.</p>
<p>â¢</p>
<p><i>Status bar</i> â Displays system information such as error messages and</p>
<p>application information.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>90</i></p>
<p><i>Chapter 12. Viewing Event Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p><i>Toolbar</i> â Provides shortcuts to the most commonly used functions.</p>
<p>â</p>
<p>â Opens the<b> Read From</b> dialog to read in a data file. Browse to the</p>
<p>desired data file and click<b> Read</b>. Note that the EventAnalyzer never writes</p>
<p>to the data file, so when a data file is closed, the program does not prompt</p>
<p>you to save changes. However, the program will prompt you to save</p>
<p>changes affecting the configuration file (for example, changes to the</p>
<p>viewing options made in the Legend).</p>
<p>â</p>
<p>and</p>
<p>â Modify the range displayed in the canvas to show more or</p>
<p>less time. When zooming in, one half the existing range will be displayed;</p>
<p>when zooming out, twice the range will be displayed. The center of the</p>
<p>screen remains constant when zooming. You can zoom out to display the</p>
<p>entire data file or zoom in to a range as small as 0.001 nanoseconds.</p>
<p>â</p>
<p>â Adjusts the canvas to display only the selected range. To select a</p>
<p>range, click the left mouse button and hold it down while moving your</p>
<p>cursor horizontally across the canvas. Then click this button and the canvas</p>
<p>will display the same range as the selection area.</p>
<p>â</p>
<p>â Changes the unit of measure in the ticks display field, the coordinates</p>
<p>field, the selection area coordinates field, and the time scale. With each</p>
<p>click of this button, the EventAnalyzer chooses a different measurement</p>
<p>unit (Second, Millisecond, Microsecond, or Nanosecond). By default, the</p>
<p>EventAnalyzer displays an appropriate time unit whenever the view is</p>
<p>changed. Clicking the change time unit icon overrides selections made by</p>
<p>the Auto Adjust Time Unit feature (see âTime Unit Settingsâ on page 104).</p>
<p>â</p>
<p>â Displays the<b> Legend</b> window describing the various labels used for</p>
<p>each status indicator and recorded thread. Line colors, line styles, and</p>
<p>icons can be modified (see âUsing the Legendâ on page 96).</p>
<p>â</p>
<p>â Provides advanced controls for searching events, states, and context</p>
<p>switches (see âSearch for Event, Status, and Context Switchesâ</p>
<p>on page 101).</p>
<p>â</p>
<p>â This searching feature is not available for ThreadX.</p>
<p>â</p>
<p><i>Browse history buttons</i> â Navigate to the earliest (</p>
<p>), previous (</p>
<p>),</p>
<p>next (</p>
<p>), and latest (</p>
<p>) views in your view history. The EventAnalyzer</p>
<p>stores up to 50 views. These buttons function like Back and Forward</p>
<p>buttons in a web browser.</p>
<p>â</p>
<p>â This feature is not available with ThreadX.</p>
<p><i>91</i></p>
<p><i>Green Hills Software</i></p>
<p><i>The EventAnalyzer Window</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â</p>
<p>â Launches online help.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>92</i></p>
<p><i>Chapter 12. Viewing Event Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Selecting Data</b></p>
<p>This section describes how to read the EventAnalyzer display, how to display</p>
<p>additional data about threads, events, and states, and how to customize the</p>
<p>EventAnalyzer display.</p>
<p><b>Selecting a Point in Time</b></p>
<p>To select a point in time, click the mouse pointer within the canvas. A solid vertical</p>
<p>line appears indicating a Point in Time selection. When a single point in time is</p>
<p>selected, the selection area coordinates beginning and ending fields contain the</p>
<p>same value, and the range field is zero.</p>
<p><i>93</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Selecting Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Selecting a Range of Time</b></p>
<p>To select a range of time, click the left mouse button and hold it down while moving</p>
<p>your cursor horizontally across the canvas. When a range of time is selected, the</p>
<p>selection area coordinates beginning and ending values contain different values and</p>
<p>the range field indicates the amount of time selected.</p>
<p><b>Zooming to a Range Selection</b></p>
<p>To display only the selected range in the canvas, choose<b> View</b> â<b> Zoom To Range</b></p>
<p>or click</p>
<p>after a range of time has been selected. The canvas adjusts to display</p>
<p>only the selected range.</p>
<p><b>Creating a Reference Line</b></p>
<p>To create a temporary reference line in the canvas, press the<b> Shift</b> key and click the</p>
<p>mouse pointer. This displays a vertical line that can be useful in analyzing event</p>
<p>data. The line remains for as long as the left mouse button is pressed. The temporary</p>
<p>reference line will not cancel a point in time or range of time selection.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>94</i></p>
<p><i>Chapter 12. Viewing Event Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Jumping to a Time Selection</b></p>
<p>The following mouse commands bring the mouse pointer to a selection. This is</p>
<p>useful for quickly returning to a selection when, after scrolling, that time selection</p>
<p>no longer appears within the view range.</p>
<p>â¢</p>
<p><b>Shift</b>+<b>Right-click</b> â Jumps to a point in time selection or to the start of a</p>
<p>range of time selection. If the shortcut menu appears, it can be cleared with a</p>
<p><b>Shift</b>+<b>Left-click</b>.</p>
<p>â¢</p>
<p><b>Ctrl</b>+<b>Right-click</b> â Jumps to a point in time selection or to the end of a range</p>
<p>of time selection. If the shortcut menu appears, it can be cleared with</p>
<p><b>Shift</b>+<b>Left-click</b>.</p>
<p><i>95</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Jumping to a Time Selection</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Viewing Event Data</b></p>
<p>This section describes how to customize the display of event data to show the events</p>
<p>of interest, hide events that are not of interest, and view details about specific events.</p>
<p><b>Using the Legend</b></p>
<p>The Legend provides a reference for displaying and modifying the meaning of the</p>
<p>various line colors, line styles and icons appearing in the canvas.</p>
<p>To open the legend, select<b> Config</b> â<b> Legend</b> or click</p>
<p>. The ThreadX Events</p>
<p>Legend appears:</p>
<p>The legend displays the names of all system events and thread states, the icon or</p>
<p>line style displayed for each event or status, and the visibility attribute for each</p>
<p>event or status. The event/status list is sorted by categories. In the Legend depicted</p>
<p>above,</p>
<p>Mutex</p>
<p>,</p>
<p>Misc</p>
<p>, and</p>
<p>Interrupt</p>
<p>are categories.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>96</i></p>
<p><i>Chapter 12. Viewing Event Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Note</b></p>
<p>Categories are defined in the configuration file. For information about</p>
<p>defining categories, see Chapter 13, âEventAnalyzer Configuration Filesâ</p>
<p>on page 107.</p>
<p>The Legend lists each status first and displays an example segment of its associated</p>
<p>line color and style.</p>
<p>To change an event icon, click the icon to view the MULTI internal icon library.</p>
<p>Select the desired replacement and click<b> OK</b>.</p>
<p>To modify line color and style, click the example line segment in the<b> Legend</b></p>
<p>window. The line configuration (RGB) window appears:</p>
<p>The Red, Green, and Blue fields determine the line color by the conventional RGB</p>
<p>color scheme, with values ranging from 0 to 255 for the intensity of each color.</p>
<p>Choosing the values Red 0, Green 0, Blue 0 would result in black. The RGB values</p>
<p>can be specified in hexadecimal (prefixed by</p>
<p>0x</p>
<p>) or decimal.</p>
<p>Select the desired line thickness and choose a line style from the drop-down list.</p>
<p>Click<b> OK</b> and the Legend appears with the new line color and/or style.</p>
<p>The last column of the<b> Legend</b> window displays the visibility attribute of each event</p>
<p>or status. Click the word to toggle the attribute between Visible and Invisible.</p>
<p>Invisible items do not appear in the canvas. To toggle the visibility attribute for an</p>
<p>entire category of events, click the visibility attribute of the category. Changes made</p>
<p>to event or status visibility do not actually change the data file; the invisibility</p>
<p><i>97</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Using the Legend</i></p>
<h1 style="page-break-before:always; "></h1>
<p>attribute only determines whether that event or status will be displayed in the</p>
<p>EventAnalyzer canvas.</p>
<p>The EventAnalyzer can save changes made in the EventAnalyzer legend to the</p>
<p>configuration file. If changes were made in the Legend, the EventAnalyzer will ask</p>
<p>whether to save or discard changes upon exiting the program.</p>
<p><b>View Event, and Status and Thread Details</b></p>
<p>You can double-click any icon or line in the canvas to open the object view</p>
<p>displaying detailed information about the event or status. You can also right-click</p>
<p>an event or status and choose<b> View Object</b>,<b> Zoom In</b>,<b> Zoom Out</b>, or (if a range</p>
<p>has been selected)<b> Zoom into Selection</b>. You can double-click any thread in the</p>
<p>thread name region to open the<b> Thread Info</b> dialog box displaying detailed</p>
<p>information about the thread.</p>
<p>The object view provides detailed information about a particular event, status, or</p>
<p>thread as well as advanced search capabilities to allow more ways to analyze and</p>
<p>troubleshoot the target system.</p>
<p>Multiple object views can be opened simultaneously. Choose<b> View</b> â<b> Delete Object</b></p>
<p><b>Views</b> to close all object views as well as any open<b> Search Results</b> windows.</p>
<p><b>Viewing Event Details</b></p>
<p>The<b> Event View</b> dialog box shows details of a specific event:</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>98</i></p>
<p><i>Chapter 12. Viewing Event Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>This dialog box shows the<b> Event Name</b>,<b> Thread ID</b>, and the time at which the</p>
<p>event occurred. The<b> More Info</b> field displays extra data about the event. For a list</p>
<p>of the extra data associated with all standard ThreadX services, see Chapter 14,</p>
<p>âThreadX Services Referenceâ on page 119. For information about defining and</p>
<p>logging custom events and displaying extra event information for them, see âDefining</p>
<p>Eventsâ on page 110.</p>
<p>Use the following buttons in the dialog to browse to the object view for adjacent</p>
<p>events:</p>
<p>â¢</p>
<p><b>Sequential</b> â Shows the next/previous event of any type for any thread.</p>
<p>â¢</p>
<p><b>Same Event</b> â Shows the next/previous event of the same type for any thread.</p>
<p>â¢</p>
<p><b>Same Thread</b> â Shows the next/previous event of any type for the same</p>
<p>thread.</p>
<p>â¢</p>
<p><b>Same Thread/Event</b> â Shows the next/previous event of the same type for</p>
<p>the same thread.</p>
<p>â¢</p>
<p><b>Goto Canvas</b> â Brings the EventAnalyzer canvas to the foreground and places</p>
<p>the mouse pointer on the event icon.</p>
<p><b>Viewing Status Details</b></p>
<p>The<b> Status View</b> dialog box shows details of a status line:</p>
<p>This dialog box shows the<b> Status Name</b>, the<b> Thread ID</b> of the thread to which the</p>
<p>status applies, the times at which the status started and ended, and the duration</p>
<p>(<b>Length</b>) of that status.</p>
<p><i>99</i></p>
<p><i>Green Hills Software</i></p>
<p><i>View Event, and Status and Thread Details</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Use the following buttons to navigate to the Status View for other states.</p>
<p>â¢</p>
<p><b>Same Thread</b> â Shows the next/previous status of any type for the same</p>
<p>system thread.</p>
<p>â¢</p>
<p><b>Same Thread/Status</b> â Shows the next/previous status of the same type for</p>
<p>the same thread.</p>
<p>â¢</p>
<p><b>Go</b> â Brings the EventAnalyzer canvas to the foreground and places the mouse</p>
<p>pointer on the status line.</p>
<p><b>Viewing Thread Details</b></p>
<p>The<b> Thread Info</b> dialog box shows details of a particular thread:</p>
<p>This dialog box shows the<b> Thread Name</b>, the<b> Thread ID</b>, and the priority of the</p>
<p>thread.</p>
<p>Use the<b> Prev</b> and<b> Next</b> buttons to scroll through all threads in the order they appear</p>
<p>in the thread name region.</p>
<p><b>Viewing Context Switch Details</b></p>
<p>To view details of a context switch, double-click the context switch object in the</p>
<p>canvas. The object view for a context switch displays the thread from which the</p>
<p>system changed, the thread to which it changed, and the time at which the change</p>
<p>occurred.</p>
<p>Use the<b> Prev</b> and<b> Next</b> buttons to jump sequentially between context switches</p>
<p>throughout the data file.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>100</i></p>
<p><i>Chapter 12. Viewing Event Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Click<b> Go</b> to bring the EventAnalyzer canvas to the foreground and place the mouse</p>
<p>pointer on the context switch.</p>
<p><b>Search for Event, Status, and Context Switches</b></p>
<p>The advanced search features of the EventAnalyzer enable you to scan the event</p>
<p>data for all instances of any particular event, status, or context switch. You can</p>
<p>restrict the search to a specific time range. The EventAnalyzer displays a list of</p>
<p>matching events that can be used to control the focus of the canvas. Selecting an</p>
<p>item from the list causes the canvas to jump to that item.</p>
<p>To use the search feature, select<b> View</b> â<b> Search</b> (or click</p>
<p>) to open the<b> Select</b></p>
<p><b>Threads</b> dialog box:</p>
<p>This dialog box lists all the threads recorded in the data file. Select the thread or</p>
<p>threads on which to search. Click<b> OK</b> to open the<b> Select Object Type</b> dialog box:</p>
<p><i>101</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Search for Event, Status, and Context Switches</i></p>
<h1 style="page-break-before:always; "></h1>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>102</i></p>
<p><i>Chapter 12. Viewing Event Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Choose one of the following options, specify a time range, if desired, and click<b> OK</b></p>
<p>to start the search:</p>
<p>â¢</p>
<p><b>Event</b>,<b> Event Pattern</b>, or<b> Status</b> â Opens another dialog in which you must</p>
<p>specify the event, event pattern, or status for which to search. When you click</p>
<p><b>OK</b> in this dialog, the<b> Search Results</b> window will open and display the results</p>
<p>of the search. Click any item in the list and the canvas jumps to that event,</p>
<p>event pattern, or status.</p>
<p>â¢</p>
<p><b>Context Switch</b> â Opens the<b> Search Results</b> window and displays a list of</p>
<p>all context switches for the selected thread. Click any item in the list and the</p>
<p>canvas jumps to that context switch.</p>
<p>Multiple<b> Search Results</b> windows can be open simultaneously. Choose<b> View</b> â</p>
<p><b>Delete Object Views</b> to close all<b> Search Results</b> windows as well as any open</p>
<p>object view windows.</p>
<p><b>Changing the Hidden Task List</b></p>
<p>The MULTI EventAnalyzer allows you to<i> hide</i> selected threads so that they do not</p>
<p>appear in the canvas, even though events and status changes for the thread have</p>
<p>been logged.</p>
<p>To hide threads, choose<b> View</b> â<b> Change Hidden Thread List</b> to open the Hidden</p>
<p>Task list:</p>
<p>The<b> Displayed Threads</b> are displayed on the left side of the window and the<b> Hidden</b></p>
<p><b>Threads</b> are displayed on the right. Select threads from either list, then click<b> Hide</b></p>
<p>or<b> Show</b>.</p>
<p><i>103</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Changing the Hidden Task List</i></p>
<h1 style="page-break-before:always; "></h1>
<p>The<b> Show All</b> button moves all threads to the<b> Displayed Threads</b> list. The<b> Hide</b></p>
<p><b>all</b> button moves all threads to the<b> Hidden Threads</b> list.</p>
<p>Click<b> OK</b> to apply your changes.</p>
<p><b>Generating Reports</b></p>
<p>The EventAnalyzer generates a variety of reports in user-defined time frames.</p>
<p>A report displays the number and percentage of occurrences of each event compared</p>
<p>to the total number of events in the time frame. For thread status reports, the time</p>
<p>spent in each status is displayed in time units and as a percentage of the total time</p>
<p>frame. This can be used to show how much time threads spend executing and in</p>
<p>the other states.</p>
<p>The reports are available from the<b> Report</b> menu.</p>
<p><b>Configuration Menu Operations</b></p>
<p>This section describes how to change the<b> Canvas name</b> and the time units used in</p>
<p>the canvas.</p>
<p>For information about changing the format of lines and icons in the canvas, see</p>
<p>âUsing the Legendâ on page 96.</p>
<p><b>Changing the Canvas Name</b></p>
<p>To change the canvas name (displayed in the title bar of the EventAnalyzer), select</p>
<p><b>Config</b> â<b> Canvas name</b>, enter the new canvas name, and click<b> OK</b>. The new</p>
<p>canvas name appears in the main screen.</p>
<p><b>Time Unit Settings</b></p>
<p>The unit of measure used to display times in the canvas can be seconds, milliseconds,</p>
<p>microseconds, or nanoseconds. The EventAnalyzer's Auto Adjust Time Unit feature</p>
<p>selects a time unit appropriate to the amount of data displayed in the canvas.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>104</i></p>
<p><i>Chapter 12. Viewing Event Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p>To enable or disable the Auto Adjust Time Unit feature, select<b> Config</b> â<b> Time</b></p>
<p><b>Unit</b>, select or clear the<b> Auto Adjust</b> check box, and click<b> OK</b>.</p>
<p>You can override the<b> Auto Adjust Time Unit</b> selection at any time by clicking the</p>
<p><b>Time Unit</b> icon on the toolbar one or more times to iterate through the available</p>
<p>unit options.</p>
<p><i>105</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Time Unit Settings</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 13</b></p>
<p><b>EventAnalyzer Configuration</b></p>
<p><b>Files</b></p>
<p><b>Contents</b></p>
<p>Thread Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>109</p>
<p>Defining Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>110</p>
<p>Event</p>
<p>Categories . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>113</p>
<p>Unknown Events . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>114</p>
<p>Miscellaneous Configuration Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>114</p>
<p>Reserved Keywords . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>116</p>
<h1 style="page-break-before:always; "></h1>
<p>An EventAnalyzer configuration file lists every event or status native to the ThreadX</p>
<p>RTOS and defines display properties such as the status line colors or event icons.</p>
<p>Some display parameters, such as the thread status line colors or event icons, can</p>
<p>be changed either by using the EventAnalyzer<b> Legend</b> window (see âUsing the</p>
<p>Legendâ on page 96) or by modifying the configuration file. Other parameters</p>
<p>(such as the icon used to indicate overlapping events) can only be changed by editing</p>
<p>the configuration file.</p>
<p>If your application logs user-defined events, the configuration file must be updated</p>
<p>so that the EventAnalyzer recognizes those events and includes the necessary event</p>
<p>data. For information about adding user-defined events, see âUser-Defined Eventsâ</p>
<p>on page 82.</p>
<p>The initial installation of MULTI contains a complete EventAnalyzer configuration</p>
<p>file set to default conditions. No modifications to the configuration file are required</p>
<p>to use the EventAnalyzer. To customize the display, the configuration file can be</p>
<p>edited. This chapter describes each parameter contained in the configuration file.</p>
<p>Except where noted, these parameters can also be defined using the EventAnalyzer.</p>
<p>The configuration file defines the following ThreadX events:</p>
<p>â¢</p>
<p>Thread Status</p>
<p>â¢</p>
<p>Event</p>
<p>â¢</p>
<p>Event Category</p>
<p>â¢</p>
<p>Overlap</p>
<p>You can modify the configuration file to include other events, as necessary, or to</p>
<p>change display parameters of these previously defined events.</p>
<p>Each line of the configuration file describes a single event. The following sections</p>
<p>describe the formatting conventions of each object type. The configuration file</p>
<p>format is case-insensitive.</p>
<p>The configuration file<b> threadx.mc</b> contains the ThreadX-specific configuration.</p>
<p>When the EventAnalyzer is invoked, it attempts to locate a user-specific version of</p>
<p>this file in:</p>
<p>â¢</p>
<p>Windows â<i><b> user_dir</i>\Application Data\GHS\event_analyzer\</b></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>108</i></p>
<p><i>Chapter 13. EventAnalyzer Configuration Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>Linux/Solaris â<i><b> user_dir</i>/.ghs/event_analyzer/</b></p>
<p>If a user-specific version of<b> threadx.mc</b> is not available,<b> mevgui</b> searches for the</p>
<p>file in the<b> defaults\event_analyzer\</b> subdirectory of the MULTI installation. Any</p>
<p>manual edits to the file located in the MULTI installation affect all users of the</p>
<p>installation who do not have a user-specific version of<b> threadx.mc</b>. Any changes</p>
<p>saved via the GUI cause the user-specific file to be created or updated, and do not</p>
<p>affect other users.</p>
<p><b>Thread Status</b></p>
<p>The format for defining a thread status is as follows:</p>
<p>MEV_Object:MEV_Status:<i>id</i>:<i>status_name</i>:<i>rgb</i>:<i>style</i>:<i>thickness</i>:<i>visibility</i></p>
<p>where:</p>
<p>â¢</p>
<p>MEV_Object</p>
<p>and</p>
<p>MEV_Status</p>
<p>â Are keywords and must be entered as shown</p>
<p>above for all thread status settings.</p>
<p>â¢</p>
<p><i>id</i></p>
<p>â Is an integer used to identify the thread status on the target.</p>
<p>â¢</p>
<p><i>status_name</i></p>
<p>â Is a string, such as</p>
<p>ready</p>
<p>,</p>
<p>executing</p>
<p>, or</p>
<p>terminated</p>
<p>,</p>
<p>corresponding to the thread status.</p>
<p>â¢</p>
<p><i>rgb</i></p>
<p>â Determines the status line color. Enter the hexadecimal value</p>
<p>representing the desired color.</p>
<p>â¢</p>
<p><i>style</i></p>
<p>â Refers to the line style used to represent the status of the thread in</p>
<p>the EventAnalyzer<b> Canvas</b>. The available line styles are:</p>
<p>â</p>
<p>MEV_Solid</p>
<p>â</p>
<p>MEV_Dot</p>
<p>â</p>
<p>MEV_Dash</p>
<p>â</p>
<p>MEV_DashDot</p>
<p>â</p>
<p>MEV_DashDotDot</p>
<p>â¢</p>
<p><i>thickness</i></p>
<p>â Determines the thickness of the line in pixels.</p>
<p>â¢</p>
<p><i>visibility</i></p>
<p>â Indicates whether the status will be displayed in the</p>
<p>EventAnalyzer<b> Canvas</b>. Enter either</p>
<p>MEV_Visible</p>
<p>(the default) or</p>
<p>MEV_Invisible</p>
<p>.</p>
<p><i>109</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Thread Status</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Defining Events</b></p>
<p>The format for defining an event is:</p>
<p>MEV_Event:<i>type</i>:<i>sub_type</i>:<i>event_name</i>:<i>icon_name</i>:[<i>extra_data</i>:]<i>visibility</i></p>
<p>where:</p>
<p>â¢</p>
<p>MEV_Event</p>
<p>â Is a keyword and should be entered as shown above.</p>
<p>â¢</p>
<p><i>type</i></p>
<p>and</p>
<p><i>sub_type</i></p>
<p>â Are two numbers used by ThreadX to identify an</p>
<p>event. For example a</p>
<p><i>type</i></p>
<p>of</p>
<p>0x3</p>
<p>and a</p>
<p><i>sub_type</i></p>
<p>of</p>
<p>0x16</p>
<p>corresponds to</p>
<p>the</p>
<p>tx_thread_create</p>
<p>event.</p>
<p>â¢</p>
<p><i>event_name</i></p>
<p>â Is the name of the event, such as</p>
<p>tx_byte_allocate</p>
<p>,</p>
<p>tx_event_flags_create</p>
<p>, or</p>
<p>tx_semaphore_delete</p>
<p>.</p>
<p>â¢</p>
<p><i>icon_name</i></p>
<p>â Is the name of the icon or the filename of an external graphic</p>
<p>icon file used to represent the event in the EventAnalyzer. MULTI provides</p>
<p>many built-in icons. The EventAnalyzer<b> Legend</b> window displays a list of</p>
<p>these icons and the icon names. To specify one of these icons, enter the icon's</p>
<p>name. Do not include a<b> .bmp</b> file extension.</p>
<p>You can also use an icon other than one provided by MULTI, by specifying</p>
<p>an external graphic icon filename. The file must be in the<b> .bmp</b> format. Enter</p>
<p>the filename of the graphic icon file, including the<b> .bmp</b> file extension. Enclose</p>
<p>the filename in quotation marks if it contains whitespace or a colon.</p>
<p>â¢</p>
<p><i>extra_data</i></p>
<p>â Specifies optional, additional data that can be useful in</p>
<p>understanding an event. For example, if a semaphore is created, the new</p>
<p>Semaphore ID</p>
<p>can be recorded as extra data for the logged semaphore create</p>
<p>event. Subsequent operations on the semaphore can also log the</p>
<p>Semaphore</p>
<p>ID</p>
<p>so that operations on the same semaphore can be located easily. (See the</p>
<p>next section for more information.)</p>
<p>â¢</p>
<p><i>visibility</i></p>
<p>â Indicates whether the status will be displayed in the</p>
<p>EventAnalyzer<b> Canvas</b>. Enter either</p>
<p>MEV_Visible</p>
<p>(default) or</p>
<p>MEV_Invisible</p>
<p>.</p>
<p><b>Specifying Extra Data</b></p>
<p>The event window displays extra data relating to the selected event as defined in</p>
<p>the configuration file. When an event occurs, the system logs the standard event</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>110</i></p>
<p><i>Chapter 13. EventAnalyzer Configuration Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>data (event name, thread ID, and elapsed time) and any extra data defined. This</p>
<p>extra data should be described by the configuration file. All of this data can then</p>
<p>be viewed in an EventAnalyzer event window, as pictured below.</p>
<p>The format for the</p>
<p><i>extra_data</i></p>
<p>field entry is the character sequence</p>
<p>MEV_Extra=</p>
<p>followed by a string enclosed in quotation marks.</p>
<p>Format strings of the following types are permitted:</p>
<p>â¢</p>
<p>%C</p>
<p>â Indicates that the next data item is a 1-byte character value.</p>
<p>â¢</p>
<p>%1D</p>
<p>â Indicates that the next data item is a 1-byte integer displayed as a</p>
<p>decimal value.</p>
<p>â¢</p>
<p>%1X</p>
<p>â Indicates that the next data item is a 1-byte integer displayed as a</p>
<p>hexadecimal value.</p>
<p>â¢</p>
<p>%2D</p>
<p>â Indicates that the next data item is a 2-byte integer displayed as a</p>
<p>decimal value.</p>
<p>â¢</p>
<p>%2X</p>
<p>â Indicates that the next data item is a 2-byte integer displayed as a</p>
<p>hexadecimal value.</p>
<p>â¢</p>
<p>%4D</p>
<p>â Indicates that the next data item is a 4-byte integer displayed as a</p>
<p>decimal value.</p>
<p>â¢</p>
<p>%4X</p>
<p>â Indicates that the next data item is a 4-byte integer displayed as a</p>
<p>hexadecimal value.</p>
<p>â¢</p>
<p>%S</p>
<p>â Indicates that the next data item is an array of a basic type. Arrays can</p>
<p>be specified as:</p>
<p><i>111</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Specifying Extra Data</i></p>
<h1 style="page-break-before:always; "></h1>
<p><i>array_length</i>%S<i>array_element</i></p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>112</i></p>
<p><i>Chapter 13. EventAnalyzer Configuration Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>where:</p>
<p>â</p>
<p><i>array_length</i></p>
<p>is a data item that indicates the length of the array.</p>
<p>â</p>
<p><i>array_element</i></p>
<p>is a data item that indicates the type of each array</p>
<p>element.</p>
<p>For example, a character string whose length is specified as a 4-byte integer is</p>
<p>expressed as:</p>
<p>%4X%S1C</p>
<p>Some examples of extra data configurations follow:</p>
<p>...:MEV_Extra=&quot;queue_ptr=%4X&quot;:...</p>
<p>...:MEV_Extra=&quot;semaphore_ptr=%4X initial_value=%4X&quot;:...</p>
<p><b>Event Categories</b></p>
<p>The EventAnalyzer allows related events to be grouped into categories. The format</p>
<p>for defining an event category is:</p>
<p>MEV_Event_Category:<i>category_name</i>:<i>visibility</i></p>
<p>where:</p>
<p>â¢</p>
<p>MEV_Event_Category</p>
<p>â Is a keyword and should be entered in the</p>
<p>configuration file as shown above.</p>
<p>â¢</p>
<p><i>category_name</i></p>
<p>â Is the name of the category as defined by the user. Some</p>
<p>examples of event categories in the ThreadX kernel are</p>
<p>Block Pool</p>
<p>,</p>
<p>Event</p>
<p>Flags</p>
<p>, and</p>
<p>Queue</p>
<p>.</p>
<p>â¢</p>
<p><i>visibility</i></p>
<p>â Indicates whether or not the threads within the category will</p>
<p>be displayed in the EventAnalyzer<b> Canvas</b>. If not defined, the default value is</p>
<p>MEV_Visible</p>
<p>. Categories that include visible and invisible objects require no</p>
<p>visibility distinction. The attribute selected at the category level applies to all</p>
<p>the events in that category. Category and object visibility can also be modified</p>
<p>from the<b> Legend</b> window.</p>
<p><i>113</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Event Categories</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Below the category definition line, list each of the events to be included in that</p>
<p>category. For example:</p>
<p>MEV_Event_Category:Thread:MEV_Visible</p>
<p>MEV_Event:0x3:0x16:tx_thread_create:tx_t_create:MEV_Extra=&quot;thread_ptr=</p>
<p>%4X statck_start=%4X stack_size=%4X priority=%4X&quot;:MEV_Visible</p>
<p>MEV_Event:0x3:0x17:tx_thread_delete:tx_t_delete:MEV_Extra=&quot;thread_ptr=</p>
<p>%4X&quot;:MEV_Visible</p>
<p>All events following an event category definition are considered to be part of the</p>
<p>event category, until another event category is defined.</p>
<p>An event can be included in multiple event categories. To do this, include a</p>
<p>description line for the event in each category. In case of conflicting event</p>
<p>definitions, the event description line appearing last in the configuration file</p>
<p>determines the visibility attribute of the object.</p>
<p><b>Unknown Events</b></p>
<p>The EventAnalyzer employs an</p>
<p>unknown</p>
<p>object to represent any events or states</p>
<p>not defined, or not defined fully in the ThreadX configuration file.</p>
<p>You can also specify</p>
<p>unknown</p>
<p>as the type for any object, for example:</p>
<p>MEV_Object:MEV_Status:0xa:unknown:0xff0000:MEV_Solid:5:MEV_Visible</p>
<p>MEV_Event:0x0:0x0:unknown:questionmark:MEV_Visible</p>
<p><b>Miscellaneous Configuration Options</b></p>
<p><b>Event Overlap Icon</b></p>
<p>If two events occur within a short amount of time, the event icons may overlap in</p>
<p>the display and, as a result, be difficult to read. By modifying the overlap setting,</p>
<p>the EventAnalyzer can display a single icon indicating that two or more icons</p>
<p>overlap. The correct event icons will be shown when the display is expanded to a</p>
<p>resolution at which the icons no longer overlap</p>
<p>Using the overlap feature increases the redraw speed in the canvas.</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>114</i></p>
<p><i>Chapter 13. EventAnalyzer Configuration Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>By default, event overlap is not enabled. It can be enabled by setting the icon as</p>
<p>described below. The format is as follows:</p>
<p>MEV_Misc:MEV_Overlap:<i>icon_name</i></p>
<p>The<b> Legend</b> window displays all the available icons and their filenames. Select an</p>
<p>appropriate icon from the<b> Legend</b> and enter its name in the</p>
<p><i>icon_name</i></p>
<p>section of</p>
<p>the overlap icon definition in the configuration file.</p>
<p>The overlap icon definition is a special entry in the configuration file that cannot</p>
<p>be changed using the<b> Legend</b> window at run time. Therefore, this feature must be</p>
<p>enabled or disabled prior to starting the EventAnalyzer.</p>
<p><b>Status Line Position</b></p>
<p>If the</p>
<p>MEV_Center_Status</p>
<p>option is true, status lines are vertically centered behind</p>
<p>event icons. If this option is false, status lines are displayed below event icons. This</p>
<p>option defaults to false, but the default configuration file sets it to true.</p>
<p>The format for this option is:</p>
<p>MEV_Misc:MEV_Center_Status:true|false</p>
<p><b>Tick Value Display</b></p>
<p>If the</p>
<p>MEV_Tick_Pattern</p>
<p>option is true, common digits in tick values are displayed</p>
<p>in the ticks display field, as described in âThe EventAnalyzer Windowâ on page 89.</p>
<p>If this option is false, the full tick value is displayed in the canvas. This option</p>
<p>defaults to true.</p>
<p>The format for this option is:</p>
<p>MEV_Misc:MEV_Tick_Pattern:true|false</p>
<p><i>115</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Status Line Position</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Warning for Unused Extra Data</b></p>
<p>If the</p>
<p>MEV_Unused_Extra_Data_Warning</p>
<p>option is true, a warning is printed</p>
<p>when an event contains</p>
<p><i>extra_data</i></p>
<p>that is not specified in the corresponding</p>
<p>MEV_Event</p>
<p>entry. If this option is false, no warning is printed. This option defaults</p>
<p>to true.</p>
<p>The format for this option is:</p>
<p>MEV_Misc:MEV_Unused_Extra_Data_Warning:true|false</p>
<p><b>Warning for Missing Extra Data</b></p>
<p>If the</p>
<p>MEV_Extra_Data_Warning</p>
<p>option is true, a warning is printed when an</p>
<p>MEV_Event</p>
<p>entry specifies</p>
<p><i>extra_data</i></p>
<p>that is not contained in the event. If this</p>
<p>option is false, no warning is printed. This option defaults to true, but the default</p>
<p>configuration file sets it to false.</p>
<p>The format for this option is:</p>
<p>MEV_Misc:MEV_Extra_Data_Warning:true|false</p>
<p><b>Reserved Keywords</b></p>
<p>The EventAnalyzer configuration file reserves the following keywords:</p>
<p>â¢</p>
<p>MEV_Object</p>
<p>â¢</p>
<p>MEV_Event_Category</p>
<p>â¢</p>
<p>MEV_Event</p>
<p>â¢</p>
<p>MEV_Status</p>
<p>â¢</p>
<p>MEV_Misc</p>
<p>â¢</p>
<p>Context Switch</p>
<p>â¢</p>
<p>running</p>
<p>â¢</p>
<p>MEV_Visible</p>
<p>â¢</p>
<p>MEV_Invisible</p>
<p>â¢</p>
<p>unknown</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>116</i></p>
<p><i>Chapter 13. EventAnalyzer Configuration Files</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>MEV_Refresh_Interval</p>
<p><i>117</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Reserved Keywords</i></p>
<h1 style="page-break-before:always; "></h1>
<h1 style="page-break-before:always; "></h1>
<p><b>Chapter 14</b></p>
<p><b>ThreadX Services Reference</b></p>
<p><b>Contents</b></p>
<p>Memory Block Pool Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>120</p>
<p>Memory Byte Pool Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>121</p>
<p>Event Flags Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>122</p>
<p>Interrupt Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>123</p>
<p>Mutex Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>123</p>
<p>Message Queue Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>124</p>
<p>Semaphore Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>125</p>
<p>Thread Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>126</p>
<p>Application Timer Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .</p>
<p>128</p>
<h1 style="page-break-before:always; "></h1>
<p>This chapter lists each ThreadX service in alphabetical order and provides the extra</p>
<p>data included for that service. For example, when a semaphore operation is</p>
<p>performed, the extra data indicates which semaphore is being operated upon.</p>
<p><b>Memory Block Pool Services</b></p>
<p>â¢</p>
<p>â</p>
<p>tx_block_allocate</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the block pool control block</p>
<p>â</p>
<p><b>Pointer Address</b> â Address of the return block pointer</p>
<p>â</p>
<p><b>Block Address</b> â Address of the block allocated</p>
<p>â¢</p>
<p>â</p>
<p>tx_block_pool_create</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the block pool control block</p>
<p>â</p>
<p><b>Pool Memory Area Address</b> â Address of the block pool memory area</p>
<p>â</p>
<p><b>Pool Size</b> â Number of bytes in the block pool</p>
<p>â¢</p>
<p>â</p>
<p>tx_block_pool_delete</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the block pool control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_block_pool_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the block pool control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_block_pool_performance_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the block pool control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_block_pool_performance_system_info_get</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p>â¢</p>
<p>â</p>
<p>tx_block_pool_prioritize</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the block pool control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_block_release</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the block pool control block</p>
<p>â</p>
<p><b>Block Address</b> â Address of the block being released</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>120</i></p>
<p><i>Chapter 14. ThreadX Services Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Memory Byte Pool Services</b></p>
<p>â¢</p>
<p>â</p>
<p>tx_byte_allocate</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the byte pool control block</p>
<p>â</p>
<p><b>Pointer Address</b> â Address of the return memory pointer</p>
<p>â</p>
<p><b>Request Size</b> â Number of bytes in the request</p>
<p>â</p>
<p><b>Memory Address</b> â Address of the memory being allocated</p>
<p>â¢</p>
<p>â</p>
<p>tx_byte_pool_create</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the byte pool control block</p>
<p>â</p>
<p><b>Pool Memory Area Address</b> â Address of the byte pool memory area</p>
<p>â</p>
<p><b>Pool Size</b> â Number of bytes in the byte pool memory area</p>
<p>â¢</p>
<p>â</p>
<p>tx_byte_pool_delete</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the byte pool control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_byte_pool_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the byte pool control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_byte_pool_performance_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the byte pool control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_byte_pool_performance_system_info_get</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p>â¢</p>
<p>â</p>
<p>tx_byte_pool_prioritize</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the byte pool control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_byte_release</p>
<p>:</p>
<p>â</p>
<p><b>Pool Address</b> â Address of the byte pool control block</p>
<p>â</p>
<p><b>Memory Address</b> â Address of the memory being released</p>
<p><i>121</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Memory Byte Pool Services</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Event Flags Services</b></p>
<p>â¢</p>
<p>â</p>
<p>tx_event_flags_create</p>
<p>:</p>
<p>â</p>
<p><b>Event Group</b> â Pointer to event flags group control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_event_flags_delete</p>
<p>:</p>
<p>â</p>
<p><b>Event Group</b> â Pointer to event flags group control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_event_flags_get</p>
<p>:</p>
<p>â</p>
<p><b>Event Group</b> â Pointer to event flags group control block</p>
<p>â</p>
<p><b>Requested Flags</b> â Flags requested for the get operation</p>
<p>â</p>
<p><b>Option</b> â Get option that was specified</p>
<p>â¢</p>
<p>â</p>
<p>tx_event_flags_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Event Group</b> â Pointer to event flags group control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_event_flags_performance_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Event Group</b> â Pointer to event flags group control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_event_flags_performance_system_info_get</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p>â¢</p>
<p>â</p>
<p>tx_event_flags_set</p>
<p>:</p>
<p>â</p>
<p><b>Event Group</b> â Pointer to event flags group control block</p>
<p>â</p>
<p><b>Flags</b> â Flags to apply to the event flags group</p>
<p>â</p>
<p><b>Option</b> â Set option that was specified</p>
<p>â¢</p>
<p>â</p>
<p>tx_event_flags_set_notify</p>
<p>:</p>
<p>â</p>
<p><b>Event Group</b> â Pointer to event flags group control block</p>
<p>â</p>
<p><b>Notify</b> â Pointer to notification callback function</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>122</i></p>
<p><i>Chapter 14. ThreadX Services Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Interrupt Services</b></p>
<p>â¢</p>
<p>â</p>
<p>tx_interrupt_control</p>
<p>:</p>
<p>â</p>
<p><b>New Posture</b> â New interrupt posture to apply</p>
<p><b>Mutex Services</b></p>
<p>â¢</p>
<p>â</p>
<p>tx_mutex_create</p>
<p>:</p>
<p>â</p>
<p><b>Mutex Pointer</b> â Pointer to the mutex control block</p>
<p>â</p>
<p><b>Priority Inheritance</b> â Priority inheritance setting</p>
<p>â¢</p>
<p>â</p>
<p>tx_mutex_delete</p>
<p>:</p>
<p>â</p>
<p><b>Mutex Pointer</b> â Pointer to the mutex control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_mutex_get</p>
<p>:</p>
<p>â</p>
<p><b>Mutex Pointer</b> â Pointer to the mutex control block</p>
<p>â</p>
<p><b>Owner</b> â Pointer to the thread control block of the mutex owner</p>
<p>â</p>
<p><b>Ownership Count</b> â Current mutex ownership count</p>
<p>â¢</p>
<p>â</p>
<p>tx_mutex_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Mutex Pointer</b> â Pointer to the mutex control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_mutex_performance_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Mutex Pointer</b> â Pointer to the mutex control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_mutex_performance_system_info_get</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p>â¢</p>
<p>â</p>
<p>tx_mutex_prioritize</p>
<p>:</p>
<p>â</p>
<p><b>Mutex Pointer</b> â Pointer to the mutex control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_mutex_put</p>
<p>:</p>
<p>â</p>
<p><b>Mutex Pointer</b> â Pointer to the mutex control block</p>
<p>â</p>
<p><b>Owner</b> â Pointer to the thread control block of the mutex owner</p>
<p>â</p>
<p><b>Ownership Count</b> â Current mutex ownership count</p>
<p><i>123</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Interrupt Services</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Message Queue Services</b></p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_create</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p>â</p>
<p><b>Queue Address</b> â Address of the start of the queue memory area</p>
<p>â</p>
<p><b>Queue Size</b> â Size of queue memory area</p>
<p>â</p>
<p><b>Message Size</b> â Size of queue messages</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_delete</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_flush</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_front_send</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p>â</p>
<p><b>Source Address</b> â Pointer to the message to send</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_performance_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_performance_system_info_get</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_prioritize</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_receive</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p>â</p>
<p><b>Destination Address</b> â Pointer to the receive message destination</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_send</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p>â</p>
<p><b>Source Address</b> â Pointer to the message to send</p>
<p>â¢</p>
<p>â</p>
<p>tx_queue_send_notify</p>
<p>:</p>
<p>â</p>
<p><b>Queue Pointer</b> â Pointer to the queue control block</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>124</i></p>
<p><i>Chapter 14. ThreadX Services Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â</p>
<p><b>Notify</b> â Pointer to notification callback function</p>
<p><b>Semaphore Services</b></p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_ceiling_put</p>
<p>:</p>
<p>â</p>
<p><b>Semaphore Pointer</b> â Pointer to the semaphore control block</p>
<p>â</p>
<p><b>Current Count</b> â Current semaphore count</p>
<p>â</p>
<p><b>Ceiling</b> â Maximum limit</p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_create</p>
<p>:</p>
<p>â</p>
<p><b>Semaphore Pointer</b> â Pointer to the semaphore control block</p>
<p>â</p>
<p><b>Initial Count</b> â The initial semaphore count</p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_delete</p>
<p>:</p>
<p>â</p>
<p><b>Semaphore Pointer</b> â Pointer to the semaphore control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_get</p>
<p>:</p>
<p>â</p>
<p><b>Semaphore Pointer</b> â Pointer to the semaphore control block</p>
<p>â</p>
<p><b>Current Count</b> â Current semaphore count</p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Semaphore Pointer</b> â Pointer to the semaphore control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_performance_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Semaphore Pointer</b> â Pointer to the semaphore control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_performance_system_info_get</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_prioritize</p>
<p>:</p>
<p>â</p>
<p><b>Semaphore Pointer</b> â Pointer to the semaphore control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_put</p>
<p>:</p>
<p>â</p>
<p><b>Semaphore Pointer</b> â Pointer to the semaphore control block</p>
<p>â</p>
<p><b>Current Count</b> â Current semaphore count</p>
<p>â¢</p>
<p>â</p>
<p>tx_semaphore_put_notify</p>
<p>:</p>
<p>â</p>
<p><b>Semaphore Pointer</b> â Pointer to the semaphore control block</p>
<p>â</p>
<p><b>Notify</b> â Pointer to notification callback function</p>
<p><i>125</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Semaphore Services</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Thread Services</b></p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_create</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block</p>
<p>â</p>
<p><b>Stack Starting Address</b> â Starting memory address of the thread's stack</p>
<p>â</p>
<p><b>Stack Size</b> â Size of threadâs stack in bytes</p>
<p>â</p>
<p><b>Priority</b> â Threadâs priority</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_delete</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_entry_exit_notify</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block</p>
<p>â</p>
<p><b>Notify</b> â Pointer to notification callback function</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_identify</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_performance_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_performance_system_info_get</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_preemption_change</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block</p>
<p>â</p>
<p><b>Previous Threshold</b> â Old preemption threshold</p>
<p>â</p>
<p><b>New Threshold</b> â New preemption threshold</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_priority_change</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block</p>
<p>â</p>
<p><b>Previous Priority</b> â Old priority</p>
<p>â</p>
<p><b>New Priority</b> â New priority</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_relinquish</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>126</i></p>
<p><i>Chapter 14. ThreadX Services Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p>â¢</p>
<p>â</p>
<p>tx_thread_reset</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block to reset</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_resume</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block to resume</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_sleep</p>
<p>:</p>
<p>â</p>
<p><b>Ticks</b> â Number of ticks to sleep</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_stack_error_notify</p>
<p>:</p>
<p>â</p>
<p><b>Notify</b> â Pointer to notification callback function</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_suspend</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block to suspend</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_terminate</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block to terminate</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_time_slice_change</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block</p>
<p>â</p>
<p><b>Previous Time-slice</b> â Threadâs old time-slice</p>
<p>â</p>
<p><b>New Time-slice</b> â Threadâs new time-slice</p>
<p>â¢</p>
<p>â</p>
<p>tx_thread_wait_abort</p>
<p>:</p>
<p>â</p>
<p><b>Thread Pointer</b> â Pointer to the thread control block</p>
<p><i>127</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Thread Services</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Application Timer Services</b></p>
<p>â¢</p>
<p>â</p>
<p>tx_time_get</p>
<p>:</p>
<p>â</p>
<p><b>Current Time</b> â Current time (tick) count</p>
<p>â¢</p>
<p>â</p>
<p>tx_time_set</p>
<p>:</p>
<p>â</p>
<p><b>New time</b> â New time (tick) count</p>
<p>â¢</p>
<p>â</p>
<p>tx_timer_activate</p>
<p>:</p>
<p>â</p>
<p><b>Timer Pointer</b> â Pointer to the timer control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_timer_change</p>
<p>:</p>
<p>â</p>
<p><b>Timer Pointer</b> â Pointer to the timer control block</p>
<p>â</p>
<p><b>Initial Ticks</b> â Number of ticks before initial expiration</p>
<p>â</p>
<p><b>Reschedule Ticks</b> â Number of ticks for subsequent expirations</p>
<p>â¢</p>
<p>â</p>
<p>tx_timer_create</p>
<p>:</p>
<p>â</p>
<p><b>Timer Pointer</b> â Pointer to the timer control block</p>
<p>â</p>
<p><b>Initial Ticks</b> â Number of ticks before initial expiration</p>
<p>â</p>
<p><b>Reschedule Ticks</b> â Number of ticks for subsequent expirations</p>
<p>â</p>
<p><b>Activate</b> â Auto-activation selection</p>
<p>â¢</p>
<p>â</p>
<p>tx_timer_deactivate</p>
<p>:</p>
<p>â</p>
<p><b>Timer Pointer</b> â Pointer to the timer control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_timer_delete</p>
<p>:</p>
<p>â</p>
<p><b>Timer Pointer</b> â Pointer to the timer control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_timer_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Timer Pointer</b> â Pointer to the timer control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_timer_performance_info_get</p>
<p>:</p>
<p>â</p>
<p><b>Timer Pointer</b> â Pointer to the timer control block</p>
<p>â¢</p>
<p>â</p>
<p>tx_timer_performance_system_info_get</p>
<p>:</p>
<p>â</p>
<p>(No extra information)</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>128</i></p>
<p><i>Chapter 14. ThreadX Services Reference</i></p>
<h1 style="page-break-before:always; "></h1>
<p><b>Index</b></p>
<p><b>A</b></p>
<p>alignment restrictions, 6</p>
<p>application timers, ix, 66</p>
<p><b>B</b></p>
<p>Block Pool Contents window, 55</p>
<p>window components</p>
<p>Address, 56</p>
<p>Block Pool Name, 55</p>
<p>Block Pool Name button, 55</p>
<p>Memory Block List, 56</p>
<p>Status, 56</p>
<p>Block Pool Information window, 10, 52</p>
<p>window components</p>
<p>Block Pool List button, 54</p>
<p>Block Pool Name, 52</p>
<p>Block Size, 53</p>
<p>Control Block, 53</p>
<p>Control Block button, 53</p>
<p>First Available, 53</p>
<p>In Use, 53</p>
<p>In Use button, 53</p>
<p>Pool Size, 53</p>
<p>Suspended Threads, 53</p>
<p>Suspended Threads List, 54</p>
<p>Block Pool List window, 50</p>
<p>window components</p>
<p>Block Size, 51</p>
<p>Full, 51</p>
<p>Name, 50</p>
<p>Suspended, 51</p>
<p>byte alignment, 6</p>
<p>Byte Pool Contents window, 62</p>
<p>window components</p>
<p>Address, 63</p>
<p>Byte Pool Name, 62</p>
<p>Byte Pool Name button, 62</p>
<p>Memory Byte List, 63</p>
<p>Size, 63</p>
<p>Status, 63</p>
<p>Byte Pool Information window, 10, 59</p>
<p>window components</p>
<p>Byte Pool List button, 61</p>
<p>Byte Pool Name, 60</p>
<p>Control Block, 60</p>
<p>Control Block button, 60</p>
<p>Fragments, 60</p>
<p>In Use, 60</p>
<p>In Use button, 60</p>
<p>Memory Start, 60</p>
<p>Search Address, 60</p>
<p>Suspended Threads, 60</p>
<p>Suspended Threads List, 61</p>
<p>Byte Pool List window, 58</p>
<p>window components</p>
<p>Full, 58</p>
<p>Name, 58</p>
<p>Suspended, 59</p>
<p><b>C</b></p>
<p>component view, 21</p>
<p>conventions</p>
<p>typographical, x</p>
<p>Current Thread Information window, 23</p>
<p><b>D</b></p>
<p>debugging, 4</p>
<p>kernel-aware, ix</p>
<p>multithreaded, 14</p>
<p>performance, 10</p>
<p>thread-aware, ix</p>
<p>ThreadX applications, 4</p>
<p>with Thread List window, 14</p>
<p>document set, viii, ix</p>
<p><b>E</b></p>
<p>event flags groups, ix, 44</p>
<p>control block address, 46</p>
<p>count, 8</p>
<p>name, 44, 45</p>
<p>status, 44, 46</p>
<p>Event Flags Information window, 45</p>
<p>window components</p>
<p>Control Block, 46</p>
<p>Control Block button, 46</p>
<p>Current Event Flags, 46</p>
<p>Event Flags List button, 47</p>
<p>Event Flags Name, 45</p>
<p>Suspended Threads, 46</p>
<h1 style="page-break-before:always; "></h1>
<p>Suspended Threads List, 47</p>
<p>Event Flags List window, 44</p>
<p>window components</p>
<p>Flags, 44</p>
<p>Name, 44</p>
<p>Suspended, 45</p>
<p>event icons</p>
<p>customizing, 110</p>
<p>EventAnalyzer</p>
<p>configuring, 104, 108</p>
<p>defining events, 110</p>
<p>event logging for, 78, 80</p>
<p>filtering event logging for, 80</p>
<p>hidden tasks, 103</p>
<p>Introduction, 74</p>
<p>launching, 88</p>
<p>reports, 104</p>
<p>reserved keywords, 116</p>
<p>retrieving event data, 84</p>
<p>searching, 101</p>
<p>selecting data, 93</p>
<p>threads, number to support, 80</p>
<p>ThreadX services, 120</p>
<p>unknown events, 114</p>
<p>user-defined events, 82</p>
<p>using the legend, 96</p>
<p>viewing context switch details, 100</p>
<p>viewing event data, 88</p>
<p>viewing event details, 98</p>
<p>viewing status details, 99</p>
<p>viewing thread details, 100</p>
<p>EventAnalyzer, MULTI, 10</p>
<p>Express Logic, Inc., ix</p>
<p><b>F</b></p>
<p>fragments</p>
<p>address, 63</p>
<p>size, 63</p>
<p>status, 63</p>
<p>Freeze button, 5, 10</p>
<p>freezing windows, 10</p>
<p><b>K</b></p>
<p>kernel components, ix</p>
<p>application timers, ix, 66</p>
<p>event flags groups, ix, 44</p>
<p>memory block pools, ix, 50</p>
<p>memory byte pools, ix, 58</p>
<p>message queues, ix, 28</p>
<p>mutexes, ix, 38</p>
<p>semaphores, ix, 34</p>
<p>threads, ix, 14</p>
<p><b>M</b></p>
<p>memory allocation</p>
<p>analyzing, 10</p>
<p>memory block pools, ix, 10, 50</p>
<p>address, 56</p>
<p>allocated, 51, 53</p>
<p>available, 53</p>
<p>control block address, 53</p>
<p>count, 8</p>
<p>list of memory blocks, 56</p>
<p>name, 50, 52, 55</p>
<p>size, 51, 53</p>
<p>status, 56</p>
<p>memory byte pools, ix, 10, 58</p>
<p>allocated, 58, 60</p>
<p>control block address, 60</p>
<p>count, 8</p>
<p>fragments, 60, 63</p>
<p>name, 58, 60, 62</p>
<p>pointer, 60</p>
<p>suspended, 59</p>
<p>unallocated fragment, 60</p>
<p>memory view, 20</p>
<p>messages</p>
<p>address, 30</p>
<p>control block address, 31</p>
<p>name, 30</p>
<p>queue count, 7</p>
<p>queue read address, 30</p>
<p>queue start address, 30</p>
<p>queue write address, 30</p>
<p>queues, ix, 28, 30</p>
<p>size, 28, 30</p>
<p>total in queue, 29</p>
<p>MULTI</p>
<p>document set, ix</p>
<p>starting, 4</p>
<p>MULTI EventAnalyzer, 10</p>
<p>Mutex Information window, 39</p>
<p>window components</p>
<p>Control Block, 40</p>
<p>Control Block button, 40</p>
<p>Mutex List button, 41</p>
<p>Mutex Name, 40</p>
<p>Original Priority (PT), 40</p>
<p>Owner, 40</p>
<p>Owner button, 40</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>130</i></p>
<p><i>Event Flags Information window (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Ownership Count, 40</p>
<p>Priority Inheritance, 40</p>
<p>Suspended Threads, 40</p>
<p>Suspended Threads List, 41</p>
<p>Mutex List window, 38</p>
<p>window components</p>
<p>Count, 39</p>
<p>Name, 38</p>
<p>Owner, 38</p>
<p>Suspended, 39</p>
<p>mutexes, ix, 38</p>
<p>control block address, 40</p>
<p>count, 8, 39</p>
<p>name, 40</p>
<p>owner, 38, 40</p>
<p>owner thread, 40</p>
<p>ownership count, 40</p>
<p>priority inheritance, 40</p>
<p><b>P</b></p>
<p>peak stack checking, 9</p>
<p>performance</p>
<p>debugging, 10</p>
<p><b>Q</b></p>
<p>Queue Information window, 29</p>
<p>window components</p>
<p>Control Block, 31</p>
<p>Control Block button, 31</p>
<p>Filled, 30</p>
<p>Message Size, 30</p>
<p>Queue End, 30</p>
<p>Queue List button, 31</p>
<p>Queue Name, 30</p>
<p>Read, 30</p>
<p>Read button, 30</p>
<p>Start, 30</p>
<p>Start button, 30</p>
<p>Suspended Threads, 31</p>
<p>Suspended Threads List, 31</p>
<p>Write, 30</p>
<p>Write button, 30</p>
<p>Queue List window, 28</p>
<p>window components</p>
<p>Full, 29</p>
<p>Msg Size, 28</p>
<p>Name, 28</p>
<p>Suspended, 29</p>
<p><b>S</b></p>
<p>Semaphore Information window, 35</p>
<p>window components</p>
<p>Control Block, 36</p>
<p>Control Block button, 36</p>
<p>Semaphore Count, 36</p>
<p>Semaphore List button, 36</p>
<p>Semaphore Name, 35</p>
<p>Suspended Threads, 36</p>
<p>Suspended Threads List, 36</p>
<p>Semaphore List window, 34</p>
<p>window components</p>
<p>Count, 34</p>
<p>Name, 34</p>
<p>Suspended, 35</p>
<p>semaphores, ix, 34</p>
<p>control block, 36</p>
<p>count, 7, 34, 36</p>
<p>name, 34, 35</p>
<p>Stack Check Information window, 9, 25</p>
<p>window components</p>
<p>Peak Stack Use, 26</p>
<p>Thread Name, 25</p>
<p>stack checking, 9</p>
<p>disabling maximum checking, 9</p>
<p>enabling maximum checking, 9</p>
<p>stack pointer, system, 9</p>
<p>stack range, 20</p>
<p>stack use, 9, 25</p>
<p>checking, 9</p>
<p>peak, 25, 26</p>
<p>starting MULTI, 4</p>
<p>system clock, 9</p>
<p>system variables, 7, 8, 9</p>
<p><b>T</b></p>
<p>Thread Information window, 19</p>
<p>window components</p>
<p>Condition, 22</p>
<p>Control Block, 22</p>
<p>Control Block button, 22</p>
<p>Current PC, 20</p>
<p>Current PC button, 20</p>
<p>Current SP, 20</p>
<p>Current SP button, 20</p>
<p>Entry Point, 22</p>
<p>Entry Point button, 22</p>
<p>Execution State, 21</p>
<p>Name, 21</p>
<p>Name button, 21</p>
<p><i>131</i></p>
<p><i>Green Hills Software</i></p>
<p><i>Mutex Information window (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>Priority (PT), 20</p>
<p>Run Count, 22</p>
<p>Stack Check button, 23</p>
<p>Stack Extent, 20</p>
<p>Stack Use, 20</p>
<p>Suspended on, 21</p>
<p>Thread List button, 23</p>
<p>Thread Name, 20</p>
<p>Time Slice, 21</p>
<p>Timeout, 22</p>
<p>Thread List window, 14, 15</p>
<p>window components</p>
<p>Name, 15</p>
<p>Priority, 16</p>
<p>Run Count, 16</p>
<p>Stack Use, 16</p>
<p>State, 15</p>
<p>Suspended On, 16</p>
<p>Thread ID, 15</p>
<p>Thread Ready List window, 17</p>
<p>window components</p>
<p>Name, 17</p>
<p>Stack Use, 18</p>
<p>State, 17</p>
<p>Time Slice, 18</p>
<p>Thread Stack Check List window, 9, 24</p>
<p>window components</p>
<p>Current Use, 25</p>
<p>Name, 24</p>
<p>Peak Use, 25</p>
<p>threads, ix, 14</p>
<p>component type, 16, 21</p>
<p>control block address, 22</p>
<p>count, 7</p>
<p>execution state, 8, 15, 17, 21</p>
<p>function name, 20, 22</p>
<p>information, 19, 22</p>
<p>name, 15, 17, 20, 21, 24, 25, 28, 38</p>
<p>number supported, 80</p>
<p>priority, 16, 20</p>
<p>run count, 16</p>
<p>scheduling, 22</p>
<p>stack pointer, 20</p>
<p>stack range, 20</p>
<p>stack use, 16, 18, 20</p>
<p>suspended, 16, 21, 29, 31, 35, 36, 39, 40, 41, 45, 46, 47, </p>
<p>51, 53, 54, 60, 61</p>
<p>thread ID, 15</p>
<p>ThreadX, ix</p>
<p>debugging with MULTI, ix, 4</p>
<p>ThreadX Information window, 5, 6</p>
<p>window components</p>
<p>Application Timers button, 8</p>
<p>Application Timers Count, 8</p>
<p>Block Pools button, 8</p>
<p>Block Pools Count, 8</p>
<p>Byte Pools button, 8</p>
<p>Byte Pools Count, 8</p>
<p>Current Thread, 8</p>
<p>Current Thread button, 8</p>
<p>Event Flag Groups button, 8</p>
<p>Message Queues button, 7</p>
<p>Message Queues Count, 7</p>
<p>Mutexes button, 8</p>
<p>Mutexes Count, 8</p>
<p>Ready List button, 8</p>
<p>Semaphores button, 7</p>
<p>Semaphores Count, 7</p>
<p>Stack Check List button, 8</p>
<p>System Clock, 9</p>
<p>System SP, 9</p>
<p>Threads button, 7</p>
<p>Threads Count, 7</p>
<p>Version ID, 8</p>
<p>timeout values, 6</p>
<p>Timer Information window, 68</p>
<p>window components</p>
<p>Callback, 69</p>
<p>Callback button, 69</p>
<p>Control Block, 69</p>
<p>Control Block button, 69</p>
<p>Parameter, 69</p>
<p>State, 69</p>
<p>Ticks, 68</p>
<p>Timer List button, 69</p>
<p>Timer Name, 68</p>
<p>Timer List window, 66</p>
<p>window components</p>
<p>Callback, 67</p>
<p>Name, 66</p>
<p>Ticks, 67</p>
<p>timer ticks, 18, 21, 22, 67, 68</p>
<p>timers, application, ix, 66</p>
<p>control block address, 69</p>
<p>count, 8</p>
<p>name, 66, 67, 68, 69</p>
<p>parameter passed to callback function, 69</p>
<p>state, 69</p>
<p>TX_EL_ENABLE_ALL_EVENTS, 82</p>
<p>TX_EL_FILTER_ALL_EVENTS, 82</p>
<p>TX_EL_FILTER_BLOCK_CALLS, 81</p>
<p>TX_EL_FILTER_BYTE_CALLS, 82</p>
<p><i>MULTI: Developing for ThreadX</i></p>
<p><i>132</i></p>
<p><i>Thread Information window (continued)</i></p>
<h1 style="page-break-before:always; "></h1>
<p>TX_EL_FILTER_EVENT_FLAG_CALLS, 81</p>
<p>TX_EL_FILTER_INTERRUPTS, 81</p>
<p>TX_EL_FILTER_MUTEX_CALLS, 82</p>
<p>TX_EL_FILTER_QUEUE_CALLS, 81</p>
<p>TX_EL_FILTER_SEMAPHORE_CALLS, 81</p>
<p>TX_EL_FILTER_STATUS_CHANGE, 81</p>
<p>TX_EL_FILTER_THREAD_CALLS, 81</p>
<p>TX_EL_FILTER_TIMER_CALLS, 81</p>
<p>typographical conventions, x</p>
<p><b>U</b></p>
<p>updating windows, 6, 10</p>
<p><b>V</b></p>
<p>version ID string, 8</p>
<p>void _tx_el_event_filter_set(UINT filter);, 80</p>
<p>void _tx_el_event_log_off(void);, 80</p>
<p>void _tx_el_event_log_on(void);, 80</p>
<p><b>W</b></p>
<p>windows</p>
<p>Block Pool Contents, 53, 55</p>
<p>Block Pool Information, 10, 52, 55</p>
<p>Block Pool List, 50, 54</p>
<p>Byte Pool Contents, 60, 62</p>
<p>Byte Pool Information, 10, 59, 62</p>
<p>Byte Pool List, 58, 61</p>
<p>common features, 5</p>
<p>component view, 21</p>
<p>Current Thread Information, 23</p>
<p>Data Explorer, 22, 31, 36, 40, 46, 53, 60, 69</p>
<p>Debugger, MULTI, 69</p>
<p>Event Flags Information, 45</p>
<p>Event Flags List, 44, 47</p>
<p>freezing, 6</p>
<p>and duplicating, 6</p>
<p>and unfreezing, 10</p>
<p>information, ix</p>
<p>list, ix</p>
<p>main control and information, 6</p>
<p>manipulating, 5</p>
<p>memory view, 20</p>
<p>Mutex Information, 39</p>
<p>Mutex List, 38, 41</p>
<p>Queue Information, 29</p>
<p>Queue List, 28, 31</p>
<p>Semaphore Information, 35</p>
<p>Semaphore List, 34, 36</p>
<p>Stack Check Information, 9, 25</p>
<p>Thread Information, 19</p>
<p>Thread List, 14, 15</p>
<p>Thread Ready List, 17</p>
<p>Thread Stack Check List, 9, 24</p>
<p>ThreadX Information, 5, 6</p>
<p>Timer List, 66, 69</p>
<p>updating, 6, 10</p>
<p><i>133</i></p>
<p><i>Green Hills Software</i></p>
<p><i>TX_EL_FILTER_EVENT_FLAG_CALLS</i></p>
<h1 style="page-break-before:always; "></h1>
</body>
</html>
{% endraw %}