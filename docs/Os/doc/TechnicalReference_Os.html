---
layout: default
title: TechnicalReference_Os
nav_order: 3
parent: OS
---
{% raw %}
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
     "http://www.w3.org/TR/html4/transitional.dtd">
<html>
<head>

  <meta http-equiv="content-type" content="text/html; charset=utf-8"/>
  <title></title>
  <meta name="generator" content="LibreOffice 24.2.7.2 (Linux)"/>
  <meta name="created" content="00:00:00"/>
  <meta name="changed" content="00:00:00"/>
</head>
<body>
<h1></h1>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>MICROSAR OS </b></p>
<p>Technical Reference </p>
<p> </p>
<p>  </p>
<p>Version 1.7.0 </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Authors </p>
<p>Anton </p>
<p>Schmukel, </p>
<p>Ivan </p>
<p>Begert, </p>
<p>Stefano </p>
<p>Simoncelli, </p>
<p>Torsten  Schmidt,  Da  He,  David  Feuerstein,  Michael </p>
<p>Kock, Martin Schultheiß, Andreas Jehl </p>
<p>Status </p>
<p>Released </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>2 </p>
<p>based on template version 6.0.1 </p>
<p><b>Document Information </b></p>
<p><b>History </b></p>
<p><b>Author </b></p>
<p><b>Date </b></p>
<p><b>Version </b></p>
<p><b>Remarks </b></p>
<p>Torsten Schmidt </p>
<p>2016-04-27 </p>
<p>1.0.0 </p>
<p>First release version </p>
<p>Torsten Schmidt </p>
<p>2016-05-18 </p>
<p>1.0.1 </p>
<p>References to hardware manuals added. </p>
<p>Revision work </p>
<p>Torsten Schmidt </p>
<p>2016-06-03 </p>
<p>1.0.2 </p>
<p>Fix of ESCAN00089598 </p>
<p>Torsten Schmidt </p>
<p>2016-06-20 </p>
<p>1.1.0 </p>
<p>List of OS internal objects added. </p>
<p>Additional startup concept chapter added. </p>
<p>Chapter “Memory mapping concept” reworked. </p>
<p>Description of “generate callout stubs” feature </p>
<p>added. </p>
<p>Torsten Schmidt </p>
<p>2016-07-05 </p>
<p>1.1.1 </p>
<p>Chapter “Memory Mapping Concept” extended. </p>
<p>IOC notification callback concept changed. </p>
<p>HSI of RH850 family added. </p>
<p>HSI of Power PC family added. </p>
<p>Torsten Schmidt </p>
<p>2016-07-19 </p>
<p>1.1.2 </p>
<p>Chapter “Memory Mapping Concept” changed. </p>
<p>Hints for shorter compile times added. </p>
<p>Nesting behavior of OS hooks described. </p>
<p>Ivan Begert </p>
<p>2016-08-11 </p>
<p>1.1.3 </p>
<p>HSI of ARM family added. </p>
<p>Torsten Schmidt </p>
<p>2016-08-12 </p>
<p>1.1.4 </p>
<p>Chapter “Memory Mapping Concept” extended. </p>
<p>Chapter “Clear Pending Interrupt” extended. </p>
<p>Chapter “RH850 Special Characteristics” </p>
<p>extended. </p>
<p>Ivan Begert </p>
<p>2016-08-18 </p>
<p>1.1.5 </p>
<p>HSI of ARM Zynq UltraScale added. </p>
<p>Torsten Schmidt </p>
<p>2016-08-30 </p>
<p>1.1.6 </p>
<p>HSI of RH850 extended. </p>
<p>Torsten Schmidt </p>
<p>2016-08-31 </p>
<p>1.1.7 </p>
<p>ORTI Debugging added. </p>
<p>Timing Hook Macros reworked. </p>
<p>Chapter “Memory Mapping Concept” changed. </p>
<p>Chapter “Category 1 Interrupts” extended. </p>
<p>Stefano Simoncelli </p>
<p>Torsten Schmidt </p>
<p>2016-09-15 </p>
<p>1.1.8 </p>
<p>Chapter “Interrupt Source API” extended. </p>
<p>HSI chapter for ARM extended </p>
<p>Torsten Schmidt </p>
<p>2016-09-22 </p>
<p>1.2.0 </p>
<p>VTT OS and Dual Target Concept added. </p>
<p>Chapter ORTI Debugging extended. </p>
<p>Anton Schmukel </p>
<p>Da He </p>
<p>2016-10-14 </p>
<p>1.3.0 </p>
<p>Ristrictions concerning API usage before </p>
<p>StartOS() documented. </p>
<p>Clarification concerning forcible termination and </p>
<p>schedule tables added. </p>
<p>Deviations in IOC added. </p>
<p>Notes on mixed criticality systems added. </p>
<p>Chapter “RH850 Special Characteristics” </p>
<p>extended. </p>
<p>Torsten Schmidt </p>
<p>2016-10-19 </p>
<p>1.3.1 </p>
<p>Chapter “Configuration of X-Signals” added. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>3 </p>
<p>based on template version 6.0.1 </p>
<p>Chapter “Power PC Special Characteristics” </p>
<p>extended. </p>
<p>Correction of startup examples. </p>
<p>Chapter “User include files” added. </p>
<p>RH850 HSI extended. </p>
<p>PPC HSI extended. </p>
<p>Hardware Overview extended by RH850. </p>
<p>David Feuerstein </p>
<p>2016-11-03 </p>
<p>1.4.0 </p>
<p>PPC HSI extended. </p>
<p>Chapter ORTI Debugging extended. </p>
<p>Michael Kock </p>
<p>2016-11-25 </p>
<p>1.5.0 </p>
<p>Updated chapter Timing Hooks </p>
<p>Martin Schultheiß </p>
<p>2016-12-08 </p>
<p>1.6.0 </p>
<p>PPC HSI extended. </p>
<p>Updated characteristics of VTT OS. </p>
<p>David Feuerstein </p>
<p>Andreas Jehl </p>
<p>Ivan Begert </p>
<p>Stefano Simoncelli </p>
<p>2016-22-12 </p>
<p>1.7.0 </p>
<p>Updated precautions in PreStartTask. </p>
<p>Support new Power PC Derivative: PC580003 </p>
<p>Support IAR compiler for ARM </p>
<p>ARM Cortex-A HSI added </p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>4 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b>Reference Documents </b></p>
<p><b>No. </b></p>
<p><b>Source </b></p>
<p><b>Title </b></p>
<p><b>Version </b></p>
<p>[1] </p>
<p> </p>
<p>AUTOSAR </p>
<p>Specification of Operating System </p>
<p>Document ID 034:  AUTOSAR_SWS_OS </p>
<p>4.2.1 </p>
<p>[2] </p>
<p> </p>
<p>OSEK/VDX </p>
<p>OSEK/VDX Operating System Specification </p>
<p>This document is available in PDF-format on </p>
<p>the Internet at the OSEK/VDX homepage </p>
<p>(http://www.osek-vdx.org) </p>
<p>2.2.3 </p>
<p>[3] </p>
<p> </p>
<p>OSEK/VDX </p>
<p>OSEK RunTime Interface (ORTI) Part A: </p>
<p>Language Specification. </p>
<p>This document is available in PDF-format on </p>
<p>the Internet at the OSEK/VDX homepage </p>
<p>(http://www.osek-vdx.org) </p>
<p>2.2 </p>
<p>[4] </p>
<p> </p>
<p>OSEK/VDX </p>
<p>OSEK Run Time Interface (ORTI) Part B: OSEK </p>
<p>Objects and Attributes </p>
<p>This document is available in PDF-format on </p>
<p>the Internet at the OSEK/VDX homepage </p>
<p>(http://www.osek-vdx.org) </p>
<p>2.2 </p>
<p>[5] </p>
<p> </p>
<p>Lauterbach </p>
<p>ORTI Representation of SMP Systems (ORTI </p>
<p>2.3) </p>
<p>4 </p>
<p>[6] </p>
<p> </p>
<p>Vector </p>
<p>vVIRTUALtarget Technical Reference </p>
<p>See delivery </p>
<p>information </p>
<p>[7] </p>
<p> </p>
<p>Vector </p>
<p>Startup with Vector and vVIRTUALtarget </p>
<p>See delivery </p>
<p>information </p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>We have configured the programs in accordance with your specifications in the </p>
<p>questionnaire. Whereas the programs do support other configurations than the one </p>
<p>specified in your questionnaire, Vector´s release of the programs delivered to your </p>
<p>company is expressly restricted to the configuration you have specified in the </p>
<p>questionnaire. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>5 </p>
<p>based on template version 6.0.1 </p>
<p><b>Contents </b></p>
<p><b>1</b></p>
<p> </p>
<p><b>Introduction................................................................................................................. 16</b></p>
<p> </p>
<p>1.1</p>
<p> </p>
<p>Architecture Overview ...................................................................................... 16</p>
<p> </p>
<p>1.2</p>
<p> </p>
<p>Abstract ........................................................................................................... 17</p>
<p> </p>
<p>1.3</p>
<p> </p>
<p>Characteristics ................................................................................................. 17</p>
<p> </p>
<p>1.4</p>
<p> </p>
<p>Hardware Overview ......................................................................................... 18</p>
<p> </p>
<p>1.4.1</p>
<p> </p>
<p>TriCore Aurix .................................................................................... 19</p>
<p> </p>
<p>1.4.2</p>
<p> </p>
<p>Power PC ......................................................................................... 20</p>
<p> </p>
<p>1.4.3</p>
<p> </p>
<p>ARM ................................................................................................. 21</p>
<p> </p>
<p>1.4.4</p>
<p> </p>
<p>RH850.............................................................................................. 22</p>
<p> </p>
<p>1.4.5</p>
<p> </p>
<p>VTT OS ............................................................................................ 23</p>
<p> </p>
<p>1.4.5.1</p>
<p> </p>
<p>Characteristics of VTT OS ............................................. 23</p>
<p> </p>
<p><b>2</b></p>
<p> </p>
<p><b>Functional Description ............................................................................................... 24</b></p>
<p> </p>
<p>2.1</p>
<p> </p>
<p>General ............................................................................................................ 24</p>
<p> </p>
<p>2.2</p>
<p> </p>
<p>MICROSAR OS Deviations from AUTOSAR OS Specification ......................... 24</p>
<p> </p>
<p>2.2.1</p>
<p> </p>
<p>Generic Deviation for API Functions ................................................. 24</p>
<p> </p>
<p>2.2.2</p>
<p> </p>
<p>Trusted Function API Deviations ...................................................... 24</p>
<p> </p>
<p>2.2.3</p>
<p> </p>
<p>Service Protection Deviation ............................................................ 25</p>
<p> </p>
<p>2.2.4</p>
<p> </p>
<p>SyncScheduleTable API Deviation ................................................... 25</p>
<p> </p>
<p>2.2.5</p>
<p> </p>
<p>CheckTask/ISRMemoryAccess API Deviation .................................. 25</p>
<p> </p>
<p>2.2.6</p>
<p> </p>
<p>Interrupt API Deviation ..................................................................... 26</p>
<p> </p>
<p>2.2.7</p>
<p> </p>
<p>Cross Core Getter APIs .................................................................... 26</p>
<p> </p>
<p>2.2.8</p>
<p> </p>
<p>IOC .................................................................................................. 26</p>
<p> </p>
<p>2.2.9</p>
<p> </p>
<p>Return value upon stack violation ..................................................... 27</p>
<p> </p>
<p>2.2.10</p>
<p> </p>
<p>Forcible Termination of Applications ................................................. 28</p>
<p> </p>
<p>2.3</p>
<p> </p>
<p>Stack Concept ................................................................................................. 29</p>
<p> </p>
<p>2.3.1</p>
<p> </p>
<p>Task Stack Sharing .......................................................................... 31</p>
<p> </p>
<p>2.3.1.1</p>
<p> </p>
<p>Description ..................................................................... 31</p>
<p> </p>
<p>2.3.1.2</p>
<p> </p>
<p>Activation ....................................................................... 31</p>
<p> </p>
<p>2.3.1.3</p>
<p> </p>
<p>Usage ............................................................................ 31</p>
<p> </p>
<p>2.3.2</p>
<p> </p>
<p>ISR Stack Sharing ............................................................................ 31</p>
<p> </p>
<p>2.3.2.1</p>
<p> </p>
<p>Description ..................................................................... 31</p>
<p> </p>
<p>2.3.2.2</p>
<p> </p>
<p>Activation ....................................................................... 31</p>
<p> </p>
<p>2.3.2.3</p>
<p> </p>
<p>Usage ............................................................................ 32</p>
<p> </p>
<p>2.3.3</p>
<p> </p>
<p>Stack Check Strategy ....................................................................... 32</p>
<p> </p>
<p>2.3.4</p>
<p> </p>
<p>Software Stack Check ...................................................................... 33</p>
<p> </p>
<p>2.3.4.1</p>
<p> </p>
<p>Description ..................................................................... 33</p>
<p> </p>
<p>2.3.4.2</p>
<p> </p>
<p>Activation ....................................................................... 33</p>
<p> </p>
<p>2.3.4.3</p>
<p> </p>
<p>Usage ............................................................................ 33</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>6 </p>
<p>based on template version 6.0.1 </p>
<p>2.3.5</p>
<p> </p>
<p>Stack Supervision by MPU ............................................................... 34</p>
<p> </p>
<p>2.3.5.1</p>
<p> </p>
<p>Description ..................................................................... 34</p>
<p> </p>
<p>2.3.5.2</p>
<p> </p>
<p>Activation ....................................................................... 34</p>
<p> </p>
<p>2.3.5.3</p>
<p> </p>
<p>Usage ............................................................................ 35</p>
<p> </p>
<p>2.3.6</p>
<p> </p>
<p>Stack Usage Measurement .............................................................. 37</p>
<p> </p>
<p>2.3.6.1</p>
<p> </p>
<p>Description ..................................................................... 37</p>
<p> </p>
<p>2.3.6.2</p>
<p> </p>
<p>Activation ....................................................................... 37</p>
<p> </p>
<p>2.3.6.3</p>
<p> </p>
<p>Usage ............................................................................ 37</p>
<p> </p>
<p>2.4</p>
<p> </p>
<p>Interrupt Concept ............................................................................................. 38</p>
<p> </p>
<p>2.4.1</p>
<p> </p>
<p>Interrupt Handling API ...................................................................... 38</p>
<p> </p>
<p>2.4.1.1</p>
<p> </p>
<p>Interrupt Handling in SC1 / SC3 ..................................... 38</p>
<p> </p>
<p>2.4.1.2</p>
<p> </p>
<p>Interrupt Handling in SC2 / SC4 ..................................... 39</p>
<p> </p>
<p>2.4.2</p>
<p> </p>
<p>Interrupt Vector Table ....................................................................... 40</p>
<p> </p>
<p>2.4.3</p>
<p> </p>
<p>Nesting of Category 2 Interrupts....................................................... 40</p>
<p> </p>
<p>2.4.3.1</p>
<p> </p>
<p>Description ..................................................................... 40</p>
<p> </p>
<p>2.4.3.2</p>
<p> </p>
<p>Activation ....................................................................... 40</p>
<p> </p>
<p>2.4.4</p>
<p> </p>
<p>Category 1 Interrupts ....................................................................... 40</p>
<p> </p>
<p>2.4.4.1</p>
<p> </p>
<p>Implementation of Category 1 ISRs ............................... 40</p>
<p> </p>
<p>2.4.4.2</p>
<p> </p>
<p>Nesting of Category 1 ISRs ............................................ 41</p>
<p> </p>
<p>2.4.4.3</p>
<p> </p>
<p>Category 1 ISRs before StartOS .................................... 41</p>
<p> </p>
<p>2.4.4.4</p>
<p> </p>
<p>Notes on Category 1 ISRs ............................................. 42</p>
<p> </p>
<p>2.4.5</p>
<p> </p>
<p>Initialization of Interrupt Sources ...................................................... 43</p>
<p> </p>
<p>2.4.6</p>
<p> </p>
<p>Unhandled Interrupts ........................................................................ 43</p>
<p> </p>
<p>2.5</p>
<p> </p>
<p>Exception Concept ........................................................................................... 43</p>
<p> </p>
<p>2.5.1</p>
<p> </p>
<p>Exception Vector Table ..................................................................... 43</p>
<p> </p>
<p>2.5.2</p>
<p> </p>
<p>Unhandled Exceptions ..................................................................... 43</p>
<p> </p>
<p>2.6</p>
<p> </p>
<p>Timer Concept ................................................................................................. 44</p>
<p> </p>
<p>2.6.1</p>
<p> </p>
<p>Description ....................................................................................... 44</p>
<p> </p>
<p>2.6.2</p>
<p> </p>
<p>Activation ......................................................................................... 44</p>
<p> </p>
<p>2.6.3</p>
<p> </p>
<p>Usage .............................................................................................. 44</p>
<p> </p>
<p>2.6.4</p>
<p> </p>
<p>Dependencies .................................................................................. 44</p>
<p> </p>
<p>2.7</p>
<p> </p>
<p>Periodical Interrupt Timer (PIT) ........................................................................ 45</p>
<p> </p>
<p>2.7.1</p>
<p> </p>
<p>Description ....................................................................................... 45</p>
<p> </p>
<p>2.7.2</p>
<p> </p>
<p>Activation ......................................................................................... 45</p>
<p> </p>
<p>2.8</p>
<p> </p>
<p>High Resolution Timer (HRT) ........................................................................... 46</p>
<p> </p>
<p>2.8.1</p>
<p> </p>
<p>Description ....................................................................................... 46</p>
<p> </p>
<p>2.8.2</p>
<p> </p>
<p>Activation ......................................................................................... 46</p>
<p> </p>
<p>2.9</p>
<p> </p>
<p>PIT versus HRT ............................................................................................... 46</p>
<p> </p>
<p>2.10</p>
<p> </p>
<p>Startup Concept ............................................................................................... 47</p>
<p> </p>
<p>2.11</p>
<p> </p>
<p>Single Core Startup .......................................................................................... 48</p>
<p> </p>
<p>2.11.1</p>
<p> </p>
<p>Single Core Derivatives .................................................................... 48</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>7 </p>
<p>based on template version 6.0.1 </p>
<p>2.11.2</p>
<p> </p>
<p>Multi Core Derivatives ...................................................................... 49</p>
<p> </p>
<p>2.11.2.1</p>
<p> </p>
<p>Examples for SC1 / SC2 Systems .................................. 49</p>
<p> </p>
<p>2.11.2.2</p>
<p> </p>
<p>Examples for SC3 / SC4 Systems .................................. 50</p>
<p> </p>
<p>2.12</p>
<p> </p>
<p>Multi Core Startup ............................................................................................ 51</p>
<p> </p>
<p>2.12.1</p>
<p> </p>
<p>Example for SC1 / SC2 Systems ...................................................... 51</p>
<p> </p>
<p>2.12.2</p>
<p> </p>
<p>Examples for SC3 / SC4 systems .................................................... 52</p>
<p> </p>
<p>2.12.2.1</p>
<p> </p>
<p>Only with AUTOSAR Cores ............................................ 52</p>
<p> </p>
<p>2.12.2.2</p>
<p> </p>
<p>Mixed Core System........................................................ 53</p>
<p> </p>
<p>2.13</p>
<p> </p>
<p>Error Handling .................................................................................................. 54</p>
<p> </p>
<p>2.14</p>
<p> </p>
<p>Error Reporting ................................................................................................ 54</p>
<p> </p>
<p>2.14.1</p>
<p> </p>
<p>Extension of Service IDs .................................................................. 55</p>
<p> </p>
<p>2.14.2</p>
<p> </p>
<p>Extension of Error Codes ................................................................. 55</p>
<p> </p>
<p>2.14.3</p>
<p> </p>
<p>Detailed Error Codes ........................................................................ 56</p>
<p> </p>
<p>2.15</p>
<p> </p>
<p>Multi Core Concepts ........................................................................................ 57</p>
<p> </p>
<p>2.15.1</p>
<p> </p>
<p>Scheduling and Dispatching ............................................................. 57</p>
<p> </p>
<p>2.15.2</p>
<p> </p>
<p>Multi Core Data Concepts ................................................................ 57</p>
<p> </p>
<p>2.15.3</p>
<p> </p>
<p>X-Signals ......................................................................................... 57</p>
<p> </p>
<p>2.15.4</p>
<p> </p>
<p>Master / Slave Core ......................................................................... 57</p>
<p> </p>
<p>2.15.5</p>
<p> </p>
<p>Startup of a Multi Core System ........................................................ 57</p>
<p> </p>
<p>2.15.6</p>
<p> </p>
<p>Spinlocks ......................................................................................... 57</p>
<p> </p>
<p>2.15.7</p>
<p> </p>
<p>Cache .............................................................................................. 58</p>
<p> </p>
<p>2.15.8</p>
<p> </p>
<p>Shutdown ......................................................................................... 58</p>
<p> </p>
<p>2.15.8.1</p>
<p> </p>
<p>Shutdown of one Core ................................................... 58</p>
<p> </p>
<p>2.15.8.2</p>
<p> </p>
<p>Shutdown of all Cores .................................................... 58</p>
<p> </p>
<p>2.15.8.3</p>
<p> </p>
<p>Shutdown during Protection Violation............................. 58</p>
<p> </p>
<p>2.16</p>
<p> </p>
<p>Debugging Concepts ....................................................................................... 59</p>
<p> </p>
<p>2.16.1</p>
<p> </p>
<p>Description ....................................................................................... 59</p>
<p> </p>
<p>2.16.2</p>
<p> </p>
<p>Activation ......................................................................................... 59</p>
<p> </p>
<p>2.16.3</p>
<p> </p>
<p>ORTI Debugging .............................................................................. 60</p>
<p> </p>
<p>2.17</p>
<p> </p>
<p>Memory Protection ........................................................................................... 62</p>
<p> </p>
<p>2.17.1</p>
<p> </p>
<p>Usage of the System MPU ............................................................... 62</p>
<p> </p>
<p>2.17.2</p>
<p> </p>
<p>Usage of the Core MPUs ................................................................. 62</p>
<p> </p>
<p>2.17.3</p>
<p> </p>
<p>Configuration Aspects ...................................................................... 63</p>
<p> </p>
<p>2.17.3.1</p>
<p> </p>
<p>Static MPU Regions ....................................................... 63</p>
<p> </p>
<p>2.17.3.2</p>
<p> </p>
<p>Dynamic MPU Regions .................................................. 63</p>
<p> </p>
<p>2.17.3.3</p>
<p> </p>
<p>Freedom from Interference ............................................ 64</p>
<p> </p>
<p>2.17.4</p>
<p> </p>
<p>Stack Monitoring .............................................................................. 65</p>
<p> </p>
<p>2.17.5</p>
<p> </p>
<p>Protection Violation Handling ........................................................... 65</p>
<p> </p>
<p>2.17.6</p>
<p> </p>
<p>Optimized / Fast Core MPU Handling .............................................. 65</p>
<p> </p>
<p>2.17.7</p>
<p> </p>
<p>Recommended Configuration ........................................................... 66</p>
<p> </p>
<p>2.18</p>
<p> </p>
<p>Memory Access Checks ................................................................................... 67</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>8 </p>
<p>based on template version 6.0.1 </p>
<p>2.18.1</p>
<p> </p>
<p>Description ....................................................................................... 67</p>
<p> </p>
<p>2.18.2</p>
<p> </p>
<p>Activation ......................................................................................... 67</p>
<p> </p>
<p>2.18.3</p>
<p> </p>
<p>Usage .............................................................................................. 67</p>
<p> </p>
<p>2.18.4</p>
<p> </p>
<p>Dependencies .................................................................................. 67</p>
<p> </p>
<p>2.19</p>
<p> </p>
<p>Timing Protection Concept ............................................................................... 68</p>
<p> </p>
<p>2.19.1</p>
<p> </p>
<p>Description ....................................................................................... 68</p>
<p> </p>
<p>2.19.2</p>
<p> </p>
<p>Activation ......................................................................................... 69</p>
<p> </p>
<p>2.19.3</p>
<p> </p>
<p>Usage .............................................................................................. 69</p>
<p> </p>
<p>2.20</p>
<p> </p>
<p>IOC .................................................................................................................. 70</p>
<p> </p>
<p>2.20.1</p>
<p> </p>
<p>Description ....................................................................................... 70</p>
<p> </p>
<p>2.20.2</p>
<p> </p>
<p>Unqeued (Last Is Best) Communication ........................................... 70</p>
<p> </p>
<p>2.20.2.1</p>
<p> </p>
<p>1:1 Communication Variant ............................................ 70</p>
<p> </p>
<p>2.20.2.2</p>
<p> </p>
<p>N:1 Communication Variant ........................................... 71</p>
<p> </p>
<p>2.20.2.3</p>
<p> </p>
<p>N:M Communication Variant .......................................... 71</p>
<p> </p>
<p>2.20.3</p>
<p> </p>
<p>Queued Communication .................................................................. 71</p>
<p> </p>
<p>2.20.4</p>
<p> </p>
<p>Notification ....................................................................................... 71</p>
<p> </p>
<p>2.20.5</p>
<p> </p>
<p>Particularities ................................................................................... 72</p>
<p> </p>
<p>2.20.5.1</p>
<p> </p>
<p>N:1 Queued Communication .......................................... 72</p>
<p> </p>
<p>2.20.5.2</p>
<p> </p>
<p>IOC Spinlocks ................................................................ 72</p>
<p> </p>
<p>2.20.5.3</p>
<p> </p>
<p>Notification ..................................................................... 73</p>
<p> </p>
<p>2.21</p>
<p> </p>
<p>Trusted OS Applications ................................................................................... 74</p>
<p> </p>
<p>2.21.1</p>
<p> </p>
<p>Trusted OS Applications with Memory Protection ............................. 74</p>
<p> </p>
<p>2.21.1.1</p>
<p> </p>
<p>Description ..................................................................... 74</p>
<p> </p>
<p>2.21.1.2</p>
<p> </p>
<p>Activation ....................................................................... 74</p>
<p> </p>
<p>2.21.1.3</p>
<p> </p>
<p>Dependencies ................................................................ 74</p>
<p> </p>
<p>2.21.2</p>
<p> </p>
<p>Trusted OS Applications in User Mode ............................................. 74</p>
<p> </p>
<p>2.21.2.1</p>
<p> </p>
<p>Description ..................................................................... 74</p>
<p> </p>
<p>2.21.2.2</p>
<p> </p>
<p>Activation ....................................................................... 74</p>
<p> </p>
<p>2.21.2.3</p>
<p> </p>
<p>Dependencies ................................................................ 74</p>
<p> </p>
<p>2.21.3</p>
<p> </p>
<p>Trusted Functions ............................................................................ 75</p>
<p> </p>
<p>2.22</p>
<p> </p>
<p>OS Hooks ........................................................................................................ 76</p>
<p> </p>
<p>2.22.1</p>
<p> </p>
<p>Runtime Context .............................................................................. 76</p>
<p> </p>
<p>2.22.2</p>
<p> </p>
<p>Nesting behavior .............................................................................. 76</p>
<p> </p>
<p>2.22.3</p>
<p> </p>
<p>Hints ................................................................................................ 77</p>
<p> </p>
<p><b>3</b></p>
<p> </p>
<p><b>Vector Specific OS Features ...................................................................................... 78</b></p>
<p> </p>
<p>3.1</p>
<p> </p>
<p>Optimized Spinlocks ........................................................................................ 78</p>
<p> </p>
<p>3.1.1</p>
<p> </p>
<p>Description ....................................................................................... 78</p>
<p> </p>
<p>3.1.2</p>
<p> </p>
<p>Activation ......................................................................................... 78</p>
<p> </p>
<p>3.1.3</p>
<p> </p>
<p>Usage .............................................................................................. 78</p>
<p> </p>
<p>3.2</p>
<p> </p>
<p>Peripheral Access API ...................................................................................... 79</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>9 </p>
<p>based on template version 6.0.1 </p>
<p>3.2.1</p>
<p> </p>
<p>Description ....................................................................................... 79</p>
<p> </p>
<p>3.2.2</p>
<p> </p>
<p>Activation ......................................................................................... 79</p>
<p> </p>
<p>3.2.3</p>
<p> </p>
<p>Usage .............................................................................................. 79</p>
<p> </p>
<p>3.2.4</p>
<p> </p>
<p>Dependencies .................................................................................. 79</p>
<p> </p>
<p>3.2.5</p>
<p> </p>
<p>Alternatives ...................................................................................... 79</p>
<p> </p>
<p>3.2.6</p>
<p> </p>
<p>Common Use Cases ........................................................................ 79</p>
<p> </p>
<p>3.3</p>
<p> </p>
<p>Trusted Function Call Stubs ............................................................................. 80</p>
<p> </p>
<p>3.3.1</p>
<p> </p>
<p>Description ....................................................................................... 80</p>
<p> </p>
<p>3.3.2</p>
<p> </p>
<p>Activation ......................................................................................... 80</p>
<p> </p>
<p>3.3.3</p>
<p> </p>
<p>Usage .............................................................................................. 80</p>
<p> </p>
<p>3.3.4</p>
<p> </p>
<p>Dependencies .................................................................................. 80</p>
<p> </p>
<p>3.4</p>
<p> </p>
<p>Non-Trusted Functions (NTF) .......................................................................... 81</p>
<p> </p>
<p>3.4.1</p>
<p> </p>
<p>Description ....................................................................................... 81</p>
<p> </p>
<p>3.4.2</p>
<p> </p>
<p>Activation ......................................................................................... 81</p>
<p> </p>
<p>3.4.3</p>
<p> </p>
<p>Usage .............................................................................................. 82</p>
<p> </p>
<p>3.4.4</p>
<p> </p>
<p>Dependencies .................................................................................. 82</p>
<p> </p>
<p>3.5</p>
<p> </p>
<p>Interrupt Source API ......................................................................................... 83</p>
<p> </p>
<p>3.5.1</p>
<p> </p>
<p>Description ....................................................................................... 83</p>
<p> </p>
<p>3.6</p>
<p> </p>
<p>Pre-Start Task .................................................................................................. 84</p>
<p> </p>
<p>3.6.1</p>
<p> </p>
<p>Description ....................................................................................... 84</p>
<p> </p>
<p>3.6.2</p>
<p> </p>
<p>Activation ......................................................................................... 84</p>
<p> </p>
<p>3.6.3</p>
<p> </p>
<p>Usage .............................................................................................. 84</p>
<p> </p>
<p>3.6.4</p>
<p> </p>
<p>Dependencies .................................................................................. 85</p>
<p> </p>
<p>3.7</p>
<p> </p>
<p>X-Signals ......................................................................................................... 86</p>
<p> </p>
<p>3.7.1</p>
<p> </p>
<p>Description ....................................................................................... 86</p>
<p> </p>
<p>3.7.1.1</p>
<p> </p>
<p>Notes on Synchronous X-Signals ................................... 89</p>
<p> </p>
<p>3.7.1.2</p>
<p> </p>
<p>Notes on Mixed Criticality Systems ................................ 89</p>
<p> </p>
<p>3.7.2</p>
<p> </p>
<p>Activation ......................................................................................... 89</p>
<p> </p>
<p>3.8</p>
<p> </p>
<p>Timing Hooks ................................................................................................... 90</p>
<p> </p>
<p>3.8.1</p>
<p> </p>
<p>Description ....................................................................................... 90</p>
<p> </p>
<p>3.8.2</p>
<p> </p>
<p>Activation ......................................................................................... 90</p>
<p> </p>
<p>3.8.3</p>
<p> </p>
<p>Usage .............................................................................................. 90</p>
<p> </p>
<p>3.9</p>
<p> </p>
<p>Kernel Panic .................................................................................................... 91</p>
<p> </p>
<p>3.10</p>
<p> </p>
<p>Generate callout stubs ..................................................................................... 92</p>
<p> </p>
<p>3.10.1</p>
<p> </p>
<p>Description ....................................................................................... 92</p>
<p> </p>
<p>3.10.2</p>
<p> </p>
<p>Activation ......................................................................................... 92</p>
<p> </p>
<p>3.10.3</p>
<p> </p>
<p>Usage .............................................................................................. 92</p>
<p> </p>
<p><b>4</b></p>
<p> </p>
<p><b>Integration ................................................................................................................... 93</b></p>
<p> </p>
<p>4.1</p>
<p> </p>
<p>Compiler Optimization Assumptions ................................................................. 93</p>
<p> </p>
<p>4.1.1</p>
<p> </p>
<p>Compile Time ................................................................................... 93</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>10 </p>
<p>based on template version 6.0.1 </p>
<p>4.2</p>
<p> </p>
<p>Hardware Software Interfaces (HSI)................................................................. 93</p>
<p> </p>
<p>4.2.1</p>
<p> </p>
<p>TriCore Aurix Family ......................................................................... 94</p>
<p> </p>
<p>4.2.1.1</p>
<p> </p>
<p>Context .......................................................................... 94</p>
<p> </p>
<p>4.2.1.2</p>
<p> </p>
<p>Core Registers ............................................................... 94</p>
<p> </p>
<p>4.2.1.3</p>
<p> </p>
<p>Interrupt Registers ......................................................... 94</p>
<p> </p>
<p>4.2.1.4</p>
<p> </p>
<p>GPT Registers ............................................................... 95</p>
<p> </p>
<p>4.2.1.5</p>
<p> </p>
<p>STM Registers ............................................................... 95</p>
<p> </p>
<p>4.2.1.6</p>
<p> </p>
<p>Aurix Special Characteristics ......................................... 96</p>
<p> </p>
<p>4.2.1.7</p>
<p> </p>
<p>PSW handling ................................................................ 98</p>
<p> </p>
<p>4.2.2</p>
<p> </p>
<p>RH850 Family .................................................................................. 99</p>
<p> </p>
<p>4.2.2.1</p>
<p> </p>
<p>Context .......................................................................... 99</p>
<p> </p>
<p>4.2.2.2</p>
<p> </p>
<p>Core Registers ............................................................. 100</p>
<p> </p>
<p>4.2.2.3</p>
<p> </p>
<p>MPU Registers ............................................................. 101</p>
<p> </p>
<p>4.2.2.4</p>
<p> </p>
<p>INTC Registers ............................................................ 101</p>
<p> </p>
<p>4.2.2.5</p>
<p> </p>
<p>Inter Processor Interrupt Control Registers .................. 101</p>
<p> </p>
<p>4.2.2.6</p>
<p> </p>
<p>Timer TAUJ Registers .................................................. 102</p>
<p> </p>
<p>4.2.2.7</p>
<p> </p>
<p>Timer STM Registers ................................................... 104</p>
<p> </p>
<p>4.2.2.8</p>
<p> </p>
<p>Timer OSTM Registers ................................................ 106</p>
<p> </p>
<p>4.2.2.9</p>
<p> </p>
<p>RH850 Special Characteristics .................................... 107</p>
<p> </p>
<p>4.2.2.10</p>
<p> </p>
<p>PSW Register Handling ............................................... 108</p>
<p> </p>
<p>4.2.2.11</p>
<p> </p>
<p>Instructions .................................................................. 108</p>
<p> </p>
<p>4.2.2.12</p>
<p> </p>
<p>Exception and Interrupt Cause Address ....................... 108</p>
<p> </p>
<p>4.2.3</p>
<p> </p>
<p>Power PC Family ........................................................................... 109</p>
<p> </p>
<p>4.2.3.1</p>
<p> </p>
<p>Context ........................................................................ 109</p>
<p> </p>
<p>4.2.3.2</p>
<p> </p>
<p>Core Registers ............................................................. 109</p>
<p> </p>
<p>4.2.3.3</p>
<p> </p>
<p>Interrupt Registers ....................................................... 109</p>
<p> </p>
<p>4.2.3.4</p>
<p> </p>
<p>PIT Registers ............................................................... 110</p>
<p> </p>
<p>4.2.3.5</p>
<p> </p>
<p>STM Registers ............................................................. 110</p>
<p> </p>
<p>4.2.3.6</p>
<p> </p>
<p>MPU Registers ............................................................. 110</p>
<p> </p>
<p>4.2.3.7</p>
<p> </p>
<p>SEMA4 Registers ......................................................... 111</p>
<p> </p>
<p>4.2.3.8</p>
<p> </p>
<p>Power PC Special Characteristics ................................. 111</p>
<p> </p>
<p>4.2.3.9</p>
<p> </p>
<p>MSR Handling .............................................................. 112</p>
<p> </p>
<p>4.2.4</p>
<p> </p>
<p>ARM Family ................................................................................... 113</p>
<p> </p>
<p>4.2.4.1</p>
<p> </p>
<p>Cortex-R derivatives .................................................... 113</p>
<p> </p>
<p>4.2.4.2</p>
<p> </p>
<p>Cortex-A derivatives ..................................................... 115</p>
<p> </p>
<p>4.2.4.3</p>
<p> </p>
<p>ARM Special Characteristics ........................................ 115</p>
<p> </p>
<p>4.3</p>
<p> </p>
<p>Memory Mapping Concept ............................................................................. 117</p>
<p> </p>
<p>4.3.1</p>
<p> </p>
<p>Provided MemMap Section Specifers ............................................ 117</p>
<p> </p>
<p>4.3.1.1</p>
<p> </p>
<p>Usage of MemMap Macros .......................................... 120</p>
<p> </p>
<p>4.3.1.2</p>
<p> </p>
<p>Resulting sections ........................................................ 121</p>
<p> </p>
<p>4.3.1.3</p>
<p> </p>
<p>Access Rights to Variable Sections .............................. 127</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>11 </p>
<p>based on template version 6.0.1 </p>
<p>4.3.2</p>
<p> </p>
<p>Link Sections.................................................................................. 130</p>
<p> </p>
<p>4.3.2.1</p>
<p> </p>
<p>Simple Linker Defines .................................................. 131</p>
<p> </p>
<p>4.3.2.2</p>
<p> </p>
<p>Hierachical Linker Defines ........................................... 131</p>
<p> </p>
<p>4.3.2.3</p>
<p> </p>
<p>Selecting OS constants ................................................ 132</p>
<p> </p>
<p>4.3.2.4</p>
<p> </p>
<p>Selecting OS variables ................................................. 133</p>
<p> </p>
<p>4.3.2.5</p>
<p> </p>
<p>Selecting OS Barriers, Core Status and Trace variables134</p>
<p> </p>
<p>4.3.2.6</p>
<p> </p>
<p>Selecting OS Spinlocks ................................................ 135</p>
<p> </p>
<p>4.3.2.7</p>
<p> </p>
<p>Selecting User Constant Sections ................................ 136</p>
<p> </p>
<p>4.3.2.8</p>
<p> </p>
<p>Selecting User Variable Sections ................................. 137</p>
<p> </p>
<p>4.3.3</p>
<p> </p>
<p>Section Symbols ............................................................................ 139</p>
<p> </p>
<p>4.4</p>
<p> </p>
<p>Static Code Analysis ...................................................................................... 139</p>
<p> </p>
<p>4.5</p>
<p> </p>
<p>Configuration of X-Signals ............................................................................. 140</p>
<p> </p>
<p>4.5.1</p>
<p> </p>
<p>TriCore Aurix Family ....................................................................... 140</p>
<p> </p>
<p>4.5.2</p>
<p> </p>
<p>RH850 Family ................................................................................ 140</p>
<p> </p>
<p>4.5.3</p>
<p> </p>
<p>Power PC Family ........................................................................... 141</p>
<p> </p>
<p>4.5.4</p>
<p> </p>
<p>ARM Family ................................................................................... 141</p>
<p> </p>
<p>4.5.5</p>
<p> </p>
<p>VTT OS .......................................................................................... 141</p>
<p> </p>
<p>4.6</p>
<p> </p>
<p>OS generated objects .................................................................................... 141</p>
<p> </p>
<p>4.6.1</p>
<p> </p>
<p>System Application ......................................................................... 141</p>
<p> </p>
<p>4.6.2</p>
<p> </p>
<p>Idle Task ......................................................................................... 142</p>
<p> </p>
<p>4.6.3</p>
<p> </p>
<p>Timer ISR ....................................................................................... 142</p>
<p> </p>
<p>4.6.4</p>
<p> </p>
<p>System Timer Counter ................................................................... 142</p>
<p> </p>
<p>4.6.5</p>
<p> </p>
<p>Timing Protection Counter .............................................................. 142</p>
<p> </p>
<p>4.6.6</p>
<p> </p>
<p>Timing protection ISR ..................................................................... 142</p>
<p> </p>
<p>4.6.7</p>
<p> </p>
<p>Resource Scheduler....................................................................... 143</p>
<p> </p>
<p>4.6.8</p>
<p> </p>
<p>X Signal ISR .................................................................................. 143</p>
<p> </p>
<p>4.6.9</p>
<p> </p>
<p>IOC Spinlocks ................................................................................ 143</p>
<p> </p>
<p>4.7</p>
<p> </p>
<p>VTT OS Specifics ........................................................................................... 144</p>
<p> </p>
<p>4.7.1</p>
<p> </p>
<p>Configuration.................................................................................. 144</p>
<p> </p>
<p>4.7.2</p>
<p> </p>
<p>CANoe Interface ............................................................................ 144</p>
<p> </p>
<p>4.8</p>
<p> </p>
<p>User include files............................................................................................ 145</p>
<p> </p>
<p><b>5</b></p>
<p> </p>
<p><b>API Description ......................................................................................................... 146</b></p>
<p> </p>
<p>5.1</p>
<p> </p>
<p>Peripheral Access API .................................................................................... 147</p>
<p> </p>
<p>5.1.1</p>
<p> </p>
<p>Read Functions .............................................................................. 147</p>
<p> </p>
<p>5.1.2</p>
<p> </p>
<p>Write Functions .............................................................................. 149</p>
<p> </p>
<p>5.1.3</p>
<p> </p>
<p>Bitmask Functions .......................................................................... 151</p>
<p> </p>
<p>5.2</p>
<p> </p>
<p>Pre-Start Task ................................................................................................ 153</p>
<p> </p>
<p>5.3</p>
<p> </p>
<p>Non-Trusted Functions (NTF) ........................................................................ 154</p>
<p> </p>
<p>5.4</p>
<p> </p>
<p>Interrupt Source API ....................................................................................... 155</p>
<p> </p>
<p>5.4.1</p>
<p> </p>
<p>Disable Interrupt Source ................................................................ 155</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>12 </p>
<p>based on template version 6.0.1 </p>
<p>5.4.2</p>
<p> </p>
<p>Enable Interrupt Source ................................................................. 156</p>
<p> </p>
<p>5.4.3</p>
<p> </p>
<p>Clear Pending Interrupt .................................................................. 157</p>
<p> </p>
<p>5.4.4</p>
<p> </p>
<p>Check Interrupt Source Enabled .................................................... 158</p>
<p> </p>
<p>5.4.5</p>
<p> </p>
<p>Check Interrupt Pending ................................................................ 159</p>
<p> </p>
<p>5.5</p>
<p> </p>
<p>Detailed Error API .......................................................................................... 160</p>
<p> </p>
<p>5.5.1</p>
<p> </p>
<p>Get detailed Error ........................................................................... 160</p>
<p> </p>
<p>5.5.2</p>
<p> </p>
<p>Unhandled Interrupt Requests ....................................................... 161</p>
<p> </p>
<p>5.5.3</p>
<p> </p>
<p>Unhandled Exception Requests ..................................................... 162</p>
<p> </p>
<p>5.6</p>
<p> </p>
<p>Stack Usage API ............................................................................................ 163</p>
<p> </p>
<p>5.7</p>
<p> </p>
<p>RTE Interrupt API ........................................................................................... 164</p>
<p> </p>
<p>5.8</p>
<p> </p>
<p>Time Conversion Macros ............................................................................... 165</p>
<p> </p>
<p>5.8.1</p>
<p> </p>
<p>Convert from Time into Counter Ticks ............................................ 165</p>
<p> </p>
<p>5.8.2</p>
<p> </p>
<p>Convert from Counter Ticks into Time ............................................ 165</p>
<p> </p>
<p>5.9</p>
<p> </p>
<p>Access Check API .......................................................................................... 166</p>
<p> </p>
<p>5.9.1</p>
<p> </p>
<p>Check ISR Memory Access ............................................................ 166</p>
<p> </p>
<p>5.9.2</p>
<p> </p>
<p>Check Task Memory Access .......................................................... 167</p>
<p> </p>
<p>5.10</p>
<p> </p>
<p>OS Initialization .............................................................................................. 168</p>
<p> </p>
<p>5.11</p>
<p> </p>
<p>Timing Hooks ................................................................................................. 170</p>
<p> </p>
<p>5.11.1</p>
<p> </p>
<p>Timing Hooks for Activation ............................................................ 170</p>
<p> </p>
<p>5.11.1.1</p>
<p> </p>
<p>Task Activation ............................................................. 170</p>
<p> </p>
<p>5.11.1.2</p>
<p> </p>
<p>Set Event ..................................................................... 171</p>
<p> </p>
<p>5.11.2</p>
<p> </p>
<p>Timing Hook for Context Switch ..................................................... 172</p>
<p> </p>
<p>5.11.3</p>
<p> </p>
<p>Timing Hooks for Locking Purposes ............................................... 173</p>
<p> </p>
<p>5.11.3.1</p>
<p> </p>
<p>Get Resource............................................................... 173</p>
<p> </p>
<p>5.11.3.2</p>
<p> </p>
<p>Release Resource ....................................................... 173</p>
<p> </p>
<p>5.11.3.3</p>
<p> </p>
<p>Request Spinlock ......................................................... 174</p>
<p> </p>
<p>5.11.3.4</p>
<p> </p>
<p>Request Internal Spinlock ............................................ 174</p>
<p> </p>
<p>5.11.3.5</p>
<p> </p>
<p>Get Spinlock ................................................................ 175</p>
<p> </p>
<p>5.11.3.6</p>
<p> </p>
<p>Get Internal Spinlock .................................................... 175</p>
<p> </p>
<p>5.11.3.7</p>
<p> </p>
<p>Release Spinlock ......................................................... 176</p>
<p> </p>
<p>5.11.3.8</p>
<p> </p>
<p>Release Internal Spinlock ............................................ 176</p>
<p> </p>
<p>5.11.3.9</p>
<p> </p>
<p>Disable Interrupts ......................................................... 177</p>
<p> </p>
<p>5.11.3.10</p>
<p> </p>
<p>Enable Interrupts ......................................................... 178</p>
<p> </p>
<p>5.12</p>
<p> </p>
<p>PanicHook ..................................................................................................... 179</p>
<p> </p>
<p>5.13</p>
<p> </p>
<p>Calling Context Overview ............................................................................... 180</p>
<p> </p>
<p><b>6</b></p>
<p> </p>
<p><b>Configuration ............................................................................................................ 181</b></p>
<p> </p>
<p><b>7</b></p>
<p> </p>
<p><b>Glossary .................................................................................................................... 182</b></p>
<p> </p>
<p><b>8</b></p>
<p> </p>
<p><b>Contact ...................................................................................................................... 183</b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>13 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>14 </p>
<p>based on template version 6.0.1 </p>
<p><b>Illustrations </b></p>
<p>Figure 1-1</p>
<p> </p>
<p>AUTOSAR Architecture Overview ............................................................. 16</p>
<p> </p>
<p>Figure 2-1</p>
<p> </p>
<p>Stack Safety Gap ...................................................................................... 35</p>
<p> </p>
<p>Figure 2-2</p>
<p> </p>
<p>Interrupt APIs in SC1 / SC3 ...................................................................... 38</p>
<p> </p>
<p>Figure 2-3</p>
<p> </p>
<p>Interrupt API in SC2 / SC4 ........................................................................ 39</p>
<p> </p>
<p>Figure 2-4</p>
<p> </p>
<p>API functions during startup ...................................................................... 47</p>
<p> </p>
<p>Figure 2-5</p>
<p> </p>
<p>MICROSAR OS Detailed Error Code ........................................................ 56</p>
<p> </p>
<p>Figure 2-6</p>
<p> </p>
<p>N:1 Multiple Sender Queues ..................................................................... 72</p>
<p> </p>
<p>Figure 3-1</p>
<p> </p>
<p>X-Signal .................................................................................................... 86</p>
<p> </p>
<p>Figure 4-1</p>
<p> </p>
<p>Padding bytes between MPU regions ....................................................... 96</p>
<p> </p>
<p><b> </b></p>
<p><b>Tables </b></p>
<p>Table 1-1 </p>
<p> </p>
<p>MICROSAR OS Characteristics ................................................................ 17</p>
<p> </p>
<p>Table 1-2 </p>
<p> </p>
<p>Supported TriCore Aurix Hardware ........................................................... 19</p>
<p> </p>
<p>Table 1-3 </p>
<p> </p>
<p>Supported TriCore Aurix Compilers ........................................................... 19</p>
<p> </p>
<p>Table 1-4 </p>
<p> </p>
<p>Supported Power PC Hardware ................................................................ 20</p>
<p> </p>
<p>Table 1-5 </p>
<p> </p>
<p>Supported Power PC compilers ................................................................ 21</p>
<p> </p>
<p>Table 1-6 </p>
<p> </p>
<p>Supported ARM Hardware ........................................................................ 21</p>
<p> </p>
<p>Table 1-7 </p>
<p> </p>
<p>Supported ARM compilers ........................................................................ 21</p>
<p> </p>
<p>Table 1-8 </p>
<p> </p>
<p>Supported RH850 Hardware ..................................................................... 22</p>
<p> </p>
<p>Table 1-9 </p>
<p> </p>
<p>Supported RH850 Compilers .................................................................... 22</p>
<p> </p>
<p>Table 1-10 </p>
<p> </p>
<p>VTT OS characteristics ............................................................................. 23</p>
<p> </p>
<p>Table 2-1 </p>
<p> </p>
<p>MICROSAR OS Stack Types .................................................................... 30</p>
<p> </p>
<p>Table 2-2 </p>
<p> </p>
<p>Stack Check Patterns ............................................................................... 33</p>
<p> </p>
<p>Table 2-3 </p>
<p> </p>
<p>PIT versus HRT ........................................................................................ 46</p>
<p> </p>
<p>Table 2-4 </p>
<p> </p>
<p>Types of OS Errors ................................................................................... 54</p>
<p> </p>
<p>Table 2-5 </p>
<p> </p>
<p>Extension of Error Codes .......................................................................... 55</p>
<p> </p>
<p>Table 2-6 </p>
<p> </p>
<p>Recommended Configuration MPU Access Rights ................................... 66</p>
<p> </p>
<p>Table 3-1 </p>
<p> </p>
<p>Differences of OS and Optimized Spinlocks .............................................. 78</p>
<p> </p>
<p>Table 3-2 </p>
<p> </p>
<p>Comparison between Synchronous and Asynchronous X-Signal .............. 87</p>
<p> </p>
<p>Table 3-3 </p>
<p> </p>
<p>Priority of X-Signal receiver ISR................................................................ 89</p>
<p> </p>
<p>Table 4-1 </p>
<p> </p>
<p>Provided MemMap Section Specifiers .................................................... 120</p>
<p> </p>
<p>Table 4-2 </p>
<p> </p>
<p>MemMap Code Sections Descriptions .................................................... 121</p>
<p> </p>
<p>Table 4-3 </p>
<p> </p>
<p>MemMap Const Sections Descriptions ................................................... 122</p>
<p> </p>
<p>Table 4-4 </p>
<p> </p>
<p>MemMap Variable Sections Descriptions ................................................ 125</p>
<p> </p>
<p>Table 4-5 </p>
<p> </p>
<p>Recommended Section Access Rights ................................................... 128</p>
<p> </p>
<p>Table 4-6 </p>
<p> </p>
<p>List of Generated Linker Command Files ................................................ 130</p>
<p> </p>
<p>Table 4-7 </p>
<p> </p>
<p>OS constants linker define group ............................................................ 132</p>
<p> </p>
<p>Table 4-8 </p>
<p> </p>
<p>OS variables linker define group ............................................................. 133</p>
<p> </p>
<p>Table 4-9 </p>
<p> </p>
<p>OS Barriers and Core status linker define group ..................................... 134</p>
<p> </p>
<p>Table 4-10 </p>
<p> </p>
<p>User constants linker define group .......................................................... 136</p>
<p> </p>
<p>Table 4-11 </p>
<p> </p>
<p>User variables linker define group ........................................................... 137</p>
<p> </p>
<p>Table 5-1 </p>
<p> </p>
<p>Read Peripheral API ............................................................................... 147</p>
<p> </p>
<p>Table 5-2 </p>
<p> </p>
<p>Write Peripheral APIs .............................................................................. 149</p>
<p> </p>
<p>Table 5-3 </p>
<p> </p>
<p>Bitmask Peripheral API ........................................................................... 152</p>
<p> </p>
<p>Table 5-4 </p>
<p> </p>
<p>API Service Os_EnterPreStartTask ......................................................... 153</p>
<p> </p>
<p>Table 5-5 </p>
<p> </p>
<p>Call Non-Trusted Function API ................................................................ 154</p>
<p> </p>
<p>Table 5-6 </p>
<p> </p>
<p>API Service Os_DisableInterruptSource ................................................. 155</p>
<p> </p>
<p>Table 5-7 </p>
<p> </p>
<p>API Service Os_EnableInterruptSource .................................................. 156</p>
<p> </p>
<p>Table 5-8 </p>
<p> </p>
<p>API Service Os_ClearPendingInterrupt ................................................... 157</p>
<p> </p>
<p>Table 5-9 </p>
<p> </p>
<p>API Service Os_IsInterruptSourceEnabled ............................................. 158</p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>15 </p>
<p>based on template version 6.0.1 </p>
<p>Table 5-10 </p>
<p> </p>
<p>API Service Os_IsInterruptPending ........................................................ 159</p>
<p> </p>
<p>Table 5-11 </p>
<p> </p>
<p>API Service Os_GetDetailedError ........................................................... 160</p>
<p> </p>
<p>Table 5-12 </p>
<p> </p>
<p>API Service Os_GetUnhandledIrq .......................................................... 161</p>
<p> </p>
<p>Table 5-13 </p>
<p> </p>
<p>API Service Os_GetUnhandledExc ......................................................... 162</p>
<p> </p>
<p>Table 5-14 </p>
<p> </p>
<p>Overview: Stack Usage Functions .......................................................... 163</p>
<p> </p>
<p>Table 5-15 </p>
<p> </p>
<p>Conversion Macros from Time to Counter Ticks ...................................... 165</p>
<p> </p>
<p>Table 5-16 </p>
<p> </p>
<p>Conversion Macros from Counter Ticks to Time ...................................... 165</p>
<p> </p>
<p>Table 5-17 </p>
<p> </p>
<p>API Service CheckISRMemoryAccess .................................................... 166</p>
<p> </p>
<p>Table 5-18 </p>
<p> </p>
<p>API Service CheckTaskMemoryAccess .................................................. 167</p>
<p> </p>
<p>Table 5-19 </p>
<p> </p>
<p>API Service Os_Init................................................................................. 168</p>
<p> </p>
<p>Table 5-20 </p>
<p> </p>
<p>API Service Os_InitMemory .................................................................... 169</p>
<p> </p>
<p>Table 5-21 </p>
<p> </p>
<p>Calling Context Overview........................................................................ 180</p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>16 </p>
<p>based on template version 6.0.1 </p>
<p><b>1 </b></p>
<p><b>Introduction </b></p>
<p>This  document  describes  the  usage  and  functions  of  “MICROSAR  OS”,  an  operating </p>
<p>system which implements the AUTOSAR BSW module “OS” as specified in [1]. </p>
<p>This </p>
<p>documentation </p>
<p>assumes </p>
<p>that </p>
<p>the </p>
<p>reader </p>
<p>is </p>
<p>familiar </p>
<p>with </p>
<p>both </p>
<p>the </p>
<p>OSEK </p>
<p>OS</p>
<p>1</p>
<p> </p>
<p>specification and the AUTOSAR OS specification. </p>
<p><b>1.1 </b></p>
<p><b>Architecture Overview </b></p>
<p>The </p>
<p>following </p>
<p>figure </p>
<p>shows </p>
<p>the </p>
<p>location </p>
<p>of </p>
<p>the </p>
<p>OS </p>
<p>module </p>
<p>within </p>
<p>the </p>
<p>AUTOSAR </p>
<p>architecture. </p>
<p> </p>
<p>Figure 1-1 </p>
<p>AUTOSAR Architecture Overview </p>
<p> </p>
<p> </p>
<p>                                            </p>
<p>1</p>
<p> OSEK is a registered trademark of Continental Automotive GmbH (until  2007: Siemens AG) </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>17 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>1.2 </b></p>
<p><b>Abstract </b></p>
<p>The  MICROSAR  OS  operating  system  is  a  real  time  operating  system,  which  was </p>
<p>specified for the usage in electronic control. </p>
<p>As a requirement, there is no dynamic creation of new tasks at runtime; all tasks have to </p>
<p>be defined before compilation (pre-compile configuration variant). </p>
<p>The OS has no dynamic memory management and there is no shell for the control of tasks </p>
<p>by hand. </p>
<p>Typically  the  source  and  configuration  files  of  the  operating  system  and  the  application </p>
<p>source files are compiled and linked together to one executable file, which is loaded into </p>
<p>an emulator or is burned into an EPROM or Flash EEPROM. </p>
<p><b>1.3 </b></p>
<p><b>Characteristics </b></p>
<p>MICROSAR OS has the following characteristics: </p>
<p><b>Supported Scalability Classes </b></p>
<p>SC1, SC2, SC3, SC4 (as described in [1]) </p>
<p><b>Single Core ECUs </b></p>
<p>Supported </p>
<p><b>Multi Core ECUs </b></p>
<p>Supported </p>
<p><b>IOC </b></p>
<p>Supported </p>
<p>Table 1-1  </p>
<p>MICROSAR OS Characteristics </p>
<p>MICROSAR  OS  supports  various  different  processor  families  of  different  vendors  in </p>
<p>conjunction with multiple compilers. </p>
<p>The  availability  for  a  particular  processor  in  conjunction  with  a  specific  compiler  can  be </p>
<p>queried from Vector Informatik. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>18 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>1.4 </b></p>
<p><b>Hardware Overview </b></p>
<p>The  following  table  summarizes  information  about  MICROSAR  OS.  It  gives  detailed </p>
<p>information </p>
<p>about </p>
<p>the </p>
<p>derivatives </p>
<p>and </p>
<p>compilers.  As </p>
<p>very </p>
<p>important </p>
<p>information </p>
<p>the </p>
<p>documentations of the hardware manufacturers are listed. MICROSAR OS is based upon </p>
<p>these documents in the given version. </p>
<p>Table Rows </p>
<p><b>&gt; </b></p>
<p><b>Compiler</b>: List of Compilers MICROSAR OS is working with. </p>
<p><b>&gt; </b></p>
<p><b>Derivative</b>: This can be a single information or a list of derivatives, MICROSAR OS </p>
<p>can be used on. </p>
<p><b>&gt; </b></p>
<p><b>Hardware Manufacturer Document Name</b>: List of hardware documentation </p>
<p>MICROSAR OS is based on. </p>
<p><b>&gt; </b></p>
<p><b>Document Version</b>: To be able to reference to this hardware documentation its </p>
<p>version is very important. </p>
<p><b> </b></p>
<p><b> </b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>19 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>1.4.1 </b></p>
<p><b>TriCore Aurix </b></p>
<p><b>Derivative </b></p>
<p><b>Hardware Manufacturer Document Name </b></p>
<p><b>Document </b></p>
<p><b>Version </b></p>
<p>TC21x </p>
<p>TC22x </p>
<p>TC23x </p>
<p>User Manual: tc23x_tc22x_tc21x_um_v1.1.pdf </p>
<p>V1.1 </p>
<p>Errata Sheet: TC22x_TC21x_AB_Errata_Sheet_v1_2_03804A.pdf </p>
<p>V1.2 </p>
<p>TC24x </p>
<p>Target Specification: tc24x_ts_v2.0_OPEN_MARKET.pdf </p>
<p>V2.0 </p>
<p>TC26x </p>
<p>User Manual: </p>
<p>tc26xB_um_v1.3._usermanual_rev1v3.pdf </p>
<p>V1.3 </p>
<p>Errata Sheet: </p>
<p>TC26x_BB_Errata_Sheet_rev1v2_03989A_2016-04-18.pdf </p>
<p>V1.2 </p>
<p>TC27x </p>
<p>User Manual: </p>
<p>tc27xD_um_v2.2_UserManual_rev2v2_2014-12.pdf </p>
<p>V2.2 </p>
<p>Errata Sheet: </p>
<p>TC27x_BC_Errata_Sheet_rev1v5_2015_09_16.pdf </p>
<p>V1.5 </p>
<p>TC29x </p>
<p>User Manual: </p>
<p>tc29xB_um_v1.3._TC29x_B-Step_User_Manual_rev_1v3_2014_12.pdf </p>
<p>V1.3 </p>
<p>Errata Sheet: </p>
<p>TC29x_BA_Errata_Sheet_v1_0.pdf </p>
<p>V1.0 </p>
<p>Table 1-2  </p>
<p>Supported TriCore Aurix Hardware </p>
<p> </p>
<p><b>Tasking </b></p>
<p>v4.2r2 </p>
<p><b>HighTec (GNU) </b></p>
<p>V4.6.3.0 </p>
<p>Table 1-3  </p>
<p>Supported TriCore Aurix Compilers </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>20 </p>
<p>based on template version 6.0.1 </p>
<p><b>1.4.2 </b></p>
<p><b>Power PC </b></p>
<p><b>Derivative </b></p>
<p><b>Hardware Manufacturer Document Name </b></p>
<p><b>Document </b></p>
<p><b>Version </b></p>
<p>MPC574xBD </p>
<p>Freescale Semiconductor MPC5746C  </p>
<p>Reference Manual </p>
<p>Rev. 2.1, </p>
<p>06/2015 </p>
<p>MPC574xC1 </p>
<p>Freescale Semiconductor MPC5746C  </p>
<p>Reference Manual </p>
<p>Rev. 2.1, </p>
<p>06/2015 </p>
<p>MPC574xC2 </p>
<p>NXP MPC5748G Reference Manual </p>
<p>Rev. 4, 07/2015 </p>
<p>MPC574xG </p>
<p>NXP MPC5748G Reference Manual </p>
<p>Rev. 4, 07/2015 </p>
<p>NXP Safety Manual for MPC5748G </p>
<p>Rev. 2, 01/2016 </p>
<p>MPC574xK </p>
<p>ST SPC574Kxx  </p>
<p>Reference Manual </p>
<p>Rev. 5, 08/2015 </p>
<p>MPC574xM </p>
<p>Freescale Semiconductor MPC5746M  </p>
<p>Reference Manual </p>
<p>Rev. 5.1, </p>
<p>04/2014 </p>
<p>MPC574xP </p>
<p>Freescale Semiconductor MPC5744P </p>
<p>Reference Manual </p>
<p>Rev. 5.1, </p>
<p>02/2015 </p>
<p>NXP Safety Manual for MPC5744P </p>
<p>Rev. 3, 06/2014 </p>
<p>MPC574xR </p>
<p>NXP MPC5746R  </p>
<p>Reference Manual </p>
<p>Rev. 6, 03/2016 </p>
<p>MPC577xK </p>
<p>Freescale Semiconductor MPC5775K  </p>
<p>Reference Manual </p>
<p>Rev. 4, 12/2015 </p>
<p>MPC577xM </p>
<p>NXP MPC5777M  </p>
<p>Reference Manual </p>
<p>Rev. 4, 04/2015 </p>
<p>MPC577xN </p>
<p>Freescale Semiconductor MPC5774N  </p>
<p>Reference Manual </p>
<p>Rev. 2, 02/2014 </p>
<p>PC580003 </p>
<p>Freescale Semiconductor PC580003 Reference Manual </p>
<p>Rev. 2, 05/2014 </p>
<p>SPC58ECxx </p>
<p>ST SPC584Cx/SPC58ECx  </p>
<p>Reference Manual </p>
<p>Rev. 1, 10/2015 </p>
<p>SPC58EGxx </p>
<p>ST SPC58NE84x/SPC58xG84x  </p>
<p>Reference Manual </p>
<p>Rev. 2, 02/2016 </p>
<p>SPC58NGxx </p>
<p>ST SPC58NE84x/SPC58xG84x  </p>
<p>Reference Manual </p>
<p>Rev. 2, 02/2016 </p>
<p>SPC582Bxx </p>
<p>ST SPC582Bx  </p>
<p>Reference Manual </p>
<p>Rev. 1, 08/2015 </p>
<p>SPC584Bxx </p>
<p>ST SPC584Cx/SPC58ECx  </p>
<p>Reference Manual </p>
<p>Rev. 1, 10/2015 </p>
<p>SPC584Cxx </p>
<p>ST SPC584Cx/SPC58ECx  </p>
<p>Reference Manual </p>
<p>Rev. 1, 10/2015 </p>
<p>SPC584Gxx </p>
<p>ST SPC58NE84x/SPC58xG84x  </p>
<p>Reference Manual </p>
<p>Rev. 2, 02/2016 </p>
<p>Table 1-4  </p>
<p>Supported Power PC Hardware </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>21 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>Windriver DiabData </b></p>
<p>5.9.4.x </p>
<p><b>Green Hills (GHS) </b></p>
<p>2014.1.6 </p>
<p>Table 1-5  </p>
<p>Supported Power PC compilers </p>
<p><b>1.4.3 </b></p>
<p><b>ARM </b></p>
<p><b>Derivative </b></p>
<p><b>Hardware Manufacturer Document Name </b></p>
<p><b>Document </b></p>
<p><b>Version </b></p>
<p>S6J32xx </p>
<p>Cypress S6J3200 Series Hardware Manual </p>
<p>Rev. 4.0, </p>
<p>09/2015 </p>
<p>ZUxxx </p>
<p>XILINX Zynq UltraScale+ MPSoc Technical Reference Manual </p>
<p>v1.2, 06/2016 </p>
<p>iMX6xx </p>
<p>i.MX 6Dual/6Quad  Applications Processor Reference Manual </p>
<p>Rev. 3, </p>
<p>07/2015 </p>
<p>Table 1-6  </p>
<p>Supported ARM Hardware </p>
<p><b>Green Hills (GHS) </b></p>
<p>2013.5.4 </p>
<p><b>IAR </b></p>
<p>V7.50.1 </p>
<p>Table 1-7  </p>
<p>Supported ARM compilers </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>22 </p>
<p>based on template version 6.0.1 </p>
<p><b>1.4.4 </b></p>
<p><b>RH850 </b></p>
<p><b>Derivative Family </b></p>
<p><b>Hardware Manufacturer Document Name </b></p>
<p><b>Document Version </b></p>
<p>RH850 C1M </p>
<p>RH850 C1H </p>
<p>RH850/C1x User’s Manual: Hardware </p>
<p>Rev.1.00 Mar 2015 </p>
<p>RH850 D1x </p>
<p>RH850/D1L/D1M Group User’s Manual: Hardware </p>
<p>Rev.2.01 Aug 2016 </p>
<p>RH850 E1x FCC2 </p>
<p>RH850/E1x-FCC2 User’s Manual: Hardware </p>
<p>Rev.0.50 Apr 2015 </p>
<p>RH850 E1x FCC1 </p>
<p>RH850/E1x-FCC1 User’s Manual: Hardware </p>
<p>Rev.0.50 Jul 2014 </p>
<p>RH850 E1L </p>
<p>RH850/E1L User’s Manual: Hardware </p>
<p>Rev.1.10 Apr 2016 </p>
<p>RH850 E1M </p>
<p>RH850/E1M-S User’s Manual: Hardware </p>
<p>Rev.1.10 Apr 2016 </p>
<p>RH850 F1H </p>
<p>RH850/F1H Group User’s Manual: Hardware </p>
<p>Rev.1.12 May 2016 </p>
<p>RH850 F1L </p>
<p>RH850/F1L Group User’s Manual: Hardware </p>
<p>Rev.1.33 Apr 2016 </p>
<p>RH850 F1K </p>
<p>RH850/F1K Group User’s Manual: Hardware </p>
<p>Rev.1.00 Jun 2016 </p>
<p>RH850 F1M </p>
<p>RH850/F1M Group User’s Manual: Hardware </p>
<p>Rev.1.03 May 2016 </p>
<p>RH850 P1HC </p>
<p>RH850/P1x-C Group User’s Manual: Hardware </p>
<p>Rev.1.10 Jul 2016 </p>
<p>RH850 P1MC </p>
<p>RH850/P1x-C Group User’s Manual: Hardware </p>
<p>Rev.1.10 Jul 2016 </p>
<p>RH850 P1M </p>
<p>RH850/P1x Group User’s Manual: Hardware </p>
<p>Rev.1.00 Jul, 2015 </p>
<p>RH850 R1L </p>
<p>RH850/R1x Group User’s Manual: Hardware </p>
<p>Rev.1.31 Jun 2016 </p>
<p>G3K Core </p>
<p>RH850G3K User’s Manual: Software </p>
<p>Rev.1.20 Apr 2016 </p>
<p>G3KH Core </p>
<p>RH850G3KH User’s Manual: Software </p>
<p>Rev.1.10 Jul 2016 </p>
<p>G3M Core </p>
<p>RH850G3M User’s Manual: Software </p>
<p>Rev.1.30 Jun 2016 </p>
<p>G3MH Core </p>
<p>RH850G3MH User’s Manual: Software </p>
<p>Rev.1.00 Mar 2015 </p>
<p>Table 1-8  </p>
<p>Supported RH850 Hardware </p>
<p><b>Green Hills (GHS) </b></p>
<p>V6.1.4 2013.5.5 </p>
<p>V6.1.6 2015.1.5 </p>
<p>Table 1-9  </p>
<p>Supported RH850 Compilers </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>23 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>1.4.5 </b></p>
<p><b>VTT OS </b></p>
<p>VTT  OS  stands  for  “vVIRTUALtarget  Operating  System”.  It  runs  within  Vectors  CANoe </p>
<p>development tool. </p>
<p>Vectors CANoe is capable of simulating an entire ECU network. Within such a simulated </p>
<p>network the OS of each ECU can be simulated. </p>
<p>This is useful in early ECU development phases when no real hardware is available yet. </p>
<p>Application development can be started at once. </p>
<p>The VTT OS behaves as regular AUTOSAR OS. All OS objects (e.g. tasks or ISRs) are </p>
<p>simulated. </p>
<p>The VTT system is described in [6]. </p>
<p><b>1.4.5.1 </b></p>
<p><b>Characteristics of VTT OS </b></p>
<p><b>Supported Scalability Classes </b></p>
<p>SC1, SC2 </p>
<p><b>Single Core ECUs </b></p>
<p>Supported </p>
<p><b>Multi Core ECUs </b></p>
<p>Up to 32 cores are supported </p>
<p><b>IOC </b></p>
<p>Supported </p>
<p><b>Number of Simulated Interrupt Sources </b></p>
<p>Up to 10000 </p>
<p><b>Simulated Interrupt Levels </b></p>
<p>VTT OS allows interrupt levels from 1 .. 200 </p>
<p>Whereas 1 is the lowest priority and 200 is the </p>
<p>highest. </p>
<p><b>Memory Protection </b></p>
<p>Not supported</p>
<p>2</p>
<p> </p>
<p><b>Stack Protection </b></p>
<p>Not supported </p>
<p><b>Stack Usage Measurement </b></p>
<p>Not supported </p>
<p><b>Stack Sharing </b></p>
<p>Not supported </p>
<p>Table 1-10  </p>
<p>VTT OS characteristics </p>
<p> </p>
<p>                                            </p>
<p>2</p>
<p> The memory protection can be configured. However the actual protection mechanism is not executed. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>24 </p>
<p>based on template version 6.0.1 </p>
<p><b>2 </b></p>
<p><b>Functional Description </b></p>
<p><b>2.1 </b></p>
<p><b>General </b></p>
<p>The  MICROSAR  OS  basically  implements  the  OS  according  to  the  AUTOSAR </p>
<p>OS </p>
<p>standard referred in [1]. </p>
<p>It  is  possible  that  MICROSAR  OS  deviates  from  specified  AUTOSAR  OS  behavior.  All </p>
<p>deviations from the standard are listed in the chapters hereafter. </p>
<p>On the other hand MICROSAR OS extends the AUTOSAR OS standard with numerous </p>
<p>functions. These extensions in function are described in detail in chapter 2.21.1. </p>
<p><b>2.2 </b></p>
<p><b>MICROSAR OS Deviations from AUTOSAR OS Specification </b></p>
<p><b>2.2.1 </b></p>
<p><b>Generic Deviation for API Functions </b></p>
<p><b>Specified Behavior </b></p>
<p>There are some API functions which are only available within specific </p>
<p>scalability classes (e.g. TerminateApplication() in SC3 and SC4 only). </p>
<p><b>Deviation Description </b></p>
<p>Within the MICROSAR OS all API functions are always available. </p>
<p><b>Deviation Reason </b></p>
<p>The static OS code gets more simplified for better maintainability (less </p>
<p>pre-processor statements are necessary). </p>
<p>Modern toolchains will remove unused function automatically. </p>
<p> </p>
<p><b>2.2.2 </b></p>
<p><b>Trusted Function API Deviations </b></p>
<p><b>Specified Behavior </b></p>
<p>The Operating System shall not schedule any other Tasks which </p>
<p>belong to the same OS-Application as the non-trusted caller of the </p>
<p>service. Also interrupts of Category 2 which belong to the same OS-</p>
<p>Application shall be disabled during the execution of the service. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS the re-scheduling of tasks in this particular case is </p>
<p>not suppressed. </p>
<p>The selective disabling of category 2 ISRs is also not done. </p>
<p><b>Deviation Reason </b></p>
<p>For a better runtime performance during trusted function calls the </p>
<p>specified behavior is not implemented in MICROSAR OS. </p>
<p>Data consistency problems can be solved in a more efficient way by </p>
<p>using the OS interrupt API and/or OS resource API. </p>
<p> </p>
<p><b>Specified Behavior </b></p>
<p>All specified OS APIs should be called with interrupts enabled. </p>
<p>In case CallTrustedFunction() API is called with disabled interrupts it </p>
<p>returns the status code E_OS_DISABLEDINT. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS this limitation does not exist. </p>
<p>It is allowed to call CallTrustedFunction() API with disabled interrupts. </p>
<p>There is no error check. </p>
<p>The return value E_OS_DISABLEDINT is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>It offers the possibility to call CallTrustedFunction() API where </p>
<p>interrupts may be disabled. This is more convenient and reasonable. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>25 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.2.3 </b></p>
<p><b>Service Protection Deviation </b></p>
<p><b>Specified Behavior </b></p>
<p>If an invalid address (address is not writable by this OS-Application) is </p>
<p>passed as an out-parameter to an Operating System service, the </p>
<p>Operating System module shall return the status code </p>
<p>E_OS_ILLEGAL_ADDRESS. </p>
<p><b>Deviation Description </b></p>
<p>The validity of out-parameters is checked automatically by the MPU. </p>
<p>Write accesses to such parameters are always done with the </p>
<p>accessing rights of the caller of the OS service. </p>
<p>If the address is invalid a MPU exception is raised. </p>
<p>The return value E_OS_ILLEGAL_ADDRESS is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>Hardware checks by the MPU are much more performant than </p>
<p>software memory checks. </p>
<p> </p>
<p><b>2.2.4 </b></p>
<p><b>SyncScheduleTable API Deviation </b></p>
<p><b>Specified Behavior </b></p>
<p>All specified OS APIs should be called with interrupts enabled. </p>
<p>In case SyncScheduleTable() is called with disabled interrupts it </p>
<p>returns the status code E_OS_DISABLEDINT. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS this limitation does not exist. </p>
<p>It is allowed to call SyncScheduleTable() with disabled interrupts. </p>
<p>There is no error check. </p>
<p>The return value E_OS_DISABLEDINT is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>It offers the possibility to call SyncScheduleTable() where interrupts </p>
<p>may be disabled. This is more convenient and reasonable. </p>
<p> </p>
<p><b>2.2.5 </b></p>
<p><b>CheckTask/ISRMemoryAccess API Deviation </b></p>
<p><b>Specified Behavior </b></p>
<p>All specified OS APIs should be called with interrupts enabled. </p>
<p>In case one of these APIs is called with disabled interrupts it issues </p>
<p>the error E_OS_DISABLEDINT. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS this limitation does not exist. </p>
<p>It is allowed to call these API functions with disabled interrupts. There </p>
<p>is no error check. </p>
<p>The return value E_OS_DISABLEDINT is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>It offers the possibility to call these functions e.g. from hardware </p>
<p>drivers where interrupts may be disabled. This is more convenient and </p>
<p>reasonable. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>26 </p>
<p>based on template version 6.0.1 </p>
<p><b>Specified Behavior </b></p>
<p>The API functions CheckTask/ISRMemoryAccess() are only allowed </p>
<p>within specific OS call contexts (Task/Cat2 </p>
<p>ISR/ErrorHook/ProtectionHook) </p>
<p>In case one of these APIs is called within the wrong OS call context it </p>
<p>issues the error E_OS_CALLEVEL. </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS In MICROSAR OS this limitation does not exist. </p>
<p>It is allowed to call these API functions from all OS contexts. </p>
<p>The return value E_OS_CALLEVEL is not possible. </p>
<p><b>Deviation Reason </b></p>
<p>Practically it is more reasonable to allow these APIs in all OS runtime </p>
<p>contexts. </p>
<p> </p>
<p><b>2.2.6 </b></p>
<p><b>Interrupt API Deviation </b></p>
<p><b>Specified Behavior </b></p>
<p>The API functions SuspendOSInterrupts() and ResumeOSInterrupts() </p>
<p>are allowed within a category 1 ISR </p>
<p><b>Deviation Description </b></p>
<p>In MICROSAR OS it is not allowed to use SuspendOSInterrupts() and </p>
<p>ResumeOSInterrupts() within a category 1 ISR. </p>
<p><b>Deviation Reason </b></p>
<p>The function SuspendOSInterrupts() lowers the current interrupt level </p>
<p>when used in a category 1 ISR. This may lead to data inconsistencies </p>
<p>if another category 1 ISR occurs. </p>
<p>Therefore those functions are not allowed. </p>
<p> </p>
<p><b>2.2.7 </b></p>
<p><b>Cross Core Getter APIs </b></p>
<p><b>Specified Behavior </b></p>
<p>All getter APIs (e.g. GetTaskID()) may be called cross core within </p>
<p>hooks and non nestable category 2 ISRs. </p>
<p><b>Deviation Description </b></p>
<p>MICROSAR OS does not allow usage of those functions within OS </p>
<p>Hooks and non-nestable category 2 ISRs. </p>
<p><b>Deviation Reason </b></p>
<p>Deadlock avoidance due to disabled interrupts in case that there are </p>
<p>two simultaneous concurrent usages of those APIs from multiple </p>
<p>cores. </p>
<p> </p>
<p><b>2.2.8 </b></p>
<p><b>IOC </b></p>
<p><b>Specified Behavior </b></p>
<p>IocSend/IocWrite APIs have an IN parameter. The parameter will be </p>
<p>passed by value for primitive data elements and by reference for all </p>
<p>other types. The data type is configured in “OsIocDataTypeRef”. </p>
<p><b>Deviation Description </b></p>
<p>The configurator does not evaluate information in </p>
<p>“OsIocDataTypeRef”. Instead it evaluates the parameter </p>
<p>“OsIocDataType“. Primitive data types are passed by value. The </p>
<p>configurator identifies the following strings as primitive data types: </p>
<p>“uint8”, “uint16” and “uint32”. All other data types are passed by </p>
<p>reference. </p>
<p><b>Deviation Reason </b></p>
<p>Usage of “OsIocDataType” reduces dependencies and complexity of </p>
<p>the OS configurator. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>27 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.2.9 </b></p>
<p><b>Return value upon stack violation </b></p>
<p><b>Specified Behavior </b></p>
<p>If a stack fault is detected by stack monitoring AND no ProtectionHook </p>
<p>is configured, the Operating System module shall call the </p>
<p>ShutdownOS() service with the status E_OS_STACKFAULT. </p>
<p><b>Deviation Description </b></p>
<p>Within a SC3 / SC4 system with MPU stack supervision: </p>
<p>If a stack fault is detected by stack monitoring AND no ProtectionHook </p>
<p>is configured, the Operating System module shall call the </p>
<p>ShutdownOS() service with the status </p>
<p>E_OS_PROTECTION_MEMORY. </p>
<p><b>Deviation Reason </b></p>
<p>With Hardware stack supervision MICROSAR OS is not possible to </p>
<p>distinguish between stack violation and other memory violation </p>
<p> </p>
<p><b>Specified Behavior </b></p>
<p>If a stack fault is detected by stack monitoring AND a ProtectionHook </p>
<p>is configured the Operating System module shall call the </p>
<p>ProtectionHook() with the status E_OS_STACKFAULT. </p>
<p><b>Deviation Description </b></p>
<p>Within a SC3 / SC4 system with MPU stack supervision: </p>
<p>If a stack fault is detected by stack monitoring AND a ProtectionHook </p>
<p>is configured the Operating System module shall call the </p>
<p>ProtectionHook() with the status E_OS_PROTECTION_MEMORY. </p>
<p><b>Deviation Reason </b></p>
<p>With Hardware stack supervision MICROSAR OS is not possible to </p>
<p>distinguish between stack violation and other memory violation </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>28 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.2.10 </b></p>
<p><b>Forcible Termination of Applications </b></p>
<p><b>Specified Behavior </b></p>
<p>AUTOSAR does not specify the handling of “next” schedule tables in </p>
<p>case of forcible termination of applications. </p>
<p><b>Deviation Description </b></p>
<p>Use case: </p>
<p>An application has a running schedule table which itself has a nexted </p>
<p>schedule table of a foreign application. </p>
<p>The foreign application is forcibly terminated. </p>
<p> </p>
<p>The OS removes the “next” request from the running schedule table. </p>
<p><b>Deviation Reason </b></p>
<p>Clarification of behavior. </p>
<p>Impact on other applications should be minimal, therefore the current </p>
<p>schedule table is not stopped. This is different to the behavior of </p>
<p>StopScheduleTable(). </p>
<p> </p>
<p><b>Specified Behavior </b></p>
<p>AUTOSAR does not specify the handling of “next” schedule tables in </p>
<p>case of forcible termination of applications. </p>
<p><b>Deviation Description </b></p>
<p>Use case: </p>
<p>An application has a running schedule table which itself has a nexted </p>
<p>schedule table of a foreign application. </p>
<p>The first application is forcibly terminated. </p>
<p> </p>
<p>The OS stops the current schedule table of the terminated application. </p>
<p>and removes the “next” request. </p>
<p>As a result it does not switch to the “next” schedule table of the foreign </p>
<p>application. </p>
<p><b>Deviation Reason </b></p>
<p>Clarification of behavior. </p>
<p>Impact on other applications should be minimal. The described </p>
<p>behavior is identical to the behavior of StopScheduleTable(). </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>29 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.3 </b></p>
<p><b>Stack Concept </b></p>
<p>MICROSAR OS implements a specific stack concept. </p>
<p>It  defines  different  stacks  which  may  be  used  by  stack  consumers  (runtime  contexts). </p>
<p>Whereas not all stacks may be used by all consumers. </p>
<p>The following table gives an overview. </p>
<p><b>Stack Type </b></p>
<p><b>Multiplicity </b></p>
<p><b>Possible Stack Consumers </b></p>
<p>Kernel stack </p>
<p>1 per core </p>
<p><b>&gt; </b></p>
<p>OS memory exception handling </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>Protection stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>ProtectionHook() </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>Error stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>ErrorHooks (global and OS-application specific) </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Category 1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>Shutdown stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>ShutdownHooks (global and OS-application </p>
<p>specific) </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>Startup stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>StartupHooks (global and OS-application specific) </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Category 1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>NTF stacks </p>
<p>0..n </p>
<p><b>&gt; </b></p>
<p>Non-trusted functions </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>OS ISR wrapper </p>
<p><b>&gt; </b></p>
<p>Trusted functions </p>
<p><b>&gt; </b></p>
<p>Alarm callback functions </p>
<p><b>&gt; </b></p>
<p>Pre / PostTaskHook() </p>
<p><b>&gt; </b></p>
<p>Category 1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>No nesting interrupt stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>No nesting category 2 ISRs </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>Trusted functions </p>
<p><b>&gt; </b></p>
<p>Alarm callback functions </p>
<p><b>&gt; </b></p>
<p>Category 1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>30 </p>
<p>based on template version 6.0.1 </p>
<p>Interrupt level stacks </p>
<p>0..n </p>
<p><b>&gt; </b></p>
<p>Nesting category 2 ISRs </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>OS ISR wrapper </p>
<p><b>&gt; </b></p>
<p>Trusted functions </p>
<p><b>&gt; </b></p>
<p>Alarm callback functions </p>
<p><b>&gt; </b></p>
<p>Category 1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>Task stacks </p>
<p>1..n </p>
<p><b>&gt; </b></p>
<p>Tasks </p>
<p><b>&gt; </b></p>
<p>OS API calls </p>
<p><b>&gt; </b></p>
<p>OS ISR wrapper </p>
<p><b>&gt; </b></p>
<p>Trusted functions </p>
<p><b>&gt; </b></p>
<p>Alarm callback functions </p>
<p><b>&gt; </b></p>
<p>Pre / PostTaskHook() </p>
<p><b>&gt; </b></p>
<p>Category 1 ISRs </p>
<p><b>&gt; </b></p>
<p>Os_PanicHook() </p>
<p>IOC receiver pull callback </p>
<p>stack </p>
<p>0..1 per core </p>
<p><b>&gt; </b></p>
<p>IOC receiver pull callback functions </p>
<p>Table 2-1  </p>
<p>MICROSAR OS Stack Types </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The stack sizes of all stacks must be configured within the ECU configuration </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>31 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.3.1 </b></p>
<p><b>Task Stack Sharing </b></p>
<p><b>2.3.1.1 </b></p>
<p><b>Description </b></p>
<p>In order to save RAM it is possible that different basic tasks share the same task stack. </p>
<p>These basic tasks must behave cooperative to each other (must not preempt each other). </p>
<p><b>2.3.1.2 </b></p>
<p><b>Activation </b></p>
<p>The attribute “OsTaskStackSharing” of a basic task has to be set to TRUE. </p>
<p>All  basic  tasks  on  the  same  task  priority  and  with  activated  task  stack  sharing  are </p>
<p>cooperative and share one task stack. </p>
<p>The  size  of  the  shared  task  stack  is  the  maximum  of  all  configured  task  stack  sizes  of </p>
<p>tasks with the same priority. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Stack sharing of tasks can only be achieved between tasks which are assigned to the </p>
<p>same core! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.1.3 </b></p>
<p><b>Usage </b></p>
<p>The feature is automatically used by the OS. Tasks which are cooperative to each other </p>
<p>are sharing the same stack. </p>
<p><b>2.3.2 </b></p>
<p><b>ISR Stack Sharing </b></p>
<p><b>2.3.2.1 </b></p>
<p><b>Description </b></p>
<p>In  order  to  save  RAM  it  is  possible  that  different  category  2  ISRs  share  the  same  ISR </p>
<p>stack. </p>
<p><b>&gt; </b></p>
<p>All category 2 ISRs which are not nestable can share one stack. </p>
<p><b>&gt; </b></p>
<p>All Category 2 ISRs which have the same priority can share one stack. </p>
<p><b>2.3.2.2 </b></p>
<p><b>Activation </b></p>
<p>The attribute “OsIsrEnableNesting” must be set to FALSE for a category 2 ISR. </p>
<p>The size of the shared ISR stack is the maximum of all configured ISR stack sizes of non-</p>
<p>nestable category 2 ISRs. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Stack sharing of ISRs can only be achieved between ISRs which are assigned to the </p>
<p>same core! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>32 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.3.2.3 </b></p>
<p><b>Usage </b></p>
<p>The feature is used automatically by the OS. All category 2 ISRs on the same core which </p>
<p>are not nestable are sharing the same stack. </p>
<p><b>2.3.3 </b></p>
<p><b>Stack Check Strategy </b></p>
<p>All OS stacks must be protected from overflowing. </p>
<p>MICROSAR  OS  offers  different  strategies  to  detect  stack  overflows  or  even  to  prevent </p>
<p>stacks from overflowing. </p>
<p>In dependency of the configured scalability class there are the following strategies: </p>
<p> </p>
<p><b>Scalability Class </b></p>
<p>Stack check strategy </p>
<p><b>SC1 / SC2 </b></p>
<p>Software stack check (see 2.3.4) </p>
<p><b>SC3 / SC4 </b></p>
<p>Stack supervision by memory protection unit (MPU) (see 2.3.5) </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>33 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.3.4 </b></p>
<p><b>Software Stack Check </b></p>
<p><b>2.3.4.1 </b></p>
<p><b>Description </b></p>
<p>The OS initializes the very last  element of each stack to a specific stack check pattern. </p>
<p>Whenever a stack switch is performed (e.g. a task switch) the OS checks whether this last </p>
<p>element of the last valid stack still holds the stack check pattern. </p>
<p>If the OS detects that the stack check pattern has been altered it assumes that the last </p>
<p>valid stack did overflow. </p>
<p><b> </b></p>
<p>Stack Check Pattern </p>
<p><b>32 Bit Microcontrollers </b></p>
<p>0xAAAAAAAA </p>
<p>Table 2-2  </p>
<p>Stack Check Patterns </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The software stack check is able to detect stack overflows. It is not capable to avoid </p>
<p>them! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.4.2 </b></p>
<p><b>Activation </b></p>
<p>Within  a  SC1  or  SC2  configuration  the  attribute  “OsStackMonitoring”  has  to  be  set  to </p>
<p>TRUE to activate the software stack check feature. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>On platforms which disable the MPU in supervisor mode, the software stack check may </p>
<p>be activated also for SC3 and SC4 configurations. </p>
<p>On other platforms the software stack check should be switched off in a SC3 or SC4 </p>
<p>configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.4.3 </b></p>
<p><b>Usage </b></p>
<p>Once  the  feature  is  activated  the  OS  checks  the  stacks  automatically  upon  each  stack </p>
<p>switch. </p>
<p>If the OS detects a stack overflow it goes into shutdown. If a ShutdownHook is configured </p>
<p>it is invoked to inform the application about OS shutdown. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Debugging hint: The stack check pattern is restored by the OS before the </p>
<p>ShutdownHook() is called. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>34 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.3.5 </b></p>
<p><b>Stack Supervision by MPU </b></p>
<p><b>2.3.5.1 </b></p>
<p><b>Description </b></p>
<p>During the whole runtime of the OS the current active stack is supervised by the MPU of </p>
<p>the microcontroller. Therefore the OS reserves one MPU region which is reprogrammed by </p>
<p>the OS with each stack switch. </p>
<p>Stack overflows  cannot happen  since  the MPU avoids  write  accesses beyond  the  stack </p>
<p>boundaries. </p>
<p>Whenever a memory violation is recognized (e.g. due to a stack violation) an exception is </p>
<p>raised. Within the exception handling the OS calls the ProtectionHook(). </p>
<p>The application decides in the ProtectionHook() how to deal with the memory protection </p>
<p>violation. If the application invokes the shutdown of the OS, the ShutdownHook() is called </p>
<p>as well (if configured). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The stack supervision recognizes write accesses beyond stack boundaries and </p>
<p>suppresses them. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.3.5.2 </b></p>
<p><b>Activation </b></p>
<p>The system must be configured as a SC3 or SC4 system. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>35 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.3.5.3 </b></p>
<p><b>Usage </b></p>
<p>In  a  SC3  /  SC4  system  the  OS  automatically  initializes </p>
<p>one  MPU  region  for  stack </p>
<p>supervision. </p>
<p>To  safely  detect  stack  violations  special  care  must  be  taken  with  configuring  additional </p>
<p>MPU regions and also with linking of sections: </p>
<p><b>&gt; </b></p>
<p>When configuring additional MPU regions included memory region must never overlap </p>
<p>with any OS stack sections. </p>
<p><b>&gt; </b></p>
<p>By using an OS generated linker command file (see 4.3.2) it is assured that the OS </p>
<p>stacks are linked consecutively into the RAM. </p>
<p><b>&gt; </b></p>
<p>A stack safety gap is needed which is linked adjacent to the stacks (in dependency of </p>
<p>the stack growth direction; see Figure 2-1). No software parts must have write access </p>
<p>to the stack safety gap. </p>
<p><b>&gt; </b></p>
<p>The size of the stack safety gap must be at least the granularity of the MPU. </p>
<p><b>&gt; </b></p>
<p>The linkage of the safety gap is mandatory. Otherwise a stack violation of the stack </p>
<p>with the lowest address cannot be detected. </p>
<p> </p>
<p> </p>
<p>Figure 2-1 </p>
<p>Stack Safety Gap </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Don’t configure MPU regions which grant access to any OS stacks </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>Stack growth direction</p>
<p>OS stacks</p>
<p>stack safety gap</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>36 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Add a stack safety gap to the linkage scheme. The stack safety gap is a restricted </p>
<p>memory region. No software parts must have write access to this region. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>37 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.3.6 </b></p>
<p><b>Stack Usage Measurement </b></p>
<p><b>2.3.6.1 </b></p>
<p><b>Description </b></p>
<p>During runtime of the OS the maximum stack usage can be obtained by the  application. </p>
<p>The OS initializes all OS stacks with the stack check pattern (see Table 2-2). </p>
<p>There are API functions which are capable to return the maximum stack usage (since call </p>
<p>of StartOS()) for each stack (see 5.6). </p>
<p><b>2.3.6.2 </b></p>
<p><b>Activation </b></p>
<p>Set “OsStackUsageMeasurement” to TRUE </p>
<p><b>2.3.6.3 </b></p>
<p><b>Usage </b></p>
<p>The stack usage APIs can be used anywhere in application. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>To save OS startup time, the feature can be deactivated in a productive environment. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>38 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.4 </b></p>
<p><b>Interrupt Concept </b></p>
<p><b>2.4.1 </b></p>
<p><b>Interrupt Handling API </b></p>
<p>The  AUTOSAR  OS  standard  specifies  several  APIs  to  disable  /  enable  Interrupts.  The </p>
<p>implementation  of  those  functions  and  their  effects  on  the  application  depends  on  the </p>
<p>timing protection configuration. </p>
<p><b>2.4.1.1 </b></p>
<p><b>Interrupt Handling in SC1 / SC3 </b></p>
<p>Without configured timing protection the interrupt APIs are implemented as follows: </p>
<p>  </p>
<p>Figure 2-2 </p>
<p>Interrupt APIs in SC1 / SC3 </p>
<p><b>DisableAllInterrupts() </b></p>
<p><b>EnableAllInterrupts() </b></p>
<p>The functions disable all interrupts by </p>
<p>manipulate a global interrupt mask / </p>
<p>disable flag </p>
<p><b>SuspendAllInterrupts() </b></p>
<p><b>ResumeAllInterrupts() </b></p>
<p><b>SuspendOSInterrupts() </b></p>
<p><b>ResumeOSInterrupts() </b></p>
<p>The functions disable category 2 </p>
<p>interrupts by manipulate the interrupt </p>
<p>priority / level </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The lowest priority of all category 1 ISRs is called OS system level. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Interrupt Priority</b></p>
<p><b>High</b></p>
<p><b>Low</b></p>
<p><b>Tasks</b></p>
<p><b>Category</b></p>
<p><b>2</b></p>
<p><b>ISRs</b></p>
<p><b>Category</b></p>
<p><b>1</b></p>
<p><b>ISRs</b></p>
<p><b>SuspendOSInterrupts()</b></p>
<p><b>ResumeOSInterrupts()</b></p>
<p><b>DisableAllInterrupts()</b></p>
<p><b>EnableAllInterrupts()</b></p>
<p><b>SuspendAllInterrupts()</b></p>
<p><b>ResumeAllInterrupts()</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>39 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.4.1.2 </b></p>
<p><b>Interrupt Handling in SC2 / SC4 </b></p>
<p>With configured timing protection the interrupt APIs are implemented as follows: </p>
<p> </p>
<p>Figure 2-3 </p>
<p>Interrupt API in SC2 / SC4 </p>
<p><b>DisableAllInterrupts() </b></p>
<p><b>EnableAllInterrupts() </b></p>
<p>The functions disable all interrupts except the timing protection </p>
<p>interrupt </p>
<p></p>
<p> By manipulate a global interrupt mask / disable flag (if the timing </p>
<p>protection interrupt is not maskable) </p>
<p></p>
<p> By manipulate the interrupt priority / level (if the timing protection </p>
<p>interrupt is maskable) </p>
<p>See chapter 2.19 for details </p>
<p><b>SuspendAllInterrupts() </b></p>
<p><b>ResumeAllInterrupts() </b></p>
<p><b>SuspendOSInterrupts() </b></p>
<p><b>ResumeOSInterrupts() </b></p>
<p>The functions disable category 2 interrupts by manipulate the </p>
<p>interrupt priority / level </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>Interrupt Priority</b></p>
<p><b>High</b></p>
<p><b>Low</b></p>
<p><b>Tasks</b></p>
<p><b>Category</b></p>
<p><b>2</b></p>
<p><b>ISRs</b></p>
<p><b>Category</b></p>
<p><b>1</b></p>
<p><b>ISRs</b></p>
<p><b>Timing </b></p>
<p><b>Protection</b></p>
<p><b>ISR</b></p>
<p><b>SuspendOSInterrupts()</b></p>
<p><b>ResumeOSInterrupts()</b></p>
<p><b>DisableAllInterrupts()</b></p>
<p><b>EnableAllInterrupts()</b></p>
<p><b>SuspendAllInterrupts()</b></p>
<p><b>ResumeAllInterrupts()</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>40 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.4.2 </b></p>
<p><b>Interrupt Vector Table </b></p>
<p>The </p>
<p>interrupt </p>
<p>vector </p>
<p>table </p>
<p>is </p>
<p>generated </p>
<p>by </p>
<p>MICROSAR </p>
<p>OS </p>
<p>with </p>
<p>respect </p>
<p>to </p>
<p>the </p>
<p>configuration, microcontroller family and used compiler. </p>
<p>In a multi core system multiple vector tables may be generated. </p>
<p>MICROSAR OS generates an interrupt vector for each possible interrupt source. </p>
<p><b>2.4.3 </b></p>
<p><b>Nesting of Category 2 Interrupts </b></p>
<p><b>2.4.3.1 </b></p>
<p><b>Description </b></p>
<p>To keep interrupt latency as low as possible it is possible that </p>
<p><b>&gt; </b></p>
<p>A higher priority category 2 ISR interrupts a lower priority category 2 ISR. </p>
<p><b>&gt; </b></p>
<p>A category 1 ISRs interrupts a category 2 ISR (category 1 ISR has always a higher </p>
<p>priority) </p>
<p><b>2.4.3.2 </b></p>
<p><b>Activation </b></p>
<p>When  setting  “OsIsrEnableNesting” to TRUE  the  category  2  ISR itself  is  interruptible  by </p>
<p>higher priority ISRs. </p>
<p><b>2.4.4 </b></p>
<p><b>Category 1 Interrupts </b></p>
<p><b>2.4.4.1 </b></p>
<p><b>Implementation of Category 1 ISRs </b></p>
<p>MICROSAR  OS  offers  a  macro  for  implementing  a  category  1  ISR.  This  is  a  similar </p>
<p>mechanism like the macro for a category 2 ISR defined by the AUTOSAR standard. </p>
<p>MICROSAR OS abstracts the needed compiler keywords. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Implement a category 1 ISR </b></p>
<p>OS_ISR1(&lt;MyCategory1ISR&gt;) </p>
<p>{ </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>41 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.4.4.2 </b></p>
<p><b>Nesting of Category 1 ISRs </b></p>
<p>Since category 1 ISRs are directly called from interrupt vector table without any OS pro- </p>
<p>and epilogue, automatic nesting of category 1 ISRs cannot be supported. </p>
<p>The configuration attribute “OsIsrEnableNesting” is ignored for category 1 ISRs. </p>
<p>Nevertheless  the  interrupts  may  be  enabled  during  a  category  1  ISR  to  allow  interrupt </p>
<p>nesting but OS API functions cannot be used for this purpose. The application has to use </p>
<p>compiler intrinsic functions or inline assembler statements. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>OS_ISR1(&lt;MyCategory1ISR&gt;) </p>
<p>{ </p>
<p>   __asm(EI); /* enable nesting of this ISR */ </p>
<p> </p>
<p>   __asm(DI); /* disable nesting before leaving the function */ </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.4.4.3 </b></p>
<p><b>Category 1 ISRs before StartOS </b></p>
<p>There may be the need to activate and serve category 1 ISRs before the OS has  been </p>
<p>started. </p>
<p>The following sequence should be implemented: </p>
<p>1. </p>
<p>Call Os_InitMemory </p>
<p>2. </p>
<p>Call Os_Init (within the function the basic interrupt controller settings are initialized </p>
<p>e.g. priorities of interrupt sources). </p>
<p>3. </p>
<p>Enable the Interrupt sources of category 1 ISRs by directly manipulating the control </p>
<p>registers in the interrupt controller. </p>
<p>4. </p>
<p>Enable  the  interrupts  by  directly  manipulating  the  global  interrupt  flag  and  /  or </p>
<p>current interrupt priority to allow the category 1 ISRs </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>42 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.4.4.4 </b></p>
<p><b>Notes on Category 1 ISRs </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>On platforms which have no automatic stack switch upon interrupt request there will be </p>
<p>no stack switch at all if a category 1 ISR occurs. Thus the stack consumption of a </p>
<p>category 1 ISR should be added to all stacks which are can be consumed by category </p>
<p>1 ISRs (see 2.3 for an overview). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Although the interrupt priorities are initialized by MICROSAR OS there is no API to </p>
<p>enable or acknowledge category 1 ISRs. The interrupt control registers have to be </p>
<p>accessed directly. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The AUTOSAR OS standard does not allow OS API usage within category 1 ISRs (the </p>
<p>only exception is the interrupt handling API). </p>
<p>If a not allowed OS API is called anyway, MICROSAR OS is not able to detect this and </p>
<p>the called API may not work as expected. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Category 1 ISRs are always executed with trusted rights on supervisor level. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>43 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.4.5 </b></p>
<p><b>Initialization of Interrupt Sources </b></p>
<p>Through the OS configuration MICROSAR OS knows the assignment of interrupt sources </p>
<p>and priorities to ISRs. In multi core system the core assignment of all ISRs is also known. </p>
<p>Based  on  these  configuration  information  MICROSAR  OS  generates  data  structures  for </p>
<p>initializing the interrupt controller. It initializes the interrupt priority and its core assignment. </p>
<p><b>2.4.6 </b></p>
<p><b>Unhandled Interrupts </b></p>
<p>Interrupt sources which are not assigned to a user defined ISR are assigned to a default </p>
<p>OS interrupt handler which collects those interrupt sources. </p>
<p>Thus interrupt requests from unassigned interrupt sources are handled by the OS. Within </p>
<p>OS  Hooks  (e.g.  ProtectionHook())  the  application  can  obtain  the  source  number  of  the </p>
<p>unhandled interrupt request by an OS API (see 5.5.1 for details). </p>
<p>In case of an unhandled interrupt request MICROSAR OS calls the ProtectionHook() with </p>
<p>the parameter E_OS_SYS_PROTECTION_IRQ. </p>
<p><b>2.5 </b></p>
<p><b>Exception Concept </b></p>
<p><b>2.5.1 </b></p>
<p><b>Exception Vector Table </b></p>
<p>The </p>
<p>exception </p>
<p>vector </p>
<p>table </p>
<p>is </p>
<p>generated </p>
<p>by </p>
<p>MICROSAR </p>
<p>OS </p>
<p>with </p>
<p>respect </p>
<p>to </p>
<p>the </p>
<p>configuration, microcontroller family and used compiler. </p>
<p>In a multi core multiple vector tables may be generated. </p>
<p>MICROSAR OS generates an exception vector for each possible exception source. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In a SC3 and SC4 system MICROSAR OS defines OS exception handlers for memory </p>
<p>protection errors and for SYSCALL / TRAP instructions. </p>
<p>Exception sources which are used by the OS cannot be configured by the application. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.5.2 </b></p>
<p><b>Unhandled Exceptions </b></p>
<p>Exception </p>
<p>sources </p>
<p>which </p>
<p>are </p>
<p>not </p>
<p>assigned </p>
<p>to </p>
<p>user </p>
<p>defined </p>
<p>exception </p>
<p>handlers </p>
<p>are </p>
<p>assigned to a default OS exception handler which collects those exceptions. </p>
<p>Thus  exception  requests  from  unassigned  exception  sources  are  handled  by  the  OS. </p>
<p>Within  OS  Hooks  the  application  can  obtain  the  exception  number  of  the  unhandled </p>
<p>exception request by an OS API (see 5.5.3 for details). </p>
<p>In case of an unhandled exception request MICROSAR OS calls the ProtectionHook() with </p>
<p>the parameter E_OS_PROTECTION_EXCEPTION. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>44 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.6 </b></p>
<p><b>Timer Concept </b></p>
<p><b>2.6.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS can provide a time base generated from  timer hardware located on the </p>
<p>microcontroller. This time base can be used to drive alarms and schedule-tables. </p>
<p><b>2.6.2 </b></p>
<p><b>Activation </b></p>
<p>The  OS  configuration  may  define  an  OsCounter  Object  of  type  “HARDWARE”.  Then  a </p>
<p>driving hardware must be assigned to “OsDriver” attribute. </p>
<p><b>2.6.3 </b></p>
<p><b>Usage </b></p>
<p>Once the hardware counter is defined it can be assigned to alarms (“OsAlarmCounterRef”) </p>
<p>and schedule-tables (“OsScheduleTableCounterRef”). </p>
<p>Such alarms and schedule-tables are driven time based. </p>
<p>Additionally </p>
<p>MICROSAR </p>
<p>OS </p>
<p>provides </p>
<p>conversion </p>
<p>macros </p>
<p>(which </p>
<p>are </p>
<p>based </p>
<p>on </p>
<p>the </p>
<p>hardware counter configuration) to convert from hardware ticks to time and vice versa (see </p>
<p>for 5.8 details). </p>
<p><b>2.6.4 </b></p>
<p><b>Dependencies </b></p>
<p>A hardware counter can be driven in two modes: </p>
<p><b>&gt; </b></p>
<p>Periodical interrupt timer mode (see 2.7) </p>
<p><b>&gt; </b></p>
<p>High resolution timer mode (see 2.8) </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>45 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.7 </b></p>
<p><b>Periodical Interrupt Timer (PIT) </b></p>
<p><b>2.7.1 </b></p>
<p><b>Description </b></p>
<p>The  timer  hardware  is  set  up  to  generate  timer  interrupts  requests  in  a  strict  periodical </p>
<p>interval (e.g. 1ms). The interval does not change during OS runtime. </p>
<p>Within  each  timer  ISR  MICROSAR  OS  checks  for  alarm  and  schedule-table  expirations </p>
<p>and execute the configured OS action. </p>
<p><b>2.7.2 </b></p>
<p><b>Activation </b></p>
<p><b>&gt; </b></p>
<p>Define an OsCounter of type “HARDWARE” and select the timer Hardware in </p>
<p>“OsDriver”. </p>
<p><b>&gt; </b></p>
<p>Set the counter sub-attribute “OsDriverHighResolution” to FALSE. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsSecondsPerTick” specifies the cycle time of interrupt generation. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsCounterTicksPerBase” specifies the number of timer counter cycles </p>
<p>which are necessary to reach “OsSecondsPerTick”. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The OS will add an appropriate ISR automatically to the configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>46 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.8 </b></p>
<p><b>High Resolution Timer (HRT) </b></p>
<p><b>2.8.1 </b></p>
<p><b>Description </b></p>
<p>The  timer  hardware  is set  up  to  generate  one  timer  interrupt  request  when  an  alarm or </p>
<p>schedule-table action shall be executed. </p>
<p>Within each timer ISR MICROSAR OS performs that action, calculates the timer interval </p>
<p>for the next action and reprograms the timer hardware with the new expiration time. </p>
<p><b>2.8.2 </b></p>
<p><b>Activation </b></p>
<p><b>&gt; </b></p>
<p>Define an OsCounter of type “HARDWARE” and select the timer Hardware in </p>
<p>“OsDriver”. </p>
<p><b>&gt; </b></p>
<p>Set the counter sub-attribute “OsDriverHighResolution” to TRUE. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsSecondsPerTick” specifies the cycle time of the timer counter. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsCounterTicksPerBase” must be set to “1”. </p>
<p><b>&gt; </b></p>
<p>The attribute “OsCounterMaxAllowedValue” must be set to 0x3FFFFFFF </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The OS will add an appropriate ISR automatically to the configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.9 </b></p>
<p><b>PIT versus HRT </b></p>
<p><b> </b></p>
<p>PIT </p>
<p>HRT </p>
<p><b>Interrupt Requests are generated … </b></p>
<p></p>
<p> Strictly periodical </p>
<p></p>
<p> On demand </p>
<p><b>Precision of Alarms / Schedule-</b></p>
<p><b>tables </b></p>
<p></p>
<p> Only multiples of the </p>
<p>attribute </p>
<p>OsSecondsPerTick are </p>
<p>possible for alarm / </p>
<p>schedule-table times. </p>
<p></p>
<p> Any times are possible. </p>
<p>With precision of the </p>
<p>cycle time of the used </p>
<p>timer hardware. </p>
<p><b>Interrupt Load </b></p>
<p></p>
<p> Generates a constant </p>
<p>interrupt load which is </p>
<p>equally distributed over </p>
<p>runtime. </p>
<p></p>
<p> Interrupt load is not </p>
<p>equally distributed over </p>
<p>runtime. </p>
<p></p>
<p> Interrupt bursts may be </p>
<p>possible. </p>
<p>Table 2-3  </p>
<p>PIT versus HRT </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>47 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.10 </b></p>
<p><b>Startup Concept </b></p>
<p>The following  figure  gives  an overview  of the  different  startup  phases  of  the  OS.  It  also </p>
<p>shows which OS API functions are available in the different phases. </p>
<p> </p>
<p>Figure 2-4 </p>
<p>API functions during startup </p>
<p> </p>
<p> </p>
<p><b> stm API Usage before StartOS</b></p>
<p>Ini ti al</p>
<p><b>Startup-Phase0</b></p>
<p><b>Startup-Phase1</b></p>
<p><b>Startup-Phases2and3</b></p>
<p>Ini ti al</p>
<p><b>Startup-Phase2</b></p>
<p>ExitPoint</p>
<p><b>Startup-Phase3</b></p>
<p>After StartOS() all API functions can be </p>
<p>called in exactly the contexts as </p>
<p>described in the AutosarOS standard. </p>
<p>Mind that StartNonAutosarCore() can still </p>
<p>be called.</p>
<p>Init-Step1</p>
<p>Init-Step2</p>
<p>Init-Step3</p>
<p>Init-Step4</p>
<p>Os_CallNonTrustedFunction(),</p>
<p>CallTrustedFunction,</p>
<p>Os_ReadPeripheral*,</p>
<p>Os_WritePeripheral*,</p>
<p>Os_ModifyPeripheral*</p>
<p>Os_EnterPreStartTask()</p>
<p>DisableAllInterrupts(),</p>
<p>EnableAllInterrupts(),</p>
<p>SuspendAllInterrupts(),</p>
<p>ResumeAllInterrupts(),</p>
<p>SuspendOSInterrupts(),</p>
<p>ResumeOSInterrupts(),</p>
<p>StartCore(), GetCoreID(),</p>
<p>StartNonAutosarCore()</p>
<p>StartOS()</p>
<p>Os_Init()</p>
<p>Os_InitMemory()</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>48 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.11 </b></p>
<p><b>Single Core Startup </b></p>
<p>This chapter shows some examples how MICROSAR OS is started as single core OS. </p>
<p><b>2.11.1 </b></p>
<p><b>Single Core Derivatives </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS single core startup on a single core derivative </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p>   StartOS(OSDEFAULTAPPMODE); </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>49 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.11.2 </b></p>
<p><b>Multi Core Derivatives </b></p>
<p><b>2.11.2.1 </b></p>
<p><b>Examples for SC1 / SC2 Systems </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS single core startup on a multi core derivative </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p> </p>
<p>   switch(GetCoreID()) </p>
<p>   { </p>
<p>      case OS_CORE_ID_MASTER: </p>
<p>         StartNonAutosarCore(OS_CORE_ID_1, &amp;rv); /* call of StartNonAutosarCore is </p>
<p>                                                    optional the other core may also be </p>
<p>                                                    held in reset */ </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case OS_CORE_ID_1: </p>
<p>         /* don’t call StartOS; do something else */ </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example starts a single core OS on the master core of a multi core derivative. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS single core startup on a multi core derivative </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p> </p>
<p>   switch(GetCoreID()) </p>
<p>   { </p>
<p>      case OS_CORE_ID_MASTER: </p>
<p>         StartCore(OS_CORE_ID_1, &amp;rv); </p>
<p>         /* don’t call StartOS; do something else */ </p>
<p>         break; </p>
<p>      case OS_CORE_ID_1: </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example starts a single core OS on the slave core of a multi core derivative </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>50 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.11.2.2 </b></p>
<p><b>Examples for SC3 / SC4 Systems </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The function GetCoreID requires a trap into the OS to be functional. Since the OS does </p>
<p>not initialize any trap tables on non-AUTOSAR cores GetCoreID cannot be used on </p>
<p>such cores. </p>
<p>Therefore it is not possible to use the API function GetCoreID within the main function. </p>
<p>A user function (e.g. UsrGetCoreID) is necessary which distinguishes the correct core </p>
<p>ID. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS single core startup on a multi core derivative </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p> </p>
<p>   switch(UsrGetCoreID()) </p>
<p>   { </p>
<p>      case 0: </p>
<p>         StartNonAutosarCore(OS_CORE_ID_1, &amp;rv); /* call of StartNonAutosarCore is </p>
<p>                                                    optional the other core may also be </p>
<p>                                                    held in reset */ </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case 1: </p>
<p>         /* don’t call StartOS; do something else */ </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example starts a single core OS on the master core of a multi core derivative. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>51 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.12 </b></p>
<p><b>Multi Core Startup </b></p>
<p>Within a multi core system each core has the following possibilities when entering the main </p>
<p>function: </p>
<p>1. </p>
<p>Mandatory: call to Os_InitMemory and Os_Init(). </p>
<p>2. </p>
<p>Optional: calls to StartCore() to start additional cores under control of MICROSAR </p>
<p>OS. </p>
<p>3. </p>
<p>Optional: calls to StartNonAutosarCore() to start additional cores which are </p>
<p>independent of MICROSAR OS. </p>
<p>4. </p>
<p>Optional: call StartOS() to start MICROSAR OS on the core  </p>
<p> </p>
<p>For a slave core this is only possible if the core once has been started with </p>
<p>StartCore() API from another core. </p>
<p> </p>
<p>For the master core this is only possible if the core itself is configured to be </p>
<p>an AUTOSAR core. </p>
<p><b>2.12.1 </b></p>
<p><b>Example for SC1 / SC2 Systems </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS multi core startup </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p>    </p>
<p>   switch(GetCoreID()) </p>
<p>   { </p>
<p>      case OS_CORE_ID_MASTER: </p>
<p>         StartCore(OS_CORE_ID_1, &amp;rv); </p>
<p>         StartCore(OS_CORE_ID_2, &amp;rv); </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_1: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_2: </p>
<p>         StartCore(OS_CORE_ID_3, &amp;rv); </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_3: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example shows a possible startup sequence for a quad core system. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>52 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.12.2 </b></p>
<p><b>Examples for SC3 / SC4 systems </b></p>
<p><b>2.12.2.1 </b></p>
<p><b>Only with AUTOSAR Cores </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS multi core startup </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p>    </p>
<p>   switch(GetCoreID()) </p>
<p>   { </p>
<p>      case OS_CORE_ID_MASTER: </p>
<p>         StartCore(OS_CORE_ID_1, &amp;rv); </p>
<p>         StartCore(OS_CORE_ID_2, &amp;rv); </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_1: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_2: </p>
<p>         StartCore(OS_CORE_ID_3, &amp;rv); </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case  OS_CORE_ID_3: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The  example  shows  a  possible  startup  sequence for a  quad  core system.  All  cores  are </p>
<p>configured to be AUTOSAR cores. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>53 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.12.2.2 </b></p>
<p><b>Mixed Core System </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The function GetCoreID requires a trap into the OS to be functional. Since the OS does </p>
<p>not initialize any trap tables on non-AUTOSAR cores GetCoreID cannot be used on </p>
<p>such cores. </p>
<p>Therefore it is not possible to use the API function GetCoreID within the main function. </p>
<p>A user function (e.g. UsrGetCoreID) is necessary which distinguishes the correct core </p>
<p>ID. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>OS multi core startup </b></p>
<p>void main (void) </p>
<p>{ </p>
<p>   StatusType rv; </p>
<p> </p>
<p>   Os_InitMemory(); </p>
<p>   Os_Init(); </p>
<p>    </p>
<p>   switch(UsrGetCoreID()) </p>
<p>   { </p>
<p>      case 0: </p>
<p>         StartNonAutosarCore(OS_CORE_ID_1, &amp;rv); </p>
<p>         StartCore(OS_CORE_ID_2, &amp;rv); </p>
<p>         StartOS(OSDEFAULTAPPMODE); </p>
<p>         break; </p>
<p>      case 1: </p>
<p>         /* not an AUTOSAR core; do something else */ </p>
<p>         break; </p>
<p>      case 2: </p>
<p>         StartCore(OS_CORE_ID_3, &amp;rv); </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      case 3: </p>
<p>         StartOS(DONOTCARE); </p>
<p>         break; </p>
<p>      default: </p>
<p>         break; </p>
<p>   } </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p>The example shows a possible startup sequence for a quad core system. Three cores are </p>
<p>AUTOSAR cores and one core is a non-AUTOSAR core. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>54 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.13 </b></p>
<p><b>Error Handling </b></p>
<p>MICROSAR OS is able to detect and handle the following types of errors: </p>
<p><b>Application Errors … </b></p>
<p></p>
<p> Are raised if the OS could not execute a requested OS API service </p>
<p>correctly. Typically the OS API is used wrong (e.g. invalid object </p>
<p>ID). </p>
<p></p>
<p> Do not corrupt the internal OS data. </p>
<p></p>
<p> Will result in call of the global ErrorHook() for centralized error </p>
<p>handling (if configured). </p>
<p></p>
<p> Will result in call of an application specific ErrorHook (if configured). </p>
<p></p>
<p> May not induce shutdown / terminate reactions. Instead the </p>
<p>application may continue execution by simply returning from the </p>
<p>ErrorHooks. </p>
<p><b>Protection Errors … </b></p>
<p></p>
<p> Are raised if the application violates its configured boundaries (e.g. </p>
<p>memory access violations, timing violations). </p>
<p></p>
<p> Do not corrupt OS internal data. </p>
<p></p>
<p> Are raised upon occurrence of unhandled exceptions and </p>
<p>interrupts. </p>
<p></p>
<p> Will result in call of the ProtectionHook() where a shutdown or </p>
<p>terminate handling (with or without restart) is induced. </p>
<p></p>
<p> If Shutdown is induced the ShutdownHook() is called (if </p>
<p>configured). </p>
<p></p>
<p> If no ProtectionHook() is configured shutdown is induced. </p>
<p><b>Kernel Errors … </b></p>
<p></p>
<p> Are raised if the OS cannot longer assume the correctness if its </p>
<p>internal data (e.g. memory access violation during </p>
<p>ProtectionHook()) </p>
<p></p>
<p> Will result in call of the Os_PanicHook() to inform the application. </p>
<p></p>
<p> Afterwards the OS disables all interrupts and enters an infinite loop. </p>
<p>Table 2-4  </p>
<p>Types of OS Errors </p>
<p><b>2.14 </b></p>
<p><b>Error Reporting </b></p>
<p>MICROSAR OS supports error reporting according to the AUTOSAR [1] and OSEK OS [2] </p>
<p>standard. </p>
<p>This includes </p>
<p><b>&gt; </b></p>
<p>StatusType return values of OS APIs </p>
<p><b>&gt; </b></p>
<p>Parameter passing of error codes error to ErrorHook() </p>
<p><b>&gt; </b></p>
<p>Service ID information provided by the macro OSErrorGetServiceId() </p>
<p><b>&gt; </b></p>
<p>Parameter access macros (e.g. OSError_ActivateTask_TaskID()) </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>55 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.14.1 </b></p>
<p><b>Extension of Service IDs </b></p>
<p>MICROSAR OS introduces new service IDs for own services. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Reference </b></p>
<p>All service IDs are listed in the OS header file </p>
<p>OsInt.h</p>
<p> and may be looked up in the </p>
<p>enum data type </p>
<p>OSServiceIdType</p>
<p>. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.14.2 </b></p>
<p><b>Extension of Error Codes </b></p>
<p>MICROSAR OS introduces new 8 bit error codes which extend the error codes which are </p>
<p>already defined by AUTOSAR OS and OSEK OS standard. </p>
<p><b>Type of Error </b></p>
<p><b>Related Error Code </b></p>
<p><b>Value </b></p>
<p>An internal OS buffer used for cross core </p>
<p>communication is full. </p>
<p>E_OS_SYS_OVERFLOW </p>
<p>0xF5 </p>
<p>A forcible termination of a kernel object has </p>
<p>been requested e.g. terminate system </p>
<p>applications. </p>
<p>E_OS_SYS_KILL_KERNEL_OBJ </p>
<p>0xF6 </p>
<p>An OS-Application has been terminated </p>
<p>with requested restart but no restart task </p>
<p>has been configured. </p>
<p>E_OS_SYS_NO_RESTARTTASK </p>
<p>0xF7 </p>
<p>The application tries to use an API cross </p>
<p>core, but the target core has not been </p>
<p>configured for cross core API </p>
<p>E_OS_SYS_CALL_NOT_ALLOWED </p>
<p>0xF8 </p>
<p>The triggered cross core function is not </p>
<p>available on the target core. </p>
<p>E_OS_SYS_FUNCTION_UNAVAILABLE  0xF9 </p>
<p>A syscall instruction has been executed </p>
<p>with an invalid syscall number. </p>
<p>E_OS_SYS_PROTECTION_SYSCALL </p>
<p>0xFA </p>
<p>An unhandled interrupt occurred. </p>
<p>E_OS_SYS_PROTECTION_IRQ </p>
<p>0xFB </p>
<p>The interrupt handling API is used wrong. </p>
<p>E_OS_SYS_API_ERROR </p>
<p>0xFC </p>
<p>Internal OS assertion (not issued to </p>
<p>customer). </p>
<p>E_OS_SYS_ASSERTION </p>
<p>0xFD </p>
<p>A system timer ISR was delayed too long. </p>
<p>E_OS_SYS_OVERLOAD </p>
<p>0xFE </p>
<p>Table 2-5  </p>
<p>Extension of Error Codes </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Reference </b></p>
<p>All error codes and their values can be looked up in the header file </p>
<p>OsInt.h</p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>56 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.14.3 </b></p>
<p><b>Detailed Error Codes </b></p>
<p>MICROSAR  OS  provides  detailed  error  code  to  extend  the  standard  error  handling  of </p>
<p>AUTOSAR to uniquely identify each possible OS error. </p>
<p>The detailed error code is assembled from AUTOSAR StatusType error code and unique </p>
<p>error code. </p>
<p> </p>
<p>Figure 2-5 </p>
<p>MICROSAR OS Detailed Error Code </p>
<p>Within OS Hook routines the error code can be obtained by calling Os_GetDetailedError() </p>
<p>(see 5.5.1 for details). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Vector OS experts always asks about the detailed error codes when supporting </p>
<p>customers in case of OS errors. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Reference </b></p>
<p>The detailed error codes are listed in the file </p>
<p>OsInt.h</p>
<p> and may be looked up in the </p>
<p>enum data type </p>
<p>Os_StatusType</p>
<p>. </p>
<p>Each detailed error code is preceded by a descriptive comment. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p>0x</p>
<p>XXXXXX</p>
<p>YY</p>
<p>Autosar StatusType</p>
<p>MICROSAR OS</p>
<p>Error code extension</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>57 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.15 </b></p>
<p><b>Multi Core Concepts </b></p>
<p><b>2.15.1 </b></p>
<p><b>Scheduling and Dispatching </b></p>
<p>MICROSAR OS implements independent schedulers and dispatchers for each core. </p>
<p><b>2.15.2 </b></p>
<p><b>Multi Core Data Concepts </b></p>
<p>The multi core data concept of MICROSAR OS tries to avoid concurrent writing accesses </p>
<p>between cores. </p>
<p>Although  cores  may  read  all  OS  data  of  all  cores,  write  accesses  to  OS  data  are  only </p>
<p>performed locally from the owning core. </p>
<p>This data concept allows optimized linking: </p>
<p><b>&gt; </b></p>
<p>The data of a particular core may be linked into fast accessible memory </p>
<p><b>&gt; </b></p>
<p>The data of a particular core may be linked into cached memory </p>
<p>Only the variables related to spinlocks have to be linked into global memory which must be </p>
<p>accessible by all participating cores. </p>
<p><b>2.15.3 </b></p>
<p><b>X-Signals </b></p>
<p>To realize cross core service APIs MICROSAR OS offers the X-Signal concept (see 3.7 for </p>
<p>details). </p>
<p><b>2.15.4 </b></p>
<p><b>Master / Slave Core </b></p>
<p>In a real master / slave multi core architecture only one core is started upon reset. This is </p>
<p>the master core. All other cores are held in a reset state and must be explicitly started by </p>
<p>the master core. These are slave cores. </p>
<p>There  are  also  multi  core  systems  which  starts  all  cores  simultaneously.  There  is  no </p>
<p>hardware master / slave classification. </p>
<p>MICROSAR OS is capable to deal with both concepts. In a system with equal cores the </p>
<p>OS emulates master / slave behavior according to the core configurations. </p>
<p><b>2.15.5 </b></p>
<p><b>Startup of a Multi Core System </b></p>
<p>The startup of a multi core system is described in detail in 2.12. </p>
<p>MICROSAR OS offers the possibility to configure a startup symbol for each core. Within a </p>
<p>real master / slave system the OS needs this information for starting the slave cores. </p>
<p><b>2.15.6 </b></p>
<p><b>Spinlocks </b></p>
<p>Synchronization of cores is done by </p>
<p><b>&gt; </b></p>
<p>OS Spinlocks (see [1]) or </p>
<p><b>&gt; </b></p>
<p>Optimized spinlocks (see 3.1) </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>58 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.15.7 </b></p>
<p><b>Cache </b></p>
<p>Due to cache coherency problems spinlock variables and other application variables which </p>
<p>are shared among cores must not be cached. </p>
<p><b>2.15.8 </b></p>
<p><b>Shutdown </b></p>
<p><b>2.15.8.1 </b></p>
<p><b>Shutdown of one Core </b></p>
<p>If ShutdownOS() is called on one core, it induces shutdown actions. </p>
<p><b>&gt; </b></p>
<p>The core terminates all its applications </p>
<p><b>&gt; </b></p>
<p>Application specific ShutdownHooks are called  </p>
<p><b>&gt; </b></p>
<p>The global ShutdownHook() is called </p>
<p><b>&gt; </b></p>
<p>Interrupts are disabled </p>
<p><b>&gt; </b></p>
<p>An endless loop is entered </p>
<p><b>2.15.8.2 </b></p>
<p><b>Shutdown of all Cores </b></p>
<p>Upon  call  to  ShutdownAllCores()  synchronized  shutdown  of  the  system  is  invoked.  An </p>
<p>asynchronous X-Signal is used for this purpose. </p>
<p>Synchronized shutdown is described in [1]. </p>
<p> </p>
<p><b>2.15.8.3 </b></p>
<p><b>Shutdown during Protection Violation </b></p>
<p>If  the  ProtectionHook()  returns  with  “PRO_SHUTDOWN”  a  shutdown  of  all  cores  is </p>
<p>invoked. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>59 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.16 </b></p>
<p><b>Debugging Concepts </b></p>
<p><b>2.16.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS offers two software utilities to support OS debugging. </p>
<p><b>ORTI </b></p>
<p>MICROSAR OS generates an ORTI debug file (<b>O</b>SEK <b>R</b>un<b>T</b>ime </p>
<p><b>I</b>nterface). Many debuggers are capable of loading such ORTI files </p>
<p>and provide comfortable debug means based upon the OS </p>
<p>configuration. </p>
<p>See chapter 2.16.3 for details </p>
<p><b>TimingHooks </b></p>
<p>MICROSAR OS provides macros which may be used for debugging </p>
<p>purposes (also suitable for third party tools). See chapter 3.8 for </p>
<p>details. </p>
<p> </p>
<p><b>2.16.2 </b></p>
<p><b>Activation </b></p>
<p>ORTI and TimingHooks may be switched on within the OsDebug container. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>There is an additional switch within the “OsDebug” container. It enables OS assertions. </p>
<p>They are intended for OS internal test purposes. If activated the OS performs additional </p>
<p>runtime checks on its own internal states. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>60 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.16.3 </b></p>
<p><b>ORTI Debugging </b></p>
<p>ORTI is the abbreviation of “OSEK Runtime Interface”. </p>
<p>When ORTI debugging is activated MICROSAR OS generates additional files with “</p>
<p>.ort</p>
<p>” </p>
<p>extension.  These  files  contain  information  about  the  whole  OS  configuration.  They  are </p>
<p>intended to be read by a debugger. </p>
<p>The  debugger  uses  the  information  from  the  ORTI  files  to  display  static  and  runtime </p>
<p>information about OS objects e.g. task states. </p>
<p>ORTI versions supported by MICROSAR OS: </p>
<p><b>ORTI 2.2 </b></p>
<p>As described in the OSEK standard [3] and [4] </p>
<p><b>ORTI 2.3 </b></p>
<p>Unofficial “Standard” based upon ORTI 2.2. It does contain extensions </p>
<p>for multi core OS and was proposed by “Lauterbach Development </p>
<p>Tools” (described in [5]). </p>
<p> </p>
<p>Both ORTI versions are capable to be used within single core and multi core systems. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note for ORTI 2.2 multi core debugging </b></p>
<p>For each configured AUTOSAR core there is one separate ORTI file. </p>
<p>For multi core debugging, the debugger software must be capable to read several </p>
<p>ORTI files. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note for ORTI 2.3 multi core debugging </b></p>
<p>The debug information for all configured cores is aggregated in one file. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Basically debuggers are capable to display the stack consumption for each stack </p>
<p>(OsStackUsageMeasurement must be switched on). </p>
<p>Please note that uninitialized OS stacks may show 100% stack usage within ORTI </p>
<p>debugging. Reliable information can only be given after the OS has initialized all </p>
<p>stacks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>61 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>MESSAGE objects and CONTEXT information specified by ORTI 2.2 Standard are not </p>
<p>supported in MICROSAR OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to performance reasons the following OS services are not traced by ORTI service </p>
<p>tracing: </p>
<p><b>&gt; </b></p>
<p>GetSpinlock (for optimized spinlocks) </p>
<p><b>&gt; </b></p>
<p>TryToGetSpinlock (for optimized spinlocks) </p>
<p><b>&gt; </b></p>
<p>ReleaseSpinlock (for optimized spinlocks) </p>
<p><b>&gt; </b></p>
<p>IOC </p>
<p><b>&gt; </b></p>
<p>Os_GetVersionInfo </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>62 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.17 </b></p>
<p><b>Memory Protection </b></p>
<p>MICROSAR OS uses memory protection facilities of a processor to achieve freedom from </p>
<p>interference between OS applications and cores. For this purpose it may use the system </p>
<p>MPU and the core MPUs. </p>
<p><b>2.17.1 </b></p>
<p><b>Usage of the System MPU </b></p>
<p>In  multi  core  systems  whereas  the  cores  have  different  levels  of  diagnostic  coverage  it </p>
<p>may  be  necessary  to  use  a  system  MPU  to  achieve  freedom  of  interference  between </p>
<p>cores. </p>
<p>A  system  MPU  allows  configuring  access  rights  for  cores  to  access  specific  memory </p>
<p>ranges. </p>
<p>The </p>
<p>system </p>
<p>MPU </p>
<p>is </p>
<p>only </p>
<p>initialized </p>
<p>once </p>
<p>during </p>
<p>startup </p>
<p>of </p>
<p>the </p>
<p>OS. </p>
<p>It </p>
<p>is </p>
<p>never </p>
<p>reprogrammed during runtime. </p>
<p>With  a  system  MPU  other  potential  bus  masters  (DMA,  FlexRay)  can  be  isolated  to </p>
<p>achieve freedom from interference. </p>
<p>This is done with the following steps: </p>
<p><b>Step </b></p>
<p>Toolchain phase </p>
<p><b>Set up a SC3 system </b></p>
<p>Configuration of OS </p>
<p><b>Configure memory regions </b></p>
<p><b>Assign the memory region to the system MPU </b></p>
<p> </p>
<p><b>2.17.2 </b></p>
<p><b>Usage of the Core MPUs </b></p>
<p>The  core  MPUs  are  used  to  achieve  freedom  from  interference  between  applications  / </p>
<p>tasks / ISRs on the same core. The basic concept is that access rights of these runtime </p>
<p>entities (read/write/executable) have to be granted explicitly to software parts. </p>
<p>This is done with the following steps: </p>
<p><b>Step </b></p>
<p>Toolchain phase </p>
<p><b>Set up a SC3 system </b></p>
<p>Configuration of OS </p>
<p><b>Configure memory regions </b></p>
<p><b>Assign the memory region to a core MPU </b></p>
<p><b>Assign the memory regions to OS applications / Tasks / ISRs </b></p>
<p><b>(optional) </b></p>
<p><b>Use the AUTOSAR MemMap mechanism to place code, constants and </b></p>
<p><b>variables into appropriate sections (see 4.3.1.1) </b></p>
<p>Compilation </p>
<p><b>Use OS generated linker command files to locate the sections into </b></p>
<p><b>memory (see 4.3.2) </b></p>
<p>Linkage </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>63 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.17.3 </b></p>
<p><b>Configuration Aspects </b></p>
<p>A memory region is typically configured by </p>
<p><b>&gt; </b></p>
<p>Specify a start and end address by number, or by linker labels (see 4.3.3 for OS </p>
<p>generated section labels) </p>
<p><b>&gt; </b></p>
<p>Specify access rights to this region (a pre-defined set of access rights is referable) </p>
<p><b>&gt; </b></p>
<p>Specify the validity of the region by ID (e.g. PID / ASID / Protection Set) </p>
<p><b>&gt; </b></p>
<p>Specify to which memory protection unit the region belongs (e.g. Core MPU / System </p>
<p>MPU) </p>
<p><b>&gt; </b></p>
<p>Specify the owner of the region </p>
<p>The owner of the memory region distinguishes the runtime behavior of the hardware MPU </p>
<p>regions (whether the region is static or dynamic). </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The start and end addresses of configured memory region should always be a multiple </p>
<p>of the granularity of the hardware MPU. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The number of available hardware MPU regions is limited by hardware! </p>
<p>MICROSAR OS checks during code generation that the overall number of configured </p>
<p>memory regions does not exceed the number of available hardware MPU regions. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.17.3.1 </b></p>
<p><b>Static MPU Regions </b></p>
<p>If no owner is specified, MICROSAR OS initializes a hardware MPU region to be static. It </p>
<p>is never reprogrammed during runtime of the OS. It is valid for all software parts. </p>
<p><b>2.17.3.2 </b></p>
<p><b>Dynamic MPU Regions </b></p>
<p>If an owner is specified for a memory region MICROSAR OS initializes a hardware MPU </p>
<p>region to be dynamically reprogrammed during OS runtime. Whenever the owner of the </p>
<p>memory is active during runtime a specific hardware MPU region is programmed with the </p>
<p>configured values of the memory region. </p>
<p>Memory regions which are assigned to an OS application are reprogrammed whenever the </p>
<p>OS application is switched. </p>
<p>Memory regions which are assigned to tasks or ISRs are reprogrammed with each thread </p>
<p>switch. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>64 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.17.3.3 </b></p>
<p><b>Freedom from Interference </b></p>
<p>MICROSAR  OS  is  able  to  encapsulate  OS  application  data,  task  private  data  and  ISR </p>
<p>private data. This does also depend on the owner of the memory region. </p>
<p><b>Memory Region Owner </b></p>
<p><b>Access Granted To </b></p>
<p><b>Access Denied For </b></p>
<p>OS application </p>
<p>Runtime objects of this OS </p>
<p>application </p>
<p><b>&gt; </b></p>
<p>Tasks </p>
<p><b>&gt; </b></p>
<p>ISRs </p>
<p><b>&gt; </b></p>
<p>IOC callbacks </p>
<p><b>&gt; </b></p>
<p>Non-trusted functions </p>
<p><b>&gt; </b></p>
<p>Application specific hooks </p>
<p><b>&gt; </b></p>
<p>Other non-trusted OS </p>
<p>applications and its </p>
<p>applications objects </p>
<p>Task </p>
<p><b>&gt; </b></p>
<p>The owning task </p>
<p><b>&gt; </b></p>
<p>Other non-trusted OS </p>
<p>applications and its </p>
<p>applications objects </p>
<p><b>&gt; </b></p>
<p>Other runtime objects of the </p>
<p>belonging OS application </p>
<p>ISR </p>
<p><b>&gt; </b></p>
<p>The owning ISR </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>65 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.17.4 </b></p>
<p><b>Stack Monitoring </b></p>
<p>MICROSAR OS uses one memory region of the MPU to supervise the current stack. This </p>
<p>is the default handling in SC3 and SC4 systems. See 2.3.5 for details. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Memory regions must not be configured to allow write access into any stack regions. </p>
<p>Otherwise the OS cannot ensure stack data integrity. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.17.5 </b></p>
<p><b>Protection Violation Handling </b></p>
<p>Upon any memory protection violation the OS </p>
<p><b>&gt; </b></p>
<p>Switches to the kernel stack </p>
<p><b>&gt; </b></p>
<p>Informs the application by execution of the ProtectionHook() </p>
<p><b>2.17.6 </b></p>
<p><b>Optimized / Fast Core MPU Handling </b></p>
<p>If the number of application / task / ISR specific memory regions is small, MICROSAR OS </p>
<p>may have the possibility to initialize the MPU entirely with static MPU regions. </p>
<p>By  utilize  memory  protection  identifiers  different  access  rights  may  still  be  achieved </p>
<p>between different applications. </p>
<p>MICROSAR OS switches access rights by simply switching the protection identifier. This </p>
<p>will result in a very fast MPU handling. </p>
<p><b>&gt; </b></p>
<p>Configure only memory regions which are static (no owner is assigned). </p>
<p><b>&gt; </b></p>
<p>Use “OsMemoryRegionIdentifier” to assign a protection identifier to that region. </p>
<p><b>&gt; </b></p>
<p>Assign either OS applications or Tasks and ISRs to use a specific protection identifier </p>
<p>(OsAppMemoryProtectionIdentifier, OsTaskMemoryProtectionIdentifier, </p>
<p>OsIsrMemoryProtectionIdentifier) </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Depending on the used platform protection identifiers are also referred as PID (MPC), </p>
<p>ASID (RH850) or protection sets (TriCore). But the basic technique is the same. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>66 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.17.7 </b></p>
<p><b>Recommended Configuration </b></p>
<p>MICROSAR OS offers a recommended MPU configuration which contains a basic setup. </p>
<p>It configures the MPU to achieve the access rights as follows </p>
<p><b>Access Rights </b></p>
<p>Trusted Software </p>
<p>Non-Trusted Software </p>
<p>Executable rights to whole memory </p>
<p><b>X </b></p>
<p><b>X </b></p>
<p>Read access to whole RAM / ROM </p>
<p><b>X </b></p>
<p><b>X </b></p>
<p>Write access to whole RAM (except </p>
<p>stack regions) </p>
<p><b>X </b></p>
<p><b>- </b></p>
<p>Read / Write access to peripheral </p>
<p>registers </p>
<p><b>X </b></p>
<p><b>- </b></p>
<p>Read / Write access to global shared </p>
<p>memory </p>
<p><b>X </b></p>
<p><b>X </b></p>
<p>Write access to current active stack </p>
<p><b>X </b></p>
<p><b>X </b></p>
<p>Table 2-6  </p>
<p>Recommended Configuration MPU Access Rights </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>67 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.18 </b></p>
<p><b>Memory Access Checks </b></p>
<p><b>2.18.1 </b></p>
<p><b>Description </b></p>
<p>AUTOSAR OS specifies functions for checking memory access rights of an ISR or task to </p>
<p>a specific memory region. </p>
<p><b>&gt; </b></p>
<p>CheckTaskMemoryAccess </p>
<p><b>&gt; </b></p>
<p>CheckISRMemoryAccess </p>
<p>MICROSAR OS implements these two functions (see 5.9 for Details) </p>
<p><b>2.18.2 </b></p>
<p><b>Activation </b></p>
<p>No </p>
<p>explicit </p>
<p>activation </p>
<p>of </p>
<p>these  API </p>
<p>service </p>
<p>functions </p>
<p>necessary. </p>
<p>They </p>
<p>are </p>
<p>provided </p>
<p>automatically by the OS. </p>
<p><b>2.18.3 </b></p>
<p><b>Usage </b></p>
<p>The  API  service  functions  CheckTaskMemoryAccess()  and  CheckISRMemoryAccess() </p>
<p>work on additional configuration data which has to be provided by the user. </p>
<p>Therefore  additional  regions  (“OsAccessCheckRegion“)  may  be  configured.  Tasks  and </p>
<p>ISRs may be assigned to each access check region. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All memory access checks are based upon the configured “OsAccessCheckRegion” </p>
<p>objects. They are not based upon current MPU values during runtime! </p>
<p>OsAccessCheckRegions and OsMemoryRegions contain redundant information. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.18.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>68 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.19 </b></p>
<p><b>Timing Protection Concept </b></p>
<p><b>2.19.1 </b></p>
<p><b>Description </b></p>
<p>To implement timing protection, MICROSAR OS needs a timer hardware which is able to </p>
<p>generate an interrupt with high priority. This interrupt is never disabled by the OS interrupt </p>
<p>handling API. </p>
<p>Two concepts may be implemented within MICROSAR OS: </p>
<p><b></b></p>
<p><b> </b></p>
<p>The timing protection interrupt request is non-maskable (NMI request) </p>
<p><b></b></p>
<p><b> </b></p>
<p>The timing protection interrupt request is maskable </p>
<p>The consequences of both concepts are shown in the comparison: </p>
<p><b> </b></p>
<p>Timing Protection IRQ is </p>
<p>Maskable </p>
<p>Timing Protection IRQ is NMI </p>
<p><b>Level of timing </b></p>
<p><b>protection IRQ </b></p>
<p>The level of the interrupt source </p>
<p>is chosen to be on the highest </p>
<p>possible priority of the </p>
<p>microcontroller. </p>
<p>The exception source has no </p>
<p>interrupt level. </p>
<p><b>DisableAllInterrupts() </b></p>
<p><b>EnableAllInterrupts() </b></p>
<p>The functions disable all ISRs </p>
<p>(with exception of timing </p>
<p>protection interrupt) by </p>
<p>manipulate the interrupt priority / </p>
<p>level </p>
<p>The functions disable all ISRs (with </p>
<p>exception of timing protection </p>
<p>interrupt) by manipulate a global </p>
<p>interrupt mask / disable flag </p>
<p><b>SuspendAllInterrupts() </b></p>
<p><b>ResumeAllInterrupts() </b></p>
<p><b>SuspendOSInterrupts() </b></p>
<p><b>ResumeOSInterrupts() </b></p>
<p>The functions disable category 2 interrupts by manipulate the interrupt </p>
<p>priority / level </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Any category 1 ISR bypasses the OS. For this reason such an ISR may get terminated </p>
<p>in case it is executed, while the budget of a monitored entity is exhausted. </p>
<p>Thus the AUTOSAR OS specification advises not to use category 1 ISRs within a </p>
<p>system which uses timing protection. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>In case of an inter-arrival time violation MICROSAR OS does currently not provide the </p>
<p>information which task or ISR did violate its inter-arrival time. GetTaskID() and </p>
<p>GetISRID() return the current task / ISR. The suppressed task / ISR ID is not returned </p>
<p>by these APIs. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>69 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.19.2 </b></p>
<p><b>Activation </b></p>
<p>Timing  protection  features  are  activated  by  setting  the  scalability  class  to  SC2  or  SC4 </p>
<p>(OsScalabilityClass). </p>
<p>Afterwards </p>
<p>timing </p>
<p>protection </p>
<p>containers </p>
<p>may </p>
<p>be </p>
<p>configured </p>
<p>for </p>
<p>tasks </p>
<p>or </p>
<p>ISRs </p>
<p>(OsTaskTimingProtection / OsIsrTimingProtection). Observed  times  are  configured  within </p>
<p>these containers. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The OS will add an appropriate ISR automatically to the configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.19.3 </b></p>
<p><b>Usage </b></p>
<p>Once the timing protection feature is active tasks and ISRs are observed automatically by </p>
<p>the OS. </p>
<p>Observation  of  a  particular  OS  object  (task  /  ISR)  only  takes  place  if  any  execution </p>
<p>budgets or locking times are configured for this object. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>70 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.20 </b></p>
<p><b>IOC </b></p>
<p><b>2.20.1 </b></p>
<p><b>Description </b></p>
<p>The Inter OS-Application Communicator (IOC) is responsible for data exchange between </p>
<p>OS applications. It handles two important tasks </p>
<p><b>&gt; </b></p>
<p>Data exchange across core boundaries </p>
<p><b>&gt; </b></p>
<p>Data exchange across memory protection boundaries </p>
<p>Parts of the IOC API services are generated. </p>
<p>MICROSAR OS always tries to generate IOC API services and data structures to minimize </p>
<p>resource usage. </p>
<p>Especially the runtime of IOC API services is influenced by the configuration of IOC </p>
<p>objects. For the customer it is important how configuration aspects minimize the IOC </p>
<p>runtime. </p>
<p>For each IOC object MICROSAR OS decides during runtime whether </p>
<p><b>&gt; </b></p>
<p>Interrupt locks </p>
<p><b>&gt; </b></p>
<p>Spinlocks </p>
<p>Are used or not. </p>
<p><b>2.20.2 </b></p>
<p><b>Unqeued (Last Is Best) Communication </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Whenever the data of a last is best IOC object can be written / read atomically (integral </p>
<p>data type) no spinlocks are used at all. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.20.2.1 </b></p>
<p><b>1:1 Communication Variant </b></p>
<p><b> </b></p>
<p>Sender and Receiver are located </p>
<p>on the same core </p>
<p>Sender and Receiver are located </p>
<p>on the different cores </p>
<p><b>Interrupt Locks </b></p>
<p>Used </p>
<p>Not used </p>
<p><b>Spinlocks </b></p>
<p>Not Used </p>
<p>Used </p>
<p><b>System Call Traps </b></p>
<p>Not Used </p>
<p>Not Used </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>71 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.20.2.2 </b></p>
<p><b>N:1 Communication Variant </b></p>
<p><b> </b></p>
<p>Sender and Receiver are located </p>
<p>on the same core </p>
<p>Sender and Receiver are located </p>
<p>on the different cores </p>
<p><b>Interrupt Locks </b></p>
<p>Used </p>
<p>Not used </p>
<p><b>Spinlocks </b></p>
<p>Not Used </p>
<p>Used </p>
<p><b>System Call Traps </b></p>
<p>Used </p>
<p>Used </p>
<p> </p>
<p><b>2.20.2.3 </b></p>
<p><b>N:M Communication Variant </b></p>
<p><b> </b></p>
<p>Sender and Receiver are located </p>
<p>on the same core </p>
<p>Sender and Receiver are located </p>
<p>on the different cores </p>
<p><b>Interrupt Locks </b></p>
<p>Used </p>
<p>Not used </p>
<p><b>Spinlocks </b></p>
<p>Not Used </p>
<p>Used </p>
<p><b>System Call Traps </b></p>
<p>Not Used </p>
<p>Not Used </p>
<p> </p>
<p><b>2.20.3 </b></p>
<p><b>Queued Communication </b></p>
<p>For 1:1 and N:1 Communication the following table is applied: </p>
<p><b> </b></p>
<p>Sender and Receiver are located </p>
<p>on the same core </p>
<p>Sender and Receiver are located </p>
<p>on the different cores </p>
<p><b>Interrupt Locks </b></p>
<p>Not Used </p>
<p>Not used </p>
<p><b>Spinlocks </b></p>
<p>Not Used </p>
<p>Not Used </p>
<p><b>System Call Traps </b></p>
<p>Not Used </p>
<p>Not Used </p>
<p> </p>
<p><b>2.20.4 </b></p>
<p><b>Notification </b></p>
<p>MICROSAR OS provides configurable receiver callback functions for notification purposes. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In case an IOC object has a configured receiver callback function a system call trap is </p>
<p>needed in any case. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>72 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.20.5 </b></p>
<p><b>Particularities </b></p>
<p><b>2.20.5.1 </b></p>
<p><b>N:1 Queued Communication </b></p>
<p>N:1 queued commination is realized with multiple sender queues. The receiver application </p>
<p>does  an  even  multiplexing  on  all  sender  queues  when  calling  the  receive  function  (see </p>
<p>figure). </p>
<p> </p>
<p>Figure 2-6 </p>
<p>N:1 Multiple Sender Queues </p>
<p><b>2.20.5.2 </b></p>
<p><b>IOC Spinlocks </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>During generation of OS data structures, if MICROSAR OS detects that a spinlock is </p>
<p>needed for a particular IOC object, it automatically creates a spinlock object within the </p>
<p>OS configuration. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>73 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.20.5.3 </b></p>
<p><b>Notification </b></p>
<p>Based  on  the  core  assignment  of  sender  and  receiver  of  an  IOC  object,  two  possible </p>
<p>scenarios for callback handling are possible. </p>
<p><b>Sender and Receiver are located on </b></p>
<p><b>the same core </b></p>
<p><b>&gt; </b></p>
<p>The callback notification function is called within the </p>
<p>IOC send function </p>
<p><b>Sender and Receiver are located on </b></p>
<p><b>different cores </b></p>
<p><b>&gt; </b></p>
<p>The sender triggers an X-Signal request on the </p>
<p>receiving core </p>
<p><b>&gt; </b></p>
<p>The callback notification function is called within the </p>
<p>X-Signal ISR </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p><b>&gt; </b></p>
<p>All callback functions are using the cores IOC receiver pull callback stack. </p>
<p><b>&gt; </b></p>
<p>During execution of the IOC receiver pull callback function category 2 ISRs are </p>
<p>disabled. </p>
<p><b>&gt; </b></p>
<p>Within IOC receiver pull callback functions only other IOC API functions and </p>
<p>interrupt dis/enable API functions are allowed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>74 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>2.21 </b></p>
<p><b>Trusted OS Applications </b></p>
<p>Trusted  OS  Applications  are  basically  executed  in  supervisor  mode.  They  can  have </p>
<p>read/write access to nearly the whole memory (except stack regions). </p>
<p>MICROSAR OS allows gradually restricting of access rights of trusted OS applications. </p>
<p>Trusted OS applications may be restricted by memory access or by processor mode. </p>
<p><b>2.21.1 </b></p>
<p><b>Trusted OS Applications with Memory Protection </b></p>
<p><b>2.21.1.1 </b></p>
<p><b>Description </b></p>
<p>Runtime objects (Tasks / ISRs / Trusted functions) of trusted OS applications with enabled </p>
<p>memory protection have the following behavior </p>
<p><b>&gt; </b></p>
<p>They run in supervisor mode </p>
<p><b>&gt; </b></p>
<p>Memory access has to be granted explicitly (in the same way as for a non-trusted OS </p>
<p>application) </p>
<p><b>&gt; </b></p>
<p>The MPU is re-programmed whenever software of the OS application is executed. </p>
<p><b>2.21.1.2 </b></p>
<p><b>Activation </b></p>
<p>Set “OsTrustedApplicationWithProtection” to TRUE. </p>
<p><b>2.21.1.3 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p><b>2.21.2 </b></p>
<p><b>Trusted OS Applications in User Mode </b></p>
<p><b>2.21.2.1 </b></p>
<p><b>Description </b></p>
<p>Such  OS  applications  can  have  read/write  access  to  nearly  the  whole  memory  (except </p>
<p>stack  regions),  but  they  are  running  in  user  mode.  This  is  also  applied  to  all  runtime </p>
<p>objects (Tasks / ISRs / Trusted functions) assigned to this OS application. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>&gt; </p>
<p>API runtimes for OS applications which run in user mode are longer. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>2.21.2.2 </b></p>
<p><b>Activation </b></p>
<p>Set “OsApplicationIsPrivileged” to FALSE. </p>
<p><b>2.21.2.3 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>75 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.21.3 </b></p>
<p><b>Trusted Functions </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>&gt; </p>
<p>The interrupt state of the caller is preserved when entering the trusted function. </p>
<p>&gt; </p>
<p>The trusted function may manipulate the interrupt state by using OS services. The changed </p>
<p>interrupt state is preserved upon return from the trusted function. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Nesting level of trusted functions is limited to 255. </p>
<p>The application has to ensure that this limitation is held. There is no error detection </p>
<p>within the OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>76 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.22 </b></p>
<p><b>OS Hooks </b></p>
<p><b>2.22.1 </b></p>
<p><b>Runtime Context </b></p>
<p>MICROSAR  OS  implements  the  runtime  context  and  accessing  rights  of  OS  Hooks </p>
<p>according to the following table </p>
<p><b>Hook Name </b></p>
<p><b>Processor Mode  Access Rights </b></p>
<p><b>Interrupt State </b></p>
<p>StartupHook </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>Disabled up to </p>
<p>system level </p>
<p>ErrorHook </p>
<p>ShutdownHook </p>
<p>Globally disabled </p>
<p>ProtectionHook </p>
<p>StartupHook_&lt;OS application name&gt; </p>
<p>Depending on the configuration of </p>
<p>the owning OS application </p>
<p>Disabled up to </p>
<p>system level </p>
<p>ErrorHook_&lt;OS application name&gt; </p>
<p>ShutdownHook_&lt;OS application name&gt; </p>
<p>Globally disabled </p>
<p>Os_PanicHook </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>Globally disabled </p>
<p>PreTaskHook </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>Globally disabled </p>
<p>PostTaskHook </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>Globally disabled </p>
<p>AlarmCallbacks </p>
<p>Supervisor </p>
<p>Trusted </p>
<p>Globally disabled </p>
<p>IOC receiver pull callbacks </p>
<p>Depending on the configuration of </p>
<p>the owning OS application </p>
<p>Disabled up to </p>
<p>system level </p>
<p>(execution is done </p>
<p>within ISR </p>
<p>context) </p>
<p> </p>
<p><b>2.22.2 </b></p>
<p><b>Nesting behavior </b></p>
<p>It is possible that OS hooks may be nested by other OS hooks according to the following </p>
<p>table </p>
<p><b>Nested by </b></p>
<p><b>OS Hook </b></p>
<p>ErrorHook(s) </p>
<p>ProtectionHook </p>
<p>StartupHook(s) </p>
<p>ShutdownHook(s))  IOC Callbacks </p>
<p>ErrorHook(s) </p>
<p>Not possible </p>
<p>possible </p>
<p>Not possible </p>
<p>possible </p>
<p>possible </p>
<p>ProtectionHook </p>
<p>Not possible </p>
<p>Not possible </p>
<p>Not possible </p>
<p>possible </p>
<p>possible </p>
<p>StartupHook(s) </p>
<p>possible </p>
<p>possible </p>
<p>Not possible </p>
<p>possible </p>
<p>possible </p>
<p>ShutdownHook(s) </p>
<p>Not possible </p>
<p>Not possible </p>
<p>Not possible </p>
<p>Not possible </p>
<p>possible </p>
<p>IOC Callbacks </p>
<p>possible </p>
<p>possible </p>
<p>Not possible </p>
<p>possible </p>
<p>Not possible </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>77 </p>
<p>based on template version 6.0.1 </p>
<p><b>2.22.3 </b></p>
<p><b>Hints </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Within OS Hooks the interrupts must not be enabled again! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Hooks must never be called by application code directly. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note for SC2 or SC4 </b></p>
<p>Hooks don’t have any own runtime budgets. OS Hooks consume the budget of the </p>
<p>current task / ISR. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>78 </p>
<p>based on template version 6.0.1 </p>
<p><b>3 </b></p>
<p><b>Vector Specific OS Features </b></p>
<p>This chapter describes functions which are available only in MICROSAR OS. They extend </p>
<p>the standardized OS functions from the AUTOSAR and OSEK OS standard [1] [2]. </p>
<p><b>3.1 </b></p>
<p><b>Optimized Spinlocks </b></p>
<p><b>3.1.1 </b></p>
<p><b>Description </b></p>
<p>For  core  synchronization  in  multi  core  systems,  MICROSAR  OS  offers  (beneath  the </p>
<p>AUTOSAR specified OS spinlocks) additional optimized spinlocks. </p>
<p>They are able to reduce the runtime of the Spinlock API. Configuration is also easier. </p>
<p>AUTOSAR  specified  OS  spinlocks  cannot  cause  any  deadlocks  between  cores  (see </p>
<p>unique order of nesting OS spinlocks in AUTOSAR OS standard). Therefore some error </p>
<p>checks on OS configuration data are necessary. </p>
<p>The error checks are not performed with optimized spinlocks. </p>
<p><b> </b></p>
<p>OS Spinlocks </p>
<p>Optimized Spinlocks </p>
<p><b>Deadlocks </b></p>
<p>No deadlocks possible </p>
<p>Deadlocks are possible </p>
<p><b>Runtime </b></p>
<p>Longer runtime due to more error </p>
<p>checks </p>
<p>Smaller runtime due to less error </p>
<p>checks </p>
<p><b>Configuration </b></p>
<p>OsSpinlockSuccessor must be </p>
<p>configured if spinlocks must be </p>
<p>nested </p>
<p>OsSpinlockSuccessor need not to </p>
<p>be configured </p>
<p><b>Nesting </b></p>
<p>Can be nested by other OS </p>
<p>spinlocks </p>
<p>Nesting of optimized spinlock </p>
<p>should be avoided or at least be </p>
<p>used with caution </p>
<p><b>Linking </b></p>
<p>OS and optimized spinlock variables are placed into different </p>
<p>dedicated memory sections (see 4.3.1). </p>
<p>Table 3-1  </p>
<p>Differences of OS and Optimized Spinlocks </p>
<p><b>3.1.2 </b></p>
<p><b>Activation </b></p>
<p>The spinlock attribute “OsSpinlockLockType” may be set to “OPTIMIZED”. </p>
<p>The “OsSpinlockSuccessor” attribute should not be configured for an optimized spinlock. </p>
<p><b>3.1.3 </b></p>
<p><b>Usage </b></p>
<p>Once a spinlock object is configured to be an optimized spinlock the application may use </p>
<p>the  Spinlock  API  as  usual.  The  Spinlock  service  functions  are  capable  to  deal  with </p>
<p>optimized and OS spinlocks. </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>79 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.2 </b></p>
<p><b>Peripheral Access API </b></p>
<p><b>3.2.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS offers peripheral access services for manipulating registers of peripheral </p>
<p>units.  The  application  may  delegate  such  accesses  to  the  OS  in  case  that  its  own </p>
<p>accessing rights are not sufficient to manipulate specific peripheral registers. </p>
<p><b>3.2.2 </b></p>
<p><b>Activation </b></p>
<p>The API service functions themselves do not need any activation. </p>
<p>But within the OS configuration “OsPeripheralRegion” objects may be specified. They are </p>
<p>needed for error and access checking by the OS. </p>
<p>An OsPeripheralRegion object consists of the start address, end address and a list of OS </p>
<p>applications which have accessing rights to the peripheral region. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Access to a peripheral region is granted if the following constraint is held </p>
<p>Start address of peripheral region &lt;= Accessed address &lt;= End address of peripheral region </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.2.3 </b></p>
<p><b>Usage </b></p>
<p>Once peripheral regions are configured they may be passed to the API functions. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Reference</b> </p>
<p>The API service functions themselves are described in chapter 5.1. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.2.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p><b>3.2.5 </b></p>
<p><b>Alternatives </b></p>
<p>The access rights to peripheral registers may also be granted by configure an additional </p>
<p>MPU region for the accessing OS application. </p>
<p><b>3.2.6 </b></p>
<p><b>Common Use Cases </b></p>
<p>The peripheral access APIs may be used … </p>
<p><b>&gt; </b></p>
<p>… if the accessing OS application runs in user mode but the register to be </p>
<p>manipulated can only be accessed in supervisor mode. </p>
<p><b>&gt; </b></p>
<p>… if the application does not want to spend a whole MPU region to grant access </p>
<p>rights. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>80 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>3.3 </b></p>
<p><b>Trusted Function Call Stubs </b></p>
<p><b>3.3.1 </b></p>
<p><b>Description </b></p>
<p>Since the OS service CallTrustedFunction() is very generic, there is the need to implement </p>
<p>a  stub-interface  which  does  the  packing  and  unpacking  of  the  arguments  for  trusted </p>
<p>functions. </p>
<p>MICROSAR OS is able to generate these stub functions. </p>
<p><b>3.3.2 </b></p>
<p><b>Activation </b></p>
<p>The OS application attribute “OsAppUseTrustedFunctionStubs” must be set to TRUE. Data </p>
<p>types </p>
<p>must </p>
<p>be </p>
<p>defined </p>
<p>in </p>
<p>the </p>
<p>header </p>
<p>file </p>
<p>which </p>
<p>is </p>
<p>referred </p>
<p>by </p>
<p>“OsAppCalloutStubsIncludeHeader”. </p>
<p><b>3.3.3 </b></p>
<p><b>Usage </b></p>
<p>A particular trusted function is called with the following syntax: </p>
<p>&lt;configured return type&gt; Os_Call_&lt;trusted function name&gt; </p>
<p>(&lt;configured parameters&gt;); </p>
<p>Parameter packing, unpacking and return value handling is done by the stub function. </p>
<p><b>3.3.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>81 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>3.4 </b></p>
<p><b>Non-Trusted Functions (NTF) </b></p>
<p><b>3.4.1 </b></p>
<p><b>Description </b></p>
<p>Service  functions  which  are  provided  by  non-trusted  OS  applications  are  called  non-</p>
<p>trusted functions. They have the following characteristic: </p>
<p><b>&gt; </b></p>
<p>They run in user mode. </p>
<p><b>&gt; </b></p>
<p>They run with the MPU access rights of the owning OS application. </p>
<p><b>&gt; </b></p>
<p>They perform a stack switch to specific non-trusted function stacks. </p>
<p><b>&gt; </b></p>
<p>They run on an own secured stack. </p>
<p><b>&gt; </b></p>
<p>They can safely provide non-trusted code to other OS applications. </p>
<p><b>&gt; </b></p>
<p>Parameters are passed to the NTF with a reference to a data structure provided by </p>
<p>the caller. </p>
<p><b>&gt; </b></p>
<p>Returning of values is only possible if the caller passes the non-trusted functions </p>
<p>parameters as pointer to global accessible data. </p>
<p><b>3.4.2 </b></p>
<p><b>Activation </b></p>
<p>They are defined within an OsApplication container. The attribute “OsTrusted” for this OS </p>
<p>application must be set to FALSE. </p>
<p>Special  care  needs  to  be  taken  when  configuring  stacks  for  non-trusted  functions.  For </p>
<p>correct stack handling the following attributes need to be configured for each non-trusted </p>
<p>function: </p>
<p><b>Non-Trusted Function Attribute </b></p>
<p><b>Description </b></p>
<p>OsNonTrustedFunctionStackSize </p>
<p>Specifies the stack size for one instance of the </p>
<p>NTF. </p>
<p>OsNonTrustedFunctionStacks </p>
<p>Specifies the number of stacks which are </p>
<p>generated for the NTF. </p>
<p>Note: This attribute limits the number of parallel </p>
<p>calls to the NTF. Once the maximum number is </p>
<p>reached any call to the NTF issues an error. </p>
<p>OsNonTrustedFunctionCaller </p>
<p>Specifies an OS application which may call the </p>
<p>NTF. </p>
<p>OsNonTrustedFunctionAppStacks </p>
<p>Specifies the number of parallel NTF calls from </p>
<p>the calling OS application. </p>
<p>Note: It must not exceed the attribute </p>
<p>OsNonTrustedFunctionStacks. </p>
<p>OsNonTrustedFunctionAppRef </p>
<p>Reference to the calling OS application. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>82 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.4.3 </b></p>
<p><b>Usage </b></p>
<p>Similar to the  CallTrustedFunction() API  of the AUTOSAR  OS  standard  MICROSAR  OS </p>
<p>implements </p>
<p>an </p>
<p>additional </p>
<p>service </p>
<p>which </p>
<p>is </p>
<p>called </p>
<p>Os_CallNonTrustedFunction() </p>
<p>(see </p>
<p>chapter 5.3 for Details). </p>
<p>Configured non-trusted functions are called with this API. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>&gt; </p>
<p>The interrupt state of the caller is preserved when entering the non-trusted function </p>
<p>&gt; </p>
<p>The non-trusted function may manipulate the interrupt state by using OS services. The </p>
<p>changed interrupt state is preserved upon return from the non-trusted function. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Non-trusted functions currently cannot be terminated without termination of the caller. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.4.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>83 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>3.5 </b></p>
<p><b>Interrupt Source API </b></p>
<p><b>3.5.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR  OS  offers  additional API  services  for  category  2  ISRs  and  their  respective </p>
<p>interrupt sources. </p>
<p>The services include </p>
<p><b>&gt; </b></p>
<p>Enable of an interrupt source </p>
<p><b>&gt; </b></p>
<p>Disable of an interrupt source </p>
<p><b>&gt; </b></p>
<p>Clearing of the interrupt pending bit </p>
<p><b>&gt; </b></p>
<p>Checking if the interrupt source is enabled </p>
<p><b>&gt; </b></p>
<p>Checking of interrupt pending bit status </p>
<p>(See 5.4 for API details). </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>84 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>3.6 </b></p>
<p><b>Pre-Start Task </b></p>
<p><b>3.6.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS offers the possibility to provide a set of OS API functions for initialization </p>
<p>purposes before StartOS has been called. </p>
<p>Therefore a pre-start task may be configured which is capable to run before the OS has </p>
<p>been started. Within this task stack protection is enabled and particular OS APIs can be </p>
<p>used. </p>
<p>The table in 5.13 lists the OS API functions which may be used within the Pre-Start task. </p>
<p><b>3.6.2 </b></p>
<p><b>Activation </b></p>
<p><b>&gt; </b></p>
<p>Define a basic task </p>
<p><b>&gt; </b></p>
<p>Within a core object this basic task has to be referred to be the pre-start task of this </p>
<p>core (attribute “OsCorePreStartTask”). Only one pre-start task per core is possible. </p>
<p><b>&gt; </b></p>
<p>Start the OS as described below </p>
<p><b>3.6.3 </b></p>
<p><b>Usage </b></p>
<p>1. </p>
<p>Execute Startup Code </p>
<p>2. </p>
<p>Call </p>
<p>Os_InitMemory()</p>
<p> </p>
<p>3. </p>
<p>Call </p>
<p>Os_Init()</p>
<p> </p>
<p>4. </p>
<p>Call </p>
<p>Os_EnterPreStartTask() </p>
<p>(see 5.2 for Details) </p>
<p>5. </p>
<p>The OS schedules and dispatches to the task which has been referred as pre-start </p>
<p>task. </p>
<p>6. </p>
<p>The pre-start task has to be left by a call to </p>
<p>StartOS()</p>
<p>  </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The pre-start task may only be active once prior to StartOS() call. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Within the pre-start task the getter OS API services (e.g. GetActiveApplicationMode()) </p>
<p>neither return a valid result nor a valid error code. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>85 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If MICROSAR OS encounters an error within the pre-start task, only the global hooks </p>
<p>(ErrorHook(), ProtectionHook() and ShutdownHook()) are executed. OS application </p>
<p>specific hooks won’t be executed. </p>
<p>Consider that the StartupHook() did not yet run when the Pre-Start Task is executed. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the Pre-Start Task is used, global hooks have to consider that the OS might not be </p>
<p>completely initialized. OS APIs which are allowed after normal initialization (e.g. </p>
<p>TerminateApplication()) are not allowed within global hooks, if the error occurred in the </p>
<p>Pre-Start Task. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the ProtectionHook() is triggered within the Pre-Start Task, the OS ignores its return </p>
<p>value. The only valid return value is PRO_SHUTDOWN. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.6.4 </b></p>
<p><b>Dependencies </b></p>
<p>This feature is of significance in SC3 and SC4 system with active memory protection. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>86 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>3.7 </b></p>
<p><b>X-Signals </b></p>
<p><b>3.7.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS uses cross core signaling (X-Signals) to realize API service calls between </p>
<p>cores. </p>
<p>The next figure shows the basic principles of an X-Signal </p>
<p> </p>
<p>Figure 3-1 </p>
<p>X-Signal </p>
<p>Whenever a core executes a service API cross core it writes this request into its own send </p>
<p>port queue. Then it signals this request by an interrupt request (X-Signal) to the serving </p>
<p>core. </p>
<p>The serving core reads the request from the send port queue and executes the requested </p>
<p>service API. The result of the service API is provided in the receive port queue. </p>
<p> </p>
<p> </p>
<p><b>Requesting</b></p>
<p><b>Core</b></p>
<p><b>Serving</b></p>
<p><b>Core</b></p>
<p><b>X-Signal</b></p>
<p><b>Send Port Queue</b></p>
<p><b>Receive Port Queue</b></p>
<p><b>R/W access</b></p>
<p><b>Read only access</b></p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>87 </p>
<p>based on template version 6.0.1 </p>
<p>X-Signals have the following characteristics: </p>
<p><b>&gt; </b></p>
<p>An X-Signal is a unidirectional request from one core to another (1:1). </p>
<p><b>&gt; </b></p>
<p>For each core interconnection one X-Signal is needed. </p>
<p><b>&gt; </b></p>
<p>All accesses to the (sender / receiver) port queues are lock free. </p>
<p><b>&gt; </b></p>
<p>Queue Sizes must be configured. </p>
<p><b>&gt; </b></p>
<p>The Queues may be protected by MPU to achieve freedom of interference between </p>
<p>cores. </p>
<p><b>&gt; </b></p>
<p>X-Signals may be configured to offer only a subset of possible cross core API services. </p>
<p>Not configured API services are refused to be served. </p>
<p><b>&gt; </b></p>
<p>The API error codes for cross core API services are extended. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Additional error codes for queue handling. </p>
<p><b></b></p>
<p><b> </b></p>
<p>Additional error code if the requested service is refused to be served. </p>
<p><b>&gt; </b></p>
<p>X-Signals can be configured to be synchronous or asynchronous. </p>
<p><b> </b></p>
<p><b>Synchronous X-Signal </b></p>
<p><b>Asynchronous X-Signal </b></p>
<p>Call behavior </p>
<p>After the cross core service API has </p>
<p>been requested the requester core </p>
<p>goes into active waiting loop and </p>
<p>polls for the result from the server </p>
<p>core (remote procedure call). </p>
<p><b>Note: </b>During active wait the </p>
<p>interrupts are enabled. </p>
<p>After the cross core service API has </p>
<p>been requested the requester core </p>
<p>continues its own program execution.  </p>
<p>Error signaling </p>
<p>Error handling is induced on the </p>
<p>requester core immediately, if the </p>
<p>polled API result is not E_OK. </p>
<p>Error handling is induced with the </p>
<p>next X-Signal request on the </p>
<p>requester core, if the result of the </p>
<p>previously requested API is not </p>
<p>E_OK. </p>
<p><b>Note</b>: Upon potential errors of the </p>
<p>previously requested API the current </p>
<p>application ID on sender and receiver </p>
<p>side meanwhile may have changed. </p>
<p>AUTOSAR standard </p>
<p>compliance </p>
<p>Compliant to the AUTOSAR </p>
<p>Standard </p>
<p>Deviation to the AUTOSAR Standard </p>
<p>Table 3-2  </p>
<p>Comparison between Synchronous and Asynchronous X-Signal </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Any cross core “getter” APIs e.g. GetTaskState() are always executed with a </p>
<p>synchronous X-Signal. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>88 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The sender core as well as the receiver core may cause protection violations. </p>
<p>Protection error handling is performed on the core where the violation is detected. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>When a cross core API is induced by an X-Signal, all static error checks (e.g. validity of </p>
<p>parameters) are done on the caller side. </p>
<p>All dynamic error checks (which depend on runtime states) are executed on the </p>
<p>receiver side. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>89 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>3.7.1.1 </b></p>
<p><b>Notes on Synchronous X-Signals </b></p>
<p>The priority of the receiver ISR determines which other category 2 ISRs of one core may </p>
<p>use cross core API services. </p>
<p>Additionally category 2 ISRs may only use cross core API services if they allow nesting. </p>
<p>The following table gives an overview. </p>
<p><b>Logical Priority </b></p>
<p><b>ISR Nesting </b></p>
<p><b>Synchronous Cross </b></p>
<p><b>Core API Calls </b></p>
<p>ISR with higher priority than X-Signal priority </p>
<p>ISR nesting is allowed </p>
<p>Not allowed </p>
<p>ISR with higher priority than X-Signal priority </p>
<p>ISR nesting is disabled </p>
<p>Not allowed </p>
<p>X-Signal ISR priority </p>
<p>- </p>
<p>- </p>
<p>ISR with lower priority than X-Signal priority </p>
<p>ISR nesting is allowed </p>
<p>Allowed </p>
<p>ISR with lower priority than X-Signal priority </p>
<p>ISR nesting is disabled </p>
<p>Not allowed </p>
<p>Table 3-3  </p>
<p>Priority of X-Signal receiver ISR </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>If the priority and nesting requirements from the previous table are not fulfilled there </p>
<p>may be deadlocks within a multicore system! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>3.7.1.2 </b></p>
<p><b>Notes on Mixed Criticality Systems </b></p>
<p>MICROSAR  OS  checks  application  access  rights  on  sender  and  on  receiver  side.  This </p>
<p>increases  isolation  of  safety-critical  parts  in  mixed  criticality  systems  (e.g.  protect  a </p>
<p>lockstep core from a non-lockstep core). </p>
<p>Consider that these application access checks are not performed for ShutdownAllCores(). </p>
<p>Thus </p>
<p>switching </p>
<p>off </p>
<p>the </p>
<p>usage </p>
<p>of </p>
<p>ShutdownAllCores </p>
<p>API </p>
<p>for </p>
<p>non-lockstep </p>
<p>cores </p>
<p>is </p>
<p>recommended. This can be done within the X-Signal configuration. </p>
<p><b>3.7.2 </b></p>
<p><b>Activation </b></p>
<p>X-Signals must be configured explicitly  in a multi core  environment. See chapter 4.5 for </p>
<p>details. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>90 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>3.8 </b></p>
<p><b>Timing Hooks </b></p>
<p><b>3.8.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR OS supports timing measurement and analysis by external tools. Therefor it </p>
<p>provides timing hooks. Timing hooks inform the external tools about several events within </p>
<p>the OS: </p>
<p><b>&gt; </b></p>
<p>Activation (arrival) of a task or ISR </p>
<p><b></b></p>
<p><b> </b></p>
<p>These allow an external tool to trace all activations of task as well as further arrivals </p>
<p>(e.g. setting of an event or the release of a semaphore with transfer to another task. </p>
<p><b></b></p>
<p><b> </b></p>
<p>They allow external tools to visualize the arrivals and to measure the time between </p>
<p>them in order to allow a schedule-ability analysis. </p>
<p><b>&gt; </b></p>
<p>Context switch </p>
<p><b></b></p>
<p><b> </b></p>
<p>These allow external tools to trace all context switches from task to ISR and back as </p>
<p>well as between tasks. So external tools may visualize the information or measure </p>
<p>the execution time of tasks and ISRs.  </p>
<p><b>&gt; </b></p>
<p>Locking of interrupts, resources or spinlocks </p>
<p><b></b></p>
<p><b> </b></p>
<p>These allow an external tool to trace locks. This is important as locking times of </p>
<p>tasks and ISRs influence the execution of other tasks and ISRs. The kind of </p>
<p>influence is different for different locks. </p>
<p>Within MICROSAR OS code the timing hooks are called. Additionally it provides empty </p>
<p>hooks by default. </p>
<p>The application may decide to implement any of the hooks by itself. The empty OS default </p>
<p>hook is then replaced by the application implemented hook. </p>
<p><b>3.8.2 </b></p>
<p><b>Activation </b></p>
<p>An  include  header  has  to  be  specified  in  the  attribute  “OsTimingHooksIncludeHeader” </p>
<p>located in the “OsDebug” container. </p>
<p><b>3.8.3 </b></p>
<p><b>Usage </b></p>
<p>The timing hooks may be implemented in the configuration specified header. All available </p>
<p>macros are introduced in chapter 5.11. </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Within the timing hooks trusted access rights are active e.g. access rights to OS </p>
<p>variables. </p>
<p>Thus the timing hooks must be disabled for a safety serial production system. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>91 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>3.9 </b></p>
<p><b>Kernel Panic </b></p>
<p>If  MICROSAR  OS  recognizes  an  inconsistent  internal  state  it  enters  the  kernel  panic </p>
<p>mode. In such cases, the OS does not know how to correctly continue execution. Even a </p>
<p>regular shutdown cannot be reached. E.g.: </p>
<p><b>&gt; </b></p>
<p>The protection hook itself causes errors </p>
<p><b>&gt; </b></p>
<p>The shutdown hook itself causes errors </p>
<p>MICROSAR OS goes into freeze as fast as possible </p>
<p>1. </p>
<p>Disable all interrupts </p>
<p>2. </p>
<p>Inform the application about the kernel panic by calling the Os_PanicHook() (see 5.12) </p>
<p>3. </p>
<p>Enter an endless loop </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>&gt; </p>
<p>The OS cannot recover from kernel panic. </p>
<p>&gt; </p>
<p>ProtectionHook() is not called </p>
<p>&gt; </p>
<p>ErrorHook() is not called </p>
<p>&gt; </p>
<p>There is no stack switch. The Os_PanicHook() runs on the current active stack </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>92 </p>
<p>based on template version 6.0.1 </p>
<p><b>3.10 </b></p>
<p><b>Generate callout stubs </b></p>
<p><b>3.10.1 </b></p>
<p><b>Description </b></p>
<p>MICROSAR  OS  offers  the  feature  to  generate  the  function  bodies  of  all  configured  OS </p>
<p>hook functions (all global hooks and application specific hooks). </p>
<p>The function bodies are generated into the file “Os_Callout_Stubs.c”. </p>
<p><b>3.10.2 </b></p>
<p><b>Activation </b></p>
<p>The Configuration attribute “OsGenerateCalloutStubs” has to be set to TRUE. </p>
<p><b>3.10.3 </b></p>
<p><b>Usage </b></p>
<p>Once the C-File has been generated it may be altered by the user. Code parts between </p>
<p>certain  special  comments  are  permanent  and  won’t  get  lost  between  two  generation </p>
<p>processes. </p>
<p>If a hook is switched off, the corresponding function body  is also removed. But the user </p>
<p>code (between the special comments) is preserved. Once the hook is switched on again, </p>
<p>the preserved user code is also restored. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>FUNC(void, OS_STARTUPHOOK_CODE) StartupHook(void) </p>
<p>{ </p>
<p>/*********************************************************************** </p>
<p> * DO NOT CHANGE THIS COMMENT!           &lt;USERBLOCK OS_Callout_Stubs_StartupHook&gt; </p>
<p> **********************************************************************/ </p>
<p> </p>
<p>   /* user code starts here */ </p>
<p>   /* code between those comments is preserved even if the file is newly generated  </p>
<p>      Or even if the hook is switched off in the meanwhile */ </p>
<p> </p>
<p>/*********************************************************************** </p>
<p> * DO NOT CHANGE THIS COMMENT!           &lt;/USERBLOCK&gt; </p>
<p> **********************************************************************/ </p>
<p> </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>93 </p>
<p>based on template version 6.0.1 </p>
<p><b>4 </b></p>
<p><b>Integration </b></p>
<p><b>4.1 </b></p>
<p><b>Compiler Optimization Assumptions </b></p>
<p>MICROSAR OS makes the following assumptions for compiler optimization: </p>
<p><b>&gt; </b></p>
<p>Inlining of functions is active </p>
<p><b>&gt; </b></p>
<p>Not used functions are removed </p>
<p><b>&gt; </b></p>
<p>If statements with a constant condition (due to configuration) are optimized </p>
<p><b>4.1.1 </b></p>
<p><b>Compile Time </b></p>
<p>To shorten the compile time of the OS the following measures can be taken within the OS </p>
<p>configuration: </p>
<p><b>Systems without active memory </b></p>
<p><b>protection (SC1/SC2) </b></p>
<p>Set “OsGenerateMemMap” to “EMPTY” </p>
<p><b>Systems with memory protection </b></p>
<p><b>(SC3/SC4) </b></p>
<p>Set “OsGenerateMemMap” to “COMPLETE” and </p>
<p>&quot;OsGenerateMemMapForThreads” to “FALSE” </p>
<p> </p>
<p><b>4.2 </b></p>
<p><b>Hardware Software Interfaces (HSI) </b></p>
<p>The </p>
<p>following </p>
<p>chapter </p>
<p>describes </p>
<p>the </p>
<p>Hardware-Software </p>
<p>Interface </p>
<p>for </p>
<p>the </p>
<p>supported </p>
<p>processor families of the MICROSAR OS. </p>
<p>The HSI describes all hardware registers which are used by the OS. Such registers must </p>
<p>not be altered by user software. </p>
<p>Included within the HSI is the context of the OS. The context is the sum of all registers </p>
<p>which are preserved upon a task switch and ISR execution. </p>
<p>Additionally platform specific characteristics of the OS are described here. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>94 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.2.1 </b></p>
<p><b>TriCore Aurix Family </b></p>
<p><b>4.2.1.1 </b></p>
<p><b>Context </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>A0-A15 </p>
<p><b></b></p>
<p><b> </b></p>
<p>D0-D15 </p>
<p><b></b></p>
<p><b> </b></p>
<p>PSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>PCXI </p>
<p><b></b></p>
<p><b> </b></p>
<p>DPR0L, DPR0H </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The register A8 is exclusively used by the OS to hold the pointer to the current thread. </p>
<p>Thus any addressing modes which would use A8 register are not possible. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.2.1.2 </b></p>
<p><b>Core Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>ICR </p>
<p><b></b></p>
<p><b> </b></p>
<p>SYSCON </p>
<p><b></b></p>
<p><b> </b></p>
<p>PCXI </p>
<p><b></b></p>
<p><b> </b></p>
<p>FCX </p>
<p><b></b></p>
<p><b> </b></p>
<p>LCX </p>
<p><b></b></p>
<p><b> </b></p>
<p>PSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>PC </p>
<p><b></b></p>
<p><b> </b></p>
<p>DBGSR </p>
<p><b></b></p>
<p><b> </b></p>
<p>DPRxL, DPRxH </p>
<p><b></b></p>
<p><b> </b></p>
<p>CPRxL, CPRxH </p>
<p><b></b></p>
<p><b> </b></p>
<p>DPRE0 – DPRE3 </p>
<p><b></b></p>
<p><b> </b></p>
<p>DPWE0 – DPWE3 </p>
<p><b></b></p>
<p><b> </b></p>
<p>CPXE0 – CPXE3 </p>
<p><b>4.2.1.3 </b></p>
<p><b>Interrupt Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>INT_SRC0 – INTSRC255 </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>95 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.2.1.4 </b></p>
<p><b>GPT Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>T2, T3, T6 </p>
<p><b></b></p>
<p><b> </b></p>
<p>T2CON, T3CON, T6CON </p>
<p><b></b></p>
<p><b> </b></p>
<p>CAPREL </p>
<p><b>4.2.1.5 </b></p>
<p><b>STM Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>TIM0, TIM5, TIM6 </p>
<p><b></b></p>
<p><b> </b></p>
<p>CMCON </p>
<p><b></b></p>
<p><b> </b></p>
<p>CAP </p>
<p><b></b></p>
<p><b> </b></p>
<p>CMP0, CMP1 </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>96 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.2.1.6 </b></p>
<p><b>Aurix Special Characteristics </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for trap class 1 is implemented by the OS </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for trap class 6 is implemented by the OS </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The TriCore Hardware enforces that a configured MPU region must be followed by at </p>
<p>least 15 padding bytes before the next region may be started. </p>
<p>MICROSAR OS obey to this rule within the generated linker scripts. For other </p>
<p>additional configured MPU regions the user has to take care to fulfill this requirement </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p>Figure 4-1 </p>
<p>Padding bytes between MPU regions </p>
<p> </p>
<p> </p>
<p>Start Address of adjacent MPU Region</p>
<p>End Address of adjacent MPU Region</p>
<p>At least 15 padding bytes</p>
<p>Start Address of MPU Region</p>
<p>End Address of MPU Region</p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>97 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to MPU granularity all start addresses and end addresses of configured MPU </p>
<p>regions must be a multiple of 8. </p>
<p>MICROSAR OS programs the MPU to grant access to the memory region between </p>
<p>start address and end address. </p>
<p>&gt; </p>
<p>Access to configured start address itself is granted </p>
<p>&gt; </p>
<p>Access to configured end address is prohibited </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>MICROSAR OS does not use the System MPU to achieve freedom of interference </p>
<p>between cores. </p>
<p>This has to be done by the application. </p>
<p>The system MPU has to be initialized by a lockstep core. It must not be accessed by </p>
<p>non-lockstep cores. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All stack sizes shall be configured to be a multiple of 8 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Expert Knowledge </b></p>
<p>For proper context management exception handling the LCX should be initialized </p>
<p>during startup code that it does not point to the last available CSA. </p>
<p>In this way some CSAs are reserved which can be used within the context exception </p>
<p>handling for further function calls. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>98 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.2.1.7 </b></p>
<p><b>PSW handling </b></p>
<p><b>PSW.RM bit handling </b></p>
<p>MICROSAR OS sets the rounding mode bits to 0 upon start of a </p>
<p>thread. </p>
<p><b>PSW.S bit handling </b></p>
<p>MICROSAR OS sets the safety task identifier bit to 1 for trusted </p>
<p>software parts and to 0 for non-trusted software parts. </p>
<p><b>PSW.IS bit handling </b></p>
<p>MICROSAR OS sets the interrupt stack bit to 1. </p>
<p>Thus automatic hardware stack switch is not supported. </p>
<p><b>PSW.GW bit handling </b></p>
<p>MICROSAR OS sets the global address register write permission to 0. </p>
<p>Write permission to A0, A1, A8 and A9 are not allowed. </p>
<p><b>PSW.CDE bit handling </b></p>
<p>MICROSAR OS sets the call depth enable bit to 1 upon start of a </p>
<p>thread. </p>
<p>Call depth counting is enabled. </p>
<p><b>PSW.CDC bits handling </b></p>
<p>MICROSAR OS sets the call depth counter to 1 upon start of a thread. </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>99 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.2 </b></p>
<p><b>RH850 Family </b></p>
<p><b>4.2.2.1 </b></p>
<p><b>Context </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>R1 ... R31 </p>
<p><b></b></p>
<p><b> </b></p>
<p>PC </p>
<p><b></b></p>
<p><b> </b></p>
<p>PSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>PMR </p>
<p><b></b></p>
<p><b> </b></p>
<p>LP </p>
<p><b></b></p>
<p><b> </b></p>
<p>SP </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIPC, EIPSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>FPSR, FPEPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>ASID </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPLA0, MPUA0 </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>100 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.2.2.2 </b></p>
<p><b>Core Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>PC </p>
<p><b></b></p>
<p><b> </b></p>
<p>PSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>PMR </p>
<p><b></b></p>
<p><b> </b></p>
<p>LP </p>
<p><b></b></p>
<p><b> </b></p>
<p>SP </p>
<p><b></b></p>
<p><b> </b></p>
<p>ASID </p>
<p><b></b></p>
<p><b> </b></p>
<p>SCCFG </p>
<p><b></b></p>
<p><b> </b></p>
<p>SCBP </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIPSW </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIWR </p>
<p><b></b></p>
<p><b> </b></p>
<p>FPSR </p>
<p><b></b></p>
<p><b> </b></p>
<p>FPEPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>EBASE </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTBP </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTCFG </p>
<p><b></b></p>
<p><b> </b></p>
<p>CTPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>EIIC </p>
<p><b></b></p>
<p><b> </b></p>
<p>FEIC </p>
<p><b></b></p>
<p><b> </b></p>
<p>FEPC </p>
<p><b></b></p>
<p><b> </b></p>
<p>FEPSW  </p>
<p><b></b></p>
<p><b> </b></p>
<p>HTCFG0 </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The register EIWR is exclusively used by the OS to hold the pointer to the current </p>
<p>thread. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>101 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.2.2.3 </b></p>
<p><b>MPU Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>MPM </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPRC </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPLA0 ... MPLA15 </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPUA0 ... MPUA15 </p>
<p><b></b></p>
<p><b> </b></p>
<p>MPAT0 ... MPAT15 </p>
<p><b>4.2.2.4 </b></p>
<p><b>INTC Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>EIC0 ... EIC511 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IBD0 … IBD511 </p>
<p><b>4.2.2.5 </b></p>
<p><b>Inter Processor Interrupt Control Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>IPIR_CH0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IPIR_CH1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IPIR_CH2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IPIR_CH3 </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>102 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.2.6 </b></p>
<p><b>Timer TAUJ Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCDR </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCNT </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCMUR </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCSR </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCSC </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTE </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTE0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTE1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTS </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTS0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTS1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTT </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTT0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTT1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTO </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTO0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTO1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOE </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOE0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOE1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOL </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOL0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOL1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDT </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDT0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDT1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRSF </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRSF0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRSF1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRSF2 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>103 </p>
<p>based on template version 6.0.1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnCMOR </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTPS </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTPS0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnBRS </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnBRS0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnBRS1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOM </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOM0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOM1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOC </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOC0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnTOC1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDE </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDE0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDE1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDM </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDM0 </p>
<p><b></b></p>
<p><b> </b></p>
<p>TAUJnRDM1 </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>104 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b>4.2.2.7 </b></p>
<p><b>Timer STM Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCKSEL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnTS </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnTT </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCSTR </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnSTR </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnSTC </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnIS </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnRM </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT0L </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT0H </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0AL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0AH </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0BL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0BH </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0CL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0CH </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0DL </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP0DH </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP1A </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP1B </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP1C </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP1D </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP2A </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP2B </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP2C </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP2D </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCNT3 </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>105 </p>
<p>based on template version 6.0.1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP3A </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP3B </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP3C </p>
<p><b></b></p>
<p><b> </b></p>
<p>STMnCMP3D </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>106 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.2.2.8 </b></p>
<p><b>Timer OSTM Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnCMP </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnCNT </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTO </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTOE </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTE </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTS </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnTT </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnCTL </p>
<p><b></b></p>
<p><b> </b></p>
<p>OSTMnEMU </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>107 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.2.9 </b></p>
<p><b>RH850 Special Characteristics </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p><b>&gt; </b></p>
<p>The exception handler for TRAP1 (offset = 0x50) is implemented by the OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In SC3 / SC4 systems </p>
<p><b>&gt; </b></p>
<p>The exception handler for TRAP0 (offset = 0x40) is implemented by the OS. </p>
<p><b>&gt; </b></p>
<p>The exception handler for MIP/MDP (offset = 0x90) is implemented by the OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The MPU in RH850 has a granularity of 4Byte. Each data section must have 4Byte </p>
<p>address alignement. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to MPU granularity the start address of any configured MPU region must be a </p>
<p>multiple of 4Byte. </p>
<p>The end address of any configured MPU region must be the address of the last valid </p>
<p>Byte of the section. </p>
<p>MICROSAR OS programs the MPU to grant access to the memory region from start </p>
<p>address and end address. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All stack sizes shall be configured to be a multiple of 4 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Tiny data area (TDA) and zero data area (ZDA) addressing are not supported. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>108 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For multicore-core derivatives, the stack used before StartOS should be linked into the </p>
<p>respective core local RAM areas. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.2.2.10 </b></p>
<p><b>PSW Register Handling </b></p>
<p><b>PSW.EBV </b></p>
<p>MICROSAR OS sets PSW.EBV to 1 upon Os_Init(). </p>
<p><b>PSW.UM </b></p>
<p>MICROSAR OS sets PSW.UM to 0 for trusted software parts and to 1 for non-</p>
<p>trusted software parts. </p>
<p><b>PSW.NP </b></p>
<p>MICROSAR OS sets PSW.NP to 1 to disable FE level interrupts and to 0 to </p>
<p>enable FE level interrupts. </p>
<p><b>PSW.ID </b></p>
<p>MICROSAR OS sets PSW.ID to 1 to disable EI level interrupts and to 0 to </p>
<p>enable EI level interrupts. </p>
<p><b>PSW.CU0 </b></p>
<p>MICROSAR OS sets PSW.CU0  to 1 in order to support FPU. </p>
<p> </p>
<p><b>4.2.2.11 </b></p>
<p><b>Instructions </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>&gt; The instructions &quot;trap 16&quot; … “trap 31” used for TRAP1 are exclusively used by the </p>
<p>OS. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>In SC3 / SC4 systems </p>
<p><b>&gt; </b></p>
<p>The instructions &quot;trap 0&quot; … “trap 15” used for TRAP0 are exclusively used by the </p>
<p>OS. </p>
<p><b>&gt; </b></p>
<p>The instruction &quot;syscall&quot; is not supported and therefore shall not be used. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.2.2.12 </b></p>
<p><b>Exception and Interrupt Cause Address </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note</b> </p>
<p>The exception and interrupt cause address from EIPC and FEPC is stored in register </p>
<p>CTPC when unhandled EIINT, unhandled SYSCALL, MIP/MDP exception (SC3/SC4) </p>
<p>or unhandled core exception is reported. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>109 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.2.3 </b></p>
<p><b>Power PC Family </b></p>
<p><b>4.2.3.1 </b></p>
<p><b>Context </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>R2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>R13-R31 </p>
<p><b></b></p>
<p><b> </b></p>
<p>PID </p>
<p><b></b></p>
<p><b> </b></p>
<p>SP </p>
<p><b></b></p>
<p><b> </b></p>
<p>PC </p>
<p><b></b></p>
<p><b> </b></p>
<p>LR </p>
<p><b></b></p>
<p><b> </b></p>
<p>MSR </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_CPR[0|1|2] </p>
<p><b></b></p>
<p><b> </b></p>
<p>SPEFSCR </p>
<p><b>4.2.3.2 </b></p>
<p><b>Core Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>SPRG0, SPRG1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>SRR0, SRR1 </p>
<p><b></b></p>
<p><b> </b></p>
<p>IVPR </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIR </p>
<p><b>4.2.3.3 </b></p>
<p><b>Interrupt Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_BCR </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_CPR0 – INTC_CPR2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_IACKR0 – INTC_IACKR2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_EOIR0 – INTC_EOIR2 </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_SSCIRn </p>
<p><b></b></p>
<p><b> </b></p>
<p>INTC_PSRn </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>110 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.3.4 </b></p>
<p><b>PIT Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_MCR </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_LDVALn </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_CVALn </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_TCTRLn </p>
<p><b></b></p>
<p><b> </b></p>
<p>PIT_TFLGn </p>
<p><b>4.2.3.5 </b></p>
<p><b>STM Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CR </p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CNT </p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CCRn </p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CIRn </p>
<p><b></b></p>
<p><b> </b></p>
<p>STM_CMPn </p>
<p><b>4.2.3.6 </b></p>
<p><b>MPU Registers </b></p>
<p><b>Core MPU </b></p>
<p><b>System MPU </b></p>
<p><b>&gt; </b></p>
<p>CMPU_MAS0 </p>
<p><b>&gt; </b></p>
<p>CMPU_MAS1 </p>
<p><b>&gt; </b></p>
<p>CMPU_MAS2 </p>
<p><b>&gt; </b></p>
<p>CMPU_MAS3 </p>
<p><b>&gt; </b></p>
<p>CMPU_MPU0CSR0 </p>
<p><b>&gt; </b></p>
<p>SMPU_CESR0 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WRD0 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WRD1 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WRD2 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WRD3 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WRD4 </p>
<p><b>&gt; </b></p>
<p>SMPU_RGDn_WRD5 </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>111 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.2.3.7 </b></p>
<p><b>SEMA4 Registers </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>SEMA42_GATE0 </p>
<p> </p>
<p><b>4.2.3.8 </b></p>
<p><b>Power PC Special Characteristics </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Machine check is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Data Storage is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Instruction Storage is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for External Input is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Program is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for System call is implemented by the OS </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The register SPRG0 is exclusively used by the OS to hold the identifier of the current </p>
<p>thread. </p>
<p>The register SPRG1 is exclusively used by the OS to hold the address of the </p>
<p>INTC_CPR register. </p>
<p>The register SEMA42_GATE0 is exclusively used by the OS to provide mutual </p>
<p>exclusion in multicore systems for spinlock handling. </p>
<p>Thus these registers must not be used otherwise. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to MPU granularity all start addresses of configured MPU regions for the </p>
<p>SystemMPU must be a multiple of 32. The configured end addresses must be a </p>
<p>multiple of 32 minus one byte. </p>
<p>MICROSAR OS programs the MPU to grant access to the memory region between </p>
<p>start address and end address. </p>
<p>&gt; </p>
<p>Access to configured start address and end address itself is granted </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>112 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For the CoreMPU, no restrictions on start address and end address apply. </p>
<p>MICROSAR OS programs the MPU to grant access to the memory region between </p>
<p>start address and end address. </p>
<p>&gt; </p>
<p>Access to configured start address and end address itself is granted </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All stack sizes shall be configured to be a multiple of 8 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>MICROSAR OS assumes that Power PC multi core derivatives are booted as a master </p>
<p>/ slave system (as described in 2.15.4). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>For System MPU regions only the format FMT1 is supported to setting up the </p>
<p>SMPUx_RGDn_WORD2. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.2.3.9 </b></p>
<p><b>MSR Handling </b></p>
<p><b>MSR.SPV bit handling </b></p>
<p>MICROSAR OS sets the SPV bit to 1 upon start of a thread. </p>
<p><b>MSR.EE bit handling </b></p>
<p>MICROSAR OS sets the external interrupt enable bit to 0 for non-</p>
<p>interruptible threads without TimingProtection supervision, and to 1 for </p>
<p>interruptible or TimingProtection supervised threads. </p>
<p><b>MSR.PR bit handling </b></p>
<p>MICROSAR OS sets the problem state bit to 0 for trusted software </p>
<p>parts and to 1 for non-trusted software parts. </p>
<p><b>MSR.ME bit handling </b></p>
<p>MICROSAR OS sets the machine check enable bit to 1. </p>
<p>Asynchronous Machine Check interrupts are enabled. </p>
<p><b>MSR remaining bits </b></p>
<p><b>handling </b></p>
<p>MICROSAR OS sets all other MSR bits to 0 upon start of a thread. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>113 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4 </b></p>
<p><b>ARM Family </b></p>
<p><b>4.2.4.1 </b></p>
<p><b>Cortex-R derivatives </b></p>
<p><b> </b></p>
<p>Generic </p>
<p>Cortex-R </p>
<p>Traveo Family </p>
<p>UltraScale Family </p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p>--- </p>
<p><b>&gt; </b></p>
<p>IRQPLM </p>
<p><b>&gt; </b></p>
<p>ICCPMR </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>SCTLR </p>
<p><b>&gt; </b></p>
<p>TPIDRURO </p>
<p><b>MPU Registers </b></p>
<p><b>&gt; </b></p>
<p>DRBAR </p>
<p><b>&gt; </b></p>
<p>DRSR </p>
<p><b>&gt; </b></p>
<p>DRACR </p>
<p><b>&gt; </b></p>
<p>RGNR </p>
<p><b>Bootrom Registers </b></p>
<p>--- </p>
<p><b>&gt; </b></p>
<p>UNLOCK </p>
<p><b>&gt; </b></p>
<p>CNFG </p>
<p><b>&gt; </b></p>
<p>UNDEFINACT </p>
<p><b>&gt; </b></p>
<p>SVCINACT </p>
<p><b>&gt; </b></p>
<p>PABORTINACT </p>
<p><b>&gt; </b></p>
<p>DABORTINACT </p>
<p>--- </p>
<p><b>INTC Registers </b></p>
<p>--- </p>
<p><b>&gt; </b></p>
<p>NMIST </p>
<p><b>&gt; </b></p>
<p>IRQST </p>
<p><b>&gt; </b></p>
<p>NMIVAn </p>
<p><b>&gt; </b></p>
<p>IRQVAn </p>
<p><b>&gt; </b></p>
<p>NMIPLn </p>
<p><b>&gt; </b></p>
<p>IRQPLn </p>
<p><b>&gt; </b></p>
<p>NMIS </p>
<p><b>&gt; </b></p>
<p>NMIR </p>
<p><b>&gt; </b></p>
<p>IRQSn </p>
<p><b>&gt; </b></p>
<p>IRQRn </p>
<p><b>&gt; </b></p>
<p>IRQCESn </p>
<p><b>&gt; </b></p>
<p>IRQCERn </p>
<p><b>&gt; </b></p>
<p>NMIHC </p>
<p><b>&gt; </b></p>
<p>IRQHC </p>
<p><b>&gt; </b></p>
<p>UNLOCK </p>
<p><b>&gt; </b></p>
<p>ICCICR </p>
<p><b>&gt; </b></p>
<p>ICCBPR </p>
<p><b>&gt; </b></p>
<p>ICCIAR </p>
<p><b>&gt; </b></p>
<p>ICCEOIR </p>
<p><b>&gt; </b></p>
<p>ICDDCR </p>
<p><b>&gt; </b></p>
<p>ICDISRn </p>
<p><b>&gt; </b></p>
<p>ICDISERn </p>
<p><b>&gt; </b></p>
<p>ICDICERn </p>
<p><b>&gt; </b></p>
<p>ICDISPRn </p>
<p><b>&gt; </b></p>
<p>ICDICPRn </p>
<p><b>&gt; </b></p>
<p>ICDIPRn </p>
<p><b>&gt; </b></p>
<p>ICDIPTRn </p>
<p><b>&gt; </b></p>
<p>ICDSGIR </p>
<p><b>FRT Registers </b></p>
<p>--- </p>
<p><b>&gt; </b></p>
<p>TCDT </p>
<p><b>&gt; </b></p>
<p>TCCS </p>
<p>--- </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>114 </p>
<p>based on template version 6.0.1 </p>
<p><b>&gt; </b></p>
<p>TCCSC </p>
<p><b>&gt; </b></p>
<p>TCCSS </p>
<p><b>Output Compare </b></p>
<p><b>Registers </b></p>
<p>--- </p>
<p><b>&gt; </b></p>
<p>OCCP0, OCCP1 </p>
<p><b>&gt; </b></p>
<p>OCS </p>
<p><b>&gt; </b></p>
<p>OCSC </p>
<p><b>&gt; </b></p>
<p>OCSS </p>
<p>--- </p>
<p><b>TTC Registers </b></p>
<p>--- </p>
<p>--- </p>
<p><b>&gt; </b></p>
<p>Clock_Control </p>
<p><b>&gt; </b></p>
<p>Counter_Control </p>
<p><b>&gt; </b></p>
<p>Counter_Value </p>
<p><b>&gt; </b></p>
<p>Interval_Counter </p>
<p><b>&gt; </b></p>
<p>Match_1_Counter </p>
<p><b>&gt; </b></p>
<p>Match_2_Counter </p>
<p><b>&gt; </b></p>
<p>Match_3_Counter </p>
<p><b>&gt; </b></p>
<p>Interrupt_Register </p>
<p><b>&gt; </b></p>
<p>Interrupt_Enable </p>
<p><b>&gt; </b></p>
<p>Event_Control_Timer </p>
<p><b>&gt; </b></p>
<p>Event_Register </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>115 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.2.4.2 </b></p>
<p><b>Cortex-A derivatives </b></p>
<p><b> </b></p>
<p>Generic Cortex-A </p>
<p>iMX6 Family </p>
<p><b>Context Registers </b></p>
<p><b>&gt; </b></p>
<p>R4-R11 </p>
<p><b>&gt; </b></p>
<p>PC </p>
<p><b>&gt; </b></p>
<p>LR </p>
<p><b>&gt; </b></p>
<p>SP </p>
<p><b>&gt; </b></p>
<p>PSR </p>
<p><b>Core Registers </b></p>
<p><b>&gt; </b></p>
<p>SCTLR </p>
<p><b>&gt; </b></p>
<p>VBAR </p>
<p><b>INTC Registers </b></p>
<p>---</p>
<p> </p>
<p><b>&gt; </b></p>
<p>ICCICR </p>
<p><b>&gt; </b></p>
<p>ICCBPR </p>
<p><b>&gt; </b></p>
<p>ICCIAR </p>
<p><b>&gt; </b></p>
<p>ICCEOIR </p>
<p><b>&gt; </b></p>
<p>ICDDCR </p>
<p><b>&gt; </b></p>
<p>ICDISRn </p>
<p><b>&gt; </b></p>
<p>ICDISERn </p>
<p><b>&gt; </b></p>
<p>ICDICERn </p>
<p><b>&gt; </b></p>
<p>ICDISPRn </p>
<p><b>&gt; </b></p>
<p>ICDICPRn </p>
<p><b>&gt; </b></p>
<p>ICDIPRn </p>
<p><b>&gt; </b></p>
<p>ICCPMR </p>
<p><b>&gt; </b></p>
<p>ICDIPTRn </p>
<p><b>&gt; </b></p>
<p>ICDSGIR </p>
<p> </p>
<p> </p>
<p> </p>
<p><b>4.2.4.3 </b></p>
<p><b>ARM Special Characteristics </b></p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Supervisor Call is implemented by the OS  </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Undefined Instruction is implemented by the OS </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Prefetch Abort is implemented by the OS </p>
<p><b></b></p>
<p><b> </b></p>
<p>The exception handler for Data Abort is implemented by the OS </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Due to MPU hardware restriction the sizes of MPU regions and stack sizes must be </p>
<p>configured with power of 2 values. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>116 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution with UltraScale derivatives </b></p>
<p>The exception vector table of each core must be located in tightly coupled RAM </p>
<p>memory at address 0x0. </p>
<p>Either the debugger or the startup code has to copy the exception vector table from </p>
<p>ROM section “OS_EXCVEC_CORE&lt;core ID&gt;_CODE” to address 0x0. </p>
<p>During OS startup OS code assumes that the exception vector table has already been </p>
<p>copied. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>To avoid memory violations during startup phase, the startup code shall initialize the </p>
<p>stack pointer to use the OS kernel stack. </p>
<p>e.g. usage of the following function within startup code </p>
<p>__asm void HwSpec_ChangeToKernelStackAndReturn(void) </p>
<p>{ </p>
<p>  ldr r0, =OsCfg_Stack_KernelStacks </p>
<p>  ldr r0, [r0] /* r0 = OsCfg_Stack_KernelStacks[0] */ </p>
<p>  ldr r0, [r0] /* r0 = OsCfg_Stack_KernelStacks[0]-&gt;StackRegionEnd */ </p>
<p>  mov sp, r0 </p>
<p>  bx lr </p>
<p>} </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>117 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.3 </b></p>
<p><b>Memory Mapping Concept </b></p>
<p>MICROSAR OS uses the AUTOSAR MemMap mechanism to locate its own variables but </p>
<p>also application variables. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>To use the OS memory mapping concept within the AUTOSAR MemMap mechanism </p>
<p>the generated OS file “Os_MemMap.h” has to be included into “MemMap.h”. </p>
<p>It should be included after the inclusion of the MemMap headers of all other basic </p>
<p>software components. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.3.1 </b></p>
<p><b>Provided MemMap Section Specifers </b></p>
<p>MICROSAR  OS  uses  and  specifies  section  specifiers  as  described  in  the  AUTOSAR </p>
<p>specification of memory mapping. All section specifiers have one of the following forms: </p>
<p>OS_START_SEC_&lt;SectionType&gt;[_&lt;InitPolicy&gt;][_&lt;Alignment&gt;] </p>
<p>OS_STOP_SEC_&lt;SectionType&gt;[_&lt;InitPolicy&gt;][_&lt;Alignment&gt;] </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Due to clarity and understanding this chapter does only refer to section specifiers that </p>
<p>shall be handled by the application. </p>
<p>The OS internally used section specifiers are not listed here. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>118 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>SectionType </b></p>
<p><b>InitPolicy </b></p>
<p><b>Alignment </b></p>
<p>&lt;Callout&gt;_CODE </p>
<p>- </p>
<p>- </p>
<p>NONAUTOSAR_CORE&lt; Core Id &gt;_CONST </p>
<p>- </p>
<p>UNSPECIFIED </p>
<p>NONAUTOSAR_CORE&lt; Core Id&gt;_VAR </p>
<p>NOINIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;_VAR </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;_VAR_FAST </p>
<p>- </p>
<p>NOINIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;_VAR_NOCACHE </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;_CONST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;ApplicationName&gt;CONST_FAST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>119 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>SectionType </b></p>
<p><b>InitPolicy </b></p>
<p><b>Alignment </b></p>
<p>&lt;Task/IsrName&gt;_VAR </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;Task/IsrName&gt;_VAR_FAST </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;Task/IsrName&gt;_CONST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>&lt;Task/IsrName&gt;_CONST_FAST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>120 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>SectionType </b></p>
<p><b>InitPolicy </b></p>
<p><b>Alignment </b></p>
<p> </p>
<p> </p>
<p> </p>
<p>GLOBALSHARED_VAR </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>GLOBALSHARED_VAR_FAST </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>GLOBALSHARED_VAR_NOCACHE </p>
<p>- </p>
<p>NOINIT </p>
<p>ZERO_INIT </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>GLOBALSHARED_CONST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>GLOBALSHARED_CONST_FAST </p>
<p>- </p>
<p>BOOLEAN </p>
<p>8BIT </p>
<p>16BIT </p>
<p>32BIT </p>
<p>UNSPECIFIED </p>
<p>Table 4-1  </p>
<p>Provided MemMap Section Specifiers </p>
<p><b>4.3.1.1 </b></p>
<p><b>Usage of MemMap Macros </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_START_SEC_MyAppl_VAR_FAST_NOINIT_UNSPECIFIED </p>
<p>#include “MemMap.h” </p>
<p>uint16 MyApplicationVariable; </p>
<p>#define OS_STOP_SEC_MyAppl_VAR_FAST_NOINIT_UNSPECIFIED </p>
<p>#include “MemMap.h” </p>
<p> </p>
<p>This code snippet puts the user variable into an OS application section. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>121 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.1.2 </b></p>
<p><b>Resulting sections </b></p>
<p>The usage of the above described macros will result in the following memory sections: </p>
<p><b>SectionType </b></p>
<p><b>Content / Description </b></p>
<p>OS_CODE </p>
<p>&gt; </p>
<p>OS Code </p>
<p>OS_INTVEC_CODE </p>
<p>&gt; </p>
<p>Interrupt vector table in case the system needs </p>
<p>one generic vector table for all cores </p>
<p>OS_INTVEC_CORE&lt;Core ID&gt;_CODE </p>
<p>&gt; </p>
<p>Interrupt vector table of one specific core </p>
<p>OS_EXCVEC_CORE&lt;Core ID&gt;_CODE </p>
<p>&gt; </p>
<p>Exception vector table of one core </p>
<p>OS_&lt;Callout&gt;_CODE </p>
<p>&gt; </p>
<p>Code of Tasks, ISRs and OS Hooks </p>
<p>Table 4-2  </p>
<p>MemMap Code Sections Descriptions </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The MPU may be set up to grant execution from the whole address space. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>122 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>SectionType </b></p>
<p><b>Content / Description </b></p>
<p>OS_CONST </p>
<p>&gt; </p>
<p>OS constant data </p>
<p>OS_CONST_FAST </p>
<p>&gt; </p>
<p>OS constant data for fast memory </p>
<p>OS_INTVEC_CONST </p>
<p>&gt; </p>
<p>Interrupt vector table in case the system needs </p>
<p>one generic vector table for all cores </p>
<p>OS_CORE&lt;Core Id&gt;_CONST </p>
<p>&gt; </p>
<p>OS constant data related to one specific core </p>
<p>OS_CORE&lt;Core Id&gt;_CONST_FAST </p>
<p>&gt; </p>
<p>OS constant data related to one specific for fast </p>
<p>memory </p>
<p>OS_INTVEC_&lt;Core Id&gt;_CONST </p>
<p>&gt; </p>
<p>Interrupt vector table of one specific core </p>
<p>OS_EXCVEC_&lt;Core Id&gt;_CONST </p>
<p>&gt; </p>
<p>Exception vector table of one core </p>
<p>OS_NONAUTOSAR_CORE&lt; Core Id &gt;_CONST </p>
<p>&gt; </p>
<p>OS constant data of a non-AUTOSAR core </p>
<p>OS_NONAUTOSAR_CORE&lt; Core Id </p>
<p>&gt;_CONST_FAST </p>
<p>&gt; </p>
<p>OS constant data of a non-AUTOSAR core with </p>
<p>shord addressing </p>
<p>OS_GLOBALSHARED_CONST </p>
<p>&gt; </p>
<p>Constants which shall be shared among core </p>
<p>boundaries </p>
<p>OS_GLOBALSHARED_CONST_FAST </p>
<p>&gt; </p>
<p>Constants which shall be shared among core </p>
<p>boundaries and which use short addressing </p>
<p>accesses (e.g. by base address pointer) </p>
<p>OS_&lt;Task/IsrName&gt;_CONST </p>
<p>&gt; </p>
<p>Thread specific constants </p>
<p>OS_&lt;Task/IsrName&gt;_CONST_FAST </p>
<p>&gt; </p>
<p>Thread specific constants which use short </p>
<p>addressing accesses (e.g. by base address </p>
<p>pointer) </p>
<p>OS_&lt;ApplicationName&gt;_CONST </p>
<p>&gt; </p>
<p>Application specific constants </p>
<p>OS_&lt;ApplicationName&gt;_CONST_FAST </p>
<p>&gt; </p>
<p>Application specific constants which use short </p>
<p>addressing accesses (e.g. by base address </p>
<p>pointer) </p>
<p>Table 4-3  </p>
<p>MemMap Const Sections Descriptions </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The MPU may be set up to grant read access to const sections from all runtime </p>
<p>contexts (trusted and non-trusted) </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>123 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>Section </b></p>
<p><b>Content </b></p>
<p>OS_VAR_NOCACHE </p>
<p>OS global variables. All cores may </p>
<p>have to access these variables. </p>
<p>OS_VAR_NOCACHE_NOINIT </p>
<p>OS_VAR_FAST_NOCACHE </p>
<p>OS_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR </p>
<p>OS core local variables. These </p>
<p>variables are never accessed from </p>
<p>foreign cores. </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOCACHE </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_PUBLIC_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS core local variables. These </p>
<p>variables may also be accessed </p>
<p>from foreign cores </p>
<p>OS_PUBLIC_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR </p>
<p>User core local variables of non-</p>
<p>AUTOSAR cores. Access to these </p>
<p>from foreign cores may be allowed. </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_FAST </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>124 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>Section </b></p>
<p><b>Content </b></p>
<p>OS_GLOBALSHARED_VAR </p>
<p>User global shared variables. </p>
<p>All cores have access to them. </p>
<p>OS_GLOBALSHARED_VAR_FAST </p>
<p>OS_GLOBALSHARED_VAR_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_ZERO_INIT </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOCACHE </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE_ZERO_INIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR </p>
<p>User application private </p>
<p>variables. Only application </p>
<p>members and other trusted </p>
<p>software may have access to </p>
<p>them. </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_ZERO_INIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOCACHE </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE_ZERO_INIT </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>125 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>Section </b></p>
<p><b>Content </b></p>
<p>OS_&lt;Task/IsrName&gt;_VAR </p>
<p>User thread private </p>
<p>variables. Only the owning </p>
<p>thread and other trusted </p>
<p>software may have </p>
<p>access to them </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_FAST </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_NOINIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_FAST_NOINIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_ZERO_INIT </p>
<p>OS_BARRIER_CORE&lt;Core Id&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS synchronization </p>
<p>barriers. Only the OS </p>
<p>must have access to </p>
<p>them. They will be </p>
<p>accessed from all cores </p>
<p>OS_BARRIER_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_CORESTATUS_CORE&lt;Core Id&gt;_VAR_ NOCACHE_NOINIT </p>
<p>Startup state of each </p>
<p>physical core. Only the </p>
<p>OS must have access to </p>
<p>them. They will be written </p>
<p>by the master core and </p>
<p>the owning core itself, and </p>
<p>read from all cores. </p>
<p>OS_CORESTATUS_CORE&lt;Core </p>
<p>Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_SPINLOCK_&lt;SpinlockName&gt;_VAR_NOCACHE_NOINIT </p>
<p>User spinlocks. Only the </p>
<p>OS must have access to </p>
<p>them. Potentially they will </p>
<p>be accessed from all </p>
<p>cores </p>
<p>OS_SPINLOCK_&lt;SpinlockName&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_STACK_&lt;StackName&gt;_VAR_NOINIT </p>
<p>OS stacks. Only the </p>
<p>current running software </p>
<p>has access to the stack. </p>
<p>Software which runs on a </p>
<p>foreign must not have </p>
<p>access to it. </p>
<p>Table 4-4  </p>
<p>MemMap Variable Sections Descriptions </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>126 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Notes </b></p>
<p>Sections which contain the keyword “FAST” are intended to be linked into fast RAM. </p>
<p>Sections which contain the keyword “NOCACHE” must never be linked into cacheable </p>
<p>memory. </p>
<p>Sections which contain the keyword “NOINIT” contain non-initialized variables. </p>
<p>Sections which contain the keyword “ZERO_INIT” contain zero initialized variables. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>127 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.3.1.3 </b></p>
<p><b>Access Rights to Variable Sections </b></p>
<p>The table shows the recommended access rights to the sections. </p>
<p><b>Section </b></p>
<p><b>Local Core </b></p>
<p><b>Trusted </b></p>
<p><b>Local core non </b></p>
<p><b>trusted </b></p>
<p><b>Foreign core </b></p>
<p><b>trusted </b></p>
<p><b>Foreign core </b></p>
<p><b>non trusted </b></p>
<p>OS_VAR_NOCACHE </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_VAR_NOCACHE_NOINIT </p>
<p>OS_VAR_FAST_NOCACHE </p>
<p>OS_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR </p>
<p>RW </p>
<p>RO </p>
<p>RO </p>
<p>RO </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOCACHE </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_PUBLIC_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_PUBLIC_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_FAST </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_NOINIT </p>
<p>OS_NONAUTOSAR_CORE&lt;Core Id&gt;_VAR_FAST_NOINIT </p>
<p>OS_GLOBALSHARED_VAR </p>
<p>RW </p>
<p>RW </p>
<p>RW </p>
<p>RW </p>
<p>OS_GLOBALSHARED_VAR_FAST </p>
<p>OS_GLOBALSHARED_VAR_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_ZERO_INIT </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOCACHE </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_GLOBALSHARED_VAR_NOCACHE_ZERO_INIT </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>128 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>Section </b></p>
<p><b>Local Core </b></p>
<p><b>Trusted </b></p>
<p><b>Local core non </b></p>
<p><b>trusted </b></p>
<p><b>Foreign core </b></p>
<p><b>trusted </b></p>
<p><b>Foreign core </b></p>
<p><b>non trusted </b></p>
<p>OS_&lt;ApplicationName&gt;_VAR </p>
<p>RW </p>
<p>RW </p>
<p>RW </p>
<p>RO </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_ZERO_INIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOCACHE </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_&lt;ApplicationName&gt;_VAR_NOCACHE_ZERO_INIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR </p>
<p>RW </p>
<p>RW </p>
<p>RW </p>
<p>RO </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_FAST </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_NOINIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_FAST_NOINIT </p>
<p>OS_&lt;Task/IsrName&gt;_VAR_ZERO_INIT </p>
<p>OS_BARRIER_CORE&lt;Core Id&gt;_VAR_NOCACHE_NOINIT </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_BARRIER_CORE&lt;Core Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_CORESTATUS_CORE&lt;Core Id&gt;_VAR_ NOCACHE_NOINIT </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_CORESTATUS_CORE&lt;Core </p>
<p>Id&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>OS_SPINLOCK_&lt;SpinlockName&gt;_VAR_NOCACHE_NOINIT </p>
<p>RW </p>
<p>RO </p>
<p>RW </p>
<p>RO </p>
<p>OS_SPINLOCK_&lt;SpinlockName&gt;_VAR_FAST_NOCACHE_NOINIT </p>
<p>Table 4-5  </p>
<p>Recommended Section Access Rights </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The access to the stack section is handled completely by MICROSAR OS </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>129 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The table is only valid for cores which have the same diagnostic level. Cores with a </p>
<p>lower diagnostic level must never interact with data from a core with a higher diagnostic </p>
<p>level. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>130 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.3.2 </b></p>
<p><b>Link Sections </b></p>
<p>Once  variables  have  been  put  into  OS  sections  (by  usage  of  the  section  specifiers </p>
<p>described in 4.3.1.1) the sections would have to be linked. </p>
<p>Therefore  MICROSAR  OS  generates  linker  command  files  which  utilize  the  linkage  of </p>
<p>those sections. </p>
<p><b>Linker Command Filename </b></p>
<p>Content </p>
<p><b>Os_Link_&lt;Core&gt;.&lt;FileSuffix&gt; </b></p>
<p>All data and code sections which are bound to a </p>
<p>core </p>
<p><b>Os_Link.&lt;FileSuffix&gt; </b></p>
<p>All data and code sections which are global </p>
<p><b>Os_Link_&lt;Core&gt;_Stacks.&lt;FileSuffix&gt; </b></p>
<p>all stacks of a core </p>
<p>Table 4-6  </p>
<p>List of Generated Linker Command Files </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>&lt;Core&gt; is the logical core ID </p>
<p>&lt;FileSuffix&gt; is the suffix for linker command files. It depends on the used compiler. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>131 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.2.1 </b></p>
<p><b>Simple Linker Defines </b></p>
<p>The following defines are used to select groups of OS sections from the linker command </p>
<p>files. </p>
<p><b>Select OS code </b></p>
<p>OS_LINK_CODE </p>
<p><b>Select an interrupt vector table </b></p>
<p>OS_LINK_INTVEC_CODE </p>
<p><b>Select an exception vector table </b></p>
<p>OS_LINK_EXCVEC_CODE </p>
<p><b>Select user callouts (Tasks, ISRs, Hooks) </b></p>
<p>OS_LINK_CALLOUT_CODE </p>
<p><b>Select constants related to an interrupt vector table </b></p>
<p>OS_LINK_INTVEC_CONST </p>
<p><b>Select constants related to an exception vector table </b></p>
<p>OS_LINK_EXCVEC_CONST </p>
<p><b>Select OS stacks </b></p>
<p>OS_LINK_KERNEL_STACKS </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_INTVEC_CODE </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects the interrupt vector table from the included linker command file for linking. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.3.2.2 </b></p>
<p><b>Hierachical Linker Defines </b></p>
<p>The linker command files are intended to be included into a main linker command file. </p>
<p>Single sections or group of sections can be selected for linkage by usage of C-like defines. </p>
<p>This mechanism is similar to the MemMap mechanism of AUTOSAR. </p>
<p>The linker defines of MICROSAR OS uses a hierarchical syntax. </p>
<p>The more one walks down in the hierarchy the less sections are selected. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>Once one have made the decision for a specific hierarchical level one will have to stick </p>
<p>to this level throughout the linker defines group. Otherwise there may be multiple </p>
<p>section definitions. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>132 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.2.3 </b></p>
<p><b>Selecting OS constants </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy level 1 </b></p>
<p>OS_LINK_CONST_KERNEL </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>Table 4-7  </p>
<p>OS constants linker define group </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_CONST_KERNEL </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all OS constants from Os_Link_Core0_Tasking.lsl file </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_CONST_KERNEL_NEAR </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all near addressable OS constants only from Os_Link_Core0_Tasking.lsl file </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>133 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>4.3.2.4 </b></p>
<p><b>Selecting OS variables </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 1 </b></p>
<p><b>Optional </b></p>
<p><b>Hierarchy level </b></p>
<p><b>2 </b></p>
<p><b>Optional </b></p>
<p><b>Hierarchy level 3 </b></p>
<p>OS_LINK_VAR_KERNEL </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>_CACHE </p>
<p>_NOCACHE </p>
<p>_INIT </p>
<p>_NOINIT </p>
<p>Table 4-8  </p>
<p>OS variables linker define group </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_VAR_KERNEL </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all OS variables from Os_Link_Core0_Tasking.lsl file </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_VAR_KERNEL_NEAR_CACHE </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all OS variables from Os_Link_Core0_Tasking.lsl file which are near </p>
<p>addressable and cacheable </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>134 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.2.5 </b></p>
<p><b>Selecting OS Barriers, Core Status and Trace variables </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy level 1 </b></p>
<p>OS_LINK_KERNEL_BARRIERS </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>OS_LINK_KERNEL_CORESTATUS </p>
<p>OS_LINK_KERNEL_TRACE </p>
<p>Table 4-9  </p>
<p>OS Barriers and Core status linker define group </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_KERNEL_BARRIERS </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all OS Barriers from Os_Link_Core0_Tasking.lsl file </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_KERNEL_CORESTATUS </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all OS core state variables from Os_Link_Core0_Tasking.lsl file </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>135 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.2.6 </b></p>
<p><b>Selecting OS Spinlocks </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy level 1 </b></p>
<p>OS_LINK_SPINLOCKS </p>
<p>_NEAR </p>
<p>_FAR </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_SPINLOCKS </p>
<p>#include Os_Link_Tasking.lsl </p>
<p> </p>
<p>Selects all OS core state variables from Os_Link_Tasking.lsl file </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>136 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.2.7 </b></p>
<p><b>Selecting User Constant Sections </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy level 1 </b></p>
<p><b>Owner Name </b></p>
<p><b>Optional Hierarchy level 2 </b></p>
<p>OS_LINK_CONST </p>
<p>_APP </p>
<p>&lt;Owner Name&gt; </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>_TASK </p>
<p>_ISR </p>
<p>_GLOBALSHARED </p>
<p>--- </p>
<p>Table 4-10  </p>
<p>User constants linker define group </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_CONST_APP_&lt;ApplicationName&gt; </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all constants from Os_Link_Core0_Tasking.lsl file which belong to the OS application &lt;ApplicationName&gt; </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_CONST_ISR_&lt;ISRName&gt;_FAR </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all constants from Os_Link_Core0_Tasking.lsl file which belong to the ISR &lt;ISRName&gt; which have far addressing </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>137 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.2.8 </b></p>
<p><b>Selecting User Variable Sections </b></p>
<p>These are hierarchical linker defines </p>
<p><b>Prefix </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 1 </b></p>
<p><b>Owner Name </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 2 </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 3 </b></p>
<p><b>Optional Hierarchy </b></p>
<p><b>level 4 </b></p>
<p>OS_LINK_VAR </p>
<p>_APP </p>
<p>&lt;Owner Name&gt; </p>
<p>_NEAR </p>
<p>_FAR </p>
<p>_CACHE </p>
<p>_NOCACHE </p>
<p>_INIT </p>
<p>_NOINIT </p>
<p>_ZEROINIT </p>
<p>_TASK </p>
<p>_ISR </p>
<p>_GLOBALSHARED </p>
<p>--- </p>
<p>--- </p>
<p>Table 4-11  </p>
<p>User variables linker define group </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_VAR_APP_&lt;ApplicationName&gt; </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all variables from Os_Link_Core0_Tasking.lsl file which belong to the OS application &lt;ApplicationName&gt; </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>138 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>#define OS_LINK_VAR_APP_&lt;ApplicationName&gt;_FAR_CACHE_INIT </p>
<p>#include Os_Link_Core0_Tasking.lsl </p>
<p> </p>
<p>Selects all variables from Os_Link_Core0_Tasking.lsl file which belong to the OS application &lt;ApplicationName&gt; which have far </p>
<p>addressing, are cacheable and are initialized </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>139 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.3.3 </b></p>
<p><b>Section Symbols </b></p>
<p>The linker command files described in 4.3.2 also generate section start and stop symbols </p>
<p>which may be used to configure start and end addresses of MPU region objects or access </p>
<p>check region objects. </p>
<p>These have the syntax </p>
<p>OS_&lt;SectionType&gt;_START </p>
<p>OS_&lt;SectionType&gt;_END </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Example </b></p>
<p>OS_MyAppl_VAR_FAST_START </p>
<p>OS_ MyAppl_VAR_FAST_END </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.4 </b></p>
<p><b>Static Code Analysis </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>When running tools for static code analysis (e.g. MISRA, MSSV), the pre-processor </p>
<p>definition OS_STATIC_CODE_ANALYSIS has to be set during analysis. It switches off </p>
<p>compiler specific keywords and inline assembler parts. Typically code analysis tools </p>
<p>cannot deal with such code parts. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>140 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.5 </b></p>
<p><b>Configuration of X-Signals </b></p>
<p>This chapter describes how X-Signals are configured for cross core API calls. </p>
<p>1. </p>
<p>Add an “OsCoreXSignalChannel” to an “OsCore” object. This core will be the sender of </p>
<p>the X-Signal. </p>
<p>2. </p>
<p>Specify the queue size of the channel with the “OsCoreXSignalChannelSize” attribute. </p>
<p>3. </p>
<p>Add an X-Signal receiver ISR. It must be of category 2. </p>
<p>4. </p>
<p>Assign this ISR to be the X-Signal receiver </p>
<p>“OsCore/OsCoreXSignalChannelReceiverIsr”. </p>
<p>5. </p>
<p>Configure an appropriate interrupt priority for the receiver ISR (see the following </p>
<p>chapters for details on your used platform). The configured priority must follow the </p>
<p>rules listed in Table 3-3. </p>
<p>6. </p>
<p>Choose an appropriate interrupt source for the receiver ISR (see the following </p>
<p>chapters for details on your used platform). </p>
<p>7. </p>
<p>Add the &quot;OsIsrXSignalReceiver&quot; to the receiver ISR and select the provided APIs </p>
<p>(callable from the sender core) with the &quot;OsIsrXSignalReceiverProvidedApis&quot; attribute. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The DaVinci Configurator provides solving actions which support the correct </p>
<p>configuration of X-signals. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>4.5.1 </b></p>
<p><b>TriCore Aurix Family </b></p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a low </p>
<p>logical priority </p>
<p><b>X-Signal ISR Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority </p>
<p>can be chosen freely. </p>
<p><b>X-Signal ISR Interrupt Source </b></p>
<p>Any interrupt source, which is not used by other modules, may </p>
<p>be used for the X-Signal ISR. </p>
<p>The offset of the SRC register of the used interrupt source has </p>
<p>to be specified for OsIsrInterruptSource. </p>
<p> </p>
<p><b>4.5.2 </b></p>
<p><b>RH850 Family </b></p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a high </p>
<p>logical priority </p>
<p><b>X-Signal ISR Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority </p>
<p>can be chosen freely. </p>
<p><b>X-Signal ISR Interrupt Source </b></p>
<p>Only interrupt source 0 is possible. </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>141 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.5.3 </b></p>
<p><b>Power PC Family </b></p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a low </p>
<p>logical priority </p>
<p><b>X-Signal ISR Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority </p>
<p>can be chosen freely. </p>
<p><b>X-Signal ISR Interrupt Source </b></p>
<p>Any Interrupt source of the available software interrupts may </p>
<p>be used. </p>
<p> </p>
<p><b>4.5.4 </b></p>
<p><b>ARM Family </b></p>
<p><b> </b></p>
<p>NVIC Interrupt Controller </p>
<p>GIC Interrupt Controller </p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a high logical priority </p>
<p><b>X-Signal ISR </b></p>
<p><b>Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority can be chosen </p>
<p>freely. </p>
<p><b>X-Signal ISR </b></p>
<p><b>Interrupt Source </b></p>
<p>Any interrupt source, which is not </p>
<p>used by other modules, may be used </p>
<p>for the X-Signal ISR. </p>
<p>The interrupt sources 0..15 have to be </p>
<p>used for the X-Signal ISR. </p>
<p> </p>
<p><b>4.5.5 </b></p>
<p><b>VTT OS </b></p>
<p><b>Logical Priority </b></p>
<p>A low number for OsIsrInterruptPriority attribute means a low </p>
<p>logical priority </p>
<p><b>X-Signal ISR Interrupt Priority </b></p>
<p>Beside the rules listed in Table 3-3 the OsIsrInterruptPriority </p>
<p>can be chosen freely. </p>
<p><b>X-Signal ISR Interrupt Source </b></p>
<p>Any interrupt source, which is not used by other modules, may </p>
<p>be used for the X-Signal ISR. </p>
<p> </p>
<p><b>4.6 </b></p>
<p><b>OS generated objects </b></p>
<p>In  dependency  of  its  configuration  MICROSAR  OS  may  add  other  OS  configuration </p>
<p>objects to it. </p>
<p><b>4.6.1 </b></p>
<p><b>System Application </b></p>
<p><b>Type </b></p>
<p>OsApplication </p>
<p><b>Name </b></p>
<p>SystemApplication_&lt;Core Id&gt; </p>
<p><b>Condition </b></p>
<p>Is added when the core &lt;Core Id&gt; is configured to be an AUTOSAR </p>
<p>core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>A system application contains the OS objects </p>
<p><b>&gt; </b></p>
<p>Idle Task_&lt;Core Id&gt; </p>
<p><b>&gt; </b></p>
<p>TpCounter_&lt;Core Id&gt; </p>
<p><b>&gt; </b></p>
<p>XSignalIsr_&lt;Core Id&gt; </p>
<p><b>&gt; </b></p>
<p>CounterIsr_TpCounter_&lt;Core Id&gt; </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>142 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.6.2 </b></p>
<p><b>Idle Task </b></p>
<p><b>Type </b></p>
<p>OsTask </p>
<p><b>Name </b></p>
<p>IdleTask_&lt;Core Id&gt; </p>
<p><b>Condition </b></p>
<p>Is added when the core &lt;Core Id&gt; is configured to be an AUTOSAR </p>
<p>core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Has the lowest priority of all tasks assigned to the same core. </p>
<p><b>&gt; </b></p>
<p>Is fully preemptive. </p>
<p><b>&gt; </b></p>
<p>Is implemented by the OS </p>
<p> </p>
<p><b>4.6.3 </b></p>
<p><b>Timer ISR </b></p>
<p><b>Type </b></p>
<p>OsIsr </p>
<p><b>Name </b></p>
<p>CounterIsr_&lt;Core Id&gt; </p>
<p><b>Condition </b></p>
<p>Is added if a hardware counter is configured to have a driver (attribute </p>
<p>“OsCounterDriver”). </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Is Implemented by the OS. </p>
<p><b>&gt; </b></p>
<p>Handles the system timer counter, alarms and scheduletables </p>
<p>which are assigned to the core. </p>
<p> </p>
<p><b>4.6.4 </b></p>
<p><b>System Timer Counter </b></p>
<p><b>Type </b></p>
<p>OsCounter </p>
<p><b>Name </b></p>
<p>SystemTimer </p>
<p><b>Condition </b></p>
<p>Is added optionally within the recommended configuration. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Is used for OSEK backward compatibility </p>
<p> </p>
<p><b>4.6.5 </b></p>
<p><b>Timing Protection Counter </b></p>
<p><b>Type </b></p>
<p>OsCounter </p>
<p><b>Name </b></p>
<p>TpCounter_&lt;Core Id&gt; </p>
<p><b>Condition </b></p>
<p>Is added when OsTask/IsrTimingProtection parameters are configured </p>
<p>on the core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Handles all times related to timing protection </p>
<p> </p>
<p><b>4.6.6 </b></p>
<p><b>Timing protection ISR </b></p>
<p><b>Type </b></p>
<p>OsIsr </p>
<p><b>Name </b></p>
<p>CounterIsr_TpCounter_&lt;Core Id&gt; </p>
<p><b>Condition </b></p>
<p>Is added when OsTask/IsrTimingProtection parameters are configured </p>
<p>on the core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Interrupt service routine of the timing protection feature </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>143 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.6.7 </b></p>
<p><b>Resource Scheduler </b></p>
<p><b>Type </b></p>
<p>OsResource </p>
<p><b>Name </b></p>
<p>RES_SCHEDULER_&lt;Core Id&gt; </p>
<p><b>Condition </b></p>
<p>For each core the resource scheduler is added when </p>
<p>OsUseResScheduler is set to TRUE. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Is automatically assigned to all tasks of core &lt;Core Id&gt;. </p>
<p> </p>
<p><b>4.6.8 </b></p>
<p><b>X Signal ISR </b></p>
<p><b>Type </b></p>
<p>OsIsr </p>
<p><b>Name </b></p>
<p>XSignalIsr_&lt;Core Id&gt; </p>
<p><b>Condition </b></p>
<p>Is added when an X signal channel is configured on the core. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Handles cross core requests. </p>
<p> </p>
<p><b>4.6.9 </b></p>
<p><b>IOC Spinlocks </b></p>
<p><b>Type </b></p>
<p>OsSpinlock </p>
<p><b>Name </b></p>
<p>IocSpinlock_&lt;IOC Name&gt; </p>
<p><b>Condition </b></p>
<p>Is added when an IOC is configured which requires cross core </p>
<p>communication. </p>
<p><b>Features </b></p>
<p><b>&gt; </b></p>
<p>Each IOC has its own spinlock to reduce core wait times </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>144 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.7 </b></p>
<p><b>VTT OS Specifics </b></p>
<p><b>4.7.1 </b></p>
<p><b>Configuration </b></p>
<p>As described in [6] all VTT configuration parameters are derived from the hardware target. </p>
<p>The only exceptions are the ISR objects for the VTT OS. </p>
<p></p>
<p>  ISRs </p>
<p>from </p>
<p>other </p>
<p>Vector </p>
<p>MICROSAR </p>
<p>BSW </p>
<p>modules </p>
<p>(e.g. </p>
<p>CAN) </p>
<p>are </p>
<p>inserted </p>
<p>automatically by the respective BSW module. </p>
<p></p>
<p>  Other user ISRs have to be added separately. </p>
<p></p>
<p>  Interrupt levels for all ISRs have to be configured manually. VTT OS knows interrupt </p>
<p>levels from 1 to 200 (where 1 is the lowest priority and 200 the highest). </p>
<p><b>4.7.2 </b></p>
<p><b>CANoe Interface </b></p>
<p>A  VTT  OS  is  simulated  within  the  CANoe  simulation  software.  There  are  a  set  of  API </p>
<p>functions which are capable to communicate with CANoe (e.g. sending a message on the </p>
<p>CAN bus). </p>
<p>These API functions are prefixed with “CANoeAPI_”. </p>
<p>The available set of API functions can be looked up in the delivered header “CANoeApi.h”. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>145 </p>
<p>based on template version 6.0.1 </p>
<p><b>4.8 </b></p>
<p><b>User include files </b></p>
<p>Within some features of MICROSAR OS it may be necessary to provide foreign data types </p>
<p>to the OS. </p>
<p>This can be done by referencing user headers within the OS configuration. </p>
<p>The  features  “IOC”  and  “trusted  functions  stub  generation”  are  relying  on  such  include </p>
<p>mechanisms. </p>
<p> </p>
<p><b> </b></p>
<p><b>Configuration </b></p>
<p><b>Content </b></p>
<p><b>IOC </b></p>
<p>IOC include files are configured with </p>
<p>the IOC attribute </p>
<p>&quot;OsIocIncludeHeader“. </p>
<p>A list of include files may be specified </p>
<p>here. </p>
<p>The headers have to provide </p>
<p><b>&gt; </b></p>
<p>Definitions of foreign OS data </p>
<p>types which are used within IOC </p>
<p>communication. </p>
<p><b>Trusted </b></p>
<p><b>Functions </b></p>
<p>Include files which are needed for </p>
<p>trusted function feature are configured </p>
<p>within the application attribute </p>
<p>“OsAppCalloutStubsIncludeHeader”. </p>
<p>A list of include files may be specified </p>
<p>here. </p>
<p>The headers have to provide </p>
<p><b>&gt; </b></p>
<p>The definitions of foreign OS data </p>
<p>types which are used as trusted </p>
<p>functions parameters or return </p>
<p>values. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>All user include files need to implement a double inclusion preventer! </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>146 </p>
<p>based on template version 6.0.1 </p>
<p><b>5 </b></p>
<p><b>API Description </b></p>
<p>This chapter lists all API service functions which are additionally provided by MICROSAR </p>
<p>OS. AUTOSAR OS API service functions are not listed here. They can be looked up in [1] </p>
<p>and [2]. </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>147 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.1 </b></p>
<p><b>Peripheral Access API </b></p>
<p>The  API  consists  of  read,  write  and  bit  manipulating  functions  for  8,  16  and  32  bit </p>
<p>accesses. </p>
<p><b>5.1.1 </b></p>
<p><b>Read Functions </b></p>
<p><b>Prototype </b></p>
<p>FUNC(uint8, OS_CODE) Os_ReadPeripheral8( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  uint32 Address </p>
<p>) </p>
<p>FUNC(uint16, OS_CODE) Os_ReadPeripheral16( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  uint32 Address </p>
<p>) </p>
<p>FUNC(uint32, OS_CODE) Os_ReadPeripheral32( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  uint32 Address </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>PeripheralID </p>
<p>The ID of a configured peripheral region. </p>
<p>The symbolic name may be passed here. </p>
<p>Address </p>
<p>The address of the peripheral register which shall be read. </p>
<p><b>Return code </b></p>
<p>uint8 </p>
<p>The content of the peripheral register which has been passed in the Address </p>
<p>parameter. </p>
<p>uint16 </p>
<p>uint32 </p>
<p><b>Functional Description </b></p>
<p>The function distinguishes the address range of the passed peripheral region. It checks whether the </p>
<p>parameter “Address” is within this range. Then it checks whether the calling OS application has access </p>
<p>rights to the passed peripheral region. </p>
<p>If all checks did pass the API returns the content of the passed address </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>If one of the performed checks within the API is not passed the OS treats it as a memory protection </p>
<p>violation. The ProtectionHook() is called. </p>
<p>&gt; </p>
<p>The data alignment of the “Address” parameter is not checked by the service function. Misaligned </p>
<p>accesses may lead to exceptions. </p>
<p>Table 5-1  </p>
<p>Read Peripheral API </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>148 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The former names of the API functions osReadPeripheral8(), osReadPeripheral16() </p>
<p>and osReadPeripheral32() may also be used (the OS is backward compatible). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>149 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.1.2 </b></p>
<p><b>Write Functions </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_WritePeripheral8( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  uint32 Address, </p>
<p>  uint8 Value </p>
<p>) </p>
<p>FUNC(void, OS_CODE) Os_WritePeripheral16( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  uint32 Address, </p>
<p>  uint16 Value </p>
<p>) </p>
<p>FUNC(void, OS_CODE) Os_WritePeripheral32( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  uint32 Address, </p>
<p>  uint32 Value </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>PeripheralID </p>
<p>The ID of a configured peripheral region. </p>
<p>The symbolic name may be passed here. </p>
<p>Address </p>
<p>The address of the peripheral register which shall be written. </p>
<p>Value uint8 </p>
<p>Value which shall be written to the peripheral register. </p>
<p>Value uint16 </p>
<p>Value uint32 </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The function distinguishes the address range of the passed peripheral region. It checks whether the </p>
<p>parameter “Address” is within this range. Then it checks whether the calling OS application has access </p>
<p>rights to the passed peripheral region. </p>
<p>If all checks did pass the OS writes the Value into the peripheral register. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>If one of the performed checks within the API is not passed the OS treats it as a memory protection </p>
<p>violation. The ProtectionHook() is called. </p>
<p>&gt; </p>
<p>The data alignment of the “Address” parameter is not checked by the service function. Misaligned </p>
<p>accesses may lead to exceptions. </p>
<p>Table 5-2  </p>
<p>Write Peripheral APIs </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>150 </p>
<p>based on template version 6.0.1 </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The former names of the API functions osWritePeripheral8(), osWritePeripheral16() </p>
<p>and osWritePeripheral32() may also be used (the OS is backward compatible). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>151 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.1.3 </b></p>
<p><b>Bitmask Functions </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_ModifyPeripheral8( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  uint32 Address, </p>
<p>  uint8 ClearMask, </p>
<p>  uint8 SetMask </p>
<p>) </p>
<p>FUNC(void, OS_CODE) Os_ModifyPeripheral16( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  uint32 Address, </p>
<p>  uint16 ClearMask, </p>
<p>  uint16 SetMask </p>
<p>) </p>
<p>FUNC(void, OS_CODE) Os_ModifyPeripheral32( </p>
<p>  Os_PeripheralIdType PeripheralID, </p>
<p>  uint32 Address, </p>
<p>  uint32 ClearMask, </p>
<p>  uint32 SetMask </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>PeripheralID </p>
<p>The ID of a configured peripheral region. </p>
<p>The symbolic name may be passed here. </p>
<p>Address </p>
<p>The address of the peripheral register which shall be modified. </p>
<p>ClearMask uint8 </p>
<p>The mask for the AND operation. </p>
<p>ClearMask uint16 </p>
<p>ClearMask uint32 </p>
<p>SetMask uint8 </p>
<p>The mask for the OR operation. </p>
<p>SetMask uint16 </p>
<p>SetMask uint32 </p>
<p><b>Return code </b></p>
<p>void </p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The function distinguishes the address range of the passed peripheral region. It checks whether the </p>
<p>parameter “Address” is within this range. Then it checks whether the calling OS application has access </p>
<p>rights to the passed peripheral region. </p>
<p>If all checks did pass the OS performs the following operation: </p>
<p>Address = (Address &amp; ClearMask) | SetMask; </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>152 </p>
<p>based on template version 6.0.1 </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>If one of the performed checks within the API is not passed the OS treats it as a memory protection </p>
<p>violation. The ProtectionHook() is called. </p>
<p>&gt; </p>
<p>The data alignment of the “Address” parameter is not checked by the service function. Misaligned </p>
<p>accesses may lead to exceptions. </p>
<p>Table 5-3  </p>
<p>Bitmask Peripheral API </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The former names of the API functions osModifyPeripheral8(), osModifyPeripheral16() </p>
<p>and osModifyPeripheral32() may also be used (the OS is backward compatible). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>153 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.2 </b></p>
<p><b>Pre-Start Task </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_EnterPreStartTask(void) </p>
<p><b>Parameter </b></p>
<p>none </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The function schedules and dispatches to the pre-start task. The core is initialized that non-trusted function </p>
<p>calls can be used safely within this task. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Has to be called on a core which is started as an AUTOSAR core. </p>
<p>&gt; </p>
<p>The core which calls this function must have a configured pre-start task. </p>
<p>&gt; </p>
<p>Must only be called once. </p>
<p>&gt; </p>
<p>Must be called prior to </p>
<p>StartOS()</p>
<p> but after </p>
<p>Os_Init()</p>
<p>  </p>
<p>Table 5-4  </p>
<p>API Service Os_EnterPreStartTask </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>154 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.3 </b></p>
<p><b>Non-Trusted Functions (NTF) </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_CallNonTrustedFunction( </p>
<p>  Os_NonTrustedFunctionIndexType FunctionIndex, </p>
<p>  Os_NonTrustedFunctionParameterRefType FunctionParams </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>FunctionIndex </p>
<p>The Index of the non-trusted function. </p>
<p>FunctionParams </p>
<p>Pointer to parameters which are passed to the non-trusted function. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_SERVICEID </p>
<p>No function defined for this index. </p>
<p>E_OS_CALLEVEL  </p>
<p>Called from invalid context. (EXTENDED status) </p>
<p>E_OS_ACCESS  </p>
<p>The given object belongs to a foreign core. (EXTENDED status) </p>
<p>E_OS_ACCESS  </p>
<p>Owner OS application is not accessible. (Service Protection) </p>
<p>E_OS_SYS_NO_NTFSTACK  </p>
<p>No further NTF-Stacks available. (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>Performs a call to the non-trusted function passed in „</p>
<p>FunctionIndex</p>
<p>“. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The non-trusted function will not be able to return any values. It has no access rights to the data </p>
<p>structure of the caller referenced by the “</p>
<p>FunctionParams</p>
<p>” parameter. </p>
<p>&gt; </p>
<p>This API service may be called with disabled interrupts. </p>
<p>Table 5-5  </p>
<p>Call Non-Trusted Function API </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>155 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.4 </b></p>
<p><b>Interrupt Source API </b></p>
<p><b>5.4.1 </b></p>
<p><b>Disable Interrupt Source </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_DisableInterruptSource( </p>
<p>  ISRType ISRID </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier (EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Wrong call context of the API function (EXTENDED status) </p>
<p>E_OS_ACCESS </p>
<p>The calling application is not the owner of the ISR passed in ISRID (Service </p>
<p>Protection) </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS disables the interrupt source by modifying the interrupt controller registers. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only. </p>
<p>Table 5-6  </p>
<p>API Service Os_DisableInterruptSource </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Depending on target platform (e.g. ARM platforms), the ISR may still become active </p>
<p>although Os_DisableInterruptSource has returned E_OK. </p>
<p>This may be caused by hardware racing conditions e.g. when the interrupt is requested </p>
<p>immediately before the effect of Os_DisableInterruptSource becomes active. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>156 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.4.2 </b></p>
<p><b>Enable Interrupt Source </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_EnableInterruptSource( </p>
<p>  ISRType ISRID, </p>
<p>  boolean ClearPending </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p>ClearPending </p>
<p>Defines whether the pending flag shall be cleared (TRUE) or not (FALSE). </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier ID (EXTENDED status) </p>
<p>E_OS_CALLEVEL  </p>
<p>Wrong call context of the API function (EXTENDED status) </p>
<p>E_OS_VALUE  </p>
<p>The parameter “ClearPending” is not a boolean value (EXTENDED status) </p>
<p>E_OS_ACCESS  </p>
<p>The calling application is not the owner of the ISR passed in ISRID (Service </p>
<p>Protection) </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS enables the interrupt source by modifying the interrupt controller registers. Additionally it </p>
<p>may clear the interrupt pending flag </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only </p>
<p>Table 5-7  </p>
<p>API Service Os_EnableInterruptSource </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>157 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.4.3 </b></p>
<p><b>Clear Pending Interrupt </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_ClearPendingInterrupt( </p>
<p>  ISRType ISRID </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No errors </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier (EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Wrong call context of the API function (EXTENDED status) </p>
<p>E_OS_ACCESS </p>
<p>The calling application is not the owner of the ISR passed in ISRID (Service </p>
<p>Protection) </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS clears the interrupt pending flag by modifying the interrupt controller registers. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only </p>
<p>Table 5-8  </p>
<p>API Service Os_ClearPendingInterrupt </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>In order to minimize the risk of spurious interrupts, Os_ClearPendingInterrupt shall be </p>
<p>called only after the ISR (IsrId) has been disabled and before it is enabled again. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The API service tries to clear the pending flag only. The interrupt cause has to be reset </p>
<p>by the application software. Otherwise the flag may be set again immediately after it </p>
<p>has been cleared by the API. This may be the case e.g. with level triggered ISRs. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>158 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.4.4 </b></p>
<p><b>Check Interrupt Source Enabled </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_IsInterruptSourceEnabled( </p>
<p>  ISRType ISRID, </p>
<p>  P2VAR(boolean, AUTOMATIC, OS_VAR_NOINIT) IsEnabled </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p>IsEnabled </p>
<p>Defines wether the source of the ISR is enabled (TRUE) or not (FALSE) </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No errors </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier (EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Wrong call context of the API function (EXTENDED status) </p>
<p>E_OS_ACCESS </p>
<p>The calling application is not the owner of the ISR passed in ISRID (Service </p>
<p>Protection) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Given pointer parameter (isEnabled) is NULL (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS checks if the interrupt source is enabled reading the interrupt controller registers and </p>
<p>update the boolean addressed by IsEnabled accordingly </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only </p>
<p>Table 5-9  </p>
<p>API Service Os_IsInterruptSourceEnabled </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>159 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.4.5 </b></p>
<p><b>Check Interrupt Pending </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_IsInterruptPending( </p>
<p>  ISRType ISRID, </p>
<p>  P2VAR(boolean, AUTOMATIC, OS_VAR_NOINIT) IsPending </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>The ID of a category 2 ISR. </p>
<p>IsPending </p>
<p>Defines wether the ISR has been already </p>
<p>requesterd (TRUE) or not (FALSE) </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No errors </p>
<p>E_OS_ID </p>
<p>ISRID is not a valid category 2 ISR identifier </p>
<p>(EXTENDED status) </p>
<p>E_OS_CALLEVEL </p>
<p>Wrong call context of the API function </p>
<p>(EXTENDED status) </p>
<p>E_OS_ACCESS </p>
<p>The calling application is not the owner of the </p>
<p>ISR passed in ISRID (Service Protection) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Given pointer parameter (isPending) is NULL </p>
<p>(EXTENDED status) </p>
<p>E_OS_SYS_UNIMPLEMENTED_FUNCTIONALITY </p>
<p>Hardware does not support to check if there are </p>
<p>pending interrupts </p>
<p><b>Functional Description </b></p>
<p>MICROSAR OS checks if the ISR has been already requested,  reading the interrupt controller registers </p>
<p>and update the boolean addressed by IsPending accordingly </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>May be called for category 2 ISRs only </p>
<p>Table 5-10  </p>
<p>API Service Os_IsInterruptPending </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>160 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.5 </b></p>
<p><b>Detailed Error API </b></p>
<p><b>5.5.1 </b></p>
<p><b>Get detailed Error </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_GetDetailedError( </p>
<p>  Os_ErrorInformationRefType ErrorRef </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ErrorRef </p>
<p>Output parameter of type Os_ErrorInformationRefType </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_CALLEVEL </p>
<p>Called from invalid context. (EXTENDED status) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Given parameter pointer is NULL. (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>Returns error information of the last error occurred on the local core. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The ErrorRef output parameter is a struct which holds the 8 bit AUTOSAR error code, the detailed error </p>
<p>code and the service ID of the causing API service. </p>
<p>Table 5-11  </p>
<p>API Service Os_GetDetailedError </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>161 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.5.2 </b></p>
<p><b>Unhandled Interrupt Requests </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_GetUnhandledIrq( </p>
<p>  Os_InterruptSourceIdRefType InterruptSource </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>InterruptSource </p>
<p>Output parameter of type Os_InterruptSourceIdRefType </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_CORE </p>
<p>Called from a non-AUTOSAR core (EXTENDED status) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Null pointer passed as argument (EXTENDED status) </p>
<p>E_OS_STATE </p>
<p>No unhandled interrupt reported since start up (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>In case of an unhandled interrupt request the triggering interrupt source can be distinguished with this </p>
<p>service. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The return value of this function may be interpreted differently for different controller families. </p>
<p>Table 5-12  </p>
<p>API Service Os_GetUnhandledIrq </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>162 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.5.3 </b></p>
<p><b>Unhandled Exception Requests </b></p>
<p><b>Prototype </b></p>
<p>FUNC(StatusType, OS_CODE) Os_GetUnhandledExc( </p>
<p>  Os_ExceptionSourceIdRefType ExceptionSource </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ExceptionSource </p>
<p>Output parameter of type Os_ExceptionSourceIdRefType </p>
<p><b>Return code </b></p>
<p>E_OK </p>
<p>No error. </p>
<p>E_OS_CORE </p>
<p>Called from a non-AUTOSAR core (EXTENDED status) </p>
<p>E_OS_PARAM_POINTER </p>
<p>Null pointer passed as argument (EXTENDED status) </p>
<p>E_OS_STATE </p>
<p>No unhandled exception reported since start up. (EXTENDED status) </p>
<p><b>Functional Description </b></p>
<p>In case of an unhandled exception request the triggering exception source can be distinguished with this </p>
<p>service. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The return value of this function may be interpreted differently for different controller families. </p>
<p>Table 5-13  </p>
<p>API Service Os_GetUnhandledExc </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>163 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.6 </b></p>
<p><b>Stack Usage API </b></p>
<p>All Service API functions which calculate stack usage are working in the same way. </p>
<p><b>&gt; </b></p>
<p>The service performs error checks: </p>
<p><b>&gt; </b></p>
<p>validity of passed parameters </p>
<p><b>&gt; </b></p>
<p>existence of OS Hook routine (if hook stacks are queried) </p>
<p><b>&gt; </b></p>
<p>cross core checks (when stack sizes are queried of stacks which are located on a </p>
<p>foreign core) </p>
<p><b>&gt; </b></p>
<p>if one of these checks fails, the OS initiates error handling (ErrorHook() is called) </p>
<p><b>&gt; </b></p>
<p>Calculates the maximum stack usage of the queried stack since call of StartOS() </p>
<p><b>&gt; </b></p>
<p>Returns the stack usage in bytes </p>
<p><b>&gt; </b></p>
<p>Stack Usage API services may be called from any context </p>
<p><b>&gt; </b></p>
<p>Stack Usage API services may be used cross core </p>
<p><b>Stack usage service API Prototypes </b></p>
<p>Parameter </p>
<p>FUNC(uint32, OS_CODE) Os_GetTaskStackUsage (TaskType TaskID) </p>
<p>Task ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetISRStackUsage (ISRType IsrID) </p>
<p>ISR ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetKernelStackUsage (CoreIdType CoreID) </p>
<p>Core ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetStartupHookStackUsage(CoreIdType CoreID) </p>
<p>Core ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetErrorHookStackUsage (CoreIdType CoreID) </p>
<p>Core ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetShutdownHookStackUsage(CoreIdType CoreID) </p>
<p>Core ID </p>
<p>FUNC(uint32, OS_CODE) Os_GetProtectionHookStackUsage(CoreIdType CoreID) </p>
<p>Core ID </p>
<p>Table 5-14  </p>
<p>Overview: Stack Usage Functions </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Any stack usage function must not be used cross core with interrupts disabled. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>164 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.7 </b></p>
<p><b>RTE Interrupt API </b></p>
<p>MICROSAR OS provides optimized interrupt en-/disable functions for exclusive usage for </p>
<p>the RTE module of Vector. </p>
<p> </p>
<p><b>API Name </b></p>
<p><b>Alias (for backward compatibility) </b></p>
<p>Os_DisableLevelAM() </p>
<p>osDisableLevelAM() </p>
<p>Os_DisableLevelKM() </p>
<p>osDisableLevelKM() </p>
<p>Os_DisableLevelUM() </p>
<p>osDisableLevelUM() </p>
<p>Os_EnableLevelAM() </p>
<p>osEnableLevelAM() </p>
<p>Os_EnableLevelKM() </p>
<p>osEnableLevelKM() </p>
<p>Os_EnableLevelUM() </p>
<p>osEnableLevelUM() </p>
<p>Os_DisableGlobalAM() </p>
<p>osDisableGlobalAM() </p>
<p>Os_DisableGlobalKM() </p>
<p>osDisableGlobalKM() </p>
<p>Os_DisableGlobalUM() </p>
<p>osDisableGlobalUM() </p>
<p>Os_EnableGlobalAM() </p>
<p>osEnableGlobalAM() </p>
<p>Os_EnableGlobalKM() </p>
<p>osEnableGlobalKM() </p>
<p>Os_EnableGlobalUM() </p>
<p>osEnableGlobalUM() </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>RTE interrupt handling functions should not be used by the application and are listed </p>
<p>here to avoid naming collisions. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>165 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.8 </b></p>
<p><b>Time Conversion Macros </b></p>
<p>Based  on  counter  configuration  attributes  conversion  macros  are  generated  which  are </p>
<p>capable to convert from time into counter ticks and vice versa. </p>
<p>There are a set of conversion macros for each configured OS counter </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>The conversion macros embody multiplication operations which may lead to a data </p>
<p>type overflow. The macros are not capable to detect these overflows </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>Caution </b></p>
<p>Although the results of the macros are mathematically rounded the result will still be an </p>
<p>integer (e.g. results smaller than 0.5 are used as 0). </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>5.8.1 </b></p>
<p><b>Convert from Time into Counter Ticks </b></p>
<p><b>OS_NS2TICKS_&lt;Counter Name&gt;(x) </b></p>
<p>x is given in nanoseconds </p>
<p><b>OS_US2TICKS_&lt;Counter Name&gt;(x) </b></p>
<p>x is given in microseconds </p>
<p><b>OS_MS2TICKS_&lt;Counter Name&gt;(x) </b></p>
<p>x is given in milliseconds </p>
<p><b>OS_SEC2TICKS_&lt;Counter Name&gt;(x) </b></p>
<p>x is given in seconds </p>
<p>Table 5-15  </p>
<p>Conversion Macros from Time to Counter Ticks </p>
<p><b>5.8.2 </b></p>
<p><b>Convert from Counter Ticks into Time </b></p>
<p><b>OS_TICKS2NS_&lt;Counter Name&gt;(x) </b></p>
<p>The result is in nanoseconds </p>
<p><b>OS_TICKS2US_&lt;Counter Name&gt;(x) </b></p>
<p>The result is in microseconds </p>
<p><b>OS_TICKS2MS_&lt;Counter Name&gt;(x) </b></p>
<p>The result is in milliseconds </p>
<p><b>OS_TICKS2SEC_&lt;Counter Name&gt;(x) </b></p>
<p>The result is in seconds </p>
<p>Table 5-16  </p>
<p>Conversion Macros from Counter Ticks to Time </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>166 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.9 </b></p>
<p><b>Access Check API </b></p>
<p><b>5.9.1 </b></p>
<p><b>Check ISR Memory Access </b></p>
<p><b>Prototype </b></p>
<p>FUNC(AccessType, OS_CODE) CheckISRMemoryAccess( </p>
<p>  ISRType ISRID, </p>
<p>  MemoryStartAddressType Address, </p>
<p>  MemorySizeType Size </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>ISRID </p>
<p>ID of category 2 ISR </p>
<p>Address </p>
<p>Start address of checked address range </p>
<p>Size </p>
<p>Size of checked address range </p>
<p><b>Return code </b></p>
<p>AccessType </p>
<p>Returns the access rights of the ISR to the given address range </p>
<p><b>Functional Description </b></p>
<p>The service distinguishes the memory access rights of a given category 2 ISR </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The access checks are based upon the “OsAccessCheckRegion” configuration objects. </p>
<p>&gt; </p>
<p>The return value of this functions is typically used with the AUTOSAR OS specified macros </p>
<p>&gt; </p>
<p>OSMEMORY_IS_READABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_WRITEABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_EXECUTABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_STACKSPACE </p>
<p>Table 5-17  </p>
<p>API Service CheckISRMemoryAccess </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>167 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.9.2 </b></p>
<p><b>Check Task Memory Access </b></p>
<p><b>Prototype </b></p>
<p>FUNC(AccessType, OS_CODE) CheckTaskMemoryAccess( </p>
<p>  TaskType TaskID, </p>
<p>  MemoryStartAddressType Address, </p>
<p>  MemorySizeType Size </p>
<p>) </p>
<p><b>Parameter </b></p>
<p>TaskID </p>
<p>ID of task </p>
<p>Address </p>
<p>Start address of checked address range </p>
<p>Size </p>
<p>Size of checked address range </p>
<p><b>Return code </b></p>
<p>AccessType </p>
<p>Returns the access rights of the Task to the given address range </p>
<p><b>Functional Description </b></p>
<p>The service distinguishes the memory access rights of a given Task. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The access checks are based upon the “OsAccessCheckRegion” configuration objects. </p>
<p>&gt; </p>
<p>The return value of this functions is typically used with the AUTOSAR OS specified macros </p>
<p>&gt; </p>
<p>OSMEMORY_IS_READABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_WRITEABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_EXECUTABLE </p>
<p>&gt; </p>
<p>OSMEMORY_IS_STACKSPACE </p>
<p>Table 5-18  </p>
<p>API Service CheckTaskMemoryAccess </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>168 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.10 </b></p>
<p><b>OS Initialization </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_Init(void) </p>
<p><b>Parameter </b></p>
<p>none </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The function performs all the basic OS initialization which includes </p>
<p>&gt; </p>
<p>Variable initialization </p>
<p>&gt; </p>
<p>Interrupt controller initialization </p>
<p>&gt; </p>
<p>System MPU initialization in SC3 and SC4 systems (if supported by platform) </p>
<p>&gt; </p>
<p>Synchronization barriers in multi core systems </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>A function call to this service must be available on all available cores (even for cores which are intended </p>
<p>to be a non-AUTOSAR core) </p>
<p>&gt; </p>
<p>After call of </p>
<p>Os_Init()</p>
<p> the AUTOSAR interrupt API may be used. </p>
<p>&gt; </p>
<p>After Call of </p>
<p>Os_Init() </p>
<p>the API GetCoreID may be used. </p>
<p>Table 5-19  </p>
<p>API Service Os_Init </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>169 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_CODE) Os_InitMemory(void) </p>
<p><b>Parameter </b></p>
<p>none </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>&gt; </p>
<p>This is an API function which is provided within all BSWs of Vector. It initializes variables of the BSW. </p>
<p>Within the OS module this function is currently empty </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>This service must be called on all available cores (even for cores which are intended to be a non-</p>
<p>AUTOSAR core) </p>
<p>Table 5-20  </p>
<p>API Service Os_InitMemory </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>170 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.11 </b></p>
<p><b>Timing Hooks </b></p>
<p>Implementation of all timing hooks must conform to the following guidelines: </p>
<p><b>&gt; </b></p>
<p>They are expected to be implemented as a macro. </p>
<p><b>&gt; </b></p>
<p>Reentrancy is possible on multicore systems with different caller core IDs. </p>
<p><b>&gt; </b></p>
<p>Calls of any operating system API functions are prohibited within the hooks. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>All hooks are called from within an OS API service. Interrupts are disabled </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>5.11.1 </b></p>
<p><b>Timing Hooks for Activation </b></p>
<p><b>5.11.1.1 </b></p>
<p><b>Task Activation </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_ACTIVATION(TaskId, DestCoreId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>TaskId </p>
<p>Identifier of the task which is activated </p>
<p>DestCoreId </p>
<p>Identifier of the core on which the task is activated </p>
<p>CallerCoreId </p>
<p>Identifier of the core which performs the activation (has called ActivateTask(), has </p>
<p>called TerminateTask() or has performed an alarm/schedule table action to activate </p>
<p>a task) </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This hook is called on the caller core when that core has successfully performed the activation of TaskId on </p>
<p>the destination core. On single core systems both core IDs are identical. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>none </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>171 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.11.1.2 </b></p>
<p><b>Set Event </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_SETEVENT(TaskId, EventMask, StateChanged, </p>
<p>DestCoreId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>TaskId </p>
<p>Identifier of the task which receives this event </p>
<p>EventMask </p>
<p>A bit mask with the events which shall be set </p>
<p>StateChanged </p>
<p>TRUE: The task state has changed from WAITING to READY  </p>
<p>FALSE: The task state hasn’t changed </p>
<p>DestCoreId </p>
<p>Identifier of the core on which the task receives the event </p>
<p>CallerCoreId </p>
<p>Identifier of the core which performs the event setting (has called SetEvent() or </p>
<p>performed an alarm/schedule table action to set an event) </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This hook is called on the caller core when that core has successfully performed the event setting on the </p>
<p>destination core. On single core systems both core IDs are always identical. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>none </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>172 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.11.2 </b></p>
<p><b>Timing Hook for Context Switch </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_SCHEDULE(FromThreadId, FromThreadReason, </p>
<p>ToThreadId, ToThreadReason, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>FromThreadId </p>
<p>Identifier of the thread (task, ISR) which has run on the caller core before the </p>
<p>switch took place </p>
<p>FromThreadReason </p>
<p>OS_VTHP_TASK_TERMINATION </p>
<p>&gt; </p>
<p>The thread is a task, which has just been terminated. </p>
<p>OS_VTHP_ISR_END </p>
<p>&gt; </p>
<p>The thread is an ISR, which has reached its end. </p>
<p>OS_VTHP_TASK_WAITEVENT </p>
<p>&gt; </p>
<p>The thread is a task, which waits for an event. </p>
<p>OS_VTHP_TASK_WAITSEMA </p>
<p>&gt; </p>
<p>The thread is a task, which waits for the release of a semaphore. </p>
<p>OS_VTHP_THREAD_PREEMPT </p>
<p>&gt; </p>
<p>The thread is interrupted by another one, which has higher priority. </p>
<p>ToThreadId </p>
<p>The identifier of the thread, which runs from now on </p>
<p>ToThreadReason </p>
<p>OS_VTHP_TASK_ACTIVATION </p>
<p>&gt; </p>
<p>The thread is a task, which was activated. </p>
<p>OS_VTHP_ISR_START </p>
<p>&gt; </p>
<p>The thread is an ISR, which now starts execution. </p>
<p>OS_VTHP_TASK_SETEVENT </p>
<p>&gt; </p>
<p>The thread is a task, which has just received an event it was </p>
<p>waiting for. It resumes execution right behind the call of </p>
<p>WaitEvent(). </p>
<p>OS_VTHP_GOTSEMA </p>
<p>&gt; </p>
<p>The thread is a task, which has just got the semaphore it was </p>
<p>waiting for. </p>
<p>OS_VTHP_THREAD_RESUME: </p>
<p>&gt; </p>
<p>The thread is a task or ISR, which was preempted before and </p>
<p>becomes running again as all higher priority tasks and ISRs do not </p>
<p>run anymore. </p>
<p>CallerCoreId </p>
<p>Identifier of the core which performs the thread switch </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>This hook is called on the caller core when that core in case it performs a thread switch (from one task or  </p>
<p>ISR to another task or ISR). On single core systems both core IDs are always identical. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>None </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>173 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.11.3 </b></p>
<p><b>Timing Hooks for Locking Purposes </b></p>
<p><b>5.11.3.1 </b></p>
<p><b>Get Resource </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_GOT_RES(ResId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>ResId </p>
<p>Identifier of the resource which has been taken </p>
<p>CallerCoreId </p>
<p>Identifier of the core where GetResorce() was called </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on a successful call of the API function GetResource(). The priority of the calling </p>
<p>task or ISR has been increased so that other tasks and ISRs on the same core may need to wait until they </p>
<p>can be executed. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>none </p>
<p> </p>
<p><b>5.11.3.2 </b></p>
<p><b>Release Resource </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REL_RES(ResId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>ResId </p>
<p>Identifier of the resource which has been released </p>
<p>CallerCoreId </p>
<p>Identifier of the core where ReleaseResorce() was called </p>
<p><b>Return code </b></p>
<p>None </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on a successful call of the API function ReleaseResource(). The priority of the </p>
<p>calling task or ISR has been decreased so that other tasks and ISRs on the same core may become </p>
<p>running as a result. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>none </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>174 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.11.3.3 </b></p>
<p><b>Request Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REQ_SPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been requested </p>
<p>CallerCoreId </p>
<p>Identifier of the core where GetSpinlock() was called </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on any attempt to get a spinlock. The calling task or ISR may end up in entering a </p>
<p>busy waiting loop. In such case other tasks or ISRs of lower priority have to wait until this task or ISR has </p>
<p>taken and released the spinlock. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for optimized spinlocks  </p>
<p>&gt; </p>
<p>The hook is called only on multicore operating system implementations </p>
<p> </p>
<p><b>5.11.3.4 </b></p>
<p><b>Request Internal Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REQ_ISPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been requested </p>
<p>CallerCoreId </p>
<p>Identifier of the core where the internal spinlock was requested </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on any attempt to get a spinlock for the OS itself. The OS may end up in entering a </p>
<p>busy waiting loop. In such case other program parts on this core have to wait until the OS has taken and </p>
<p>released the spinlock. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Only called for Spinlocks which used internally by the OS </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>175 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.11.3.5 </b></p>
<p><b>Get Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_GOT_SPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been taken </p>
<p>CallerCoreId </p>
<p>Identifier of the core where GetSpinlock() or TryToGetSpinlock() were called </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook whenever a spinlock has successfully been taken. </p>
<p>If a previosly attempt of getting the spinlock  was not successful immediately (entered busy waiting loop), </p>
<p>this hook means that the core leaves the busy waiting loop. </p>
<p>From now on no other thread may get the spinlock until the current task or ISR has released it. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for optimized spinlocks  </p>
<p>&gt; </p>
<p>The hook is called only on multicore operating system implementations </p>
<p> </p>
<p><b>5.11.3.6 </b></p>
<p><b>Get Internal Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_GOT_ISPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been taken </p>
<p>CallerCoreId </p>
<p>Identifier of the core where the internal spinlock has been taken </p>
<p><b>Return code </b></p>
<p>None </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook whenever a spinlock has successfully been taken by the OS itself. </p>
<p>If a previosly attempt of getting the spinlock  was not successful immediately (entered busy waiting loop), </p>
<p>this hook means that the core leaves the busy waiting loop. </p>
<p>From now on no other thread may get the spinlock until the OS has released it. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Only called for Spinlocks which used internally by the OS </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>176 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.11.3.7 </b></p>
<p><b>Release Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REL_SPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been released </p>
<p>CallerCoreId </p>
<p>Identifier of the core where ReleaseSpinlock() was called </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on a release of a spinlock. Other tasks and ISR may take the spinlock now. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for optimized spinlocks  </p>
<p>&gt; </p>
<p>The hook is called only on multicore operating system implementations </p>
<p> </p>
<p><b>5.11.3.8 </b></p>
<p><b>Release Internal Spinlock </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_REL_ISPINLOCK(SpinlockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>SpinlockId </p>
<p>Identifier of the spinlock which has been released </p>
<p>CallerCoreId </p>
<p>Identifier of the core where the internal spinlock has been released </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook on a release of a spinlock. Other tasks and ISR may take the spinlock now. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Only called for Spinlocks which used internally by the OS </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>177 </p>
<p>based on template version 6.0.1 </p>
<p> </p>
<p><b>5.11.3.9 </b></p>
<p><b>Disable Interrupts </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_DISABLEDINT(IntLockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>IntLockId </p>
<p>OS_VTHP_CAT2INTERRUPTS: </p>
<p>Interrupts have been disabled by means of the current interrupt level. That </p>
<p>interrupt level has been changed in order to disable all category 2 interrupts, </p>
<p>which also prevents task switch and alarm/schedule table management. </p>
<p>OS_VTHP_ALLINTERRUPTS: </p>
<p>Interrupts have been disabled by means of the global interrupt enable/disable </p>
<p>flag. Additionally to the effects described above, also category 1 interrupts are </p>
<p>disabled. </p>
<p>CallerCoreId </p>
<p>Identifier of the core where interrupts are disabled </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook if the application has called an API function to disable interrupts. </p>
<p>The parameter IntLockId describes whether category 1 interrupts may still occur. Mind that the two types of </p>
<p>interrupt locking (as described by the IntLockId) are independent from each other so that the hook may be </p>
<p>called twice before the hook OS_VTH_ENABLEDINT is called, dependent on the application. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for operating system internal interrupt locks </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>178 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.11.3.10 Enable Interrupts </b></p>
<p><b>Macro </b></p>
<p>#define OS_VTH_ENABLEDINT(IntLockId, CallerCoreId) </p>
<p><b>Parameter </b></p>
<p>IntLockId </p>
<p>OS_VTHP_CAT2INTERRUPTS </p>
<p>&gt; </p>
<p>Interrupts had been disabled by means of the current interrupt level </p>
<p>until this hook was called. The OS releases this lock right after the </p>
<p>hook has returned. </p>
<p>OS_VTHP_ALLINTERRUPTS </p>
<p>&gt; </p>
<p>Interrupts had been disabled by means of the global interrupt </p>
<p>enable/disable flag before this hook was called. The OS releases this </p>
<p>lock right after the hook has returned. </p>
<p>CallerCoreId </p>
<p>Identifier of the core where interrupts are disabled </p>
<p><b>Return code </b></p>
<p>None </p>
<p><b>Functional Description </b></p>
<p>The OS calls this hook if the application has called an API function to enable interrupts. Mind that the two </p>
<p>types of interrupt locking (as described by the IntLockId) are independent from each other so that interrupts </p>
<p>may still be disabled by means of the other locking type after this hook has returned. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>The hook is not called for operating system internal interrupt locks </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>179 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.12 </b></p>
<p><b>PanicHook </b></p>
<p><b>Prototype </b></p>
<p>FUNC(void, OS_PANICHOOK_CODE) Os_PanicHook(void) </p>
<p><b>Parameter </b></p>
<p>none </p>
<p><b>Return code </b></p>
<p>none </p>
<p><b>Functional Description </b></p>
<p>Called upon kernel panic mode. </p>
<p><b>Particularities and Limitations </b></p>
<p>&gt; </p>
<p>Trusted access rights </p>
<p>&gt; </p>
<p>Interrupts are disabled </p>
<p>&gt; </p>
<p>No OS API service calls are allowed </p>
<p> </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>180 </p>
<p>based on template version 6.0.1 </p>
<p><b>5.13 </b></p>
<p><b>Calling Context Overview </b></p>
<p>The  following </p>
<p>table </p>
<p>gives </p>
<p>an </p>
<p>overview </p>
<p>about </p>
<p>the </p>
<p>valid </p>
<p>context </p>
<p>for </p>
<p>MICROSAR </p>
<p>OS </p>
<p>additional API service calls. </p>
<p><b>Calling Context </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b> </b></p>
<p><b>API Service </b></p>
<p>Task </p>
<p>Category 1 ISR </p>
<p>Category 2 ISR </p>
<p>Error Hook </p>
<p>PreTask Hook </p>
<p>PostTask Hook </p>
<p>Startup Hook </p>
<p>Shutdown Hook </p>
<p>Alarm Callback </p>
<p>Protection Hook </p>
<p>Before Start of OS </p>
<p>Pre-Start Task </p>
<p>IOC callbacks </p>
<p>Peripheral Access APIs </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p>Os_EnterPreStartTask </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p>Os_CallNonTrustedFunction </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p>Os_DisableInterruptSource </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_EnableInterruptSource </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_ClearPendingInterrupt </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_GetDetailedError </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_GetUnhandledIrq </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_GetUnhandledExc </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Stack Usage APIs </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Time Conversion Macros </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>Os_Init </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p>CheckISRMemoryAccess </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>CheckTaskMemoryAccess </p>
<p>X </p>
<p> </p>
<p>X </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p>CallTrustedFunction </p>
<p>X </p>
<p> </p>
<p>X </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p>X </p>
<p> </p>
<p>Table 5-21  </p>
<p>Calling Context Overview </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>181 </p>
<p>based on template version 6.0.1 </p>
<p><b>6 </b></p>
<p><b>Configuration </b></p>
<p>MICROSAR OS is configured with Vectors “DaVinci Configurator”. </p>
<p>The descriptions of all OS configuration attributes are described with tool tips within  the </p>
<p>configuration tool. </p>
<p>They can easily be look up during configuration of the OS component. </p>
<p> </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p><b>Note </b></p>
<p>The configuration with OIL (OSEK implementation language) is not supported. </p>
<p><b> </b></p>
<p><b> </b></p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>182 </p>
<p>based on template version 6.0.1 </p>
<p><b>7 </b></p>
<p><b>Glossary </b></p>
<p><b>Term </b></p>
<p><b>Description </b></p>
<p>Non-trusted function </p>
<p>(NTF) </p>
<p>A non-trusted function is a functional service provided by a non-trusted </p>
<p>OS application. </p>
<p>It runs in the non-privileged mode of the processor with restricted memory </p>
<p>rights. </p>
<p>Application </p>
<p>Any software parts that uses the OS. This may include other software </p>
<p>modules or customer software (don’t confuse this with the OS-application </p>
<p>object). </p>
<p>Pre-start task </p>
<p>An OS task which may run before StartOS has been called. Within the </p>
<p>pre-start task the usage of non-trusted functions is allowed. </p>
<p>OS-application </p>
<p>An OS object of type application. </p>
<p>OS system level </p>
<p>The lowest priority of all category 1 ISRs. </p>
<p>X-Signal </p>
<p>MICROSAR OS mechanism which realizes cross core service APIs. </p>
<p>Kernel Panic </p>
<p>An inconsistent state of the OS results in kernel panic mode. The OS </p>
<p>does not know how to proceed correctly. It goes into freeze as fast as </p>
<p>possible (interrupts are disabled, the panic hook is called and afterwards </p>
<p>an endless loop is entered). </p>
<p>Thread </p>
<p>Umbrella Term for OS Task, OS hooks and OS ISR objects </p>
<p> </p>
<p> </p>
<h1 style="page-break-before:always; "></h1>
<p>Technical Reference MICROSAR OS </p>
<p>© 2016 Vector Informatik GmbH </p>
<p>Version 1.7.0 </p>
<p>183 </p>
<p>based on template version 6.0.1 </p>
<p><b>8 </b></p>
<p><b>Contact </b></p>
<p>Visit our website for more information on </p>
<p> </p>
<p><b>&gt; </b> News </p>
<p><b>&gt; </b> Products </p>
<p><b>&gt; </b> Demo software </p>
<p><b>&gt; </b> Support </p>
<p><b>&gt; </b> Training data </p>
<p><b>&gt; </b> Addresses </p>
<p> </p>
<p><b>www.vector.com </b></p>
</body>
</html>
{% endraw %}